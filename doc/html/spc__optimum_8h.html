<!-- This comment will put IE 6, 7 and 8 in quirks mode -->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>TIPS: /renoir/fourmano/Desktop/OUSIM/TIPS/branches/tips_build/include/axesim/spc_optimum.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.6.1 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <img id="MSearchSelect" src="search/search.png"
             onmouseover="return searchBox.OnSearchSelectShow()"
             onmouseout="return searchBox.OnSearchSelectHide()"
             alt=""/>
        <input type="text" id="MSearchField" value="Search" accesskey="S"
             onfocus="searchBox.OnSearchFieldFocus(true)" 
             onblur="searchBox.OnSearchFieldFocus(false)" 
             onkeyup="searchBox.OnSearchFieldChange(event)"/>
        <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
        </div>
      </li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>/renoir/fourmano/Desktop/OUSIM/TIPS/branches/tips_build/include/axesim/spc_optimum.h File Reference</h1>
<p><a href="spc__optimum_8h_source.html">Go to the source code of this file.</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Namespaces</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacespc__optimum.html">spc_optimum</a></td></tr>
<tr><td colspan="2"><h2>Defines</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="spc__optimum_8h.html#afc4aeb5fcf5e5d09a28ee6a9d5ce2028">_SPC_OPTIMUM_H</a>&nbsp;&nbsp;&nbsp;1</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="spc__optimum_8h.html#abdc6bc362d81a01e32c9cc612bd30fec">NSPARE_PIX</a>&nbsp;&nbsp;&nbsp;5</td></tr>
<tr><td colspan="2"><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">gsl_matrix *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="spc__optimum_8h.html#a97faff7f2d71c20769d89c594515adc9">create_weightimage</a> (<a class="el" href="structap__pixel.html">ap_pixel</a> *ap_p, const <a class="el" href="structbeam.html">beam</a> actbeam, const <a class="el" href="structaperture__conf.html">aperture_conf</a> *conf, const double exptime, const double sky_cps)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structdrzstamp.html">drzstamp</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="spc__optimum_8h.html#a4da3f4712620de5171d7a0daa5f0bf61">compute_modvar</a> (<a class="el" href="structap__pixel.html">ap_pixel</a> *ap_p, const <a class="el" href="structbeam.html">beam</a> actbeam, const <a class="el" href="structdrzstamp__dim.html">drzstamp_dim</a> dimension)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="spc__optimum_8h.html#a1f6715d47ee4f6ff176974c14dc6401c">prepare_inv_variance</a> (<a class="el" href="structap__pixel.html">ap_pixel</a> *ap_p, <a class="el" href="structap__pixel.html">ap_pixel</a> *bg_p, const int dobck, const <a class="el" href="structaperture__conf.html">aperture_conf</a> *conf, const double exptime, const double sky_cps, const double xi_shift)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="spc__optimum_8h.html#a507edca311317b7c885a40aff09a4e34">compute_object_ivar</a> (<a class="el" href="structap__pixel.html">ap_pixel</a> *ap_p, const double rdnoise, const double exptime, const double sky_cps)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="spc__optimum_8h.html#aa900417c8629b95d35d362ca481c5483">compute_total_ivar</a> (<a class="el" href="structap__pixel.html">ap_pixel</a> *ap_p, const <a class="el" href="structap__pixel.html">ap_pixel</a> *bg_p, const double rdnoise, const double exptime, const double sky_cps)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structdrzstamp.html">drzstamp</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="spc__optimum_8h.html#a1eb0bd08ffa79cfb7f96ebffcb3325c7">alloc_drzstamp</a> (const <a class="el" href="structdrzstamp__dim.html">drzstamp_dim</a> dimension)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structdrzstamp__dim.html">drzstamp_dim</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="spc__optimum_8h.html#a1dc967d6de4c0d294342ef5124da686e">get_all_dims</a> (const <a class="el" href="structap__pixel.html">ap_pixel</a> *ap_p, const <a class="el" href="structap__pixel.html">ap_pixel</a> *bg_p, const <a class="el" href="structbeam.html">beam</a> actbeam, const int dobck)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structdrzstamp__dim.html">drzstamp_dim</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="spc__optimum_8h.html#a925a44a925643f7770807b6352ae5109">get_resample_dims</a> (const <a class="el" href="structap__pixel.html">ap_pixel</a> *ap_p, const <a class="el" href="structbeam.html">beam</a> actbeam)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structdrzstamp__dim.html">drzstamp_dim</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="spc__optimum_8h.html#a48973ed3e4aa7384e047f4d75ee06582">get_default_dim</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structdrzstamp.html">drzstamp</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="spc__optimum_8h.html#aef1186ac7f985de47fe8cd962a4381b8">get_default_modvar</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">gsl_matrix *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="spc__optimum_8h.html#a6f7e58438e5ed0d86dcaa2f170db30c9">get_default_weight</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">gsl_matrix *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="spc__optimum_8h.html#a670955b1949d9ed6a54528c55b2d7bfe">comp_allweight</a> (<a class="el" href="structdrzstamp.html">drzstamp</a> *modvar)</td></tr>
</table>
<hr/><h2>Define Documentation</h2>
<a class="anchor" id="afc4aeb5fcf5e5d09a28ee6a9d5ce2028"></a><!-- doxytag: member="spc_optimum.h::_SPC_OPTIMUM_H" ref="afc4aeb5fcf5e5d09a28ee6a9d5ce2028" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define _SPC_OPTIMUM_H&nbsp;&nbsp;&nbsp;1</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="abdc6bc362d81a01e32c9cc612bd30fec"></a><!-- doxytag: member="spc_optimum.h::NSPARE_PIX" ref="abdc6bc362d81a01e32c9cc612bd30fec" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define NSPARE_PIX&nbsp;&nbsp;&nbsp;5</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="a1eb0bd08ffa79cfb7f96ebffcb3325c7"></a><!-- doxytag: member="spc_optimum.h::alloc_drzstamp" ref="a1eb0bd08ffa79cfb7f96ebffcb3325c7" args="(const drzstamp_dim dimension)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdrzstamp.html">drzstamp</a>* alloc_drzstamp </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdrzstamp__dim.html">drzstamp_dim</a>&nbsp;</td>
          <td class="paramname"> <em>dimension</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Function: alloc_drzstamp Allocates memory for a drizzle stamp structure according the the dimension specified in the input.</p>
<p>Parameters: </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dimension</em>&nbsp;</td><td>- the dimesions to allocate</td></tr>
  </table>
  </dd>
</dl>
<p>Returns: </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>ret - the drizzle stamp image allocated </dd></dl>

<p><div class="fragment"><pre class="fragment"><a name="l00351"></a>00351 {
<a name="l00352"></a>00352   <a class="code" href="structdrzstamp.html">drzstamp</a>   *ret;
<a name="l00353"></a>00353   <a class="code" href="aXe__grism_8h.html#a6117e17bb3108107676f4486e62d40e5">gsl_matrix</a> *counts;
<a name="l00354"></a>00354   <a class="code" href="aXe__grism_8h.html#a6117e17bb3108107676f4486e62d40e5">gsl_matrix</a> *weight;
<a name="l00355"></a>00355 
<a name="l00356"></a>00356   ret = (<a class="code" href="structdrzstamp.html">drzstamp</a> *) malloc(<span class="keyword">sizeof</span>(<a class="code" href="structdrzstamp.html">drzstamp</a>));
<a name="l00357"></a>00357 
<a name="l00358"></a>00358   <span class="comment">/* Allocate the stamp matrix*/</span>
<a name="l00359"></a>00359   <span class="comment">/* Fill stamp with NaN values */</span>
<a name="l00360"></a>00360   counts = <a class="code" href="aXe__grism_8h.html#a1214ab1bea5fd80474d7a27db0bfb429">gsl_matrix_alloc</a>(dimension.<a class="code" href="structdrzstamp__dim.html#a459626637b5697c339db9e2b31f3ded6">xsize</a>,dimension.<a class="code" href="structdrzstamp__dim.html#a8e268f2124d4cc8783fe4f37708bbe8f">ysize</a>);
<a name="l00361"></a>00361   <span class="comment">//  gsl_matrix_set_all(counts, GSL_NAN);</span>
<a name="l00362"></a>00362   <a class="code" href="aXe__grism_8h.html#af6161aeb008a1ffa7d888df6ccbef7cc">gsl_matrix_set_all</a>(counts, 0.0);
<a name="l00363"></a>00363 
<a name="l00364"></a>00364   <span class="comment">/* Allocate the weight matrix*/</span>
<a name="l00365"></a>00365   <span class="comment">/* Fill weight with 0.0 values */</span>
<a name="l00366"></a>00366   weight = <a class="code" href="aXe__grism_8h.html#a1214ab1bea5fd80474d7a27db0bfb429">gsl_matrix_alloc</a>(dimension.<a class="code" href="structdrzstamp__dim.html#a459626637b5697c339db9e2b31f3ded6">xsize</a>,dimension.<a class="code" href="structdrzstamp__dim.html#a8e268f2124d4cc8783fe4f37708bbe8f">ysize</a>);
<a name="l00367"></a>00367   <a class="code" href="aXe__grism_8h.html#af6161aeb008a1ffa7d888df6ccbef7cc">gsl_matrix_set_all</a>(weight, 0.0);
<a name="l00368"></a>00368 
<a name="l00369"></a>00369   <span class="comment">// fill the output structure</span>
<a name="l00370"></a>00370   ret-&gt;<a class="code" href="structdrzstamp.html#a1e8778c4fa3383cb553fbfd9d6eb2582">counts</a> = counts;
<a name="l00371"></a>00371   ret-&gt;<a class="code" href="structdrzstamp.html#a175c8d689fec7a99909d3df716891907">weight</a> = weight;
<a name="l00372"></a>00372 
<a name="l00373"></a>00373   <span class="comment">// return the allocated structure</span>
<a name="l00374"></a>00374   <span class="keywordflow">return</span> ret;
<a name="l00375"></a>00375 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a670955b1949d9ed6a54528c55b2d7bfe"></a><!-- doxytag: member="spc_optimum.h::comp_allweight" ref="a670955b1949d9ed6a54528c55b2d7bfe" args="(drzstamp *modvar)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gsl_matrix* comp_allweight </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdrzstamp.html">drzstamp</a> *&nbsp;</td>
          <td class="paramname"> <em>modvar</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><div class="fragment"><pre class="fragment"><a name="l00601"></a>00601 {
<a name="l00602"></a>00602   <a class="code" href="aXe__grism_8h.html#a6117e17bb3108107676f4486e62d40e5">gsl_matrix</a> *weight;
<a name="l00603"></a>00603 
<a name="l00604"></a>00604   <span class="keywordtype">double</span> mod_sum, weight_sum;
<a name="l00605"></a>00605   <span class="keywordtype">double</span> contr, norm, allweight;
<a name="l00606"></a>00606   <span class="keywordtype">double</span> mod_val;
<a name="l00607"></a>00607   <span class="comment">//double var_val;</span>
<a name="l00608"></a>00608   <span class="keywordtype">double</span> act_weight=0;
<a name="l00609"></a>00609 
<a name="l00610"></a>00610   <span class="comment">//int beamInt = 0;</span>
<a name="l00611"></a>00611   <span class="keywordtype">int</span> i, j;
<a name="l00612"></a>00612 
<a name="l00613"></a>00613   <span class="comment">// allocate the weight matrix and set the default</span>
<a name="l00614"></a>00614   weight = <a class="code" href="aXe__grism_8h.html#a1214ab1bea5fd80474d7a27db0bfb429">gsl_matrix_alloc</a>(modvar-&gt;<a class="code" href="structdrzstamp.html#a1e8778c4fa3383cb553fbfd9d6eb2582">counts</a>-&gt;size1, modvar-&gt;<a class="code" href="structdrzstamp.html#a1e8778c4fa3383cb553fbfd9d6eb2582">counts</a>-&gt;size2);
<a name="l00615"></a>00615   <a class="code" href="aXe__grism_8h.html#af6161aeb008a1ffa7d888df6ccbef7cc">gsl_matrix_set_all</a>(weight, 1000.0);
<a name="l00616"></a>00616 
<a name="l00617"></a>00617   <span class="comment">//* go over all columns</span>
<a name="l00618"></a>00618   <span class="keywordflow">for</span> (i=0; i &lt; modvar-&gt;<a class="code" href="structdrzstamp.html#a1e8778c4fa3383cb553fbfd9d6eb2582">counts</a>-&gt;size1; i++)
<a name="l00619"></a>00619     {
<a name="l00620"></a>00620       mod_sum = 0.0;
<a name="l00621"></a>00621       contr = 0.0;
<a name="l00622"></a>00622       allweight = 0.0;
<a name="l00623"></a>00623       weight_sum=0.0;
<a name="l00624"></a>00624 
<a name="l00625"></a>00625       <span class="comment">// determine for each column the total model counts</span>
<a name="l00626"></a>00626       <span class="comment">// and the number of pixels with non-zero model_counts</span>
<a name="l00627"></a>00627       <span class="keywordflow">for</span> (j=0; j &lt; modvar-&gt;<a class="code" href="structdrzstamp.html#a1e8778c4fa3383cb553fbfd9d6eb2582">counts</a>-&gt;size2; j++)
<a name="l00628"></a>00628         {
<a name="l00629"></a>00629           mod_sum = mod_sum + <a class="code" href="aXe__grism_8h.html#acf709ee71c580f1cd65d726ed03200ea">gsl_matrix_get</a>(modvar-&gt;<a class="code" href="structdrzstamp.html#a1e8778c4fa3383cb553fbfd9d6eb2582">counts</a>, i, j);
<a name="l00630"></a>00630           contr = contr + 1.0;
<a name="l00631"></a>00631         }
<a name="l00632"></a>00632 
<a name="l00633"></a>00633       <span class="comment">// check whether the column has model values.</span>
<a name="l00634"></a>00634       <span class="comment">// normalize the model values and compute</span>
<a name="l00635"></a>00635       <span class="comment">// optimal weights if yes.</span>
<a name="l00636"></a>00636       <span class="keywordflow">if</span> (mod_sum &gt; 0.0)
<a name="l00637"></a>00637         {
<a name="l00638"></a>00638           <span class="comment">//* determine the mean model value</span>
<a name="l00639"></a>00639           <span class="comment">//      norm = mod_sum / contr;</span>
<a name="l00640"></a>00640           norm = mod_sum;
<a name="l00641"></a>00641 
<a name="l00642"></a>00642           <span class="comment">// go over each row</span>
<a name="l00643"></a>00643           <span class="keywordflow">for</span> (j=0; j &lt; modvar-&gt;<a class="code" href="structdrzstamp.html#a1e8778c4fa3383cb553fbfd9d6eb2582">counts</a>-&gt;size2; j++)
<a name="l00644"></a>00644             {
<a name="l00645"></a>00645               <span class="comment">// normalize the model counts</span>
<a name="l00646"></a>00646               mod_val = <a class="code" href="aXe__grism_8h.html#acf709ee71c580f1cd65d726ed03200ea">gsl_matrix_get</a>(modvar-&gt;<a class="code" href="structdrzstamp.html#a1e8778c4fa3383cb553fbfd9d6eb2582">counts</a>, i, j)/norm;
<a name="l00647"></a>00647 
<a name="l00648"></a>00648               <span class="comment">// store the normalized model counts</span>
<a name="l00649"></a>00649               <a class="code" href="aXe__grism_8h.html#a1f386ef5cd5a3b916246c2bee80f083a">gsl_matrix_set</a>(modvar-&gt;<a class="code" href="structdrzstamp.html#a1e8778c4fa3383cb553fbfd9d6eb2582">counts</a>, i, j, mod_val);
<a name="l00650"></a>00650 
<a name="l00651"></a>00651               <span class="comment">// add up the normalization value for the optimal weights</span>
<a name="l00652"></a>00652               weight_sum = weight_sum
<a name="l00653"></a>00653                 + mod_val*mod_val*<a class="code" href="aXe__grism_8h.html#acf709ee71c580f1cd65d726ed03200ea">gsl_matrix_get</a>(modvar-&gt;<a class="code" href="structdrzstamp.html#a175c8d689fec7a99909d3df716891907">weight</a>, i, j);
<a name="l00654"></a>00654             }
<a name="l00655"></a>00655 
<a name="l00656"></a>00656           <span class="comment">// finally compute and write the weights:</span>
<a name="l00657"></a>00657           <span class="comment">// go over each pixel</span>
<a name="l00658"></a>00658           <span class="keywordflow">for</span> (j=0; j &lt; modvar-&gt;<a class="code" href="structdrzstamp.html#a1e8778c4fa3383cb553fbfd9d6eb2582">counts</a>-&gt;size2; j++)
<a name="l00659"></a>00659             {
<a name="l00660"></a>00660               <span class="keywordflow">if</span> (<a class="code" href="aXe__grism_8h.html#acf709ee71c580f1cd65d726ed03200ea">gsl_matrix_get</a>(modvar-&gt;<a class="code" href="structdrzstamp.html#a1e8778c4fa3383cb553fbfd9d6eb2582">counts</a>, i, j) &gt; 0.0 )
<a name="l00661"></a>00661                 {
<a name="l00662"></a>00662                   <span class="comment">// compute and set the individual pixel weight</span>
<a name="l00663"></a>00663                   act_weight = <a class="code" href="aXe__grism_8h.html#acf709ee71c580f1cd65d726ed03200ea">gsl_matrix_get</a>(modvar-&gt;<a class="code" href="structdrzstamp.html#a1e8778c4fa3383cb553fbfd9d6eb2582">counts</a>,i,j)
<a name="l00664"></a>00664                     *<a class="code" href="aXe__grism_8h.html#acf709ee71c580f1cd65d726ed03200ea">gsl_matrix_get</a>(modvar-&gt;<a class="code" href="structdrzstamp.html#a175c8d689fec7a99909d3df716891907">weight</a>,i,j)/weight_sum;
<a name="l00665"></a>00665                   <span class="comment">//              gsl_matrix_set(weight,i,j,gsl_matrix_get(modvar-&gt;counts,i,j)</span>
<a name="l00666"></a>00666                   <span class="comment">//             *gsl_matrix_get(modvar-&gt;weight,i,j)/weight_sum);</span>
<a name="l00667"></a>00667                   <a class="code" href="aXe__grism_8h.html#a1f386ef5cd5a3b916246c2bee80f083a">gsl_matrix_set</a>(weight, i, j, act_weight);
<a name="l00668"></a>00668                   allweight = allweight + <a class="code" href="aXe__grism_8h.html#acf709ee71c580f1cd65d726ed03200ea">gsl_matrix_get</a>(weight, i, j);
<a name="l00669"></a>00669                 }
<a name="l00670"></a>00670               <span class="keywordflow">else</span>
<a name="l00671"></a>00671                 {
<a name="l00672"></a>00672                   <span class="comment">// set the default value if no model value is zero</span>
<a name="l00673"></a>00673                   <a class="code" href="aXe__grism_8h.html#a1f386ef5cd5a3b916246c2bee80f083a">gsl_matrix_set</a>(weight, i, j,0.0);
<a name="l00674"></a>00674                 }
<a name="l00675"></a>00675             }
<a name="l00676"></a>00676         }
<a name="l00677"></a>00677       <span class="comment">// if the column does not have model values at all:</span>
<a name="l00678"></a>00678       <span class="keywordflow">else</span>
<a name="l00679"></a>00679         {
<a name="l00680"></a>00680           <span class="comment">// go over each row</span>
<a name="l00681"></a>00681           <span class="keywordflow">for</span> (j=0; j &lt; modvar-&gt;<a class="code" href="structdrzstamp.html#a1e8778c4fa3383cb553fbfd9d6eb2582">counts</a>-&gt;size2; j++)
<a name="l00682"></a>00682             {
<a name="l00683"></a>00683               <span class="comment">// set the inside default value</span>
<a name="l00684"></a>00684               <a class="code" href="aXe__grism_8h.html#a1f386ef5cd5a3b916246c2bee80f083a">gsl_matrix_set</a>(weight, i,j,1.0);
<a name="l00685"></a>00685               allweight = allweight + <a class="code" href="aXe__grism_8h.html#acf709ee71c580f1cd65d726ed03200ea">gsl_matrix_get</a>(modvar-&gt;<a class="code" href="structdrzstamp.html#a1e8778c4fa3383cb553fbfd9d6eb2582">counts</a>, i, j);
<a name="l00686"></a>00686 
<a name="l00687"></a>00687             }
<a name="l00688"></a>00688         }
<a name="l00689"></a>00689     }
<a name="l00690"></a>00690 
<a name="l00691"></a>00691   <span class="comment">// return the weight matrix</span>
<a name="l00692"></a>00692   <span class="keywordflow">return</span> weight;
<a name="l00693"></a>00693 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a4da3f4712620de5171d7a0daa5f0bf61"></a><!-- doxytag: member="spc_optimum.h::compute_modvar" ref="a4da3f4712620de5171d7a0daa5f0bf61" args="(ap_pixel *ap_p, const beam actbeam, const drzstamp_dim dimension)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdrzstamp.html">drzstamp</a>* compute_modvar </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structap__pixel.html">ap_pixel</a> *&nbsp;</td>
          <td class="paramname"> <em>ap_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structbeam.html">beam</a>&nbsp;</td>
          <td class="paramname"> <em>actbeam</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdrzstamp__dim.html">drzstamp_dim</a>&nbsp;</td>
          <td class="paramname"> <em>dimension</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Function: compute_modvar</p>
<p>Parameters: </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ap_p</em>&nbsp;</td><td>- the PET table </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>actbeam</em>&nbsp;</td><td>- <a class="el" href="structbeam.html">beam</a> to compute the modvar structure for </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dimension</em>&nbsp;</td><td>- dimenasion of the images </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>modvar</em>&nbsp;</td><td>- the structure to fill </td></tr>
  </table>
  </dd>
</dl>

<p><div class="fragment"><pre class="fragment"><a name="l00066"></a>00066 {
<a name="l00067"></a>00067   <a class="code" href="structap__pixel.html">ap_pixel</a> *cur_p;
<a name="l00068"></a>00068   <a class="code" href="structap__pixel.html">ap_pixel</a> *tmp_p;
<a name="l00069"></a>00069 
<a name="l00070"></a>00070   <a class="code" href="structquadrangle.html">quadrangle</a> quad;
<a name="l00071"></a>00071 
<a name="l00072"></a>00072   <span class="keywordtype">double</span> jacob;
<a name="l00073"></a>00073 
<a name="l00074"></a>00074   <span class="keywordtype">int</span> jcen, icen;
<a name="l00075"></a>00075   <span class="keywordtype">int</span> jupp, iupp;
<a name="l00076"></a>00076   <span class="keywordtype">int</span> jlow, ilow;
<a name="l00077"></a>00077 
<a name="l00078"></a>00078   <span class="keywordtype">int</span> ii, jj;
<a name="l00079"></a>00079   <span class="keywordtype">int</span> stpi, stpj;
<a name="l00080"></a>00080 
<a name="l00081"></a>00081   <span class="keywordtype">double</span> maxarr, arr;
<a name="l00082"></a>00082   <span class="comment">//int iim, jjm;</span>
<a name="l00083"></a>00083   <span class="keywordtype">double</span> value, allweig, weig;
<a name="l00084"></a>00084   <span class="keywordtype">double</span> stpc;
<a name="l00085"></a>00085   <span class="keywordtype">double</span> totweight;
<a name="l00086"></a>00086   <a class="code" href="structdrzstamp.html">drzstamp</a> *modvar;
<a name="l00087"></a>00087 
<a name="l00088"></a>00088   <span class="comment">// allocate memory for the result structure</span>
<a name="l00089"></a>00089   modvar = <a class="code" href="spc__optimum_8c.html#a1eb0bd08ffa79cfb7f96ebffcb3325c7">alloc_drzstamp</a>(dimension);
<a name="l00090"></a>00090 
<a name="l00091"></a>00091   <span class="comment">// allocate memory</span>
<a name="l00092"></a>00092   tmp_p = (<a class="code" href="structap__pixel.html">ap_pixel</a> *) malloc(<span class="keyword">sizeof</span>(<a class="code" href="structap__pixel.html">ap_pixel</a>));
<a name="l00093"></a>00093 
<a name="l00094"></a>00094   <span class="comment">// go over each pixel</span>
<a name="l00095"></a>00095   <span class="keywordflow">for</span> (cur_p = ap_p; cur_p-&gt;<a class="code" href="structap__pixel.html#abca28f0936fbd5a569ad548fb25e5a38">p_x</a> != -1; cur_p++)
<a name="l00096"></a>00096     {
<a name="l00097"></a>00097       <span class="comment">// Skip this pixel if it was not actually used</span>
<a name="l00098"></a>00098       <span class="keywordflow">if</span> (fabs(cur_p-&gt;<a class="code" href="structap__pixel.html#abd0f197da151fac01c9e4cbd4146f212">dist</a>)&gt;actbeam.<a class="code" href="structbeam.html#ae99ff960c070381b6e76af5a58cb9c45">width</a>+0.5)
<a name="l00099"></a>00099         <span class="keywordflow">continue</span>;
<a name="l00100"></a>00100 
<a name="l00101"></a>00101       <span class="comment">// transfer values to the temporary pixel</span>
<a name="l00102"></a>00102       tmp_p-&gt;<a class="code" href="structap__pixel.html#ac36fd281b7d91081490e41ce07a60501">lambda</a>  = cur_p-&gt;<a class="code" href="structap__pixel.html#aeae2e14e0f53bd1090acb2a8758104a5">xi</a>;
<a name="l00103"></a>00103       tmp_p-&gt;<a class="code" href="structap__pixel.html#abd0f197da151fac01c9e4cbd4146f212">dist</a>    = cur_p-&gt;<a class="code" href="structap__pixel.html#abd0f197da151fac01c9e4cbd4146f212">dist</a>;
<a name="l00104"></a>00104       tmp_p-&gt;<a class="code" href="structap__pixel.html#a92d9e84a233d0a1ad482830b23c5e5ba">dxs</a>     = cur_p-&gt;<a class="code" href="structap__pixel.html#a92d9e84a233d0a1ad482830b23c5e5ba">dxs</a>;
<a name="l00105"></a>00105       tmp_p-&gt;<a class="code" href="structap__pixel.html#a8c1c7b5a35a04145fccfc3f84c420cde">dlambda</a> = 1.0;
<a name="l00106"></a>00106 
<a name="l00107"></a>00107       <span class="comment">// create the quadrangle for the current pixel</span>
<a name="l00108"></a>00108       quad = <a class="code" href="spce__output_8c.html#a0b04392e15823b7d3e07a84cc698d56d">get_quad_from_pixel</a>(tmp_p, actbeam.<a class="code" href="structbeam.html#a362f20c7f29a9d08731a03939103c8c1">orient</a>, dimension);
<a name="l00109"></a>00109 
<a name="l00110"></a>00110 
<a name="l00111"></a>00111       <span class="comment">// get the jacobian (well, easy here)</span>
<a name="l00112"></a>00112       <span class="comment">// the term &quot;cos(cur_p-&gt;dxs)&quot; must be there</span>
<a name="l00113"></a>00113       <span class="comment">// to correct the enlargement necessary</span>
<a name="l00114"></a>00114       <span class="comment">// to cover the whole lambda-crossdispersion area!</span>
<a name="l00115"></a>00115       <span class="comment">// NOT COMPLETELY understood</span>
<a name="l00116"></a>00116       jacob = cos(cur_p-&gt;<a class="code" href="structap__pixel.html#a92d9e84a233d0a1ad482830b23c5e5ba">dxs</a>);
<a name="l00117"></a>00117 
<a name="l00118"></a>00118       <span class="comment">// get the central pixel (icen, jcen) of the current PET-pixel</span>
<a name="l00119"></a>00119       icen = (int) floor(cur_p-&gt;<a class="code" href="structap__pixel.html#aeae2e14e0f53bd1090acb2a8758104a5">xi</a>   - dimension.<a class="code" href="structdrzstamp__dim.html#af6df14c21230e289ef6abe7134de3cc3">xstart</a>+.5);
<a name="l00120"></a>00120       jcen = (int) floor(cur_p-&gt;<a class="code" href="structap__pixel.html#abd0f197da151fac01c9e4cbd4146f212">dist</a> - dimension.<a class="code" href="structdrzstamp__dim.html#a9ed53e0c679cabe8bd15189b7b9b7a62">ystart</a>+.5);
<a name="l00121"></a>00121 
<a name="l00122"></a>00122       <span class="comment">// get the uper and lower extend of the quadrangle in x</span>
<a name="l00123"></a>00123       iupp = (int)floor(quad.<a class="code" href="structquadrangle.html#a07cdc1aa08d997f3ecf4a4527e1958b1">xmax</a> - (<span class="keywordtype">double</span>)icen + 0.5)+1;
<a name="l00124"></a>00124       ilow = (int)floor(quad.<a class="code" href="structquadrangle.html#a4a693bbae5ab2389a2e89aba2cd1ec6c">xmin</a> - (<span class="keywordtype">double</span>)icen + 0.5);
<a name="l00125"></a>00125 
<a name="l00126"></a>00126       <span class="comment">// get the uper and lower extend of the quadrangle in x</span>
<a name="l00127"></a>00127       jupp = (int)floor(quad.<a class="code" href="structquadrangle.html#a9cd9de4d5ad81c686c3bbea6093d5f2a">ymax</a> - (<span class="keywordtype">double</span>)jcen + 0.5)+1;
<a name="l00128"></a>00128       jlow = (int)floor(quad.<a class="code" href="structquadrangle.html#a28f1d44685c1b1fc1302c23fa53e3c82">ymin</a> - (<span class="keywordtype">double</span>)jcen + 0.5);
<a name="l00129"></a>00129 
<a name="l00130"></a>00130       maxarr=0.0;
<a name="l00131"></a>00131       totweight = 0.0;
<a name="l00132"></a>00132       <span class="comment">// go over the extend in x</span>
<a name="l00133"></a>00133       <span class="keywordflow">for</span> (ii=ilow;ii&lt;iupp;ii++)
<a name="l00134"></a>00134         {
<a name="l00135"></a>00135           <span class="comment">// go over the extend in x</span>
<a name="l00136"></a>00136           <span class="keywordflow">for</span> (jj=jlow;jj&lt;jupp;jj++)
<a name="l00137"></a>00137             {
<a name="l00138"></a>00138 
<a name="l00139"></a>00139               <span class="comment">// get the coordinates of the current output pixel</span>
<a name="l00140"></a>00140               stpi = icen+ii;
<a name="l00141"></a>00141               stpj = jcen+jj;
<a name="l00142"></a>00142 
<a name="l00143"></a>00143               <span class="comment">// check whether the current output pixel is within</span>
<a name="l00144"></a>00144               <span class="comment">// the stamp image; continue if not</span>
<a name="l00145"></a>00145               <span class="keywordflow">if</span> ((stpi&gt;=dimension.<a class="code" href="structdrzstamp__dim.html#a459626637b5697c339db9e2b31f3ded6">xsize</a>)||(stpi&lt;0)
<a name="l00146"></a>00146                   ||(stpj&gt;=dimension.<a class="code" href="structdrzstamp__dim.html#a8e268f2124d4cc8783fe4f37708bbe8f">ysize</a>)||(stpj&lt;0))
<a name="l00147"></a>00147                 <span class="keywordflow">continue</span>;
<a name="l00148"></a>00148 
<a name="l00149"></a>00149               <span class="comment">// get the area which falls onto the current output pixel</span>
<a name="l00150"></a>00150               arr = <a class="code" href="spc__driz_8c.html#a8aae79a1f68a0ac2de5f34e6e9f9f2df">boxer</a>(stpi,stpj,quad.<a class="code" href="structquadrangle.html#a2838cc41fa0d8d867757b05ed1cfdbc2">x</a>,quad.<a class="code" href="structquadrangle.html#a7a086b8fde718d39d81a1d0a5855beff">y</a>);
<a name="l00151"></a>00151 
<a name="l00152"></a>00152               <span class="keywordflow">if</span> (arr &gt; 0.0)
<a name="l00153"></a>00153                 {
<a name="l00154"></a>00154                   <span class="comment">// get the already existing counts and weights</span>
<a name="l00155"></a>00155                   stpc = <a class="code" href="aXe__grism_8h.html#acf709ee71c580f1cd65d726ed03200ea">gsl_matrix_get</a>(modvar-&gt;<a class="code" href="structdrzstamp.html#a1e8778c4fa3383cb553fbfd9d6eb2582">counts</a>,stpi,stpj);
<a name="l00156"></a>00156                   weig = <a class="code" href="aXe__grism_8h.html#acf709ee71c580f1cd65d726ed03200ea">gsl_matrix_get</a>(modvar-&gt;<a class="code" href="structdrzstamp.html#a175c8d689fec7a99909d3df716891907">weight</a>,stpi,stpj);
<a name="l00157"></a>00157 
<a name="l00158"></a>00158                   <span class="comment">// compute the new, total weight of the current output pixel</span>
<a name="l00159"></a>00159                   allweig = weig + arr*cur_p-&gt;<a class="code" href="structap__pixel.html#a34600405e114d4bd366c1d33860aff14">weight</a>;
<a name="l00160"></a>00160 
<a name="l00161"></a>00161                   <span class="comment">// do a weighted sum of the count value at the current</span>
<a name="l00162"></a>00162                   <span class="comment">// output pixel</span>
<a name="l00163"></a>00163                   value = (stpc*weig + arr*cur_p-&gt;<a class="code" href="structap__pixel.html#ada106f5981b17786de87cfeb2a7db0d1">model</a>*cur_p-&gt;<a class="code" href="structap__pixel.html#a34600405e114d4bd366c1d33860aff14">weight</a>*jacob)
<a name="l00164"></a>00164                     / (allweig);
<a name="l00165"></a>00165 
<a name="l00166"></a>00166                   <span class="comment">// store the new count value and the new weight</span>
<a name="l00167"></a>00167                   <a class="code" href="aXe__grism_8h.html#a1f386ef5cd5a3b916246c2bee80f083a">gsl_matrix_set</a>(modvar-&gt;<a class="code" href="structdrzstamp.html#a1e8778c4fa3383cb553fbfd9d6eb2582">counts</a>,stpi,stpj,value);
<a name="l00168"></a>00168                   <a class="code" href="aXe__grism_8h.html#a1f386ef5cd5a3b916246c2bee80f083a">gsl_matrix_set</a>(modvar-&gt;<a class="code" href="structdrzstamp.html#a175c8d689fec7a99909d3df716891907">weight</a>,stpi,stpj,allweig);
<a name="l00169"></a>00169                 }
<a name="l00170"></a>00170             }
<a name="l00171"></a>00171         }
<a name="l00172"></a>00172     }
<a name="l00173"></a>00173 
<a name="l00174"></a>00174   <span class="comment">// freep the temporary PET pixel</span>
<a name="l00175"></a>00175   free(tmp_p);
<a name="l00176"></a>00176 
<a name="l00177"></a>00177   <span class="comment">// return the result</span>
<a name="l00178"></a>00178   <span class="keywordflow">return</span> modvar;
<a name="l00179"></a>00179 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a507edca311317b7c885a40aff09a4e34"></a><!-- doxytag: member="spc_optimum.h::compute_object_ivar" ref="a507edca311317b7c885a40aff09a4e34" args="(ap_pixel *ap_p, const double rdnoise, const double exptime, const double sky_cps)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void compute_object_ivar </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structap__pixel.html">ap_pixel</a> *&nbsp;</td>
          <td class="paramname"> <em>ap_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>rdnoise</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>exptime</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>sky_cps</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Function: compute_model_ivar The function computes for each PET pixel the associated inverse variance value. The input for variance and inverse variance are the model value, the contamination value, the constant sky background value and the readnoise. The computed inverse variance value is stored in the weight entry of the PET. The function also offers the possibility to shift the trace distance by a fixed amount.</p>
<p>Parameters: </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ap_p</em>&nbsp;</td><td>- the PET table </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>rdnoise</em>&nbsp;</td><td>- the readnoise value </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>exptime</em>&nbsp;</td><td>- the exposure time </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>sky_cps</em>&nbsp;</td><td>- the sky background </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>xi_shift</em>&nbsp;</td><td>- shift in trace distance </td></tr>
  </table>
  </dd>
</dl>

<p><div class="fragment"><pre class="fragment"><a name="l00257"></a>00257 {
<a name="l00258"></a>00258   <span class="keywordtype">double</span> variance;
<a name="l00259"></a>00259   <span class="keywordtype">double</span> sqr_rdnoise;
<a name="l00260"></a>00260   <span class="keywordtype">double</span> sqr_exptime;
<a name="l00261"></a>00261   <a class="code" href="structap__pixel.html">ap_pixel</a> *cur_p;
<a name="l00262"></a>00262 
<a name="l00263"></a>00263   <span class="comment">// square the readnoise</span>
<a name="l00264"></a>00264   sqr_rdnoise = rdnoise*rdnoise;
<a name="l00265"></a>00265 
<a name="l00266"></a>00266   <span class="comment">// square the exposure time</span>
<a name="l00267"></a>00267   sqr_exptime = exptime*exptime;
<a name="l00268"></a>00268 
<a name="l00269"></a>00269   <span class="comment">// go over each PET pixel</span>
<a name="l00270"></a>00270   <span class="keywordflow">for</span> (cur_p = ap_p; cur_p-&gt;<a class="code" href="structap__pixel.html#abca28f0936fbd5a569ad548fb25e5a38">p_x</a> != -1; cur_p++)
<a name="l00271"></a>00271     {
<a name="l00272"></a>00272         <span class="comment">// compute the variance</span>
<a name="l00273"></a>00273         variance = ((cur_p-&gt;<a class="code" href="structap__pixel.html#ada106f5981b17786de87cfeb2a7db0d1">model</a> + cur_p-&gt;<a class="code" href="structap__pixel.html#a2191ef670b1b5c515fda841dda181f62">contam</a> + sky_cps) * exptime
<a name="l00274"></a>00274                     + sqr_rdnoise) / sqr_exptime;
<a name="l00275"></a>00275 
<a name="l00276"></a>00276       <span class="comment">// store the inverse variance</span>
<a name="l00277"></a>00277       cur_p-&gt;<a class="code" href="structap__pixel.html#a34600405e114d4bd366c1d33860aff14">weight</a> = 1.0/variance;
<a name="l00278"></a>00278     }
<a name="l00279"></a>00279 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="aa900417c8629b95d35d362ca481c5483"></a><!-- doxytag: member="spc_optimum.h::compute_total_ivar" ref="aa900417c8629b95d35d362ca481c5483" args="(ap_pixel *ap_p, const ap_pixel *bg_p, const double rdnoise, const double exptime, const double sky_cps)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void compute_total_ivar </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structap__pixel.html">ap_pixel</a> *&nbsp;</td>
          <td class="paramname"> <em>ap_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structap__pixel.html">ap_pixel</a> *&nbsp;</td>
          <td class="paramname"> <em>bg_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>rdnoise</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>exptime</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>sky_cps</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Function: compute_value_ivar The function computes for each PET pixel the associated inverse variance value. The input to derive the variance is the count value and the readnoise. The computed inverse variance value is stored in the weight entry of the PET. The function also offers the possibility to shift the trace distance by a fixed amount.</p>
<p>Parameters: </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ap_p</em>&nbsp;</td><td>- the PET table </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>rdnoise</em>&nbsp;</td><td>- the readnoise value </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>exptime</em>&nbsp;</td><td>- the exposure time </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>sky_cps</em>&nbsp;</td><td>- the sky background </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>xi_shift</em>&nbsp;</td><td>- shift in trace distance </td></tr>
  </table>
  </dd>
</dl>

<p><div class="fragment"><pre class="fragment"><a name="l00302"></a>00302 {
<a name="l00303"></a>00303   <span class="keywordtype">double</span> variance;
<a name="l00304"></a>00304   <span class="keywordtype">double</span> sqr_rdnoise;
<a name="l00305"></a>00305   <span class="keywordtype">double</span> sqr_exptime;
<a name="l00306"></a>00306 
<a name="l00307"></a>00307   <a class="code" href="structap__pixel.html">ap_pixel</a> *cur_p;
<a name="l00308"></a>00308   <span class="keyword">const</span> <a class="code" href="structap__pixel.html">ap_pixel</a> *bac_p;
<a name="l00309"></a>00309 
<a name="l00310"></a>00310   <span class="comment">// square the readnoise</span>
<a name="l00311"></a>00311   sqr_rdnoise = rdnoise*rdnoise;
<a name="l00312"></a>00312 
<a name="l00313"></a>00313   <span class="comment">// square the exposure time</span>
<a name="l00314"></a>00314   sqr_exptime = exptime*exptime;
<a name="l00315"></a>00315 
<a name="l00316"></a>00316   <span class="comment">// go over each PET pixel</span>
<a name="l00317"></a>00317   bac_p = bg_p;
<a name="l00318"></a>00318   <span class="keywordflow">for</span> (cur_p = ap_p; cur_p-&gt;<a class="code" href="structap__pixel.html#abca28f0936fbd5a569ad548fb25e5a38">p_x</a> != -1; cur_p++)
<a name="l00319"></a>00319     {
<a name="l00320"></a>00320       <span class="comment">// check that the foreground and background</span>
<a name="l00321"></a>00321       <span class="comment">// PET element describe the same pixel</span>
<a name="l00322"></a>00322       <span class="keywordflow">if</span> (bac_p-&gt;<a class="code" href="structap__pixel.html#a0ce028c33a28f543bd9255324800e9ea">x</a> != cur_p-&gt;<a class="code" href="structap__pixel.html#a0ce028c33a28f543bd9255324800e9ea">x</a> || bac_p-&gt;<a class="code" href="structap__pixel.html#a1df90884734bfaea8ec545b69d802281">y</a> != cur_p-&gt;<a class="code" href="structap__pixel.html#a1df90884734bfaea8ec545b69d802281">y</a>)
<a name="l00323"></a>00323         <a class="code" href="aXe__errors_8c.html#a7ef7588e5f91237ba7ce4084e6ed3c11">aXe_message</a> (<a class="code" href="aXe__errors_8h.html#a2556a67874555249b07691c37aa6d6e9">aXe_M_FATAL</a>, __FILE__, __LINE__,
<a name="l00324"></a>00324                      <span class="stringliteral">&quot;aXe_PET2SPC: Background PET and Object PET &quot;</span>
<a name="l00325"></a>00325                      <span class="stringliteral">&quot;have different pixel orders in PET&apos;s.\n&quot;</span>);
<a name="l00326"></a>00326       <span class="keywordflow">else</span>
<a name="l00327"></a>00327       <span class="comment">// compute the variance</span>
<a name="l00328"></a>00328       variance = ((cur_p-&gt;<a class="code" href="structap__pixel.html#a846018a7e3b143259419bd74e2d9073f">count</a> + bac_p-&gt;<a class="code" href="structap__pixel.html#a846018a7e3b143259419bd74e2d9073f">count</a> + sky_cps) * exptime + sqr_rdnoise) / sqr_exptime;
<a name="l00329"></a>00329 
<a name="l00330"></a>00330       <span class="comment">// store the inverse variance</span>
<a name="l00331"></a>00331       cur_p-&gt;<a class="code" href="structap__pixel.html#a34600405e114d4bd366c1d33860aff14">weight</a> = 1.0/variance;
<a name="l00332"></a>00332 
<a name="l00333"></a>00333       <span class="comment">// increase the background pointer</span>
<a name="l00334"></a>00334       bac_p++;
<a name="l00335"></a>00335     }
<a name="l00336"></a>00336 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a97faff7f2d71c20769d89c594515adc9"></a><!-- doxytag: member="spc_optimum.h::create_weightimage" ref="a97faff7f2d71c20769d89c594515adc9" args="(ap_pixel *ap_p, const beam actbeam, const aperture_conf *conf, const double exptime, const double sky_cps)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gsl_matrix* create_weightimage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structap__pixel.html">ap_pixel</a> *&nbsp;</td>
          <td class="paramname"> <em>ap_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structbeam.html">beam</a>&nbsp;</td>
          <td class="paramname"> <em>actbeam</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structaperture__conf.html">aperture_conf</a> *&nbsp;</td>
          <td class="paramname"> <em>conf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>exptime</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>sky_cps</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a1dc967d6de4c0d294342ef5124da686e"></a><!-- doxytag: member="spc_optimum.h::get_all_dims" ref="a1dc967d6de4c0d294342ef5124da686e" args="(const ap_pixel *ap_p, const ap_pixel *bg_p, const beam actbeam, const int dobck)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdrzstamp__dim.html">drzstamp_dim</a> get_all_dims </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structap__pixel.html">ap_pixel</a> *&nbsp;</td>
          <td class="paramname"> <em>ap_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structap__pixel.html">ap_pixel</a> *&nbsp;</td>
          <td class="paramname"> <em>bg_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structbeam.html">beam</a>&nbsp;</td>
          <td class="paramname"> <em>actbeam</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>dobck</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Function: get_all_dims The function derives the dimensional information on the foreground and, if available, on the background PET. The dimensions are compared, and in case of inequality an error is thrown. If the dimensions are equal, one of them is returned.</p>
<p>Parameters: </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ap_p</em>&nbsp;</td><td>- the table of aperture pixels </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>bg_p</em>&nbsp;</td><td>- the table of background pixels </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>actbeam</em>&nbsp;</td><td>- the <a class="el" href="structbeam.html">beam</a> to compute the dimensions for </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dobck</em>&nbsp;</td><td>- integer indicating background subtraction</td></tr>
  </table>
  </dd>
</dl>
<p>Returns: </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>ret - the dimension structure </dd></dl>

<p><div class="fragment"><pre class="fragment"><a name="l00398"></a>00398 {
<a name="l00399"></a>00399   <a class="code" href="structdrzstamp__dim.html">drzstamp_dim</a> ret;
<a name="l00400"></a>00400   <a class="code" href="structdrzstamp__dim.html">drzstamp_dim</a> bck;
<a name="l00401"></a>00401 
<a name="l00402"></a>00402   <span class="comment">// get the aperture PET diemnsion</span>
<a name="l00403"></a>00403   ret = <a class="code" href="spc__optimum_8c.html#a925a44a925643f7770807b6352ae5109">get_resample_dims</a>(ap_p, actbeam);
<a name="l00404"></a>00404 
<a name="l00405"></a>00405   <span class="keywordflow">if</span> (dobck)
<a name="l00406"></a>00406     {
<a name="l00407"></a>00407       <span class="comment">// get the background PET dimension</span>
<a name="l00408"></a>00408       bck = <a class="code" href="spc__optimum_8c.html#a925a44a925643f7770807b6352ae5109">get_resample_dims</a>(bg_p, actbeam);
<a name="l00409"></a>00409 
<a name="l00410"></a>00410       <span class="comment">// check whether the two dimensions</span>
<a name="l00411"></a>00411       <span class="comment">// are equal, throw an error if not</span>
<a name="l00412"></a>00412       <span class="keywordflow">if</span> (ret.<a class="code" href="structdrzstamp__dim.html#ab3c0ed305132ecda42a1e8b6dad5ce27">resolution</a> != bck.<a class="code" href="structdrzstamp__dim.html#ab3c0ed305132ecda42a1e8b6dad5ce27">resolution</a>
<a name="l00413"></a>00413           || ret.<a class="code" href="structdrzstamp__dim.html#af6df14c21230e289ef6abe7134de3cc3">xstart</a>  != bck.<a class="code" href="structdrzstamp__dim.html#af6df14c21230e289ef6abe7134de3cc3">xstart</a>
<a name="l00414"></a>00414           || ret.<a class="code" href="structdrzstamp__dim.html#a9ed53e0c679cabe8bd15189b7b9b7a62">ystart</a>  != bck.<a class="code" href="structdrzstamp__dim.html#a9ed53e0c679cabe8bd15189b7b9b7a62">ystart</a>
<a name="l00415"></a>00415           || ret.<a class="code" href="structdrzstamp__dim.html#a459626637b5697c339db9e2b31f3ded6">xsize</a>   != bck.<a class="code" href="structdrzstamp__dim.html#a459626637b5697c339db9e2b31f3ded6">xsize</a>
<a name="l00416"></a>00416           || ret.<a class="code" href="structdrzstamp__dim.html#a8e268f2124d4cc8783fe4f37708bbe8f">ysize</a>   != bck.<a class="code" href="structdrzstamp__dim.html#a8e268f2124d4cc8783fe4f37708bbe8f">ysize</a>)
<a name="l00417"></a>00417         <a class="code" href="aXe__errors_8c.html#a7ef7588e5f91237ba7ce4084e6ed3c11">aXe_message</a> (<a class="code" href="aXe__errors_8h.html#a2556a67874555249b07691c37aa6d6e9">aXe_M_FATAL</a>, __FILE__, __LINE__,
<a name="l00418"></a>00418                      <span class="stringliteral">&quot;aXe_PET2SPC: Background PET and Object PET &quot;</span>
<a name="l00419"></a>00419                      <span class="stringliteral">&quot;do not have the same dimension.\n&quot;</span>);
<a name="l00420"></a>00420     }
<a name="l00421"></a>00421 
<a name="l00422"></a>00422   <span class="comment">// return one of the dimensional infos</span>
<a name="l00423"></a>00423   <span class="keywordflow">return</span> ret;
<a name="l00424"></a>00424 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a48973ed3e4aa7384e047f4d75ee06582"></a><!-- doxytag: member="spc_optimum.h::get_default_dim" ref="a48973ed3e4aa7384e047f4d75ee06582" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdrzstamp__dim.html">drzstamp_dim</a> get_default_dim </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Function: get_default_dim The function creates and returns the default dimension structure. The dewfault dimension structure contains a 0.0 in all fields.</p>
<p>Returns: </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>res - the dimension structure </dd></dl>

<p><div class="fragment"><pre class="fragment"><a name="l00523"></a>00523 {
<a name="l00524"></a>00524   <a class="code" href="structdrzstamp__dim.html">drzstamp_dim</a> ret;
<a name="l00525"></a>00525 
<a name="l00526"></a>00526   <span class="comment">// just set everything to zero</span>
<a name="l00527"></a>00527   ret.<a class="code" href="structdrzstamp__dim.html#ab3c0ed305132ecda42a1e8b6dad5ce27">resolution</a>=0.0;
<a name="l00528"></a>00528   ret.<a class="code" href="structdrzstamp__dim.html#af6df14c21230e289ef6abe7134de3cc3">xstart</a> = 0;
<a name="l00529"></a>00529   ret.<a class="code" href="structdrzstamp__dim.html#a9ed53e0c679cabe8bd15189b7b9b7a62">ystart</a> = 0;
<a name="l00530"></a>00530   ret.<a class="code" href="structdrzstamp__dim.html#a459626637b5697c339db9e2b31f3ded6">xsize</a>  = 0;
<a name="l00531"></a>00531   ret.<a class="code" href="structdrzstamp__dim.html#a8e268f2124d4cc8783fe4f37708bbe8f">ysize</a>  = 0;
<a name="l00532"></a>00532 
<a name="l00533"></a>00533   <span class="comment">// return the result</span>
<a name="l00534"></a>00534   <span class="keywordflow">return</span> ret;
<a name="l00535"></a>00535 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="aef1186ac7f985de47fe8cd962a4381b8"></a><!-- doxytag: member="spc_optimum.h::get_default_modvar" ref="aef1186ac7f985de47fe8cd962a4381b8" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdrzstamp.html">drzstamp</a>* get_default_modvar </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Function: get_default_modvar The function computes the default drizzle stamp structure, which in this case is used for tha calculation of the resampled variance and profile image.</p>
<p>Returns: </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>res - the resulting <a class="el" href="structdrzstamp.html">drzstamp</a> structure </dd></dl>

<p><div class="fragment"><pre class="fragment"><a name="l00549"></a>00549 {
<a name="l00550"></a>00550   <a class="code" href="aXe__grism_8h.html#a6117e17bb3108107676f4486e62d40e5">gsl_matrix</a> *counts;
<a name="l00551"></a>00551   <a class="code" href="aXe__grism_8h.html#a6117e17bb3108107676f4486e62d40e5">gsl_matrix</a> *weight;
<a name="l00552"></a>00552   <a class="code" href="structdrzstamp.html">drzstamp</a> *res;
<a name="l00553"></a>00553 
<a name="l00554"></a>00554   res = (<a class="code" href="structdrzstamp.html">drzstamp</a> *) malloc(<span class="keyword">sizeof</span>(<a class="code" href="structdrzstamp.html">drzstamp</a>));
<a name="l00555"></a>00555 
<a name="l00556"></a>00556   <span class="comment">/* Create a dummy stamp image */</span>
<a name="l00557"></a>00557   counts = <a class="code" href="aXe__grism_8h.html#a1214ab1bea5fd80474d7a27db0bfb429">gsl_matrix_alloc</a>(10,10);
<a name="l00558"></a>00558   weight = <a class="code" href="aXe__grism_8h.html#a1214ab1bea5fd80474d7a27db0bfb429">gsl_matrix_alloc</a>(10,10);
<a name="l00559"></a>00559   <span class="comment">/* Fill stamp with 0.0 values */</span>
<a name="l00560"></a>00560   <a class="code" href="aXe__grism_8h.html#af6161aeb008a1ffa7d888df6ccbef7cc">gsl_matrix_set_all</a>(counts, 0.0);
<a name="l00561"></a>00561   <a class="code" href="aXe__grism_8h.html#af6161aeb008a1ffa7d888df6ccbef7cc">gsl_matrix_set_all</a>(weight, 0.0);
<a name="l00562"></a>00562 
<a name="l00563"></a>00563   <span class="comment">// fill the output</span>
<a name="l00564"></a>00564   res-&gt;<a class="code" href="structdrzstamp.html#a1e8778c4fa3383cb553fbfd9d6eb2582">counts</a> = counts;
<a name="l00565"></a>00565   res-&gt;<a class="code" href="structdrzstamp.html#a175c8d689fec7a99909d3df716891907">weight</a> = weight;
<a name="l00566"></a>00566 
<a name="l00567"></a>00567   <span class="comment">// return the output</span>
<a name="l00568"></a>00568   <span class="keywordflow">return</span> res;
<a name="l00569"></a>00569 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a6f7e58438e5ed0d86dcaa2f170db30c9"></a><!-- doxytag: member="spc_optimum.h::get_default_weight" ref="a6f7e58438e5ed0d86dcaa2f170db30c9" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gsl_matrix* get_default_weight </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><div class="fragment"><pre class="fragment"><a name="l00573"></a>00573 {
<a name="l00574"></a>00574   <a class="code" href="aXe__grism_8h.html#a6117e17bb3108107676f4486e62d40e5">gsl_matrix</a> *res;
<a name="l00575"></a>00575 
<a name="l00576"></a>00576   res = <a class="code" href="aXe__grism_8h.html#a1214ab1bea5fd80474d7a27db0bfb429">gsl_matrix_alloc</a>(10,10);
<a name="l00577"></a>00577   <a class="code" href="aXe__grism_8h.html#af6161aeb008a1ffa7d888df6ccbef7cc">gsl_matrix_set_all</a>(res, 0.0);
<a name="l00578"></a>00578 
<a name="l00579"></a>00579   <span class="comment">// return the output</span>
<a name="l00580"></a>00580   <span class="keywordflow">return</span> res;
<a name="l00581"></a>00581 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a925a44a925643f7770807b6352ae5109"></a><!-- doxytag: member="spc_optimum.h::get_resample_dims" ref="a925a44a925643f7770807b6352ae5109" args="(const ap_pixel *ap_p, const beam actbeam)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdrzstamp__dim.html">drzstamp_dim</a> get_resample_dims </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structap__pixel.html">ap_pixel</a> *&nbsp;</td>
          <td class="paramname"> <em>ap_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structbeam.html">beam</a>&nbsp;</td>
          <td class="paramname"> <em>actbeam</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Function: get_resample_dims The function parses through a PET table and determines the dimension of the image in the coordinates trace distance - cross-dispersion direction. Those dimensions are stored in a special structure and returned to the calling routine.</p>
<p>Parameters: </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ap_p</em>&nbsp;</td><td>- the table of aperture pixels </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>actbeam</em>&nbsp;</td><td>- the <a class="el" href="structbeam.html">beam</a> to compute the dimensions for</td></tr>
  </table>
  </dd>
</dl>
<p>Returns: </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>ret - the dimension structure </dd></dl>

<p><div class="fragment"><pre class="fragment"><a name="l00444"></a>00444 {
<a name="l00445"></a>00445   <a class="code" href="structdrzstamp__dim.html">drzstamp_dim</a> ret;
<a name="l00446"></a>00446 
<a name="l00447"></a>00447   <span class="keyword">const</span> <a class="code" href="structap__pixel.html">ap_pixel</a> *cur_p;
<a name="l00448"></a>00448 
<a name="l00449"></a>00449   <span class="keywordtype">int</span> i_xint, i_dist;
<a name="l00450"></a>00450   <span class="keywordtype">int</span> imin_xint=0, imin_dist=0;
<a name="l00451"></a>00451   <span class="keywordtype">int</span> imax_xint=0, imax_dist=0;
<a name="l00452"></a>00452 
<a name="l00453"></a>00453   <span class="keywordtype">int</span> npixel = 0;
<a name="l00454"></a>00454 
<a name="l00455"></a>00455   <span class="comment">// immediately return empty PET&apos;s</span>
<a name="l00456"></a>00456   <span class="keywordflow">if</span> (ap_p==NULL)
<a name="l00457"></a>00457     <span class="keywordflow">return</span> <a class="code" href="spc__optimum_8c.html#a48973ed3e4aa7384e047f4d75ee06582">get_default_dim</a>();
<a name="l00458"></a>00458 
<a name="l00459"></a>00459   <span class="comment">// set the tmp pixel to the table start</span>
<a name="l00460"></a>00460   cur_p = ap_p;
<a name="l00461"></a>00461 
<a name="l00462"></a>00462   <span class="comment">// initialize some relevant numbers</span>
<a name="l00463"></a>00463   <span class="comment">// based on the first pixel</span>
<a name="l00464"></a>00464   i_xint = floor(cur_p-&gt;<a class="code" href="structap__pixel.html#aeae2e14e0f53bd1090acb2a8758104a5">xi</a>   + 0.5);
<a name="l00465"></a>00465   i_dist = floor(cur_p-&gt;<a class="code" href="structap__pixel.html#abd0f197da151fac01c9e4cbd4146f212">dist</a> + 0.5);
<a name="l00466"></a>00466   imin_xint = i_xint;
<a name="l00467"></a>00467   imax_xint = i_xint;
<a name="l00468"></a>00468   imin_dist = i_dist;
<a name="l00469"></a>00469   imax_dist = i_dist;
<a name="l00470"></a>00470 
<a name="l00471"></a>00471   <span class="comment">// go over all pixels, check</span>
<a name="l00472"></a>00472   <span class="comment">// for new MIN&apos;s ans MAX&apos;s</span>
<a name="l00473"></a>00473   <span class="keywordflow">for</span> (cur_p = ap_p; cur_p-&gt;<a class="code" href="structap__pixel.html#abca28f0936fbd5a569ad548fb25e5a38">p_x</a> != -1; cur_p++)
<a name="l00474"></a>00474     {
<a name="l00475"></a>00475       <span class="comment">// Skip the pixel if it was not actually used</span>
<a name="l00476"></a>00476       <span class="keywordflow">if</span> (fabs(cur_p-&gt;<a class="code" href="structap__pixel.html#abd0f197da151fac01c9e4cbd4146f212">dist</a>)&gt;actbeam.<a class="code" href="structbeam.html#ae99ff960c070381b6e76af5a58cb9c45">width</a>+.5)
<a name="l00477"></a>00477         <span class="keywordflow">continue</span>;
<a name="l00478"></a>00478 
<a name="l00479"></a>00479       <span class="comment">// compute the rounded value in (x,y)</span>
<a name="l00480"></a>00480       i_xint = floor(cur_p-&gt;<a class="code" href="structap__pixel.html#aeae2e14e0f53bd1090acb2a8758104a5">xi</a>   + 0.5);
<a name="l00481"></a>00481       i_dist = floor(cur_p-&gt;<a class="code" href="structap__pixel.html#abd0f197da151fac01c9e4cbd4146f212">dist</a> + 0.5);
<a name="l00482"></a>00482 
<a name="l00483"></a>00483       <span class="comment">// check for extrema in x</span>
<a name="l00484"></a>00484       imin_xint = <a class="code" href="aXe__utils_8c.html#a74e75242132eaabbc1c512488a135926">MIN</a>(imin_xint, i_xint);
<a name="l00485"></a>00485       imax_xint = <a class="code" href="aper__conf_8c.html#aacc3ee1a7f283f8ef65cea31f4436a95">MAX</a>(imax_xint, i_xint);
<a name="l00486"></a>00486 
<a name="l00487"></a>00487       <span class="comment">// check for extrema in y</span>
<a name="l00488"></a>00488       imin_dist = <a class="code" href="aXe__utils_8c.html#a74e75242132eaabbc1c512488a135926">MIN</a>(imin_dist, i_dist);
<a name="l00489"></a>00489       imax_dist = <a class="code" href="aper__conf_8c.html#aacc3ee1a7f283f8ef65cea31f4436a95">MAX</a>(imax_dist, i_dist);
<a name="l00490"></a>00490 
<a name="l00491"></a>00491       <span class="comment">// enhance the pixel counter</span>
<a name="l00492"></a>00492       npixel++;
<a name="l00493"></a>00493     }
<a name="l00494"></a>00494 
<a name="l00495"></a>00495 
<a name="l00496"></a>00496   <span class="comment">// in case there were no valid pixels,</span>
<a name="l00497"></a>00497   <span class="comment">// return a dummy structure</span>
<a name="l00498"></a>00498   <span class="keywordflow">if</span> (!npixel)
<a name="l00499"></a>00499     <span class="keywordflow">return</span> <a class="code" href="spc__optimum_8c.html#a48973ed3e4aa7384e047f4d75ee06582">get_default_dim</a>();
<a name="l00500"></a>00500 
<a name="l00501"></a>00501   <span class="comment">// fill the structure with the correct values</span>
<a name="l00502"></a>00502   ret.<a class="code" href="structdrzstamp__dim.html#ab3c0ed305132ecda42a1e8b6dad5ce27">resolution</a> = 1.0;
<a name="l00503"></a>00503   ret.<a class="code" href="structdrzstamp__dim.html#af6df14c21230e289ef6abe7134de3cc3">xstart</a>     = imin_xint - <a class="code" href="spc__optimum_8h.html#abdc6bc362d81a01e32c9cc612bd30fec">NSPARE_PIX</a>;
<a name="l00504"></a>00504   ret.<a class="code" href="structdrzstamp__dim.html#a9ed53e0c679cabe8bd15189b7b9b7a62">ystart</a>     = imin_dist - NSPARE_PIX;
<a name="l00505"></a>00505   ret.<a class="code" href="structdrzstamp__dim.html#a459626637b5697c339db9e2b31f3ded6">xsize</a>      = imax_xint - imin_xint + 2 * NSPARE_PIX;
<a name="l00506"></a>00506   ret.<a class="code" href="structdrzstamp__dim.html#a8e268f2124d4cc8783fe4f37708bbe8f">ysize</a>      = imax_dist - imin_dist + 2 * NSPARE_PIX;
<a name="l00507"></a>00507 
<a name="l00508"></a>00508   <span class="comment">// return the structure</span>
<a name="l00509"></a>00509   <span class="keywordflow">return</span> ret;
<a name="l00510"></a>00510 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a1f6715d47ee4f6ff176974c14dc6401c"></a><!-- doxytag: member="spc_optimum.h::prepare_inv_variance" ref="a1f6715d47ee4f6ff176974c14dc6401c" args="(ap_pixel *ap_p, ap_pixel *bg_p, const int dobck, const aperture_conf *conf, const double exptime, const double sky_cps, const double xi_shift)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void prepare_inv_variance </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structap__pixel.html">ap_pixel</a> *&nbsp;</td>
          <td class="paramname"> <em>ap_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structap__pixel.html">ap_pixel</a> *&nbsp;</td>
          <td class="paramname"> <em>bg_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>dobck</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structaperture__conf.html">aperture_conf</a> *&nbsp;</td>
          <td class="paramname"> <em>conf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>exptime</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>sky_cps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>xi_shift</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Function: prepare_inv_variance The function prepares the inverse model variances for a data set containing an <a class="el" href="structobject.html">object</a> and a background PET. This is done in subroutines which compute the theoretical inverse pixel variance following different methods for the <a class="el" href="structobject.html">object</a> and the background PET.</p>
<p>Parameters: </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ap_p</em>&nbsp;</td><td>- the <a class="el" href="structobject.html">object</a> PET table </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>bg_p</em>&nbsp;</td><td>- the background PET table </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dobck</em>&nbsp;</td><td>- integer indicating background subtraction </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>conf</em>&nbsp;</td><td>- the configuration structure </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>exptime</em>&nbsp;</td><td>- the exposure time </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>sky_cps</em>&nbsp;</td><td>- the sky background </td></tr>
  </table>
  </dd>
</dl>

<p><div class="fragment"><pre class="fragment"><a name="l00214"></a>00214 {
<a name="l00215"></a>00215 
<a name="l00216"></a>00216   <span class="keywordflow">if</span> (dobck)
<a name="l00217"></a>00217     {
<a name="l00218"></a>00218       <span class="comment">// shift both, the object and the background PET</span>
<a name="l00219"></a>00219       <a class="code" href="spc__optimum_8c.html#aa3e8e6e9854df4de96ee44cbacfad4a8">shift_tracelength</a>(ap_p, xi_shift);
<a name="l00220"></a>00220       <a class="code" href="spc__optimum_8c.html#aa3e8e6e9854df4de96ee44cbacfad4a8">shift_tracelength</a>(bg_p, xi_shift);
<a name="l00221"></a>00221 
<a name="l00222"></a>00222       <span class="comment">// compute the inverse variance for the object + background PET</span>
<a name="l00223"></a>00223       <a class="code" href="spc__optimum_8c.html#aa900417c8629b95d35d362ca481c5483">compute_total_ivar</a>(bg_p, bg_p, conf-&gt;<a class="code" href="structaperture__conf.html#a13683d2e63f2e2ccb4f834dec5b2d0e3">rdnoise</a>, exptime, sky_cps);
<a name="l00224"></a>00224     }
<a name="l00225"></a>00225   <span class="keywordflow">else</span>
<a name="l00226"></a>00226     {
<a name="l00227"></a>00227       <span class="comment">// shift both, the object PET</span>
<a name="l00228"></a>00228       <a class="code" href="spc__optimum_8c.html#aa3e8e6e9854df4de96ee44cbacfad4a8">shift_tracelength</a>(ap_p, xi_shift);
<a name="l00229"></a>00229 
<a name="l00230"></a>00230       <span class="comment">// compute the inverse variance for the object PET</span>
<a name="l00231"></a>00231       <a class="code" href="spc__optimum_8c.html#a507edca311317b7c885a40aff09a4e34">compute_object_ivar</a>(ap_p, conf-&gt;<a class="code" href="structaperture__conf.html#a13683d2e63f2e2ccb4f834dec5b2d0e3">rdnoise</a>, exptime, sky_cps);
<a name="l00232"></a>00232     }
<a name="l00233"></a>00233 }
</pre></div></p>

</div>
</div>
</div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&nbsp;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&nbsp;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&nbsp;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&nbsp;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&nbsp;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&nbsp;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&nbsp;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&nbsp;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&nbsp;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&nbsp;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr size="1"/><address style="text-align: right;"><small>Generated on 12 Oct 2014 for TIPS by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.1 </small></address>
</body>
</html>
