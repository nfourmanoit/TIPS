<!-- This comment will put IE 6, 7 and 8 in quirks mode -->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>TIPS: /renoir/fourmano/Desktop/OUSIM/TIPS/branches/tips_build/src/axesim/fringe_model.c File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.6.1 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <img id="MSearchSelect" src="search/search.png"
             onmouseover="return searchBox.OnSearchSelectShow()"
             onmouseout="return searchBox.OnSearchSelectHide()"
             alt=""/>
        <input type="text" id="MSearchField" value="Search" accesskey="S"
             onfocus="searchBox.OnSearchFieldFocus(true)" 
             onblur="searchBox.OnSearchFieldFocus(false)" 
             onkeyup="searchBox.OnSearchFieldChange(event)"/>
        <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
        </div>
      </li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>/renoir/fourmano/Desktop/OUSIM/TIPS/branches/tips_build/src/axesim/fringe_model.c File Reference</h1><code>#include &lt;math.h&gt;</code><br/>
<code>#include &lt;gsl/gsl_matrix.h&gt;</code><br/>
<code>#include &lt;gsl/gsl_vector.h&gt;</code><br/>
<code>#include &lt;gsl/gsl_complex.h&gt;</code><br/>
<code>#include &lt;gsl/gsl_complex_math.h&gt;</code><br/>
<code>#include &lt;gsl/gsl_math.h&gt;</code><br/>
<code>#include &lt;gsl/gsl_interp.h&gt;</code><br/>
<code>#include &quot;<a class="el" href="aXe__utils_8h_source.html">aXe_utils.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="aXe__errors_8h_source.html">aXe_errors.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="fringe__conf_8h_source.html">fringe_conf.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="fringe__model_8h_source.html">fringe_model.h</a>&quot;</code><br/>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Namespaces</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefringe__model.html">fringe_model</a></td></tr>
<tr><td colspan="2"><h2>Defines</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="fringe__model_8c.html#aacc3ee1a7f283f8ef65cea31f4436a95">MAX</a>(x, y)&nbsp;&nbsp;&nbsp;(((x)&gt;(y))?(x):(y))</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="fringe__model_8c.html#a74e75242132eaabbc1c512488a135926">MIN</a>(x, y)&nbsp;&nbsp;&nbsp;(((x)&lt;(y))?(x):(y))</td></tr>
<tr><td colspan="2"><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">gsl_matrix *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="fringe__model_8c.html#a53c99dc930106fd2748fd0f3d5279e6e">compute_fringe_amplitude</a> (<a class="el" href="structfringe__conf.html">fringe_conf</a> *fconf)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">gsl_matrix *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="fringe__model_8c.html#a4bee6456d00567df917dad489810ecf6">alloc_fringe_image</a> (const <a class="el" href="structccd__layers.html">ccd_layers</a> *opt_layers)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">gsl_vector **&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="fringe__model_8c.html#aa1d042ae3943c7168b6d8c18bced875d">get_calibration_data</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">gsl_vector **&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="fringe__model_8c.html#a825847406083c196d7fb8363cdd5f7ff">get_PET_calibration_data</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">gsl_vector **&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="fringe__model_8c.html#a49198f0a9909b50f00a1f8202b2905d3">evaluate_wavelength_steps</a> (<a class="el" href="structfringe__conf.html">fringe_conf</a> *fconf)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structinterpolator.html">interpolator</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="fringe__model_8c.html#a8f0e1b1f5664107be3cba2068c0a83e1">redefine_filter_throughput</a> (const int lower, const int upper, <a class="el" href="structfringe__conf.html">fringe_conf</a> *fconf)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="fringe__model_8c.html#ac350c8322c6ddd6d21d854690076eed1">eval_linear_interp</a> (<a class="el" href="structlinear__interp.html">linear_interp</a> *lin_int, const double xval)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="fringe__model_8c.html#a4b144c7b307bae789a6b06582364de66">get_layer_thickness</a> (const <a class="el" href="structccd__layer.html">ccd_layer</a> *opt_layer, const int ii, const int jj)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">gsl_complex&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="fringe__model_8c.html#acdd00a7b8f4c951200544ae65e90e38b">get_complex_refindex</a> (const <a class="el" href="structccd__layer.html">ccd_layer</a> *opt_layer, const double lambda)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="fringe__model_8c.html#a0c717cd5d164c86327c7077a33022724">compute_reflection</a> (const gsl_complex refract_l1, const gsl_complex refract_l2)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="fringe__model_8c.html#a63e9f0b1fcef4d177b599ffb8c4c610d">compute_transmission</a> (const gsl_complex refract_l1, const gsl_complex refract_l2)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="fringe__model_8c.html#ae4753d72683ba416c4b01b25685501f8">compute_attenuation</a> (const gsl_complex refract, const double thickness, const double phase_number)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">gsl_complex&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="fringe__model_8c.html#a45318b077b4923e5d339053d41d6d2b3">compute_pshift</a> (const gsl_complex refract, const double thickness, const double phase_number)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structoptical__property.html">optical_property</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="fringe__model_8c.html#ac701ed4f58f047e545bb39105bd38ba4">alloc_optprops_list</a> (const <a class="el" href="structfringe__conf.html">fringe_conf</a> *fconf)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="fringe__model_8c.html#a8d36095f41729289c111fa1fa483a807">print_optprops_list</a> (const <a class="el" href="structoptical__property.html">optical_property</a> *optprops, const int num_entries)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="fringe__model_8c.html#a1b8ec54dcd7b41e31b24bbc5baacdd28">free_optprops_list</a> (<a class="el" href="structoptical__property.html">optical_property</a> *optprops)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="fringe__model_8c.html#a30b4bda7a269be14d5225de5aaec952e">init_optprops_list</a> (const <a class="el" href="structfringe__conf.html">fringe_conf</a> *fconf, const double lambda_mean, <a class="el" href="structoptical__property.html">optical_property</a> *optprops)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="fringe__model_8c.html#a4d241cd2c21f6836aabfc05690fa2361">fill_optprops_thickness</a> (const <a class="el" href="structccd__layers.html">ccd_layers</a> *opt_layers, const int ii, const int jj, <a class="el" href="structoptical__property.html">optical_property</a> *optprops)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="fringe__model_8c.html#a7583c38c8f52f4db360e402b0cff8354">fill_optprops_all</a> (const <a class="el" href="structccd__layers.html">ccd_layers</a> *opt_layers, const double lambda, <a class="el" href="structoptical__property.html">optical_property</a> *optprops)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="fringe__model_8c.html#ab3355b989a07f5f88786c7148a5c76e5">fringe_contrib_single</a> (const <a class="el" href="structoptical__property.html">optical_property</a> *optprops, const <a class="el" href="structfringe__conf.html">fringe_conf</a> *fconf)</td></tr>
</table>
<hr/><h2>Define Documentation</h2>
<a class="anchor" id="aacc3ee1a7f283f8ef65cea31f4436a95"></a><!-- doxytag: member="fringe_model.c::MAX" ref="aacc3ee1a7f283f8ef65cea31f4436a95" args="(x, y)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MAX</td>
          <td>(</td>
          <td class="paramtype">x, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">y&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td>&nbsp;&nbsp;&nbsp;(((x)&gt;(y))?(x):(y))</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a74e75242132eaabbc1c512488a135926"></a><!-- doxytag: member="fringe_model.c::MIN" ref="a74e75242132eaabbc1c512488a135926" args="(x, y)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MIN</td>
          <td>(</td>
          <td class="paramtype">x, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">y&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td>&nbsp;&nbsp;&nbsp;(((x)&lt;(y))?(x):(y))</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="a4bee6456d00567df917dad489810ecf6"></a><!-- doxytag: member="fringe_model.c::alloc_fringe_image" ref="a4bee6456d00567df917dad489810ecf6" args="(const ccd_layers *opt_layers)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gsl_matrix* alloc_fringe_image </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structccd__layers.html">ccd_layers</a> *&nbsp;</td>
          <td class="paramname"> <em>opt_layers</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Function: alloc_fringe_image The function browses through the the structure for the CCD layers and extracts all information on image sizes stored there in one or several thickness images. This information is checked for consistency. Finally, a matrix for a fringe image is allocated, initialized and returned.</p>
<p>Parameters: </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>opt_layers</em>&nbsp;</td><td>- the optical layers in the CCD</td></tr>
  </table>
  </dd>
</dl>
<p>Returns: </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>fringe_image - the allocated matrix for the fringe image </dd></dl>

<p><div class="fragment"><pre class="fragment"><a name="l00141"></a>00141 {
<a name="l00142"></a>00142   <span class="keywordtype">int</span> n1         = 0;
<a name="l00143"></a>00143   <span class="keywordtype">int</span> n2         = 0;
<a name="l00144"></a>00144   <span class="keywordtype">int</span> n1_new     = 0;
<a name="l00145"></a>00145   <span class="keywordtype">int</span> n2_new     = 0;
<a name="l00146"></a>00146   <span class="keywordtype">int</span> index      = 0;
<a name="l00147"></a>00147   <span class="keywordtype">int</span> is_defined = 0;
<a name="l00148"></a>00148   
<a name="l00149"></a>00149   <a class="code" href="aXe__grism_8h.html#a6117e17bb3108107676f4486e62d40e5">gsl_matrix</a> *fringe_image;
<a name="l00150"></a>00150   <span class="comment">// go through all CCD layers</span>
<a name="l00151"></a>00151   <span class="keywordflow">for</span> (index=0; index &lt; opt_layers-&gt;<a class="code" href="structccd__layers.html#a228a06a9acfab17cbdec81a21e82a58a">num_layers</a>; index++)
<a name="l00152"></a>00152     {
<a name="l00153"></a>00153       <span class="comment">// check whether the thickness information</span>
<a name="l00154"></a>00154       <span class="comment">// is represented by an image</span>
<a name="l00155"></a>00155       <span class="keywordflow">if</span> (opt_layers-&gt;<a class="code" href="structccd__layers.html#ae9861ce32cfcdbdec138e90f66f8ce9f">opt_layer</a>[index]-&gt;<a class="code" href="structccd__layer.html#a831ea82c1e042d7fc58c507b682a32b0">thickness2D</a> != NULL)
<a name="l00156"></a>00156         {
<a name="l00157"></a>00157 
<a name="l00158"></a>00158           <span class="comment">// mark that an image was found</span>
<a name="l00159"></a>00159           is_defined=1;
<a name="l00160"></a>00160 
<a name="l00161"></a>00161           <span class="comment">// get the dimension of the image</span>
<a name="l00162"></a>00162           n1_new = opt_layers-&gt;<a class="code" href="structccd__layers.html#ae9861ce32cfcdbdec138e90f66f8ce9f">opt_layer</a>[index]-&gt;<a class="code" href="structccd__layer.html#a831ea82c1e042d7fc58c507b682a32b0">thickness2D</a>-&gt;size1;
<a name="l00163"></a>00163           n2_new = opt_layers-&gt;<a class="code" href="structccd__layers.html#ae9861ce32cfcdbdec138e90f66f8ce9f">opt_layer</a>[index]-&gt;<a class="code" href="structccd__layer.html#a831ea82c1e042d7fc58c507b682a32b0">thickness2D</a>-&gt;size2;
<a name="l00164"></a>00164         
<a name="l00165"></a>00165           <span class="comment">// check the frst axix value against</span>
<a name="l00166"></a>00166           <span class="comment">// previous values, if possible</span>
<a name="l00167"></a>00167           <span class="keywordflow">if</span> (n1 &amp;&amp; n1_new != n1)
<a name="l00168"></a>00168             <span class="comment">// give an error if the new value is different</span>
<a name="l00169"></a>00169             <a class="code" href="aXe__errors_8c.html#a7ef7588e5f91237ba7ce4084e6ed3c11">aXe_message</a> (<a class="code" href="aXe__errors_8h.html#a2556a67874555249b07691c37aa6d6e9">aXe_M_FATAL</a>, __FILE__, __LINE__,
<a name="l00170"></a>00170                          <span class="stringliteral">&quot;Thickness image of layer %i &quot;</span>
<a name="l00171"></a>00171                          <span class="stringliteral">&quot;has %i pixels in first axis.&quot;</span>
<a name="l00172"></a>00172                          <span class="stringliteral">&quot;This differs from the previous value %i\n&quot;</span>,
<a name="l00173"></a>00173                          index, n1_new, n1);
<a name="l00174"></a>00174           <span class="keywordflow">else</span>
<a name="l00175"></a>00175             <span class="comment">// store the new value</span>
<a name="l00176"></a>00176             n1 = n1_new;
<a name="l00177"></a>00177           
<a name="l00178"></a>00178           <span class="comment">// check the frst axix value against</span>
<a name="l00179"></a>00179           <span class="comment">// previous values, if possible</span>
<a name="l00180"></a>00180           <span class="keywordflow">if</span> (n2 &amp;&amp; n2_new != n2)
<a name="l00181"></a>00181             <span class="comment">// give an error if the new value is different</span>
<a name="l00182"></a>00182             <a class="code" href="aXe__errors_8c.html#a7ef7588e5f91237ba7ce4084e6ed3c11">aXe_message</a> (<a class="code" href="aXe__errors_8h.html#a2556a67874555249b07691c37aa6d6e9">aXe_M_FATAL</a>, __FILE__, __LINE__,
<a name="l00183"></a>00183                          <span class="stringliteral">&quot;Thickness image of layer %i &quot;</span>
<a name="l00184"></a>00184                          <span class="stringliteral">&quot;has %i pixels in second axis.&quot;</span>
<a name="l00185"></a>00185                          <span class="stringliteral">&quot;This differs from the previous value %i\n&quot;</span>,
<a name="l00186"></a>00186                          index, n2_new, n2);
<a name="l00187"></a>00187           <span class="keywordflow">else</span>
<a name="l00188"></a>00188             <span class="comment">// store the new value</span>
<a name="l00189"></a>00189             n2 = n2_new;
<a name="l00190"></a>00190         }
<a name="l00191"></a>00191     }
<a name="l00192"></a>00192 
<a name="l00193"></a>00193 <span class="preprocessor">#ifdef DEBUGFCONF</span>
<a name="l00194"></a>00194 <span class="preprocessor"></span>  fprintf(stdout, <span class="stringliteral">&quot;Allocating an image with size: (%i, %i)\n&quot;</span>, n1, n2);
<a name="l00195"></a>00195 <span class="preprocessor">#endif</span>
<a name="l00196"></a>00196 <span class="preprocessor"></span>
<a name="l00197"></a>00197   <span class="comment">// check whether at least one image was</span>
<a name="l00198"></a>00198   <span class="comment">// found as thickness information</span>
<a name="l00199"></a>00199   <span class="keywordflow">if</span> (is_defined)
<a name="l00200"></a>00200     {
<a name="l00201"></a>00201       <span class="comment">// allocate the image</span>
<a name="l00202"></a>00202       fringe_image =  <a class="code" href="aXe__grism_8h.html#a1214ab1bea5fd80474d7a27db0bfb429">gsl_matrix_alloc</a>(n1, n2);
<a name="l00203"></a>00203       
<a name="l00204"></a>00204       <span class="comment">// set all vallues to zero</span>
<a name="l00205"></a>00205       <a class="code" href="aXe__grism_8h.html#af6161aeb008a1ffa7d888df6ccbef7cc">gsl_matrix_set_all</a>(fringe_image, 0.0);
<a name="l00206"></a>00206     }
<a name="l00207"></a>00207   <span class="keywordflow">else</span>
<a name="l00208"></a>00208     {
<a name="l00209"></a>00209       <span class="comment">// no image found; report the error</span>
<a name="l00210"></a>00210       <a class="code" href="aXe__errors_8c.html#a7ef7588e5f91237ba7ce4084e6ed3c11">aXe_message</a> (<a class="code" href="aXe__errors_8h.html#a2556a67874555249b07691c37aa6d6e9">aXe_M_FATAL</a>, __FILE__, __LINE__,
<a name="l00211"></a>00211                    <span class="stringliteral">&quot;The size of the fringe image is unknown\n&quot;</span>
<a name="l00212"></a>00212                    <span class="stringliteral">&quot;since none of the layers has an image &quot;</span>
<a name="l00213"></a>00213                    <span class="stringliteral">&quot;to specify its thickness!\n&quot;</span>);
<a name="l00214"></a>00214     }
<a name="l00215"></a>00215 
<a name="l00216"></a>00216   <span class="comment">// return the image</span>
<a name="l00217"></a>00217   <span class="keywordflow">return</span> fringe_image;
<a name="l00218"></a>00218 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ac701ed4f58f047e545bb39105bd38ba4"></a><!-- doxytag: member="fringe_model.c::alloc_optprops_list" ref="ac701ed4f58f047e545bb39105bd38ba4" args="(const fringe_conf *fconf)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structoptical__property.html">optical_property</a>* alloc_optprops_list </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structfringe__conf.html">fringe_conf</a> *&nbsp;</td>
          <td class="paramname"> <em>fconf</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Function: alloc_optprops_list The function allocates space for a list of optical property elements. the size of the list is derived from a fringe configuration structure given in the input.</p>
<p>Parameters: </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>fconf</em>&nbsp;</td><td>- the fringe configuration file</td></tr>
  </table>
  </dd>
</dl>
<p>Returns: </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>optprops - the list of optical properties </dd></dl>

<p><div class="fragment"><pre class="fragment"><a name="l00821"></a>00821 {
<a name="l00822"></a>00822   <a class="code" href="structoptical__property.html">optical_property</a> *optprops;
<a name="l00823"></a>00823 
<a name="l00824"></a>00824   <span class="comment">// allocate large enough memory </span>
<a name="l00825"></a>00825   optprops =
<a name="l00826"></a>00826     (<a class="code" href="structoptical__property.html">optical_property</a> *)malloc(fconf-&gt;<a class="code" href="structfringe__conf.html#a82eebf75b191ca25f824437be6f23c51">opt_layers</a>-&gt;<a class="code" href="structccd__layers.html#a228a06a9acfab17cbdec81a21e82a58a">num_layers</a>*<span class="keyword">sizeof</span>(<a class="code" href="structap__pixel.html">ap_pixel</a>));
<a name="l00827"></a>00827 
<a name="l00828"></a>00828   <span class="comment">// return the pointer</span>
<a name="l00829"></a>00829   <span class="keywordflow">return</span> optprops;
<a name="l00830"></a>00830 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ae4753d72683ba416c4b01b25685501f8"></a><!-- doxytag: member="fringe_model.c::compute_attenuation" ref="ae4753d72683ba416c4b01b25685501f8" args="(const gsl_complex refract, const double thickness, const double phase_number)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double compute_attenuation </td>
          <td>(</td>
          <td class="paramtype">const gsl_complex&nbsp;</td>
          <td class="paramname"> <em>refract</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>thickness</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>phase_number</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Function: compute_attenuation The function computes the attenuation/damping of a plane wave with a given inverse wavelelength (phase number) traversing TWO TIMES a layer of a given thickness and complex refraction index.</p>
<p>Parameters: </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>refract</em>&nbsp;</td><td>- the complex refraction index </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>thickness</em>&nbsp;</td><td>- the thickness of the layer </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>phase_number</em>&nbsp;</td><td>- the inverse wavelength</td></tr>
  </table>
  </dd>
</dl>
<p>Returns: </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>(value) - the attenuation </dd></dl>

<p><div class="fragment"><pre class="fragment"><a name="l00772"></a>00772 {
<a name="l00773"></a>00773   <span class="comment">// check if there is something to compute</span>
<a name="l00774"></a>00774   <span class="keywordflow">if</span> (GSL_IMAG(refract)) 
<a name="l00775"></a>00775     <span class="comment">// compute and return the value</span>
<a name="l00776"></a>00776     <span class="keywordflow">return</span> exp(-2.0*GSL_IMAG(refract)*thickness*phase_number);
<a name="l00777"></a>00777   <span class="keywordflow">else</span>
<a name="l00778"></a>00778     <span class="comment">// return the value for exp(0.0)</span>
<a name="l00779"></a>00779     <span class="keywordflow">return</span> 1.0;
<a name="l00780"></a>00780 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a53c99dc930106fd2748fd0f3d5279e6e"></a><!-- doxytag: member="fringe_model.c::compute_fringe_amplitude" ref="a53c99dc930106fd2748fd0f3d5279e6e" args="(fringe_conf *fconf)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gsl_matrix* compute_fringe_amplitude </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structfringe__conf.html">fringe_conf</a> *&nbsp;</td>
          <td class="paramname"> <em>fconf</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Function: compute_fringe_amplitude The function computes the fringe image for a CCD setup stored in a fringe configuration structure. This fringe configuration structure completely describes the problem, and this function executes the loops for every pixel over the wavelength range spanned by the filter.</p>
<p>Parameters </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>fconf</em>&nbsp;</td><td>- the fringe configuration structure</td></tr>
  </table>
  </dd>
</dl>
<p>Returns: </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>fringe_image - the image with the computed fringe amplitudes </dd></dl>

<p><div class="fragment"><pre class="fragment"><a name="l00045"></a>00045 {
<a name="l00046"></a>00046   <a class="code" href="aXe__grism_8h.html#a6117e17bb3108107676f4486e62d40e5">gsl_matrix</a> *fringe_image;
<a name="l00047"></a>00047   
<a name="l00048"></a>00048   gsl_vector **filter_vectors;
<a name="l00049"></a>00049 
<a name="l00050"></a>00050   <span class="keywordtype">int</span> index=0;
<a name="l00051"></a>00051   <span class="keywordtype">int</span> ii=0;
<a name="l00052"></a>00052   <span class="keywordtype">int</span> jj=0;
<a name="l00053"></a>00053 
<a name="l00054"></a>00054   <span class="keywordtype">double</span> lambda_mean;
<a name="l00055"></a>00055   <span class="keywordtype">double</span> pixel_ampl;
<a name="l00056"></a>00056   <span class="comment">//double phase_number;</span>
<a name="l00057"></a>00057 
<a name="l00058"></a>00058   <a class="code" href="structoptical__property.html">optical_property</a> *optprops;
<a name="l00059"></a>00059 
<a name="l00060"></a>00060   <span class="comment">// allocate the fringe image</span>
<a name="l00061"></a>00061   fringe_image = <a class="code" href="fringe__model_8c.html#a4bee6456d00567df917dad489810ecf6">alloc_fringe_image</a>(fconf-&gt;<a class="code" href="structfringe__conf.html#a82eebf75b191ca25f824437be6f23c51">opt_layers</a>);
<a name="l00062"></a>00062 
<a name="l00063"></a>00063   <span class="comment">// allocate memory for the optical property structure  </span>
<a name="l00064"></a>00064   optprops = <a class="code" href="fringe__model_8c.html#ac701ed4f58f047e545bb39105bd38ba4">alloc_optprops_list</a>(fconf);
<a name="l00065"></a>00065 
<a name="l00066"></a>00066   <span class="comment">// find the exact wavelength range,</span>
<a name="l00067"></a>00067   <span class="comment">// and define the wavelength values and</span>
<a name="l00068"></a>00068   <span class="comment">// normalized fiter throughput there</span>
<a name="l00069"></a>00069   filter_vectors = <a class="code" href="fringe__model_8c.html#a49198f0a9909b50f00a1f8202b2905d3">evaluate_wavelength_steps</a>(fconf);
<a name="l00070"></a>00070   <span class="comment">//filter_vectors = get_PET_calibration_data();</span>
<a name="l00071"></a>00071 
<a name="l00072"></a>00072   <span class="comment">// compute the mean wavelength</span>
<a name="l00073"></a>00073   lambda_mean = gsl_vector_get(filter_vectors[0],filter_vectors[0]-&gt;size-1)/2.0
<a name="l00074"></a>00074                  + gsl_vector_get(filter_vectors[0],0)/2.0;
<a name="l00075"></a>00075 
<a name="l00076"></a>00076   <span class="comment">// initialize some values in the optical property list</span>
<a name="l00077"></a>00077   <a class="code" href="fringe__model_8c.html#a30b4bda7a269be14d5225de5aaec952e">init_optprops_list</a>(fconf, lambda_mean, optprops);
<a name="l00078"></a>00078 
<a name="l00079"></a>00079     <span class="keywordflow">for</span> (ii=0; ii &lt; fringe_image-&gt;size1; ii++)
<a name="l00080"></a>00080       <span class="comment">//    for (ii=0; ii &lt; 2; ii++)</span>
<a name="l00081"></a>00081     {
<a name="l00082"></a>00082       fprintf(stderr, <span class="stringliteral">&quot;Computing row No.: %i\n&quot;</span>, ii);
<a name="l00083"></a>00083             <span class="keywordflow">for</span> (jj=0; jj &lt; fringe_image-&gt;size2; jj++)
<a name="l00084"></a>00084               <span class="comment">//for (jj=0; jj &lt; 2; jj++)</span>
<a name="l00085"></a>00085         {
<a name="l00086"></a>00086           <span class="comment">// fill the optical thickness of the layers</span>
<a name="l00087"></a>00087           <span class="comment">// into the structure</span>
<a name="l00088"></a>00088           <a class="code" href="fringe__model_8c.html#a4d241cd2c21f6836aabfc05690fa2361">fill_optprops_thickness</a>(fconf-&gt;<a class="code" href="structfringe__conf.html#a82eebf75b191ca25f824437be6f23c51">opt_layers</a>, ii, jj, optprops);
<a name="l00089"></a>00089 
<a name="l00090"></a>00090           pixel_ampl = 0.0;
<a name="l00091"></a>00091           <span class="keywordflow">for</span> (index=0; index &lt; filter_vectors[0]-&gt;size; index++)
<a name="l00092"></a>00092             {
<a name="l00093"></a>00093               <span class="comment">// fill all information in the optical</span>
<a name="l00094"></a>00094               <span class="comment">// property list</span>
<a name="l00095"></a>00095               <a class="code" href="fringe__model_8c.html#a7583c38c8f52f4db360e402b0cff8354">fill_optprops_all</a>(fconf-&gt;<a class="code" href="structfringe__conf.html#a82eebf75b191ca25f824437be6f23c51">opt_layers</a>,
<a name="l00096"></a>00096                                 gsl_vector_get(filter_vectors[0],index),
<a name="l00097"></a>00097                                 optprops);
<a name="l00098"></a>00098 
<a name="l00099"></a>00099               <span class="comment">// compute and add the contribution at a wavelength</span>
<a name="l00100"></a>00100               pixel_ampl += gsl_vector_get(filter_vectors[1],index)*
<a name="l00101"></a>00101                 <a class="code" href="fringe__model_8c.html#ab3355b989a07f5f88786c7148a5c76e5">fringe_contrib_single</a>(optprops, fconf);
<a name="l00102"></a>00102             }
<a name="l00103"></a>00103 
<a name="l00104"></a>00104           <span class="comment">// finally set the pixel value</span>
<a name="l00105"></a>00105           <span class="comment">// in the output image</span>
<a name="l00106"></a>00106           <a class="code" href="aXe__grism_8h.html#a1f386ef5cd5a3b916246c2bee80f083a">gsl_matrix_set</a>(fringe_image, ii, jj,
<a name="l00107"></a>00107                          fconf-&gt;<a class="code" href="structfringe__conf.html#a82769d872faed1af21769411078d76f5">fringe_amp</a> * pixel_ampl + 1.0);
<a name="l00108"></a>00108         }
<a name="l00109"></a>00109     }
<a name="l00110"></a>00110 
<a name="l00111"></a>00111   <span class="comment">// release the memory in the vectors</span>
<a name="l00112"></a>00112   gsl_vector_free(filter_vectors[0]);
<a name="l00113"></a>00113   gsl_vector_free(filter_vectors[1]);
<a name="l00114"></a>00114   free(filter_vectors);
<a name="l00115"></a>00115 
<a name="l00116"></a>00116   <span class="comment">// free the optical property structure</span>
<a name="l00117"></a>00117   <a class="code" href="fringe__model_8c.html#a1b8ec54dcd7b41e31b24bbc5baacdd28">free_optprops_list</a>(optprops);
<a name="l00118"></a>00118 
<a name="l00119"></a>00119   <span class="comment">// return the fringe image</span>
<a name="l00120"></a>00120   <span class="keywordflow">return</span> fringe_image;
<a name="l00121"></a>00121 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a45318b077b4923e5d339053d41d6d2b3"></a><!-- doxytag: member="fringe_model.c::compute_pshift" ref="a45318b077b4923e5d339053d41d6d2b3" args="(const gsl_complex refract, const double thickness, const double phase_number)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gsl_complex compute_pshift </td>
          <td>(</td>
          <td class="paramtype">const gsl_complex&nbsp;</td>
          <td class="paramname"> <em>refract</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>thickness</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>phase_number</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Function: compute_pshift The function computes the phase shift of a plane wave with a given inverse wavelelength (phase number) traversing TWO TIMES a layer of a given thickness and complex refraction index.</p>
<p>Parameters: </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>refract</em>&nbsp;</td><td>- the complex refraction index </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>thickness</em>&nbsp;</td><td>- the thickness of the layer </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>phase_number</em>&nbsp;</td><td>- the inverse wavelength</td></tr>
  </table>
  </dd>
</dl>
<p>Returns: </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>(value) - the complex phase shift </dd></dl>

<p><div class="fragment"><pre class="fragment"><a name="l00801"></a>00801 {
<a name="l00802"></a>00802   <span class="comment">// all in one line:</span>
<a name="l00803"></a>00803   <span class="keywordflow">return</span> gsl_complex_exp(gsl_complex_rect(0.0,2.0*GSL_REAL(refract)*thickness*phase_number));
<a name="l00804"></a>00804 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a0c717cd5d164c86327c7077a33022724"></a><!-- doxytag: member="fringe_model.c::compute_reflection" ref="a0c717cd5d164c86327c7077a33022724" args="(const gsl_complex refract_l1, const gsl_complex refract_l2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double compute_reflection </td>
          <td>(</td>
          <td class="paramtype">const gsl_complex&nbsp;</td>
          <td class="paramname"> <em>refract_l1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const gsl_complex&nbsp;</td>
          <td class="paramname"> <em>refract_l2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Function: compute_reflection The function computes and returns the reflection index (in %) for two complex refraction indices at a given wavelength.</p>
<p>Parameters: </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>refract_l1</em>&nbsp;</td><td>- refraction index of one layer </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>refract_l2</em>&nbsp;</td><td>- refraction index of the second layer</td></tr>
  </table>
  </dd>
</dl>
<p>Returns: </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>(value) - the reflection index </dd></dl>

<p><div class="fragment"><pre class="fragment"><a name="l00697"></a>00697 {
<a name="l00698"></a>00698   gsl_complex conj_l1;
<a name="l00699"></a>00699   gsl_complex conj_l2;
<a name="l00700"></a>00700 
<a name="l00701"></a>00701   gsl_complex refl_compl;
<a name="l00702"></a>00702 
<a name="l00703"></a>00703   <span class="comment">// get the comlex conjugated values of the input</span>
<a name="l00704"></a>00704   conj_l1 = gsl_complex_conjugate(refract_l1);
<a name="l00705"></a>00705   conj_l2 = gsl_complex_conjugate(refract_l2);
<a name="l00706"></a>00706 
<a name="l00707"></a>00707   <span class="comment">// compute the complex reflection</span>
<a name="l00708"></a>00708   refl_compl = gsl_complex_div(gsl_complex_sub(conj_l1, conj_l2),
<a name="l00709"></a>00709                                gsl_complex_add(conj_l1, conj_l2));
<a name="l00710"></a>00710 
<a name="l00711"></a>00711   <span class="comment">// return the magnitude of the complex reflection</span>
<a name="l00712"></a>00712   <span class="keywordflow">return</span> gsl_complex_abs2(refl_compl);
<a name="l00713"></a>00713 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a63e9f0b1fcef4d177b599ffb8c4c610d"></a><!-- doxytag: member="fringe_model.c::compute_transmission" ref="a63e9f0b1fcef4d177b599ffb8c4c610d" args="(const gsl_complex refract_l1, const gsl_complex refract_l2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double compute_transmission </td>
          <td>(</td>
          <td class="paramtype">const gsl_complex&nbsp;</td>
          <td class="paramname"> <em>refract_l1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const gsl_complex&nbsp;</td>
          <td class="paramname"> <em>refract_l2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Function: compute_transmission The function computes and returns the transmission index (in %) for two complex refraction indices at a given wavelength.</p>
<p>Parameters: </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>refract_l1</em>&nbsp;</td><td>- refraction index of one layer </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>refract_l2</em>&nbsp;</td><td>- refraction index of the second layer</td></tr>
  </table>
  </dd>
</dl>
<p>Returns: </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>(value) - the trnasmission index </dd></dl>

<p><div class="fragment"><pre class="fragment"><a name="l00731"></a>00731 {
<a name="l00732"></a>00732   gsl_complex conj_l1;
<a name="l00733"></a>00733   gsl_complex conj_l2;
<a name="l00734"></a>00734 
<a name="l00735"></a>00735   gsl_complex trans_compl;
<a name="l00736"></a>00736 
<a name="l00737"></a>00737   <span class="comment">// get the comlex conjugated values of the input</span>
<a name="l00738"></a>00738   conj_l1 = gsl_complex_conjugate(refract_l1);
<a name="l00739"></a>00739   conj_l2 = gsl_complex_conjugate(refract_l2);
<a name="l00740"></a>00740 
<a name="l00741"></a>00741   <span class="comment">// compute the complex transmission</span>
<a name="l00742"></a>00742   trans_compl =
<a name="l00743"></a>00743     gsl_complex_div(gsl_complex_sqrt(gsl_complex_mul(conj_l1, conj_l2)),
<a name="l00744"></a>00744                     gsl_complex_add(conj_l1, conj_l2));
<a name="l00745"></a>00745   
<a name="l00746"></a>00746   <span class="comment">// finish the computation of the complex transmission</span>
<a name="l00747"></a>00747   trans_compl = gsl_complex_mul_real (trans_compl, 2.0);
<a name="l00748"></a>00748 
<a name="l00749"></a>00749   <span class="comment">// return the magnitude of the complex transmission</span>
<a name="l00750"></a>00750   <span class="keywordflow">return</span> gsl_complex_abs2(trans_compl);
<a name="l00751"></a>00751 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ac350c8322c6ddd6d21d854690076eed1"></a><!-- doxytag: member="fringe_model.c::eval_linear_interp" ref="ac350c8322c6ddd6d21d854690076eed1" args="(linear_interp *lin_int, const double xval)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double eval_linear_interp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structlinear__interp.html">linear_interp</a> *&nbsp;</td>
          <td class="paramname"> <em>lin_int</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>xval</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Function: eval_linear_interp The function computes and returns the interpolated value at a given position for a linear <a class="el" href="structinterpolator.html">interpolator</a>.</p>
<p>Parameters: </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>lin_int</em>&nbsp;</td><td>- the linear <a class="el" href="structinterpolator.html">interpolator</a> </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>xval</em>&nbsp;</td><td>- the position to evaluate the linear <a class="el" href="structinterpolator.html">interpolator</a></td></tr>
  </table>
  </dd>
</dl>
<p>Returns: </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>(value) - the interpolated data value </dd></dl>

<p><div class="fragment"><pre class="fragment"><a name="l00582"></a>00582 {
<a name="l00583"></a>00583 
<a name="l00584"></a>00584   <span class="keywordtype">double</span> factor=0.0;
<a name="l00585"></a>00585 
<a name="l00586"></a>00586   <span class="comment">// check whether the x-value is within </span>
<a name="l00587"></a>00587   <span class="comment">// the range spanned by the data;</span>
<a name="l00588"></a>00588   <span class="comment">// complain if the x-value is outside</span>
<a name="l00589"></a>00589   <span class="keywordflow">if</span> (xval &lt; lin_int-&gt;xmin || xval &gt; lin_int-&gt;<a class="code" href="structlinear__interp.html#a07c70a028df86af8bd56afed39e34bc3">xmax</a>)
<a name="l00590"></a>00590     <a class="code" href="aXe__errors_8c.html#a7ef7588e5f91237ba7ce4084e6ed3c11">aXe_message</a> (<a class="code" href="aXe__errors_8h.html#a2556a67874555249b07691c37aa6d6e9">aXe_M_FATAL</a>, __FILE__, __LINE__,
<a name="l00591"></a>00591                  <span class="stringliteral">&quot;independent linear interpolation value %f &quot;</span>
<a name="l00592"></a>00592                  <span class="stringliteral">&quot;is outside interval (%f, %f)\n&quot;</span>, xval,
<a name="l00593"></a>00593                  lin_int-&gt;<a class="code" href="structlinear__interp.html#ae596d0ba2cbacf04e8ca8ec4b2b12999">xmin</a>, lin_int-&gt;<a class="code" href="structlinear__interp.html#a07c70a028df86af8bd56afed39e34bc3">xmax</a>);
<a name="l00594"></a>00594 
<a name="l00595"></a>00595   <span class="comment">// check whether you have to search upwards or downwards</span>
<a name="l00596"></a>00596   <span class="keywordflow">if</span> (xval &gt;= gsl_vector_get(lin_int-&gt;<a class="code" href="structlinear__interp.html#afda3a38e339f779b46246d52f1605a65">xvals</a>, lin_int-&gt;<a class="code" href="structlinear__interp.html#a188bb88ba290596ef94628b0f5a684ba">act_index</a>))
<a name="l00597"></a>00597     {
<a name="l00598"></a>00598 
<a name="l00599"></a>00599       <span class="comment">// in case that you search upwards, go up</span>
<a name="l00600"></a>00600       <span class="comment">// the independent values until you find the right interval</span>
<a name="l00601"></a>00601       lin_int-&gt;<a class="code" href="structlinear__interp.html#a188bb88ba290596ef94628b0f5a684ba">act_index</a> += 1;
<a name="l00602"></a>00602       <span class="keywordflow">while</span>(xval &gt; gsl_vector_get(lin_int-&gt;<a class="code" href="structlinear__interp.html#afda3a38e339f779b46246d52f1605a65">xvals</a>, lin_int-&gt;<a class="code" href="structlinear__interp.html#a188bb88ba290596ef94628b0f5a684ba">act_index</a>))
<a name="l00603"></a>00603         lin_int-&gt;<a class="code" href="structlinear__interp.html#a188bb88ba290596ef94628b0f5a684ba">act_index</a>++;
<a name="l00604"></a>00604     }
<a name="l00605"></a>00605   <span class="keywordflow">else</span>
<a name="l00606"></a>00606     {
<a name="l00607"></a>00607 
<a name="l00608"></a>00608       <span class="comment">// in case that you search downwards, go down</span>
<a name="l00609"></a>00609       <span class="comment">// the independent values  until you find the right interval</span>
<a name="l00610"></a>00610       <span class="comment">//      while(wavelength &lt; resp-&gt;spec[nact-1].lambda_mean)</span>
<a name="l00611"></a>00611       <span class="keywordflow">while</span>(xval &lt; gsl_vector_get(lin_int-&gt;<a class="code" href="structlinear__interp.html#afda3a38e339f779b46246d52f1605a65">xvals</a>, lin_int-&gt;<a class="code" href="structlinear__interp.html#a188bb88ba290596ef94628b0f5a684ba">act_index</a>-1))
<a name="l00612"></a>00612         lin_int-&gt;<a class="code" href="structlinear__interp.html#a188bb88ba290596ef94628b0f5a684ba">act_index</a>--;
<a name="l00613"></a>00613     }
<a name="l00614"></a>00614 
<a name="l00615"></a>00615   <span class="comment">// interpolate within the interval to calculate the </span>
<a name="l00616"></a>00616   <span class="comment">// sensitivity</span>
<a name="l00617"></a>00617   factor = (xval - gsl_vector_get(lin_int-&gt;<a class="code" href="structlinear__interp.html#afda3a38e339f779b46246d52f1605a65">xvals</a>, lin_int-&gt;<a class="code" href="structlinear__interp.html#a188bb88ba290596ef94628b0f5a684ba">act_index</a>-1))/
<a name="l00618"></a>00618     (gsl_vector_get(lin_int-&gt;<a class="code" href="structlinear__interp.html#afda3a38e339f779b46246d52f1605a65">xvals</a>, lin_int-&gt;<a class="code" href="structlinear__interp.html#a188bb88ba290596ef94628b0f5a684ba">act_index</a>) - gsl_vector_get(lin_int-&gt;<a class="code" href="structlinear__interp.html#afda3a38e339f779b46246d52f1605a65">xvals</a>, lin_int-&gt;<a class="code" href="structlinear__interp.html#a188bb88ba290596ef94628b0f5a684ba">act_index</a>-1));
<a name="l00619"></a>00619 
<a name="l00620"></a>00620   <span class="comment">// compute and terutn the interpolated value</span>
<a name="l00621"></a>00621     <span class="keywordflow">return</span> (gsl_vector_get(lin_int-&gt;<a class="code" href="structlinear__interp.html#a5f5e240a2f31547ed083b1013b5da850">yvals</a>, lin_int-&gt;<a class="code" href="structlinear__interp.html#a188bb88ba290596ef94628b0f5a684ba">act_index</a>-1)
<a name="l00622"></a>00622     + factor * (gsl_vector_get(lin_int-&gt;<a class="code" href="structlinear__interp.html#a5f5e240a2f31547ed083b1013b5da850">yvals</a>, lin_int-&gt;<a class="code" href="structlinear__interp.html#a188bb88ba290596ef94628b0f5a684ba">act_index</a>)-gsl_vector_get(lin_int-&gt;<a class="code" href="structlinear__interp.html#a5f5e240a2f31547ed083b1013b5da850">yvals</a>, lin_int-&gt;<a class="code" href="structlinear__interp.html#a188bb88ba290596ef94628b0f5a684ba">act_index</a>-1)));
<a name="l00623"></a>00623 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a49198f0a9909b50f00a1f8202b2905d3"></a><!-- doxytag: member="fringe_model.c::evaluate_wavelength_steps" ref="a49198f0a9909b50f00a1f8202b2905d3" args="(fringe_conf *fconf)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gsl_vector** evaluate_wavelength_steps </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structfringe__conf.html">fringe_conf</a> *&nbsp;</td>
          <td class="paramname"> <em>fconf</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Function: evaluate_wavelength_steps The function defines and computes the wavelength steps and the filter throughputs which are used to compute the fringe amplitude for all pixels. The basis for the wavelength data are the filter data and the general are where fringing is significant and computed, which is defined in the fringe configuration structure. First all throughput values below a certain value are discarded at the short and long wavelength edge. Then the final wavelength range is determined using the fringing range. Then all wavelength values and the filter throughputs are determined and returned as two gsl-vectors.</p>
<p>Parameters: </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>fconf</em>&nbsp;</td><td>- the fringe configuration structure</td></tr>
  </table>
  </dd>
</dl>
<p>Returns: </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>double_vector - a set of two gsl-vectors with wavlength and throughput </dd></dl>

<p><div class="fragment"><pre class="fragment"><a name="l00386"></a>00386 {
<a name="l00387"></a>00387   <span class="keywordtype">int</span> index=0;
<a name="l00388"></a>00388   <span class="keywordtype">int</span> lower=0;
<a name="l00389"></a>00389   <span class="keywordtype">int</span> upper=0;
<a name="l00390"></a>00390 
<a name="l00391"></a>00391   <span class="keywordtype">int</span> nsteps;
<a name="l00392"></a>00392 
<a name="l00393"></a>00393   <span class="keywordtype">double</span> lambda_min;
<a name="l00394"></a>00394   <span class="keywordtype">double</span> lambda_max;
<a name="l00395"></a>00395   <span class="keywordtype">double</span> lambda_act;
<a name="l00396"></a>00396   <span class="keywordtype">double</span> through_act=0.0;
<a name="l00397"></a>00397   <span class="keywordtype">double</span> through_tot=0.0;
<a name="l00398"></a>00398 
<a name="l00399"></a>00399   gsl_vector *lambda_values;
<a name="l00400"></a>00400   gsl_vector *through_values;
<a name="l00401"></a>00401 
<a name="l00402"></a>00402   gsl_vector **double_vector;
<a name="l00403"></a>00403 
<a name="l00404"></a>00404 
<a name="l00405"></a>00405   <span class="comment">// allocate space for the return vector</span>
<a name="l00406"></a>00406   double_vector  = (gsl_vector **)malloc(2*<span class="keyword">sizeof</span> (gsl_vector *));
<a name="l00407"></a>00407 
<a name="l00408"></a>00408   <span class="comment">// search through the filter data</span>
<a name="l00409"></a>00409   <span class="comment">// to narrow the usable range from below</span>
<a name="l00410"></a>00410   lower=0;
<a name="l00411"></a>00411   <span class="keywordflow">while</span> (lower &lt; fconf-&gt;filter_through-&gt;nvals
<a name="l00412"></a>00412          &amp;&amp; fconf-&gt;<a class="code" href="structfringe__conf.html#abe82bcdcd21b328bb374df7b1af43153">filter_through</a>-&gt;<a class="code" href="structinterpolator.html#a990b3a655c74b64fd02f04b5fc344ff0">yvals</a>[lower] &lt; <a class="code" href="fringe__conf_8h.html#aee45f3007241406bbff51414aa630450">FILTER_THRESHOLD</a>)
<a name="l00413"></a>00413     lower++;
<a name="l00414"></a>00414   lower = <a class="code" href="aper__conf_8c.html#aacc3ee1a7f283f8ef65cea31f4436a95">MAX</a>(0,lower-1);
<a name="l00415"></a>00415 
<a name="l00416"></a>00416   <span class="comment">// search through the filter data</span>
<a name="l00417"></a>00417   <span class="comment">// to narrow the usable range from above</span>
<a name="l00418"></a>00418   upper=fconf-&gt;<a class="code" href="structfringe__conf.html#abe82bcdcd21b328bb374df7b1af43153">filter_through</a>-&gt;<a class="code" href="structinterpolator.html#a058a378f76dfb0349cd2016f450a7332">nvals</a> - 1;
<a name="l00419"></a>00419   <span class="keywordflow">while</span> (upper &gt; -1
<a name="l00420"></a>00420          &amp;&amp; fconf-&gt;<a class="code" href="structfringe__conf.html#abe82bcdcd21b328bb374df7b1af43153">filter_through</a>-&gt;<a class="code" href="structinterpolator.html#a990b3a655c74b64fd02f04b5fc344ff0">yvals</a>[upper] &lt; <a class="code" href="fringe__conf_8h.html#aee45f3007241406bbff51414aa630450">FILTER_THRESHOLD</a>)
<a name="l00421"></a>00421     upper--;
<a name="l00422"></a>00422   upper = <a class="code" href="aXe__utils_8c.html#a74e75242132eaabbc1c512488a135926">MIN</a>(fconf-&gt;<a class="code" href="structfringe__conf.html#abe82bcdcd21b328bb374df7b1af43153">filter_through</a>-&gt;<a class="code" href="structinterpolator.html#a058a378f76dfb0349cd2016f450a7332">nvals</a> - 1, upper+1);
<a name="l00423"></a>00423 
<a name="l00424"></a>00424 <span class="preprocessor">#ifdef DEBUGFCONF</span>
<a name="l00425"></a>00425 <span class="preprocessor"></span>  fprintf(stderr, <span class="stringliteral">&quot;New lower range index: %i, new upper: %i, old number: %i\n&quot;</span>,
<a name="l00426"></a>00426           lower, upper, fconf-&gt;<a class="code" href="structfringe__conf.html#abe82bcdcd21b328bb374df7b1af43153">filter_through</a>-&gt;<a class="code" href="structinterpolator.html#a058a378f76dfb0349cd2016f450a7332">nvals</a>);
<a name="l00427"></a>00427 <span class="preprocessor">#endif</span>
<a name="l00428"></a>00428 <span class="preprocessor"></span>
<a name="l00429"></a>00429   <span class="comment">// replace the old filter interpolator</span>
<a name="l00430"></a>00430   <span class="comment">// with a new one, if necessary</span>
<a name="l00431"></a>00431   <span class="keywordflow">if</span> (lower != 0 || upper != (fconf-&gt;<a class="code" href="structfringe__conf.html#abe82bcdcd21b328bb374df7b1af43153">filter_through</a>-&gt;<a class="code" href="structinterpolator.html#a058a378f76dfb0349cd2016f450a7332">nvals</a> - 1))
<a name="l00432"></a>00432     fconf-&gt;<a class="code" href="structfringe__conf.html#abe82bcdcd21b328bb374df7b1af43153">filter_through</a> = <a class="code" href="fringe__model_8c.html#a8f0e1b1f5664107be3cba2068c0a83e1">redefine_filter_throughput</a>(lower, upper, fconf);
<a name="l00433"></a>00433 
<a name="l00434"></a>00434   <span class="comment">// compute the lower wavelength range by comparing</span>
<a name="l00435"></a>00435   <span class="comment">// the filter throughput with the range important</span>
<a name="l00436"></a>00436   <span class="comment">// for fringing; the latter is given in AA!!</span>
<a name="l00437"></a>00437   lambda_min = <a class="code" href="aper__conf_8c.html#aacc3ee1a7f283f8ef65cea31f4436a95">MAX</a>(gsl_vector_get(fconf-&gt;<a class="code" href="structfringe__conf.html#aa96d6742b1e0009ca830907949e8875b">fringe_range</a>, 0),
<a name="l00438"></a>00438                    fconf-&gt;<a class="code" href="structfringe__conf.html#abe82bcdcd21b328bb374df7b1af43153">filter_through</a>-&gt;<a class="code" href="structinterpolator.html#a09c1238a6c4be948ef51e29676074b6f">xmin</a>);
<a name="l00439"></a>00439 
<a name="l00440"></a>00440   <span class="comment">// compute the upper wavelength range by comparing</span>
<a name="l00441"></a>00441   <span class="comment">// the filter throughput with the range important</span>
<a name="l00442"></a>00442   <span class="comment">// for fringing; the latter is given in AA!!</span>
<a name="l00443"></a>00443   lambda_max = <a class="code" href="aXe__utils_8c.html#a74e75242132eaabbc1c512488a135926">MIN</a>(gsl_vector_get(fconf-&gt;<a class="code" href="structfringe__conf.html#aa96d6742b1e0009ca830907949e8875b">fringe_range</a>, 1),
<a name="l00444"></a>00444                    fconf-&gt;<a class="code" href="structfringe__conf.html#abe82bcdcd21b328bb374df7b1af43153">filter_through</a>-&gt;<a class="code" href="structinterpolator.html#a4ccf4f1e42f5207f311bffcbebb7ea9c">xmax</a>);
<a name="l00445"></a>00445 
<a name="l00446"></a>00446   <span class="comment">// find the number of steps to cover the wavelength range</span>
<a name="l00447"></a>00447   nsteps = (int)ceil((lambda_max-lambda_min)/(fconf-&gt;<a class="code" href="structfringe__conf.html#aa2e4fd8fec88650b18a12372ef85ba4b">fringe_step</a>)) + 1;
<a name="l00448"></a>00448 
<a name="l00449"></a>00449   <span class="comment">// allocate the space for the vectors</span>
<a name="l00450"></a>00450   lambda_values  = gsl_vector_alloc(nsteps);
<a name="l00451"></a>00451   through_values = gsl_vector_alloc(nsteps);
<a name="l00452"></a>00452 
<a name="l00453"></a>00453   <span class="comment">// fill the vectors with the wavelength steps and the </span>
<a name="l00454"></a>00454   <span class="comment">// filter throughput at those wavelengths.</span>
<a name="l00455"></a>00455   lambda_act = lambda_min;
<a name="l00456"></a>00456   <span class="keywordflow">for</span> (index=0; index &lt; nsteps-1; index+=1)
<a name="l00457"></a>00457     {
<a name="l00458"></a>00458       gsl_vector_set(lambda_values, index, lambda_act);
<a name="l00459"></a>00459       through_act = <a class="code" href="fringe__conf_8c.html#ace9546cd2761b6436b8295f6ce94fba1">eval_interp</a>(fconf-&gt;<a class="code" href="structfringe__conf.html#abe82bcdcd21b328bb374df7b1af43153">filter_through</a>, lambda_act);
<a name="l00460"></a>00460       through_tot += through_act;
<a name="l00461"></a>00461       gsl_vector_set(through_values, index, through_act);
<a name="l00462"></a>00462       lambda_act += fconf-&gt;<a class="code" href="structfringe__conf.html#aa2e4fd8fec88650b18a12372ef85ba4b">fringe_step</a>;
<a name="l00463"></a>00463     }
<a name="l00464"></a>00464 
<a name="l00465"></a>00465   <span class="comment">// add also the values at lambda_amax</span>
<a name="l00466"></a>00466   gsl_vector_set(lambda_values, nsteps-1, lambda_max);
<a name="l00467"></a>00467   through_act = <a class="code" href="fringe__conf_8c.html#ace9546cd2761b6436b8295f6ce94fba1">eval_interp</a>(fconf-&gt;<a class="code" href="structfringe__conf.html#abe82bcdcd21b328bb374df7b1af43153">filter_through</a>, lambda_max);
<a name="l00468"></a>00468   through_tot += through_act;
<a name="l00469"></a>00469   gsl_vector_set(through_values, nsteps-1, through_act);
<a name="l00470"></a>00470 
<a name="l00471"></a>00471  
<a name="l00472"></a>00472   <span class="keywordflow">for</span> (index=0; index &lt; through_values-&gt;size; index++)
<a name="l00473"></a>00473     {
<a name="l00474"></a>00474       <span class="comment">// normalize the filter throughput values</span>
<a name="l00475"></a>00475       gsl_vector_set(through_values, index,
<a name="l00476"></a>00476                      gsl_vector_get(through_values, index)/through_tot);
<a name="l00477"></a>00477 
<a name="l00478"></a>00478       <span class="comment">// convert the wavelength from AA to micron</span>
<a name="l00479"></a>00479       gsl_vector_set(lambda_values, index,
<a name="l00480"></a>00480                      gsl_vector_get(lambda_values, index)*1.0e-04);
<a name="l00481"></a>00481     }
<a name="l00482"></a>00482 <span class="preprocessor">#ifdef DEBUGFCONF</span>
<a name="l00483"></a>00483 <span class="preprocessor"></span>  through_tot = 0.0;
<a name="l00484"></a>00484   <span class="keywordflow">for</span> (index=0; index &lt; through_values-&gt;size; index++)
<a name="l00485"></a>00485     {
<a name="l00486"></a>00486       fprintf(stderr, <span class="stringliteral">&quot;Wavelength: %f, Throughput: %f\n&quot;</span>,
<a name="l00487"></a>00487               gsl_vector_get(lambda_values, index),
<a name="l00488"></a>00488               gsl_vector_get(through_values, index));
<a name="l00489"></a>00489       through_tot += gsl_vector_get(through_values, index);
<a name="l00490"></a>00490     }
<a name="l00491"></a>00491   fprintf(stderr, <span class="stringliteral">&quot;Total throughput: %f\n&quot;</span>, through_tot);
<a name="l00492"></a>00492 <span class="preprocessor">#endif</span>
<a name="l00493"></a>00493 <span class="preprocessor"></span>
<a name="l00494"></a>00494   <span class="comment">// build up the output array</span>
<a name="l00495"></a>00495   double_vector[0] = lambda_values;
<a name="l00496"></a>00496   double_vector[1] = through_values;
<a name="l00497"></a>00497 
<a name="l00498"></a>00498   <span class="keywordflow">return</span> double_vector;
<a name="l00499"></a>00499 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a7583c38c8f52f4db360e402b0cff8354"></a><!-- doxytag: member="fringe_model.c::fill_optprops_all" ref="a7583c38c8f52f4db360e402b0cff8354" args="(const ccd_layers *opt_layers, const double lambda, optical_property *optprops)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fill_optprops_all </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structccd__layers.html">ccd_layers</a> *&nbsp;</td>
          <td class="paramname"> <em>opt_layers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>lambda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structoptical__property.html">optical_property</a> *&nbsp;</td>
          <td class="paramname"> <em>optprops</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><div class="fragment"><pre class="fragment"><a name="l01009"></a>01009 {
<a name="l01010"></a>01010   <span class="keywordtype">int</span> index;
<a name="l01011"></a>01011 
<a name="l01012"></a>01012   <span class="keywordtype">double</span> phase_number;
<a name="l01013"></a>01013 
<a name="l01014"></a>01014   gsl_complex compl_upp;
<a name="l01015"></a>01015   gsl_complex compl_low;
<a name="l01016"></a>01016 
<a name="l01017"></a>01017   <span class="keywordtype">int</span> num_layers;
<a name="l01018"></a>01018 
<a name="l01019"></a>01019   <span class="comment">// store the number of layers</span>
<a name="l01020"></a>01020   num_layers = opt_layers-&gt;<a class="code" href="structccd__layers.html#a228a06a9acfab17cbdec81a21e82a58a">num_layers</a>;
<a name="l01021"></a>01021 
<a name="l01022"></a>01022   <span class="comment">// compute the phase number</span>
<a name="l01023"></a>01023   phase_number = 2.0*M_PI / lambda;
<a name="l01024"></a>01024 
<a name="l01025"></a>01025   <span class="comment">// get the complex refractive index for the first layer</span>
<a name="l01026"></a>01026   compl_upp =
<a name="l01027"></a>01027     <a class="code" href="fringe__model_8c.html#acdd00a7b8f4c951200544ae65e90e38b">get_complex_refindex</a>(opt_layers-&gt;<a class="code" href="structccd__layers.html#ae9861ce32cfcdbdec138e90f66f8ce9f">opt_layer</a>[0],lambda);
<a name="l01028"></a>01028 
<a name="l01029"></a>01029   <span class="keywordflow">for</span> (index=0; index &lt; num_layers-1; index++)
<a name="l01030"></a>01030     {
<a name="l01031"></a>01031 
<a name="l01032"></a>01032       <span class="comment">// get the refractive index for the next layer</span>
<a name="l01033"></a>01033       compl_low =
<a name="l01034"></a>01034         <a class="code" href="fringe__model_8c.html#acdd00a7b8f4c951200544ae65e90e38b">get_complex_refindex</a>(opt_layers-&gt;<a class="code" href="structccd__layers.html#ae9861ce32cfcdbdec138e90f66f8ce9f">opt_layer</a>[index+1],lambda);
<a name="l01035"></a>01035 
<a name="l01036"></a>01036       <span class="comment">// compute the reflection and transmission</span>
<a name="l01037"></a>01037       <span class="comment">// to the lower layers</span>
<a name="l01038"></a>01038       optprops[index].<a class="code" href="structoptical__property.html#abf81db5da1e05a9f72d6baed4dea69e4">reflect_lower</a> =
<a name="l01039"></a>01039         <a class="code" href="fringe__model_8c.html#a0c717cd5d164c86327c7077a33022724">compute_reflection</a>(compl_upp, compl_low);
<a name="l01040"></a>01040       optprops[index].<a class="code" href="structoptical__property.html#a3e8917182777e9314832fd4efd9a2105">trans_lower</a>   = 1.0 - optprops[index].<a class="code" href="structoptical__property.html#abf81db5da1e05a9f72d6baed4dea69e4">reflect_lower</a>;
<a name="l01041"></a>01041 
<a name="l01042"></a>01042       <span class="comment">// compute the reflection and transmission</span>
<a name="l01043"></a>01043       <span class="comment">// to the upper layers</span>
<a name="l01044"></a>01044       optprops[index+1].<a class="code" href="structoptical__property.html#a1c483ffff6b6392a5200798f1d74077c">reflect_upper</a> = optprops[index].<a class="code" href="structoptical__property.html#abf81db5da1e05a9f72d6baed4dea69e4">reflect_lower</a>;
<a name="l01045"></a>01045       optprops[index+1].<a class="code" href="structoptical__property.html#a97c5d40160ec802fc519857500e13072">trans_upper</a>   = 1.0 - optprops[index+1].<a class="code" href="structoptical__property.html#a1c483ffff6b6392a5200798f1d74077c">reflect_upper</a>;
<a name="l01046"></a>01046 
<a name="l01047"></a>01047       <span class="comment">// compute the attenuation</span>
<a name="l01048"></a>01048       optprops[index].<a class="code" href="structoptical__property.html#a558bb1c84d5da44820be51660781cc57">double_attenuation</a> =
<a name="l01049"></a>01049         <a class="code" href="fringe__model_8c.html#ae4753d72683ba416c4b01b25685501f8">compute_attenuation</a>(compl_upp,optprops[index].thickness,phase_number);
<a name="l01050"></a>01050 
<a name="l01051"></a>01051       <span class="comment">// compute the phase shift</span>
<a name="l01052"></a>01052       optprops[index].<a class="code" href="structoptical__property.html#a541278c1aa9254d59a00530bb188df61">double_phshift</a> =
<a name="l01053"></a>01053         <a class="code" href="fringe__model_8c.html#a45318b077b4923e5d339053d41d6d2b3">compute_pshift</a>(compl_upp, optprops[index].thickness, phase_number);
<a name="l01054"></a>01054 
<a name="l01055"></a>01055 
<a name="l01056"></a>01056       <span class="comment">// prepare the next iteration:</span>
<a name="l01057"></a>01057       <span class="comment">// the now upper layer will then be the lower</span>
<a name="l01058"></a>01058       compl_upp = compl_low;
<a name="l01059"></a>01059     }
<a name="l01060"></a>01060   <span class="comment">// compute the attenuation for the last layer</span>
<a name="l01061"></a>01061   optprops[num_layers-1].<a class="code" href="structoptical__property.html#a558bb1c84d5da44820be51660781cc57">double_attenuation</a> =
<a name="l01062"></a>01062     <a class="code" href="fringe__model_8c.html#ae4753d72683ba416c4b01b25685501f8">compute_attenuation</a>(compl_upp,optprops[num_layers-1].thickness,phase_number);
<a name="l01063"></a>01063  
<a name="l01064"></a>01064   <span class="comment">// compute the phase shift for the last layer</span>
<a name="l01065"></a>01065   optprops[num_layers-1].<a class="code" href="structoptical__property.html#a541278c1aa9254d59a00530bb188df61">double_phshift</a> =
<a name="l01066"></a>01066     <a class="code" href="fringe__model_8c.html#a45318b077b4923e5d339053d41d6d2b3">compute_pshift</a>(compl_upp, optprops[num_layers-1].thickness, phase_number);
<a name="l01067"></a>01067 
<a name="l01068"></a>01068   <span class="comment">// compute the transmission of the last layer</span>
<a name="l01069"></a>01069   <span class="comment">// towards the substrate</span>
<a name="l01070"></a>01070   optprops[num_layers-1].<a class="code" href="structoptical__property.html#a3e8917182777e9314832fd4efd9a2105">trans_lower</a> = 
<a name="l01071"></a>01071     <a class="code" href="fringe__conf_8c.html#ace9546cd2761b6436b8295f6ce94fba1">eval_interp</a>(opt_layers-&gt;<a class="code" href="structccd__layers.html#ab144a515d289cf051cabcecc9adf8343">substrate</a>, lambda);
<a name="l01072"></a>01072 
<a name="l01073"></a>01073   <span class="comment">// compute the reflection of the last layer</span>
<a name="l01074"></a>01074   <span class="comment">// towards the substrate</span>
<a name="l01075"></a>01075   optprops[num_layers-1].<a class="code" href="structoptical__property.html#abf81db5da1e05a9f72d6baed4dea69e4">reflect_lower</a> =
<a name="l01076"></a>01076     1.0 - optprops[num_layers-1].<a class="code" href="structoptical__property.html#a3e8917182777e9314832fd4efd9a2105">trans_lower</a>;
<a name="l01077"></a>01077 
<a name="l01078"></a>01078 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a4d241cd2c21f6836aabfc05690fa2361"></a><!-- doxytag: member="fringe_model.c::fill_optprops_thickness" ref="a4d241cd2c21f6836aabfc05690fa2361" args="(const ccd_layers *opt_layers, const int ii, const int jj, optical_property *optprops)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fill_optprops_thickness </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structccd__layers.html">ccd_layers</a> *&nbsp;</td>
          <td class="paramname"> <em>opt_layers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>ii</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>jj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structoptical__property.html">optical_property</a> *&nbsp;</td>
          <td class="paramname"> <em>optprops</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><div class="fragment"><pre class="fragment"><a name="l00979"></a>00979 {
<a name="l00980"></a>00980   <span class="keywordtype">int</span> index;
<a name="l00981"></a>00981 
<a name="l00982"></a>00982   <span class="comment">// go over all layers</span>
<a name="l00983"></a>00983   <span class="keywordflow">for</span> (index=0; index &lt; opt_layers-&gt;<a class="code" href="structccd__layers.html#a228a06a9acfab17cbdec81a21e82a58a">num_layers</a>; index++)
<a name="l00984"></a>00984     <span class="comment">// get and store the thickness</span>
<a name="l00985"></a>00985     optprops[index].thickness =
<a name="l00986"></a>00986       <a class="code" href="fringe__model_8c.html#a4b144c7b307bae789a6b06582364de66">get_layer_thickness</a>(opt_layers-&gt;<a class="code" href="structccd__layers.html#ae9861ce32cfcdbdec138e90f66f8ce9f">opt_layer</a>[index], ii, jj);
<a name="l00987"></a>00987 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a1b8ec54dcd7b41e31b24bbc5baacdd28"></a><!-- doxytag: member="fringe_model.c::free_optprops_list" ref="a1b8ec54dcd7b41e31b24bbc5baacdd28" args="(optical_property *optprops)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void free_optprops_list </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structoptical__property.html">optical_property</a> *&nbsp;</td>
          <td class="paramname"> <em>optprops</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Function: free_optprops_list The function releases the space allocated in an optical property list.</p>
<p>Parameters: </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>optprops</em>&nbsp;</td><td>- the optical property list</td></tr>
  </table>
  </dd>
</dl>
<p>Returns: </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>- </dd></dl>

<p><div class="fragment"><pre class="fragment"><a name="l00872"></a>00872 {
<a name="l00873"></a>00873   <span class="keywordflow">if</span> (optprops != NULL)
<a name="l00874"></a>00874     {
<a name="l00875"></a>00875       <span class="comment">// free the structure</span>
<a name="l00876"></a>00876       free(optprops);
<a name="l00877"></a>00877 
<a name="l00878"></a>00878       <span class="comment">// set it to NULL</span>
<a name="l00879"></a>00879       optprops = NULL;
<a name="l00880"></a>00880     }
<a name="l00881"></a>00881 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ab3355b989a07f5f88786c7148a5c76e5"></a><!-- doxytag: member="fringe_model.c::fringe_contrib_single" ref="ab3355b989a07f5f88786c7148a5c76e5" args="(const optical_property *optprops, const fringe_conf *fconf)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double fringe_contrib_single </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structoptical__property.html">optical_property</a> *&nbsp;</td>
          <td class="paramname"> <em>optprops</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structfringe__conf.html">fringe_conf</a> *&nbsp;</td>
          <td class="paramname"> <em>fconf</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><div class="fragment"><pre class="fragment"><a name="l01101"></a>01101 {
<a name="l01102"></a>01102   <span class="keywordtype">int</span> index=2;
<a name="l01103"></a>01103  
<a name="l01104"></a>01104   gsl_complex amp_tmp;
<a name="l01105"></a>01105   gsl_complex amp_tot;
<a name="l01106"></a>01106 
<a name="l01107"></a>01107 
<a name="l01108"></a>01108   <span class="comment">// compute the initial phase at the top of the</span>
<a name="l01109"></a>01109   <span class="comment">// first layer</span>
<a name="l01110"></a>01110   amp_tot =
<a name="l01111"></a>01111     gsl_complex_mul_real(gsl_complex_exp(gsl_complex_rect(0.0,fconf-&gt;<a class="code" href="structfringe__conf.html#a063f94aa831f45434151fcd07e18a05d">fringe_phase</a>*M_PI/180.0)), 1.0);
<a name="l01112"></a>01112   
<a name="l01113"></a>01113 
<a name="l01114"></a>01114   <span class="comment">// transfer the intitial value </span>
<a name="l01115"></a>01115   <span class="comment">// to the running variable</span>
<a name="l01116"></a>01116   amp_tmp = amp_tot; 
<a name="l01117"></a>01117    
<a name="l01118"></a>01118   <span class="comment">// pile up the amplitude,</span>
<a name="l01119"></a>01119   <span class="comment">// also putting in the transmission</span>
<a name="l01120"></a>01120   amp_tmp =
<a name="l01121"></a>01121     gsl_complex_mul(amp_tmp,
<a name="l01122"></a>01122                     gsl_complex_mul_real(optprops[0].double_phshift,
<a name="l01123"></a>01123                                          1.0*1.0*optprops[0].double_attenuation));
<a name="l01124"></a>01124 
<a name="l01125"></a>01125   <span class="comment">// compute the intermediate result </span>
<a name="l01126"></a>01126   <span class="comment">// for the first layer</span>
<a name="l01127"></a>01127   amp_tot = 
<a name="l01128"></a>01128     gsl_complex_add(amp_tot, 
<a name="l01129"></a>01129                     gsl_complex_mul_real(amp_tmp,
<a name="l01130"></a>01130                                          optprops[0].sign_lower*optprops[0].reflect_lower));
<a name="l01131"></a>01131 
<a name="l01132"></a>01132   <span class="comment">// go over layer 2 to the end</span>
<a name="l01133"></a>01133   <span class="keywordflow">for</span> (index=1; index &lt; fconf-&gt;<a class="code" href="structfringe__conf.html#a82eebf75b191ca25f824437be6f23c51">opt_layers</a>-&gt;<a class="code" href="structccd__layers.html#a228a06a9acfab17cbdec81a21e82a58a">num_layers</a>; index++)
<a name="l01134"></a>01134     {
<a name="l01135"></a>01135       <span class="comment">// pile up the amplitude </span>
<a name="l01136"></a>01136       <span class="comment">// to that layer</span>
<a name="l01137"></a>01137       amp_tmp =
<a name="l01138"></a>01138         gsl_complex_mul(amp_tmp,
<a name="l01139"></a>01139                         gsl_complex_mul_real(optprops[index].double_phshift,
<a name="l01140"></a>01140                                            optprops[index-1].trans_lower*optprops[index].trans_upper*optprops[index].double_attenuation));
<a name="l01141"></a>01141 
<a name="l01142"></a>01142       <span class="comment">// compute the intermediate result </span>
<a name="l01143"></a>01143       <span class="comment">// for the that layer</span>
<a name="l01144"></a>01144       amp_tot = 
<a name="l01145"></a>01145         gsl_complex_add(amp_tot, 
<a name="l01146"></a>01146                         gsl_complex_mul_real(amp_tmp,
<a name="l01147"></a>01147                                              optprops[index].sign_lower*optprops[index].reflect_lower));
<a name="l01148"></a>01148       <span class="comment">//      if (index==3)</span>
<a name="l01149"></a>01149       <span class="comment">//        fprintf(stdout,&quot;ccc:%f, %f\n&quot;, GSL_REAL(amp_tmp),GSL_IMAG(amp_tmp) );</span>
<a name="l01150"></a>01150 
<a name="l01151"></a>01151     }
<a name="l01152"></a>01152 
<a name="l01153"></a>01153   <span class="comment">// return the final value</span>
<a name="l01154"></a>01154   <span class="keywordflow">return</span> (GSL_REAL(amp_tot) - 1.0);
<a name="l01155"></a>01155 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="aa1d042ae3943c7168b6d8c18bced875d"></a><!-- doxytag: member="fringe_model.c::get_calibration_data" ref="aa1d042ae3943c7168b6d8c18bced875d" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gsl_vector** get_calibration_data </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Function: <a class="el" href="fringe__model_8c.html#aa1d042ae3943c7168b6d8c18bced875d">get_calibration_data()</a> This function is a data storage for filter throughput values as computed by the orioginal program 'final.f' of J.Walsh. The cubic spline routine used there turned out to give (slightly) different results than the gsl-routine used here. To be able making a in-depth comparison the throughuts were computed for the filter 'ccd_ref.fits' and stored here.</p>
<p>Parameters:</p>
<p>Returns: </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>double_vector - interpolated standard filter throughputs </dd></dl>

<p><div class="fragment"><pre class="fragment"><a name="l00237"></a>00237 {
<a name="l00238"></a>00238   gsl_vector *lambda_values;
<a name="l00239"></a>00239   gsl_vector *through_values;
<a name="l00240"></a>00240 
<a name="l00241"></a>00241   gsl_vector **double_vector;
<a name="l00242"></a>00242 
<a name="l00243"></a>00243 
<a name="l00244"></a>00244   <span class="comment">// allocate space for the return vector</span>
<a name="l00245"></a>00245   double_vector  = (gsl_vector **)malloc(2*<span class="keyword">sizeof</span> (gsl_vector *));
<a name="l00246"></a>00246 
<a name="l00247"></a>00247   <span class="comment">// allocate the space for the vectors</span>
<a name="l00248"></a>00248   lambda_values  = gsl_vector_alloc(43);
<a name="l00249"></a>00249   through_values = gsl_vector_alloc(43);
<a name="l00250"></a>00250 
<a name="l00251"></a>00251 
<a name="l00252"></a>00252   <span class="comment">// what follows is the wavelength steps as well as the normalized</span>
<a name="l00253"></a>00253   <span class="comment">// filter throughputs which were computed in the original</span>
<a name="l00254"></a>00254   <span class="comment">// program &apos;final.f&apos; of J.Walsh.</span>
<a name="l00255"></a>00255   <span class="comment">// The gsl-cubic spline routine yields slightly different values.</span>
<a name="l00256"></a>00256   <span class="comment">// The values fixed here are good for a detailed cross-check</span>
<a name="l00257"></a>00257   <span class="comment">// of the two programs.</span>
<a name="l00258"></a>00258   gsl_vector_set(through_values, 0, 0.0000000000000000);gsl_vector_set(lambda_values, 0,   0.9179);
<a name="l00259"></a>00259   gsl_vector_set(through_values, 1, 0.0095066184313808);gsl_vector_set(lambda_values, 1,   0.9180);
<a name="l00260"></a>00260   gsl_vector_set(through_values, 2, 0.0176006475945001);gsl_vector_set(lambda_values, 2,   0.9181);
<a name="l00261"></a>00261   gsl_vector_set(through_values, 3, 0.0240259215044616);gsl_vector_set(lambda_values, 3,   0.9182);
<a name="l00262"></a>00262   gsl_vector_set(through_values, 4, 0.0289185490230508);gsl_vector_set(lambda_values, 4,   0.9183);
<a name="l00263"></a>00263   gsl_vector_set(through_values, 5, 0.0324146730103703);gsl_vector_set(lambda_values, 5,   0.9184);
<a name="l00264"></a>00264   gsl_vector_set(through_values, 6, 0.0346504181940869);gsl_vector_set(lambda_values, 6,   0.9185);
<a name="l00265"></a>00265   gsl_vector_set(through_values, 7, 0.0357619115684218);gsl_vector_set(lambda_values, 7,   0.9186);
<a name="l00266"></a>00266   gsl_vector_set(through_values, 8, 0.0358852710613785);gsl_vector_set(lambda_values, 8,   0.9187);
<a name="l00267"></a>00267   gsl_vector_set(through_values, 9, 0.0351566282002872);gsl_vector_set(lambda_values, 9,   0.9188);
<a name="l00268"></a>00268   gsl_vector_set(through_values,10, 0.0337121099793692);gsl_vector_set(lambda_values,10,   0.9189);
<a name="l00269"></a>00269   gsl_vector_set(through_values,11, 0.0316878433928458);gsl_vector_set(lambda_values,11,   0.9190);
<a name="l00270"></a>00270   gsl_vector_set(through_values,12, 0.0292199509018293);gsl_vector_set(lambda_values,12,   0.9191);
<a name="l00271"></a>00271   gsl_vector_set(through_values,13, 0.0264445572339866);gsl_vector_set(lambda_values,13,   0.9192);
<a name="l00272"></a>00272   gsl_vector_set(through_values,14, 0.0234977916500934);gsl_vector_set(lambda_values,14,   0.9193);
<a name="l00273"></a>00273   gsl_vector_set(through_values,15, 0.0205157811443709);gsl_vector_set(lambda_values,15,   0.9194);
<a name="l00274"></a>00274   gsl_vector_set(through_values,16, 0.0176346504444861);gsl_vector_set(lambda_values,16,   0.9195);
<a name="l00275"></a>00275   gsl_vector_set(through_values,17, 0.0149905288112146);gsl_vector_set(lambda_values,17,   0.9196);
<a name="l00276"></a>00276   gsl_vector_set(through_values,18, 0.0127195375723916);gsl_vector_set(lambda_values,18,   0.9197);
<a name="l00277"></a>00277   gsl_vector_set(through_values,19, 0.0109578003224067);gsl_vector_set(lambda_values,19,   0.9198);
<a name="l00278"></a>00278   gsl_vector_set(through_values,20, 0.0098414542549762);gsl_vector_set(lambda_values,20,   0.9199);
<a name="l00279"></a>00279   gsl_vector_set(through_values,21, 0.0095066184313808);gsl_vector_set(lambda_values,21,   0.9200);
<a name="l00280"></a>00280   gsl_vector_set(through_values,22, 0.0100435357173845);gsl_vector_set(lambda_values,22,   0.9201);
<a name="l00281"></a>00281   gsl_vector_set(through_values,23, 0.0113589226644173);gsl_vector_set(lambda_values,23,   0.9202);
<a name="l00282"></a>00282   gsl_vector_set(through_values,24, 0.0133136264280558);gsl_vector_set(lambda_values,24,   0.9203);
<a name="l00283"></a>00283   gsl_vector_set(through_values,25, 0.0157684646986687);gsl_vector_set(lambda_values,25,   0.9204);
<a name="l00284"></a>00284   gsl_vector_set(through_values,26, 0.0185842800987238);gsl_vector_set(lambda_values,26,   0.9205);
<a name="l00285"></a>00285   gsl_vector_set(through_values,27, 0.0216219095843027);gsl_vector_set(lambda_values,27,   0.9206);
<a name="l00286"></a>00286   gsl_vector_set(through_values,28, 0.0247421844451007);gsl_vector_set(lambda_values,28,   0.9207);
<a name="l00287"></a>00287   gsl_vector_set(through_values,29, 0.0278059450370313);gsl_vector_set(lambda_values,29,   0.9208);
<a name="l00288"></a>00288   gsl_vector_set(through_values,30, 0.0306740203832353);gsl_vector_set(lambda_values,30,   0.9209);
<a name="l00289"></a>00289   gsl_vector_set(through_values,31, 0.0332072463065172);gsl_vector_set(lambda_values,31,   0.9210);
<a name="l00290"></a>00290   gsl_vector_set(through_values,32, 0.0352664608962358);gsl_vector_set(lambda_values,32,   0.9211);
<a name="l00291"></a>00291   gsl_vector_set(through_values,33, 0.0367124999751954);gsl_vector_set(lambda_values,33,   0.9212);
<a name="l00292"></a>00292   gsl_vector_set(through_values,34, 0.0374061970996460);gsl_vector_set(lambda_values,34,   0.9213);
<a name="l00293"></a>00293   gsl_vector_set(through_values,35, 0.0372083835592830);gsl_vector_set(lambda_values,35,   0.9214);
<a name="l00294"></a>00294   gsl_vector_set(through_values,36, 0.0359798997100196);gsl_vector_set(lambda_values,36,   0.9215);
<a name="l00295"></a>00295   gsl_vector_set(through_values,37, 0.0335815745749970);gsl_vector_set(lambda_values,37,   0.9216);
<a name="l00296"></a>00296   gsl_vector_set(through_values,38, 0.0298742553097917);gsl_vector_set(lambda_values,38,   0.9217);
<a name="l00297"></a>00297   gsl_vector_set(through_values,39, 0.0247187709375447);gsl_vector_set(lambda_values,39,   0.9218);
<a name="l00298"></a>00298   gsl_vector_set(through_values,40, 0.0179759414151792);gsl_vector_set(lambda_values,40,   0.9219);
<a name="l00299"></a>00299   gsl_vector_set(through_values,41, 0.0095066184313808);gsl_vector_set(lambda_values,41,   0.9220);
<a name="l00300"></a>00300   gsl_vector_set(through_values,42, 0.0000000000000000);gsl_vector_set(lambda_values,42,   0.9221);
<a name="l00301"></a>00301   
<a name="l00302"></a>00302   <span class="comment">// build up the output array</span>
<a name="l00303"></a>00303   double_vector[0] = lambda_values;
<a name="l00304"></a>00304   double_vector[1] = through_values;
<a name="l00305"></a>00305 
<a name="l00306"></a>00306   <span class="comment">// return the two vectors</span>
<a name="l00307"></a>00307   <span class="keywordflow">return</span> double_vector;
<a name="l00308"></a>00308 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="acdd00a7b8f4c951200544ae65e90e38b"></a><!-- doxytag: member="fringe_model.c::get_complex_refindex" ref="acdd00a7b8f4c951200544ae65e90e38b" args="(const ccd_layer *opt_layer, const double lambda)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gsl_complex get_complex_refindex </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structccd__layer.html">ccd_layer</a> *&nbsp;</td>
          <td class="paramname"> <em>opt_layer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>lambda</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Function: get_complex_refindex The function computes and returns the complex refraction index of a given CCD layer at a given wavelength.</p>
<p>Parameters: </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>opt_layer</em>&nbsp;</td><td>- the optical layer </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>lambda</em>&nbsp;</td><td>- the wavelength</td></tr>
  </table>
  </dd>
</dl>
<p>Returns: </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>(value) - the complex refraction index </dd></dl>

<p><div class="fragment"><pre class="fragment"><a name="l00667"></a>00667 {
<a name="l00668"></a>00668   <span class="keywordtype">double</span> re;
<a name="l00669"></a>00669   <span class="keywordtype">double</span> im;
<a name="l00670"></a>00670 
<a name="l00671"></a>00671   <span class="comment">// compute the real part</span>
<a name="l00672"></a>00672   re = <a class="code" href="fringe__conf_8c.html#ace9546cd2761b6436b8295f6ce94fba1">eval_interp</a>(opt_layer-&gt;<a class="code" href="structccd__layer.html#add2149e5c5ee94567c955b2cd82c7e92">re_refraction</a>, lambda);
<a name="l00673"></a>00673 
<a name="l00674"></a>00674   <span class="comment">// comute the imaginary part</span>
<a name="l00675"></a>00675   im = <a class="code" href="fringe__conf_8c.html#ace9546cd2761b6436b8295f6ce94fba1">eval_interp</a>(opt_layer-&gt;<a class="code" href="structccd__layer.html#a893d59ee0cd5db8abd32b4259a0a7484">im_refraction</a>, lambda);
<a name="l00676"></a>00676 
<a name="l00677"></a>00677   <span class="comment">// return the complex number</span>
<a name="l00678"></a>00678   <span class="keywordflow">return</span> gsl_complex_rect(re, im);
<a name="l00679"></a>00679 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a4b144c7b307bae789a6b06582364de66"></a><!-- doxytag: member="fringe_model.c::get_layer_thickness" ref="a4b144c7b307bae789a6b06582364de66" args="(const ccd_layer *opt_layer, const int ii, const int jj)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double get_layer_thickness </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structccd__layer.html">ccd_layer</a> *&nbsp;</td>
          <td class="paramname"> <em>opt_layer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>ii</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>jj</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Function: get_layer_thickness The function determines the thickness of an individual layer at a given pixel position.</p>
<p>Parameters: </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>opt_layer</em>&nbsp;</td><td>- the optical layer </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ii</em>&nbsp;</td><td>- the first pixel index </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>jj</em>&nbsp;</td><td>- the second pixel index</td></tr>
  </table>
  </dd>
</dl>
<p>Returns: </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>(value) - the thickness of the layer at the requested position </dd></dl>

<p><div class="fragment"><pre class="fragment"><a name="l00642"></a>00642 {
<a name="l00643"></a>00643   <span class="comment">// check whether the thickness is 2D</span>
<a name="l00644"></a>00644   <span class="keywordflow">if</span> (opt_layer-&gt;<a class="code" href="structccd__layer.html#a831ea82c1e042d7fc58c507b682a32b0">thickness2D</a>)
<a name="l00645"></a>00645     <span class="comment">// return the 2D value</span>
<a name="l00646"></a>00646     <span class="keywordflow">return</span> <a class="code" href="aXe__grism_8h.html#acf709ee71c580f1cd65d726ed03200ea">gsl_matrix_get</a>(opt_layer-&gt;<a class="code" href="structccd__layer.html#a831ea82c1e042d7fc58c507b682a32b0">thickness2D</a>, ii, jj);
<a name="l00647"></a>00647   <span class="keywordflow">else</span>
<a name="l00648"></a>00648     <span class="comment">// return the constant value</span>
<a name="l00649"></a>00649     <span class="keywordflow">return</span> opt_layer-&gt;<a class="code" href="structccd__layer.html#a8bada4a0ff9e515bd8c177644d72af1a">thickness</a>;
<a name="l00650"></a>00650 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a825847406083c196d7fb8363cdd5f7ff"></a><!-- doxytag: member="fringe_model.c::get_PET_calibration_data" ref="a825847406083c196d7fb8363cdd5f7ff" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gsl_vector** get_PET_calibration_data </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Function: <a class="el" href="fringe__model_8c.html#a825847406083c196d7fb8363cdd5f7ff">get_PET_calibration_data()</a> </p>

<p><div class="fragment"><pre class="fragment"><a name="l00316"></a>00316 {
<a name="l00317"></a>00317   gsl_vector *lambda_values;
<a name="l00318"></a>00318   gsl_vector *through_values;
<a name="l00319"></a>00319 
<a name="l00320"></a>00320   gsl_vector **double_vector;
<a name="l00321"></a>00321 
<a name="l00322"></a>00322 
<a name="l00323"></a>00323   <span class="comment">// allocate space for the return vector</span>
<a name="l00324"></a>00324   double_vector  = (gsl_vector **)malloc(2*<span class="keyword">sizeof</span> (gsl_vector *));
<a name="l00325"></a>00325 
<a name="l00326"></a>00326   <span class="comment">// allocate the space for the vectors</span>
<a name="l00327"></a>00327   lambda_values  = gsl_vector_alloc(21);
<a name="l00328"></a>00328   through_values = gsl_vector_alloc(21);
<a name="l00329"></a>00329 
<a name="l00330"></a>00330   gsl_vector_set(lambda_values, 0,1.069460);  gsl_vector_set(through_values, 0, 0.000000);
<a name="l00331"></a>00331   gsl_vector_set(lambda_values, 1,1.069653);  gsl_vector_set(through_values, 1, 0.012630);
<a name="l00332"></a>00332   gsl_vector_set(lambda_values, 2,1.069846);  gsl_vector_set(through_values, 2, 0.025261);
<a name="l00333"></a>00333   gsl_vector_set(lambda_values, 3,1.070039);  gsl_vector_set(through_values, 3, 0.037891);
<a name="l00334"></a>00334   gsl_vector_set(lambda_values, 4,1.070232);  gsl_vector_set(through_values, 4,   0.050522);
<a name="l00335"></a>00335   gsl_vector_set(lambda_values, 5,1.070424);  gsl_vector_set(through_values, 5,   0.063152);
<a name="l00336"></a>00336   gsl_vector_set(lambda_values, 6,1.070617);  gsl_vector_set(through_values, 6,   0.069010);
<a name="l00337"></a>00337   gsl_vector_set(lambda_values, 7,1.070810);  gsl_vector_set(through_values, 7,   0.069010);
<a name="l00338"></a>00338   gsl_vector_set(lambda_values, 8,1.071003);  gsl_vector_set(through_values, 8,   0.069010);
<a name="l00339"></a>00339   gsl_vector_set(lambda_values, 9,1.071196);  gsl_vector_set(through_values, 9,   0.069010);
<a name="l00340"></a>00340   gsl_vector_set(lambda_values, 10,1.071389); gsl_vector_set(through_values, 10,   0.069010);
<a name="l00341"></a>00341   gsl_vector_set(lambda_values, 11,1.071582); gsl_vector_set(through_values, 11,   0.069010);
<a name="l00342"></a>00342   gsl_vector_set(lambda_values, 12,1.071775); gsl_vector_set(through_values, 12,   0.069010);
<a name="l00343"></a>00343   gsl_vector_set(lambda_values, 13,1.071967); gsl_vector_set(through_values, 13,   0.069010);
<a name="l00344"></a>00344   gsl_vector_set(lambda_values, 14,1.072160); gsl_vector_set(through_values, 14,   0.069010);
<a name="l00345"></a>00345   gsl_vector_set(lambda_values, 15,1.072353); gsl_vector_set(through_values, 15,   0.063152);
<a name="l00346"></a>00346   gsl_vector_set(lambda_values, 16,1.072546); gsl_vector_set(through_values, 16,   0.050522);
<a name="l00347"></a>00347   gsl_vector_set(lambda_values, 17,1.072739); gsl_vector_set(through_values, 17,   0.037891);
<a name="l00348"></a>00348   gsl_vector_set(lambda_values, 18,1.072932); gsl_vector_set(through_values, 18,   0.025261);
<a name="l00349"></a>00349   gsl_vector_set(lambda_values, 19,1.073125); gsl_vector_set(through_values, 19,  0.012630);
<a name="l00350"></a>00350   gsl_vector_set(lambda_values, 20,1.073318); gsl_vector_set(through_values, 20,   0.000000);
<a name="l00351"></a>00351 
<a name="l00352"></a>00352   <span class="comment">//Wavelength: 10713.888672, fringe factor: 1.097945, (x,y): (18, 745)</span>
<a name="l00353"></a>00353 
<a name="l00354"></a>00354   
<a name="l00355"></a>00355   <span class="comment">// build up the output array</span>
<a name="l00356"></a>00356   double_vector[0] = lambda_values;
<a name="l00357"></a>00357   double_vector[1] = through_values;
<a name="l00358"></a>00358 
<a name="l00359"></a>00359   <span class="comment">// return the two vectors</span>
<a name="l00360"></a>00360   <span class="keywordflow">return</span> double_vector;
<a name="l00361"></a>00361 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a30b4bda7a269be14d5225de5aaec952e"></a><!-- doxytag: member="fringe_model.c::init_optprops_list" ref="a30b4bda7a269be14d5225de5aaec952e" args="(const fringe_conf *fconf, const double lambda_mean, optical_property *optprops)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void init_optprops_list </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structfringe__conf.html">fringe_conf</a> *&nbsp;</td>
          <td class="paramname"> <em>fconf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>lambda_mean</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structoptical__property.html">optical_property</a> *&nbsp;</td>
          <td class="paramname"> <em>optprops</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><div class="fragment"><pre class="fragment"><a name="l00903"></a>00903 {
<a name="l00904"></a>00904   <span class="keywordtype">int</span> num_layers;
<a name="l00905"></a>00905   <span class="keywordtype">int</span> index;
<a name="l00906"></a>00906 
<a name="l00907"></a>00907   <span class="keywordtype">double</span> n1;
<a name="l00908"></a>00908   <span class="keywordtype">double</span> n2;
<a name="l00909"></a>00909 
<a name="l00910"></a>00910   <span class="comment">// determine the number of layers</span>
<a name="l00911"></a>00911   num_layers = fconf-&gt;<a class="code" href="structfringe__conf.html#a82eebf75b191ca25f824437be6f23c51">opt_layers</a>-&gt;<a class="code" href="structccd__layers.html#a228a06a9acfab17cbdec81a21e82a58a">num_layers</a>;
<a name="l00912"></a>00912 
<a name="l00913"></a>00913   <span class="keywordflow">if</span> (num_layers &gt; 0)
<a name="l00914"></a>00914     {
<a name="l00915"></a>00915       <span class="comment">// set the transmission and reflection</span>
<a name="l00916"></a>00916       <span class="comment">// vacuum -- first CCD layer</span>
<a name="l00917"></a>00917       <span class="comment">// that&apos;s a bit heuristic, since</span>
<a name="l00918"></a>00918       <span class="comment">// the true value using the true</span>
<a name="l00919"></a>00919       <span class="comment">// refration index for vacuum would</span>
<a name="l00920"></a>00920       <span class="comment">// give a different result</span>
<a name="l00921"></a>00921       optprops[0].<a class="code" href="structoptical__property.html#a97c5d40160ec802fc519857500e13072">trans_upper</a>   = 1.0;
<a name="l00922"></a>00922       optprops[0].<a class="code" href="structoptical__property.html#a1c483ffff6b6392a5200798f1d74077c">reflect_upper</a> = 0.0;      
<a name="l00923"></a>00923 
<a name="l00924"></a>00924       <span class="comment">// also that one is a bit heuristic</span>
<a name="l00925"></a>00925       <span class="comment">// but assuming n(vacuum)=1.0 its also true </span>
<a name="l00926"></a>00926       optprops[0].<a class="code" href="structoptical__property.html#afc3a820943b39f39fa102fd3f4fecc18">sign_upper</a> = 1.0;
<a name="l00927"></a>00927 
<a name="l00928"></a>00928       <span class="comment">// set the sign of the lowest layer -- substrate</span>
<a name="l00929"></a>00929       <span class="comment">// this is purely heuristic and works </span>
<a name="l00930"></a>00930       <span class="comment">// only for the HRC/WFC fringing models!! </span>
<a name="l00931"></a>00931       optprops[num_layers-1].<a class="code" href="structoptical__property.html#a0aa625d6bded51f0b5e4fcb1a41d8ec1">sign_lower</a> = -1.0;
<a name="l00932"></a>00932     }
<a name="l00933"></a>00933 
<a name="l00934"></a>00934   <span class="keywordflow">for</span> (index=0; index &lt; num_layers-1; index++)
<a name="l00935"></a>00935     {
<a name="l00936"></a>00936       <span class="comment">// get the real part of the refraction index</span>
<a name="l00937"></a>00937       <span class="comment">// of the upper layer</span>
<a name="l00938"></a>00938       n1 = GSL_REAL(<a class="code" href="fringe__model_8c.html#acdd00a7b8f4c951200544ae65e90e38b">get_complex_refindex</a>(fconf-&gt;<a class="code" href="structfringe__conf.html#a82eebf75b191ca25f824437be6f23c51">opt_layers</a>-&gt;<a class="code" href="structccd__layers.html#ae9861ce32cfcdbdec138e90f66f8ce9f">opt_layer</a>[index],
<a name="l00939"></a>00939                                          lambda_mean));
<a name="l00940"></a>00940 
<a name="l00941"></a>00941       <span class="comment">// get the real part of the refraction index</span>
<a name="l00942"></a>00942       <span class="comment">// of the lower layer</span>
<a name="l00943"></a>00943       n2 = GSL_REAL(<a class="code" href="fringe__model_8c.html#acdd00a7b8f4c951200544ae65e90e38b">get_complex_refindex</a>(fconf-&gt;<a class="code" href="structfringe__conf.html#a82eebf75b191ca25f824437be6f23c51">opt_layers</a>-&gt;<a class="code" href="structccd__layers.html#ae9861ce32cfcdbdec138e90f66f8ce9f">opt_layer</a>[index+1],
<a name="l00944"></a>00944                                          lambda_mean));
<a name="l00945"></a>00945 
<a name="l00946"></a>00946       <span class="comment">// distribute the signs</span>
<a name="l00947"></a>00947       <span class="comment">// for the upper and lower layer</span>
<a name="l00948"></a>00948       <span class="keywordflow">if</span> (n1 &lt; n2)
<a name="l00949"></a>00949         {
<a name="l00950"></a>00950           optprops[index].<a class="code" href="structoptical__property.html#a0aa625d6bded51f0b5e4fcb1a41d8ec1">sign_lower</a>   =  1.0;
<a name="l00951"></a>00951           optprops[index+1].<a class="code" href="structoptical__property.html#afc3a820943b39f39fa102fd3f4fecc18">sign_upper</a> = -1.0;
<a name="l00952"></a>00952         }
<a name="l00953"></a>00953       <span class="keywordflow">else</span>
<a name="l00954"></a>00954         {
<a name="l00955"></a>00955           optprops[index].<a class="code" href="structoptical__property.html#a0aa625d6bded51f0b5e4fcb1a41d8ec1">sign_lower</a>   = -1.0;
<a name="l00956"></a>00956           optprops[index+1].<a class="code" href="structoptical__property.html#afc3a820943b39f39fa102fd3f4fecc18">sign_upper</a> =  1.0;
<a name="l00957"></a>00957         }
<a name="l00958"></a>00958     }
<a name="l00959"></a>00959 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a8d36095f41729289c111fa1fa483a807"></a><!-- doxytag: member="fringe_model.c::print_optprops_list" ref="a8d36095f41729289c111fa1fa483a807" args="(const optical_property *optprops, const int num_entries)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void print_optprops_list </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structoptical__property.html">optical_property</a> *&nbsp;</td>
          <td class="paramname"> <em>optprops</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>num_entries</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Function: print_optprops_list The function prints the content of an optical property list onto the screen.</p>
<p>Parameters: </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>optprops</em>&nbsp;</td><td>- the optical property list</td></tr>
  </table>
  </dd>
</dl>
<p>Returns: </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>- </dd></dl>

<p><div class="fragment"><pre class="fragment"><a name="l00846"></a>00846 {
<a name="l00847"></a>00847   <span class="keywordtype">int</span> index;
<a name="l00848"></a>00848   
<a name="l00849"></a>00849   <span class="keywordflow">for</span> (index = 0; index &lt; num_entries; index++)
<a name="l00850"></a>00850     {
<a name="l00851"></a>00851       fprintf(stdout, <span class="stringliteral">&quot;#%i: %f %f %f %f %f %f \n&quot;</span>,index,
<a name="l00852"></a>00852               optprops[index].trans_upper, optprops[index].reflect_upper,
<a name="l00853"></a>00853               GSL_REAL(optprops[index].double_phshift),
<a name="l00854"></a>00854               GSL_IMAG(optprops[index].double_phshift),
<a name="l00855"></a>00855               optprops[index].trans_lower, optprops[index].reflect_lower);
<a name="l00856"></a>00856     }
<a name="l00857"></a>00857 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a8f0e1b1f5664107be3cba2068c0a83e1"></a><!-- doxytag: member="fringe_model.c::redefine_filter_throughput" ref="a8f0e1b1f5664107be3cba2068c0a83e1" args="(const int lower, const int upper, fringe_conf *fconf)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structinterpolator.html">interpolator</a>* redefine_filter_throughput </td>
          <td>(</td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>lower</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>upper</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structfringe__conf.html">fringe_conf</a> *&nbsp;</td>
          <td class="paramname"> <em>fconf</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Function: redefine_filter_throughput The function re-defines an existing <a class="el" href="structinterpolator.html">interpolator</a> using only the existing data values in an index range given as parameters.</p>
<p>Parameters: </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>lower</em>&nbsp;</td><td>- index with the lowest data point </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>upper</em>&nbsp;</td><td>- index with the highest data point</td></tr>
  </table>
  </dd>
</dl>
<p>Returns: </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>new_interp - the new <a class="el" href="structinterpolator.html">interpolator</a> </dd></dl>

<p><div class="fragment"><pre class="fragment"><a name="l00516"></a>00516 {
<a name="l00517"></a>00517   <span class="keywordtype">int</span> new_nvals;
<a name="l00518"></a>00518   <span class="keywordtype">int</span> index;
<a name="l00519"></a>00519 
<a name="l00520"></a>00520   <span class="keywordtype">double</span> *new_x;
<a name="l00521"></a>00521   <span class="keywordtype">double</span> *new_y;
<a name="l00522"></a>00522 
<a name="l00523"></a>00523   <a class="code" href="structinterpolator.html">interpolator</a> *new_interp;
<a name="l00524"></a>00524  
<a name="l00525"></a>00525    <span class="comment">// allocate space for the return structure;</span>
<a name="l00526"></a>00526   <span class="comment">// complain if this fails</span>
<a name="l00527"></a>00527   new_interp = (<a class="code" href="structinterpolator.html">interpolator</a> *)malloc (<span class="keyword">sizeof</span> (<a class="code" href="structinterpolator.html">interpolator</a>));
<a name="l00528"></a>00528   <span class="keywordflow">if</span> (new_interp == NULL)
<a name="l00529"></a>00529       <a class="code" href="aXe__errors_8c.html#a7ef7588e5f91237ba7ce4084e6ed3c11">aXe_message</a> (<a class="code" href="aXe__errors_8h.html#a2556a67874555249b07691c37aa6d6e9">aXe_M_FATAL</a>, __FILE__, __LINE__,
<a name="l00530"></a>00530                    <span class="stringliteral">&quot;Could not allocate memory for interpolator&quot;</span>);
<a name="l00531"></a>00531 
<a name="l00532"></a>00532   <span class="comment">// compute the new length of the data arrays</span>
<a name="l00533"></a>00533   new_nvals = upper-lower+1;
<a name="l00534"></a>00534 
<a name="l00535"></a>00535   <span class="comment">// allocate space for the new data arrays</span>
<a name="l00536"></a>00536   new_x = (<span class="keywordtype">double</span> *)malloc(new_nvals*<span class="keyword">sizeof</span>(<span class="keywordtype">double</span>));
<a name="l00537"></a>00537   new_y = (<span class="keywordtype">double</span> *)malloc(new_nvals*<span class="keyword">sizeof</span>(<span class="keywordtype">double</span>));
<a name="l00538"></a>00538 
<a name="l00539"></a>00539   <span class="comment">// transfer the data</span>
<a name="l00540"></a>00540   <span class="keywordflow">for</span> (index=lower; index &lt; upper+1; index++)
<a name="l00541"></a>00541     {
<a name="l00542"></a>00542       new_x[index-lower] = fconf-&gt;<a class="code" href="structfringe__conf.html#abe82bcdcd21b328bb374df7b1af43153">filter_through</a>-&gt;<a class="code" href="structinterpolator.html#a0114ddc19b1dd09d7920d11970e22a8e">xvals</a>[index];
<a name="l00543"></a>00543       new_y[index-lower] = fconf-&gt;<a class="code" href="structfringe__conf.html#abe82bcdcd21b328bb374df7b1af43153">filter_through</a>-&gt;<a class="code" href="structinterpolator.html#a990b3a655c74b64fd02f04b5fc344ff0">yvals</a>[index];
<a name="l00544"></a>00544     }
<a name="l00545"></a>00545 
<a name="l00546"></a>00546   <span class="comment">// free the old structure</span>
<a name="l00547"></a>00547   <a class="code" href="fringe__conf_8c.html#a518a01a879febbaf974b85585defaf7c">free_interp</a>(fconf-&gt;<a class="code" href="structfringe__conf.html#abe82bcdcd21b328bb374df7b1af43153">filter_through</a>);
<a name="l00548"></a>00548 
<a name="l00549"></a>00549   <span class="comment">// build up the interpolator structure</span>
<a name="l00550"></a>00550   new_interp-&gt;<a class="code" href="structinterpolator.html#a09c1238a6c4be948ef51e29676074b6f">xmin</a>    = new_x[0];
<a name="l00551"></a>00551   new_interp-&gt;<a class="code" href="structinterpolator.html#a4ccf4f1e42f5207f311bffcbebb7ea9c">xmax</a>    = new_x[new_nvals-1];
<a name="l00552"></a>00552   new_interp-&gt;<a class="code" href="structinterpolator.html#a058a378f76dfb0349cd2016f450a7332">nvals</a>   = new_nvals;
<a name="l00553"></a>00553   new_interp-&gt;<a class="code" href="structinterpolator.html#a0114ddc19b1dd09d7920d11970e22a8e">xvals</a>   = new_x;
<a name="l00554"></a>00554   new_interp-&gt;<a class="code" href="structinterpolator.html#a990b3a655c74b64fd02f04b5fc344ff0">yvals</a>   = new_y;
<a name="l00555"></a>00555   new_interp-&gt;<a class="code" href="structinterpolator.html#ac56df03bb67d65c1ebfd99a4c0d5438b">acc</a>     = gsl_interp_accel_alloc();
<a name="l00556"></a>00556   new_interp-&gt;<a class="code" href="structinterpolator.html#abc3ee4eff3db3bcae7407d825710fb0d">interp</a>  = gsl_interp_alloc(<a class="code" href="fringe__conf_8h.html#a71212969dcee17149ade8393c642f454">FILTER_INTERP_TYPE</a>,
<a name="l00557"></a>00557                                          new_interp-&gt;<a class="code" href="structinterpolator.html#a058a378f76dfb0349cd2016f450a7332">nvals</a>);
<a name="l00558"></a>00558 
<a name="l00559"></a>00559   <span class="comment">// initialize the cubic spline</span>
<a name="l00560"></a>00560   gsl_interp_init(new_interp-&gt;<a class="code" href="structinterpolator.html#abc3ee4eff3db3bcae7407d825710fb0d">interp</a>, new_interp-&gt;<a class="code" href="structinterpolator.html#a0114ddc19b1dd09d7920d11970e22a8e">xvals</a>, new_interp-&gt;<a class="code" href="structinterpolator.html#a990b3a655c74b64fd02f04b5fc344ff0">yvals</a>, 
<a name="l00561"></a>00561                   new_interp-&gt;<a class="code" href="structinterpolator.html#a058a378f76dfb0349cd2016f450a7332">nvals</a>);
<a name="l00562"></a>00562   
<a name="l00563"></a>00563   <span class="comment">// return the new structure</span>
<a name="l00564"></a>00564   <span class="keywordflow">return</span> new_interp;
<a name="l00565"></a>00565 }
</pre></div></p>

</div>
</div>
</div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&nbsp;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&nbsp;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&nbsp;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&nbsp;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&nbsp;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&nbsp;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&nbsp;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&nbsp;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&nbsp;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&nbsp;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr size="1"/><address style="text-align: right;"><small>Generated on 12 Oct 2014 for TIPS by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.1 </small></address>
</body>
</html>
