<!-- This comment will put IE 6, 7 and 8 in quirks mode -->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>TIPS: /renoir/fourmano/Desktop/OUSIM/TIPS/branches/tips_build/src/axesim/spc_fluxcube.c File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.6.1 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <img id="MSearchSelect" src="search/search.png"
             onmouseover="return searchBox.OnSearchSelectShow()"
             onmouseout="return searchBox.OnSearchSelectHide()"
             alt=""/>
        <input type="text" id="MSearchField" value="Search" accesskey="S"
             onfocus="searchBox.OnSearchFieldFocus(true)" 
             onblur="searchBox.OnSearchFieldFocus(false)" 
             onkeyup="searchBox.OnSearchFieldChange(event)"/>
        <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
        </div>
      </li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>/renoir/fourmano/Desktop/OUSIM/TIPS/branches/tips_build/src/axesim/spc_fluxcube.c File Reference</h1><code>#include &lt;math.h&gt;</code><br/>
<code>#include &lt;fitsio.h&gt;</code><br/>
<code>#include &lt;gsl/gsl_matrix.h&gt;</code><br/>
<code>#include &lt;gsl/gsl_vector.h&gt;</code><br/>
<code>#include &lt;gsl/gsl_interp.h&gt;</code><br/>
<code>#include &quot;<a class="el" href="inout__aper_8h_source.html">inout_aper.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="aXe__grism_8h_source.html">aXe_grism.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="spce__PET_8h_source.html">spce_PET.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="spc__wl__calib_8h_source.html">spc_wl_calib.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="aXe__errors_8h_source.html">aXe_errors.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="fringe__conf_8h_source.html">fringe_conf.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="spc__resp_8h_source.html">spc_resp.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="spce__pathlength_8h_source.html">spce_pathlength.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="aper__conf_8h_source.html">aper_conf.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="trace__conf_8h_source.html">trace_conf.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="specmodel__utils_8h_source.html">specmodel_utils.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="model__utils_8h_source.html">model_utils.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="spc__fluxcube_8h_source.html">spc_fluxcube.h</a>&quot;</code><br/>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Namespaces</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacespcfluxcube.html">spcfluxcube</a></td></tr>
<tr><td colspan="2"><h2>Defines</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="spc__fluxcube_8c.html#aacc3ee1a7f283f8ef65cea31f4436a95">MAX</a>(x, y)&nbsp;&nbsp;&nbsp;(((x)&gt;(y))?(x):(y))</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="spc__fluxcube_8c.html#a74e75242132eaabbc1c512488a135926">MIN</a>(x, y)&nbsp;&nbsp;&nbsp;(((x)&lt;(y))?(x):(y))</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="spc__fluxcube_8c.html#aa7866fa5e4e0ee9b034e9dab6599a9cc">SQR</a>(x)&nbsp;&nbsp;&nbsp;((x)*(x))</td></tr>
<tr><td colspan="2"><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structflux__cube.html">flux_cube</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="spc__fluxcube_8c.html#ab4f88c30f07f1b2e86e3c156ae495691">load_fluxcube</a> (const char fcube_file[])</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structflux__cube.html">flux_cube</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="spc__fluxcube_8c.html#ad34f3325fb0c75b628a15f8dfb856b61">alloc_fluxcube</a> (const int nflux)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="spc__fluxcube_8c.html#a20041a83ddc2d8aa08695983981141ba">load_offsets</a> (const char fcube_file[], <a class="el" href="structflux__cube.html">flux_cube</a> *fcube)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">gsl_matrix_int *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="spc__fluxcube_8c.html#a80aa93013c03ce8ca7d5a2fddf0ed404">load_segmentation</a> (const char fcube_file[])</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structflux__image.html">flux_image</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="spc__fluxcube_8c.html#ab25b98aa66e43bc8a965e7ee056795ed">load_fluximage</a> (const char fcube_file[], int hdunum)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">gsl_vector_int *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="spc__fluxcube_8c.html#a5c1a750847b6040abc13eeabb47585b2">order_fluxims</a> (<a class="el" href="structflux__cube.html">flux_cube</a> *fcube)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="spc__fluxcube_8c.html#a4326413c31d848f7f10076d3776b2d08">free_fluxcube</a> (<a class="el" href="structflux__cube.html">flux_cube</a> *fcube)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="spc__fluxcube_8c.html#a106c1cdd426ec4412413f3926a69e825">free_fluximage</a> (<a class="el" href="structflux__image.html">flux_image</a> *fimage)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structd__point.html">d_point</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="spc__fluxcube_8c.html#a350fb76c81c3285d1978f350e3a0fe8b">flt_to_fcube_trans</a> (const <a class="el" href="structflux__cube.html">flux_cube</a> *fcube, const <a class="el" href="structd__point.html">d_point</a> flt_point)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structd__point.html">d_point</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="spc__fluxcube_8c.html#adbcfc42b8b653d54a14f17e4de25619d">fcube_to_flt_trans</a> (const <a class="el" href="structflux__cube.html">flux_cube</a> *fcube, const <a class="el" href="structd__point.html">d_point</a> fcube_point)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structdirobject.html">dirobject</a> **&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="spc__fluxcube_8c.html#a682c533a63bf1a76022725edab374764">fluxcube_to_dirlist</a> (const <a class="el" href="structflux__cube.html">flux_cube</a> *fcube, <a class="el" href="structobject.html">object</a> **oblist)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structdirobject.html">dirobject</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="spc__fluxcube_8c.html#ad1a7873ace1a14d664bf453c76e27411">dirobject_from_segpoint</a> (const <a class="el" href="structpx__point.html">px_point</a> flt_point, const <a class="el" href="structobject.html">object</a> *actobject)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="spc__fluxcube_8c.html#ad90a902ccd2f90598490b151687c579a">update_dirobject</a> (<a class="el" href="structdirobject.html">dirobject</a> *actdir, const <a class="el" href="structpx__point.html">px_point</a> flt_point)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="spc__fluxcube_8c.html#aecabb3459b749d8e33ea85f4e0bcfcbe">fill_xy_offsets</a> (<a class="el" href="structdirobject.html">dirobject</a> **dirlist, char CONF_file[])</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="spc__fluxcube_8c.html#a2177a42473f70dd15e8fd25315589552">fill_fluxvalues</a> (const <a class="el" href="structflux__cube.html">flux_cube</a> *fcube, const <a class="el" href="structpx__point.html">px_point</a> point, <a class="el" href="structdirobject.html">dirobject</a> *actdir, const int inter_type)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="spc__fluxcube_8c.html#aeb6a2b975b5359734fec27bef4d60d3e">print_fluxcube</a> (const <a class="el" href="structflux__cube.html">flux_cube</a> *fcube)</td></tr>
</table>
<hr/><h2>Define Documentation</h2>
<a class="anchor" id="aacc3ee1a7f283f8ef65cea31f4436a95"></a><!-- doxytag: member="spc_fluxcube.c::MAX" ref="aacc3ee1a7f283f8ef65cea31f4436a95" args="(x, y)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MAX</td>
          <td>(</td>
          <td class="paramtype">x, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">y&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td>&nbsp;&nbsp;&nbsp;(((x)&gt;(y))?(x):(y))</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a74e75242132eaabbc1c512488a135926"></a><!-- doxytag: member="spc_fluxcube.c::MIN" ref="a74e75242132eaabbc1c512488a135926" args="(x, y)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MIN</td>
          <td>(</td>
          <td class="paramtype">x, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">y&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td>&nbsp;&nbsp;&nbsp;(((x)&lt;(y))?(x):(y))</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="aa7866fa5e4e0ee9b034e9dab6599a9cc"></a><!-- doxytag: member="spc_fluxcube.c::SQR" ref="aa7866fa5e4e0ee9b034e9dab6599a9cc" args="(x)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SQR</td>
          <td>(</td>
          <td class="paramtype">x&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td>&nbsp;&nbsp;&nbsp;((x)*(x))</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="ad34f3325fb0c75b628a15f8dfb856b61"></a><!-- doxytag: member="spc_fluxcube.c::alloc_fluxcube" ref="ad34f3325fb0c75b628a15f8dfb856b61" args="(const int nflux)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structflux__cube.html">flux_cube</a>* alloc_fluxcube </td>
          <td>(</td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>nflux</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>The function allocates space for a new fluxcube structure.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>nflux</em>&nbsp;</td><td>- the number of fluximages</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>ret - the fluxcube structure </dd></dl>

<p><div class="fragment"><pre class="fragment"><a name="l00098"></a>00098 {
<a name="l00099"></a>00099    <a class="code" href="structflux__cube.html">flux_cube</a> *fcube;
<a name="l00100"></a>00100 
<a name="l00101"></a>00101    <span class="comment">// allocate space for the flux_cube structure</span>
<a name="l00102"></a>00102    fcube = (<a class="code" href="structflux__cube.html">flux_cube</a> *)malloc(<span class="keyword">sizeof</span>(<a class="code" href="structflux__cube.html">flux_cube</a>));
<a name="l00103"></a>00103 
<a name="l00104"></a>00104    <span class="comment">// allocate space for the array of fluximages</span>
<a name="l00105"></a>00105    fcube-&gt;<a class="code" href="structflux__cube.html#ab8326cc76fb87ffb4aa998f1f3a11cc7">fluxims</a>      = (<a class="code" href="structflux__image.html">flux_image</a> **)malloc(nflux * <span class="keyword">sizeof</span>(<a class="code" href="structflux__image.html">flux_image</a> *));
<a name="l00106"></a>00106 
<a name="l00107"></a>00107    <span class="comment">// return the result</span>
<a name="l00108"></a>00108    <span class="keywordflow">return</span> fcube;
<a name="l00109"></a>00109 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ad1a7873ace1a14d664bf453c76e27411"></a><!-- doxytag: member="spc_fluxcube.c::dirobject_from_segpoint" ref="ad1a7873ace1a14d664bf453c76e27411" args="(const px_point flt_point, const object *actobject)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdirobject.html">dirobject</a>* dirobject_from_segpoint </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structpx__point.html">px_point</a>&nbsp;</td>
          <td class="paramname"> <em>flt_point</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structobject.html">object</a> *&nbsp;</td>
          <td class="paramname"> <em>actobject</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Function: dirobject_from_segpoint</p>
<p>The function creates a a <a class="el" href="structdirobject.html">dirobject</a> on the basis of an <a class="el" href="structobject.html">object</a> and the pixel coos of a point which is part of that <a class="el" href="structobject.html">object</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>flt_point</em>&nbsp;</td><td>- the fluxcube structure </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>actobject</em>&nbsp;</td><td>- the <a class="el" href="structobject.html">object</a> list</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><a class="el" href="structdirobject.html">dirobject</a> - the <a class="el" href="structdirobject.html">dirobject</a> created </dd></dl>

<p><div class="fragment"><pre class="fragment"><a name="l00534"></a>00534 {
<a name="l00535"></a>00535 
<a name="l00536"></a>00536   <a class="code" href="structdirobject.html">dirobject</a>  *actdir;
<a name="l00537"></a>00537 
<a name="l00538"></a>00538   <span class="comment">// allocate space for the dirobject</span>
<a name="l00539"></a>00539   actdir = (<a class="code" href="structdirobject.html">dirobject</a> *) malloc (<span class="keyword">sizeof</span> (<a class="code" href="structdirobject.html">dirobject</a>));
<a name="l00540"></a>00540   <span class="keywordflow">if</span> (actdir == NULL)
<a name="l00541"></a>00541     <a class="code" href="aXe__errors_8c.html#a7ef7588e5f91237ba7ce4084e6ed3c11">aXe_message</a> (<a class="code" href="aXe__errors_8h.html#a2556a67874555249b07691c37aa6d6e9">aXe_M_FATAL</a>, __FILE__, __LINE__,
<a name="l00542"></a>00542                  <span class="stringliteral">&quot;fill_dirobject:&quot;</span> <span class="stringliteral">&quot; Could not allocate&quot;</span>
<a name="l00543"></a>00543                  <span class="stringliteral">&quot; memory for a dirobject object&quot;</span>);
<a name="l00544"></a>00544 
<a name="l00545"></a>00545   <span class="comment">// transfer refpoint and ID</span>
<a name="l00546"></a>00546   actdir-&gt;<a class="code" href="structdirobject.html#ac7f75c9d3cdd6d50adc84ec001beee5b">ID</a> = actobject-&gt;<a class="code" href="structobject.html#a8575880bdfc1c0bf44914b4efd2665bf">ID</a>;
<a name="l00547"></a>00547   actdir-&gt;<a class="code" href="structdirobject.html#a66ec2727d2a5269c84804a89626834fa">refpoint</a>.<a class="code" href="structd__point.html#a922a3b5d82a119168ba85e5f939d02c3">x</a> = actobject-&gt;<a class="code" href="structobject.html#ad643757142781f8265b430e19700cfe5">beams</a>[0].<a class="code" href="structbeam.html#a54c64670a8b3e8732c1468d156ddb0ca">refpoint</a>.<a class="code" href="structd__point.html#a922a3b5d82a119168ba85e5f939d02c3">x</a>;
<a name="l00548"></a>00548   actdir-&gt;<a class="code" href="structdirobject.html#a66ec2727d2a5269c84804a89626834fa">refpoint</a>.<a class="code" href="structd__point.html#ad9846a025508bf8873a501ca5fcefbf4">y</a> = actobject-&gt;<a class="code" href="structobject.html#ad643757142781f8265b430e19700cfe5">beams</a>[0].<a class="code" href="structbeam.html#a54c64670a8b3e8732c1468d156ddb0ca">refpoint</a>.<a class="code" href="structd__point.html#ad9846a025508bf8873a501ca5fcefbf4">y</a>;
<a name="l00549"></a>00549 
<a name="l00550"></a>00550   <span class="comment">// derive and store min/max in x/y for the corners</span>
<a name="l00551"></a>00551   actdir-&gt;<a class="code" href="structdirobject.html#ac068f35c585eec4cd1e5d3392c2dd698">ix_min</a> = flt_point.<a class="code" href="structpx__point.html#ab715a558731a820a25b50bd7797dd004">x</a>;
<a name="l00552"></a>00552   actdir-&gt;<a class="code" href="structdirobject.html#ac8c6104f2c2e1384c64bba61ecf40d69">ix_max</a> = flt_point.<a class="code" href="structpx__point.html#ab715a558731a820a25b50bd7797dd004">x</a>;
<a name="l00553"></a>00553   actdir-&gt;<a class="code" href="structdirobject.html#af24c9a92fa18516591e43d96eec13272">iy_min</a> = flt_point.<a class="code" href="structpx__point.html#a2d02b900722a71f22a8d5100822bda61">y</a>;
<a name="l00554"></a>00554   actdir-&gt;<a class="code" href="structdirobject.html#a3b36973dd52d158c059bfe6587a04244">iy_max</a> = flt_point.<a class="code" href="structpx__point.html#a2d02b900722a71f22a8d5100822bda61">y</a>;
<a name="l00555"></a>00555 
<a name="l00556"></a>00556   <span class="comment">// derive the distortion scales along the major an minor axis</span>
<a name="l00557"></a>00557   actdir-&gt;<a class="code" href="structdirobject.html#a1e61e87181abdea5dab21eb1dc3564dc">drzscale</a>.<a class="code" href="structd__point.html#a922a3b5d82a119168ba85e5f939d02c3">x</a> = 1.0;
<a name="l00558"></a>00558   actdir-&gt;<a class="code" href="structdirobject.html#a1e61e87181abdea5dab21eb1dc3564dc">drzscale</a>.<a class="code" href="structd__point.html#ad9846a025508bf8873a501ca5fcefbf4">y</a> = 1.0;
<a name="l00559"></a>00559 
<a name="l00560"></a>00560   <span class="comment">// set the variable</span>
<a name="l00561"></a>00561   actdir-&gt;<a class="code" href="structdirobject.html#a8fe8b9502f2baafd4ea433cb8f6acaa9">bb_sed</a> = 0;
<a name="l00562"></a>00562 
<a name="l00563"></a>00563   <span class="comment">// make it a dummy</span>
<a name="l00564"></a>00564   actdir-&gt;<a class="code" href="structdirobject.html#a79645e83aebf3988bd3464b2079d24c1">SED</a> = NULL;
<a name="l00565"></a>00565 
<a name="l00566"></a>00566   <span class="comment">// return the new dirobject</span>
<a name="l00567"></a>00567   <span class="keywordflow">return</span> actdir;
<a name="l00568"></a>00568 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="adbcfc42b8b653d54a14f17e4de25619d"></a><!-- doxytag: member="spc_fluxcube.c::fcube_to_flt_trans" ref="adbcfc42b8b653d54a14f17e4de25619d" args="(const flux_cube *fcube, const d_point fcube_point)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structd__point.html">d_point</a> fcube_to_flt_trans </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structflux__cube.html">flux_cube</a> *&nbsp;</td>
          <td class="paramname"> <em>fcube</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structd__point.html">d_point</a>&nbsp;</td>
          <td class="paramname"> <em>fcube_point</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>The function transforms an image coordinate point in a fluxcube into an image coo point in the associated flt image</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>fcube</em>&nbsp;</td><td>- the fluxcube structure </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>fcube_point</em>&nbsp;</td><td>- image-coo in the fcube</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>flt_point - the image coo in the flt </dd></dl>

<p><div class="fragment"><pre class="fragment"><a name="l00407"></a>00407 {
<a name="l00408"></a>00408   <a class="code" href="structd__point.html">d_point</a> flt_point;
<a name="l00409"></a>00409 
<a name="l00410"></a>00410   flt_point.<a class="code" href="structd__point.html#a922a3b5d82a119168ba85e5f939d02c3">x</a> = fcube_point.<a class="code" href="structd__point.html#a922a3b5d82a119168ba85e5f939d02c3">x</a> + (double)fcube-&gt;<a class="code" href="structflux__cube.html#aed8b9a141c8fd3f09022f27ca0f7d670">xoffs</a>;
<a name="l00411"></a>00411   flt_point.<a class="code" href="structd__point.html#ad9846a025508bf8873a501ca5fcefbf4">y</a> = fcube_point.<a class="code" href="structd__point.html#ad9846a025508bf8873a501ca5fcefbf4">y</a> + (<span class="keywordtype">double</span>)fcube-&gt;<a class="code" href="structflux__cube.html#a0ac57c4e5fe235758efb4a7ca70e5d29">yoffs</a>;
<a name="l00412"></a>00412 
<a name="l00413"></a>00413   <span class="keywordflow">return</span> flt_point;
<a name="l00414"></a>00414 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a2177a42473f70dd15e8fd25315589552"></a><!-- doxytag: member="spc_fluxcube.c::fill_fluxvalues" ref="a2177a42473f70dd15e8fd25315589552" args="(const flux_cube *fcube, const px_point point, dirobject *actdir, const int inter_type)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fill_fluxvalues </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structflux__cube.html">flux_cube</a> *&nbsp;</td>
          <td class="paramname"> <em>fcube</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structpx__point.html">px_point</a>&nbsp;</td>
          <td class="paramname"> <em>point</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdirobject.html">dirobject</a> *&nbsp;</td>
          <td class="paramname"> <em>actdir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>inter_type</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>The function fills the flux information from a point in a fluxcube structure into the flux part of a direct <a class="el" href="structobject.html">object</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>fcube</em>&nbsp;</td><td>- the fluxcube structure </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>point</em>&nbsp;</td><td>- the position to take the flux from </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>actdir</em>&nbsp;</td><td>- the direct <a class="el" href="structobject.html">object</a> to update </td></tr>
  </table>
  </dd>
</dl>

<p><div class="fragment"><pre class="fragment"><a name="l00668"></a>00668 {
<a name="l00669"></a>00669 
<a name="l00670"></a>00670 
<a name="l00671"></a>00671   <a class="code" href="structenergy__distrib.html">energy_distrib</a> *sed;
<a name="l00672"></a>00672   <span class="keywordtype">double</span> *sed_wavs;
<a name="l00673"></a>00673   <span class="keywordtype">double</span> *sed_flux;
<a name="l00674"></a>00674 
<a name="l00675"></a>00675   <span class="keywordtype">int</span> i;
<a name="l00676"></a>00676   <span class="keywordtype">int</span> iact;
<a name="l00677"></a>00677 
<a name="l00678"></a>00678 
<a name="l00679"></a>00679   sed = (<a class="code" href="structenergy__distrib.html">energy_distrib</a>*) malloc(<span class="keyword">sizeof</span>(<a class="code" href="structenergy__distrib.html">energy_distrib</a>));
<a name="l00680"></a>00680   sed_wavs = (<span class="keywordtype">double</span>*) malloc(fcube-&gt;<a class="code" href="structflux__cube.html#ad2a0926e5395663598768f3e09a14c69">n_fimage</a>*<span class="keyword">sizeof</span>(<span class="keywordtype">double</span>));
<a name="l00681"></a>00681   sed_flux = (<span class="keywordtype">double</span>*) malloc(fcube-&gt;<a class="code" href="structflux__cube.html#ad2a0926e5395663598768f3e09a14c69">n_fimage</a>*<span class="keyword">sizeof</span>(<span class="keywordtype">double</span>));
<a name="l00682"></a>00682 
<a name="l00683"></a>00683   <span class="keywordflow">if</span> (actdir-&gt;<a class="code" href="structdirobject.html#a79645e83aebf3988bd3464b2079d24c1">SED</a>)
<a name="l00684"></a>00684     <a class="code" href="model__utils_8c.html#af4aeb43aa090824fe3dcad3049d38a62">free_enerdist</a> (actdir-&gt;<a class="code" href="structdirobject.html#a79645e83aebf3988bd3464b2079d24c1">SED</a>);
<a name="l00685"></a>00685 
<a name="l00686"></a>00686   <span class="comment">// go over each fluximage in the fluxcube structure</span>
<a name="l00687"></a>00687   <span class="keywordflow">for</span> (i=0; i &lt; fcube-&gt;<a class="code" href="structflux__cube.html#ad2a0926e5395663598768f3e09a14c69">n_fimage</a>; i++)
<a name="l00688"></a>00688     {
<a name="l00689"></a>00689 
<a name="l00690"></a>00690       <span class="comment">// determine the index of the next fluximage</span>
<a name="l00691"></a>00691       iact = gsl_vector_int_get(fcube-&gt;<a class="code" href="structflux__cube.html#a4ec5facf29796f861f62aadd0661f946">fimage_order</a>, i);
<a name="l00692"></a>00692 
<a name="l00693"></a>00693       <span class="comment">// transfer the wavelength and flux from the fluxcube</span>
<a name="l00694"></a>00694       sed_wavs[i] = fcube-&gt;<a class="code" href="structflux__cube.html#ab8326cc76fb87ffb4aa998f1f3a11cc7">fluxims</a>[iact]-&gt;<a class="code" href="structflux__image.html#a5f1c5f618a37935d59c16a56afd5eba2">wavelength</a>;
<a name="l00695"></a>00695       sed_flux[i] = <a class="code" href="aXe__grism_8h.html#acf709ee71c580f1cd65d726ed03200ea">gsl_matrix_get</a>(fcube-&gt;<a class="code" href="structflux__cube.html#ab8326cc76fb87ffb4aa998f1f3a11cc7">fluxims</a>[iact]-&gt;<a class="code" href="structflux__image.html#a1913e83222367e56da001f9e27e1702b">flux</a>, point.<a class="code" href="structpx__point.html#ab715a558731a820a25b50bd7797dd004">x</a>, point.<a class="code" href="structpx__point.html#a2d02b900722a71f22a8d5100822bda61">y</a>);
<a name="l00696"></a>00696     }
<a name="l00697"></a>00697 
<a name="l00698"></a>00698   sed-&gt;<a class="code" href="structenergy__distrib.html#ae5e24fde4a41b46a8b8510118f646e67">npoints</a>    = fcube-&gt;<a class="code" href="structflux__cube.html#ad2a0926e5395663598768f3e09a14c69">n_fimage</a>;
<a name="l00699"></a>00699   sed-&gt;<a class="code" href="structenergy__distrib.html#ac32d12647e9ef7f158b0d4532c09a568">wavelength</a> = sed_wavs ;
<a name="l00700"></a>00700   sed-&gt;<a class="code" href="structenergy__distrib.html#a7da8059a7bb2f8af463b6ee1dd1e6554">flux</a>       = sed_flux;
<a name="l00701"></a>00701 
<a name="l00702"></a>00702   <span class="keywordflow">if</span> (fcube-&gt;<a class="code" href="structflux__cube.html#ad2a0926e5395663598768f3e09a14c69">n_fimage</a> &gt; 1)
<a name="l00703"></a>00703     {
<a name="l00704"></a>00704       <span class="keywordflow">if</span> (inter_type == 2)
<a name="l00705"></a>00705         sed-&gt;<a class="code" href="structenergy__distrib.html#a3d90efb6bd5ace3c19884613063644af">interp</a>     = gsl_interp_alloc (gsl_interp_polynomial, (<span class="keywordtype">size_t</span>)fcube-&gt;<a class="code" href="structflux__cube.html#ad2a0926e5395663598768f3e09a14c69">n_fimage</a>);
<a name="l00706"></a>00706       <span class="keywordflow">else</span> <span class="keywordflow">if</span> (inter_type == 3)
<a name="l00707"></a>00707         sed-&gt;<a class="code" href="structenergy__distrib.html#a3d90efb6bd5ace3c19884613063644af">interp</a>     = gsl_interp_alloc (gsl_interp_cspline, (<span class="keywordtype">size_t</span>)fcube-&gt;<a class="code" href="structflux__cube.html#ad2a0926e5395663598768f3e09a14c69">n_fimage</a>);
<a name="l00708"></a>00708       <span class="keywordflow">else</span>
<a name="l00709"></a>00709         sed-&gt;<a class="code" href="structenergy__distrib.html#a3d90efb6bd5ace3c19884613063644af">interp</a>     = gsl_interp_alloc (gsl_interp_linear, (<span class="keywordtype">size_t</span>)fcube-&gt;<a class="code" href="structflux__cube.html#ad2a0926e5395663598768f3e09a14c69">n_fimage</a>);
<a name="l00710"></a>00710 
<a name="l00711"></a>00711       sed-&gt;<a class="code" href="structenergy__distrib.html#a7d0d556a145bd34158514bdbab57b0ee">accel</a>      = gsl_interp_accel_alloc ();
<a name="l00712"></a>00712       gsl_interp_init (sed-&gt;<a class="code" href="structenergy__distrib.html#a3d90efb6bd5ace3c19884613063644af">interp</a>, sed-&gt;<a class="code" href="structenergy__distrib.html#ac32d12647e9ef7f158b0d4532c09a568">wavelength</a>, sed-&gt;<a class="code" href="structenergy__distrib.html#a7da8059a7bb2f8af463b6ee1dd1e6554">flux</a>, (<span class="keywordtype">size_t</span>)sed-&gt;<a class="code" href="structenergy__distrib.html#ae5e24fde4a41b46a8b8510118f646e67">npoints</a>);
<a name="l00713"></a>00713     }
<a name="l00714"></a>00714   <span class="keywordflow">else</span>
<a name="l00715"></a>00715     {
<a name="l00716"></a>00716       sed-&gt;<a class="code" href="structenergy__distrib.html#a3d90efb6bd5ace3c19884613063644af">interp</a> = NULL;
<a name="l00717"></a>00717       sed-&gt;<a class="code" href="structenergy__distrib.html#a7d0d556a145bd34158514bdbab57b0ee">accel</a>= NULL;
<a name="l00718"></a>00718     }
<a name="l00719"></a>00719 
<a name="l00720"></a>00720   <span class="comment">// transfer the SED;</span>
<a name="l00721"></a>00721   <span class="comment">// announce the SED</span>
<a name="l00722"></a>00722   actdir-&gt;<a class="code" href="structdirobject.html#a79645e83aebf3988bd3464b2079d24c1">SED</a>    = sed;
<a name="l00723"></a>00723   actdir-&gt;<a class="code" href="structdirobject.html#a8fe8b9502f2baafd4ea433cb8f6acaa9">bb_sed</a> = 1;
<a name="l00724"></a>00724 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="aecabb3459b749d8e33ea85f4e0bcfcbe"></a><!-- doxytag: member="spc_fluxcube.c::fill_xy_offsets" ref="aecabb3459b749d8e33ea85f4e0bcfcbe" args="(dirobject **dirlist, char CONF_file[])" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fill_xy_offsets </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdirobject.html">dirobject</a> **&nbsp;</td>
          <td class="paramname"> <em>dirlist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&nbsp;</td>
          <td class="paramname"> <em>CONF_file</em>[]</td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>The function computes and stores at the according position the xy offsets of a direct image. This is only important in the fluxcube emission model, since the image coordinates in fluxcubes are 'filter' coordinates and do not take into account the offsets introduce by the grism. For each <a class="el" href="structobject.html">object</a> and <a class="el" href="structbeam.html">beam</a> those offsets are evaluated and stored in the direct <a class="el" href="structobject.html">object</a> structure.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dirlist</em>&nbsp;</td><td>- the direct <a class="el" href="structobject.html">object</a> </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>CONF_file</em>&nbsp;</td><td>- the new coordinate point </td></tr>
  </table>
  </dd>
</dl>

<p><div class="fragment"><pre class="fragment"><a name="l00606"></a>00606 {
<a name="l00607"></a>00607   <a class="code" href="structaperture__conf.html">aperture_conf</a>   *conf;
<a name="l00608"></a>00608 
<a name="l00609"></a>00609   gsl_vector *x_coeffs;
<a name="l00610"></a>00610   gsl_vector *y_coeffs;
<a name="l00611"></a>00611 
<a name="l00612"></a>00612   <a class="code" href="structd__point.html">d_point</a> m_point;
<a name="l00613"></a>00613 
<a name="l00614"></a>00614   <span class="comment">//double xoffs, yoffs;</span>
<a name="l00615"></a>00615 
<a name="l00616"></a>00616   <span class="keywordtype">int</span> beamID=0;
<a name="l00617"></a>00617   <span class="keywordtype">int</span> i;
<a name="l00618"></a>00618 
<a name="l00619"></a>00619   <span class="comment">// load the configuration file</span>
<a name="l00620"></a>00620   conf = <a class="code" href="aper__conf_8c.html#a45d84f2fc00f438b5da9054c45b7736c">get_aperture_descriptor</a> (CONF_file);
<a name="l00621"></a>00621 
<a name="l00622"></a>00622   <span class="comment">// go over each beam defined in the configuration</span>
<a name="l00623"></a>00623   <span class="comment">// file</span>
<a name="l00624"></a>00624   <span class="keywordflow">for</span> (beamID=0; beamID &lt; conf-&gt;<a class="code" href="structaperture__conf.html#af53b09fa4f86ff116c002640c3e817d9">nbeams</a>; beamID++)
<a name="l00625"></a>00625     {
<a name="l00626"></a>00626 
<a name="l00627"></a>00627       <span class="comment">// determine the coeeficients for the offsets</span>
<a name="l00628"></a>00628       <span class="comment">// in x and in y</span>
<a name="l00629"></a>00629       x_coeffs = <a class="code" href="trace__conf_8c.html#aead378057f951a43c28c4031ca3fd71a">get_beam_trace_xoff</a> (CONF_file, beamID);
<a name="l00630"></a>00630       y_coeffs = <a class="code" href="trace__conf_8c.html#aeea3871e481f563841b276e4c8633be7">get_beam_trace_yoff</a> (CONF_file, beamID);
<a name="l00631"></a>00631 
<a name="l00632"></a>00632       <span class="comment">// go over each direct object</span>
<a name="l00633"></a>00633       i=0;
<a name="l00634"></a>00634       <span class="keywordflow">while</span> (dirlist[i] !=NULL)
<a name="l00635"></a>00635         {
<a name="l00636"></a>00636 
<a name="l00637"></a>00637           <span class="comment">// get the mean direct object position</span>
<a name="l00638"></a>00638           m_point = <a class="code" href="model__utils_8c.html#a6dbc5b3a67592030d394cee3570b44e8">get_dirobject_meanpos</a>(dirlist[i]);
<a name="l00639"></a>00639 
<a name="l00640"></a>00640           <span class="comment">// evaluate the coefficients for the 2D variable offsets</span>
<a name="l00641"></a>00641           <span class="comment">// at the mean position</span>
<a name="l00642"></a>00642           dirlist[i]-&gt;<a class="code" href="structdirobject.html#a804b505c34bbecd0eb09832e34cbd5ce">xy_off</a>[beamID].<a class="code" href="structd__point.html#a922a3b5d82a119168ba85e5f939d02c3">x</a> = <a class="code" href="trace__conf_8c.html#a9eed4438755d4ceab064f95250f6218e">eval_trace_off_at_pos</a> (x_coeffs, m_point, beamID);
<a name="l00643"></a>00643           dirlist[i]-&gt;<a class="code" href="structdirobject.html#a804b505c34bbecd0eb09832e34cbd5ce">xy_off</a>[beamID].<a class="code" href="structd__point.html#ad9846a025508bf8873a501ca5fcefbf4">y</a> = <a class="code" href="trace__conf_8c.html#a9eed4438755d4ceab064f95250f6218e">eval_trace_off_at_pos</a> (y_coeffs, m_point, beamID);
<a name="l00644"></a>00644 
<a name="l00645"></a>00645           <span class="comment">// iterate the counter</span>
<a name="l00646"></a>00646           i++;
<a name="l00647"></a>00647         }
<a name="l00648"></a>00648 
<a name="l00649"></a>00649       <span class="comment">// free the vectors for the coefficients</span>
<a name="l00650"></a>00650       gsl_vector_free(x_coeffs);
<a name="l00651"></a>00651       gsl_vector_free(y_coeffs);
<a name="l00652"></a>00652     }
<a name="l00653"></a>00653         <span class="comment">// release memory</span>
<a name="l00654"></a>00654         <a class="code" href="aper__conf_8c.html#a608428f59a2adb25874101610cd6afe4">free_aperture_conf</a>(conf);
<a name="l00655"></a>00655 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a350fb76c81c3285d1978f350e3a0fe8b"></a><!-- doxytag: member="spc_fluxcube.c::flt_to_fcube_trans" ref="a350fb76c81c3285d1978f350e3a0fe8b" args="(const flux_cube *fcube, const d_point flt_point)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structd__point.html">d_point</a> flt_to_fcube_trans </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structflux__cube.html">flux_cube</a> *&nbsp;</td>
          <td class="paramname"> <em>fcube</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structd__point.html">d_point</a>&nbsp;</td>
          <td class="paramname"> <em>flt_point</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>The function transforms a pixel coordinate point in a flt image into an pixel coordinate point in the associated fluxcube image</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>fcube</em>&nbsp;</td><td>- the fluxcube structure </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>flt_point</em>&nbsp;</td><td>- pixel coordinate point in the flt-image</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>fcube_point - the pixel coordinate in the fluxcube </dd></dl>

<p><div class="fragment"><pre class="fragment"><a name="l00386"></a>00386 {
<a name="l00387"></a>00387   <a class="code" href="structd__point.html">d_point</a> fcube_point;
<a name="l00388"></a>00388 
<a name="l00389"></a>00389   fcube_point.<a class="code" href="structd__point.html#a922a3b5d82a119168ba85e5f939d02c3">x</a> = flt_point.<a class="code" href="structd__point.html#a922a3b5d82a119168ba85e5f939d02c3">x</a> - (double)fcube-&gt;<a class="code" href="structflux__cube.html#aed8b9a141c8fd3f09022f27ca0f7d670">xoffs</a>;
<a name="l00390"></a>00390   fcube_point.<a class="code" href="structd__point.html#ad9846a025508bf8873a501ca5fcefbf4">y</a> = flt_point.<a class="code" href="structd__point.html#ad9846a025508bf8873a501ca5fcefbf4">y</a> - (<span class="keywordtype">double</span>)fcube-&gt;<a class="code" href="structflux__cube.html#a0ac57c4e5fe235758efb4a7ca70e5d29">yoffs</a>;
<a name="l00391"></a>00391 
<a name="l00392"></a>00392   <span class="keywordflow">return</span> fcube_point;
<a name="l00393"></a>00393 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a682c533a63bf1a76022725edab374764"></a><!-- doxytag: member="spc_fluxcube.c::fluxcube_to_dirlist" ref="a682c533a63bf1a76022725edab374764" args="(const flux_cube *fcube, object **oblist)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdirobject.html">dirobject</a>** fluxcube_to_dirlist </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structflux__cube.html">flux_cube</a> *&nbsp;</td>
          <td class="paramname"> <em>fcube</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structobject.html">object</a> **&nbsp;</td>
          <td class="paramname"> <em>oblist</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>The function converts the information stored in the segmenation matrix of a fluxcube and the <a class="el" href="structobject.html">object</a> list to a list of direct objects</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>fcube</em>&nbsp;</td><td>- the fluxcube structure </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>oblist</em>&nbsp;</td><td>- the <a class="el" href="structobject.html">object</a> list</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>dirlist - the <a class="el" href="structdirobject.html">dirobject</a> list created </dd></dl>

<p><div class="fragment"><pre class="fragment"><a name="l00428"></a>00428 {
<a name="l00429"></a>00429   <a class="code" href="structdirobject.html">dirobject</a> **dirlist;
<a name="l00430"></a>00430   <a class="code" href="structdirobject.html">dirobject</a>  *actdir;
<a name="l00431"></a>00431 
<a name="l00432"></a>00432   <span class="comment">//px_point fcube_point;</span>
<a name="l00433"></a>00433   <a class="code" href="structpx__point.html">px_point</a> flt_point;
<a name="l00434"></a>00434 
<a name="l00435"></a>00435   <a class="code" href="structd__point.html">d_point</a> tmp1, tmp2;
<a name="l00436"></a>00436 
<a name="l00437"></a>00437   <span class="keywordtype">int</span> iact=0;
<a name="l00438"></a>00438   <span class="keywordtype">int</span> nobjects=0;
<a name="l00439"></a>00439   <span class="keywordtype">int</span> ndir=0;
<a name="l00440"></a>00440   <span class="keywordtype">int</span> i, j;
<a name="l00441"></a>00441   <span class="keywordtype">int</span> objindex;
<a name="l00442"></a>00442 
<a name="l00443"></a>00443   <span class="comment">//int itmp=0;</span>
<a name="l00444"></a>00444 
<a name="l00445"></a>00445   <span class="comment">// determine the number of objects in the object list</span>
<a name="l00446"></a>00446   nobjects = <a class="code" href="inout__aper_8c.html#aa4bd812673400180537c7ea98650d3fe">object_list_size</a>(oblist);
<a name="l00447"></a>00447 
<a name="l00448"></a>00448   <span class="comment">// allocate space for the dirobject list</span>
<a name="l00449"></a>00449   dirlist = (<a class="code" href="structdirobject.html">dirobject</a> **) malloc((nobjects+1) * <span class="keyword">sizeof</span>(<a class="code" href="structdirobject.html">dirobject</a> *));
<a name="l00450"></a>00450   <span class="keywordflow">if</span> (dirlist == NULL)
<a name="l00451"></a>00451     <a class="code" href="aXe__errors_8c.html#a7ef7588e5f91237ba7ce4084e6ed3c11">aXe_message</a> (<a class="code" href="aXe__errors_8h.html#a2556a67874555249b07691c37aa6d6e9">aXe_M_FATAL</a>, __FILE__, __LINE__,
<a name="l00452"></a>00452                  <span class="stringliteral">&quot;fluxcube_to_dirlist:&quot;</span> <span class="stringliteral">&quot; Could not allocate&quot;</span>
<a name="l00453"></a>00453                  <span class="stringliteral">&quot; memory for pointers to %i dirobject objects&quot;</span>, nobjects+1);
<a name="l00454"></a>00454 
<a name="l00455"></a>00455   <span class="comment">// initialize the number of direct object</span>
<a name="l00456"></a>00456   <span class="comment">// and set the first item to NULL</span>
<a name="l00457"></a>00457   ndir=0;
<a name="l00458"></a>00458   dirlist[ndir]=NULL;
<a name="l00459"></a>00459 
<a name="l00460"></a>00460   <span class="comment">//  if (nobjects &lt; 1)</span>
<a name="l00461"></a>00461   <span class="comment">//    return dirlist;</span>
<a name="l00462"></a>00462 
<a name="l00463"></a>00463   <span class="comment">// go over each column in the segmentation image</span>
<a name="l00464"></a>00464   <span class="keywordflow">for</span> (i=0; i &lt; fcube-&gt;<a class="code" href="structflux__cube.html#a5003df20f749b61b1b9ba3818460ca0c">segmentation</a>-&gt;size1; i++)
<a name="l00465"></a>00465     {
<a name="l00466"></a>00466 
<a name="l00467"></a>00467       <span class="comment">// go over each row in the segmentation image</span>
<a name="l00468"></a>00468       <span class="keywordflow">for</span> (j=0; j &lt; fcube-&gt;<a class="code" href="structflux__cube.html#a5003df20f749b61b1b9ba3818460ca0c">segmentation</a>-&gt;size2; j++)
<a name="l00469"></a>00469         {
<a name="l00470"></a>00470 
<a name="l00471"></a>00471           <span class="comment">// get the pixel value in the segmentation image</span>
<a name="l00472"></a>00472           iact = gsl_matrix_int_get(fcube-&gt;<a class="code" href="structflux__cube.html#a5003df20f749b61b1b9ba3818460ca0c">segmentation</a>, i, j);
<a name="l00473"></a>00473 
<a name="l00474"></a>00474           <span class="comment">// do something if the pixel is part of an object</span>
<a name="l00475"></a>00475           <span class="keywordflow">if</span> (iact &gt; 0)
<a name="l00476"></a>00476             {
<a name="l00477"></a>00477 
<a name="l00478"></a>00478               <span class="comment">// transform the cooridnates from the fcube-system</span>
<a name="l00479"></a>00479               <span class="comment">// into the flt system</span>
<a name="l00480"></a>00480               tmp1.<a class="code" href="structd__point.html#a922a3b5d82a119168ba85e5f939d02c3">x</a> = (double)i;
<a name="l00481"></a>00481               tmp1.<a class="code" href="structd__point.html#ad9846a025508bf8873a501ca5fcefbf4">y</a> = (double)j;
<a name="l00482"></a>00482               tmp2 = <a class="code" href="spc__fluxcube_8c.html#adbcfc42b8b653d54a14f17e4de25619d">fcube_to_flt_trans</a>(fcube, tmp1);
<a name="l00483"></a>00483               flt_point.<a class="code" href="structpx__point.html#ab715a558731a820a25b50bd7797dd004">x</a> = (int)tmp2.<a class="code" href="structd__point.html#a922a3b5d82a119168ba85e5f939d02c3">x</a>;
<a name="l00484"></a>00484               flt_point.<a class="code" href="structpx__point.html#a2d02b900722a71f22a8d5100822bda61">y</a> = (<span class="keywordtype">int</span>)tmp2.<a class="code" href="structd__point.html#ad9846a025508bf8873a501ca5fcefbf4">y</a>;
<a name="l00485"></a>00485 
<a name="l00486"></a>00486               <span class="comment">// try to get a dirobject for that object (=pixel value)</span>
<a name="l00487"></a>00487               actdir = <a class="code" href="model__utils_8c.html#a39965b9d4410809472bb1a5fd4328026">get_dirobject_from_list</a>(dirlist, iact);
<a name="l00488"></a>00488 
<a name="l00489"></a>00489               <span class="comment">// check whether a dirobject just exists</span>
<a name="l00490"></a>00490               <span class="keywordflow">if</span> (actdir != NULL)
<a name="l00491"></a>00491                 {
<a name="l00492"></a>00492                   <span class="comment">// udate an existing object</span>
<a name="l00493"></a>00493                   <a class="code" href="spc__fluxcube_8c.html#ad90a902ccd2f90598490b151687c579a">update_dirobject</a>(actdir, flt_point);
<a name="l00494"></a>00494                 }
<a name="l00495"></a>00495               <span class="keywordflow">else</span>
<a name="l00496"></a>00496                 {
<a name="l00497"></a>00497 
<a name="l00498"></a>00498                   <span class="comment">// find the the object index for a (hypotetical) new dirobject</span>
<a name="l00499"></a>00499                   objindex = <a class="code" href="inout__aper_8c.html#a12854533fd67781a0bf70a93a6ad91e4">find_object_in_object_list</a>(oblist, iact);
<a name="l00500"></a>00500                   <span class="comment">// check whether object exists in oblist</span>
<a name="l00501"></a>00501                   <span class="keywordflow">if</span> (objindex &gt;-1)
<a name="l00502"></a>00502                     {
<a name="l00503"></a>00503                       <span class="comment">// create a new dirobject and enhance the counter</span>
<a name="l00504"></a>00504                       dirlist[ndir++] = <a class="code" href="spc__fluxcube_8c.html#ad1a7873ace1a14d664bf453c76e27411">dirobject_from_segpoint</a>(flt_point, oblist[objindex]);
<a name="l00505"></a>00505 
<a name="l00506"></a>00506                       <span class="comment">// set the actually last dirobject to NULL</span>
<a name="l00507"></a>00507                       <span class="comment">// to get a properly closed list at all time</span>
<a name="l00508"></a>00508                       dirlist[ndir]=NULL;
<a name="l00509"></a>00509                     }
<a name="l00510"></a>00510                 }
<a name="l00511"></a>00511             }
<a name="l00512"></a>00512         }
<a name="l00513"></a>00513     }
<a name="l00514"></a>00514 
<a name="l00515"></a>00515 
<a name="l00516"></a>00516   <span class="comment">// return the direct object list</span>
<a name="l00517"></a>00517   <span class="keywordflow">return</span> dirlist;
<a name="l00518"></a>00518 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a4326413c31d848f7f10076d3776b2d08"></a><!-- doxytag: member="spc_fluxcube.c::free_fluxcube" ref="a4326413c31d848f7f10076d3776b2d08" args="(flux_cube *fcube)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void free_fluxcube </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structflux__cube.html">flux_cube</a> *&nbsp;</td>
          <td class="paramname"> <em>fcube</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>The function releases the space allocated for a fluxcube structure.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>fcube</em>&nbsp;</td><td>- the pointer to the fluxcube structure </td></tr>
  </table>
  </dd>
</dl>

<p><div class="fragment"><pre class="fragment"><a name="l00328"></a>00328 {
<a name="l00329"></a>00329   <span class="keywordtype">int</span> i;
<a name="l00330"></a>00330 
<a name="l00331"></a>00331   <span class="comment">// free the segmentation matrix</span>
<a name="l00332"></a>00332   gsl_matrix_int_free(fcube-&gt;<a class="code" href="structflux__cube.html#a5003df20f749b61b1b9ba3818460ca0c">segmentation</a>);
<a name="l00333"></a>00333 
<a name="l00334"></a>00334   <span class="comment">// free the wavelength order vector</span>
<a name="l00335"></a>00335   gsl_vector_int_free(fcube-&gt;<a class="code" href="structflux__cube.html#a4ec5facf29796f861f62aadd0661f946">fimage_order</a>);
<a name="l00336"></a>00336 
<a name="l00337"></a>00337   <span class="comment">// go over the fluximages, and free them</span>
<a name="l00338"></a>00338   <span class="keywordflow">for</span> (i=0; i &lt; fcube-&gt;<a class="code" href="structflux__cube.html#ad2a0926e5395663598768f3e09a14c69">n_fimage</a>; i++)
<a name="l00339"></a>00339     <a class="code" href="spc__fluxcube_8c.html#a106c1cdd426ec4412413f3926a69e825">free_fluximage</a>(fcube-&gt;<a class="code" href="structflux__cube.html#ab8326cc76fb87ffb4aa998f1f3a11cc7">fluxims</a>[i]);
<a name="l00340"></a>00340 
<a name="l00341"></a>00341   <span class="comment">// free the fluximage vector</span>
<a name="l00342"></a>00342   free(fcube-&gt;<a class="code" href="structflux__cube.html#ab8326cc76fb87ffb4aa998f1f3a11cc7">fluxims</a>);
<a name="l00343"></a>00343 
<a name="l00344"></a>00344   <span class="comment">// free the fluximage order vector</span>
<a name="l00345"></a>00345   <span class="comment">//  gsl_vector_int_free(fcube-&gt;fimage_order);</span>
<a name="l00346"></a>00346 
<a name="l00347"></a>00347   <span class="comment">// free the fluxcube</span>
<a name="l00348"></a>00348   free(fcube);
<a name="l00349"></a>00349 
<a name="l00350"></a>00350   <span class="comment">// set the fluxcube to NULL</span>
<a name="l00351"></a>00351   fcube=NULL;
<a name="l00352"></a>00352 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a106c1cdd426ec4412413f3926a69e825"></a><!-- doxytag: member="spc_fluxcube.c::free_fluximage" ref="a106c1cdd426ec4412413f3926a69e825" args="(flux_image *fimage)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void free_fluximage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structflux__image.html">flux_image</a> *&nbsp;</td>
          <td class="paramname"> <em>fimage</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>The function releases the space allocated for a fluximage structure.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>fimage</em>&nbsp;</td><td>- the pointer to the fluximage structure </td></tr>
  </table>
  </dd>
</dl>

<p><div class="fragment"><pre class="fragment"><a name="l00363"></a>00363 {
<a name="l00364"></a>00364   <span class="comment">// free the flux matrix</span>
<a name="l00365"></a>00365   <a class="code" href="aXe__grism_8h.html#a61aa1d37853a90711852146f18d0b85f">gsl_matrix_free</a>(fimage-&gt;<a class="code" href="structflux__image.html#a1913e83222367e56da001f9e27e1702b">flux</a>);
<a name="l00366"></a>00366 
<a name="l00367"></a>00367   <span class="comment">// free the fluximage</span>
<a name="l00368"></a>00368   free(fimage);
<a name="l00369"></a>00369 
<a name="l00370"></a>00370   <span class="comment">// set the fluximage to NULL</span>
<a name="l00371"></a>00371   fimage=NULL;
<a name="l00372"></a>00372 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ab4f88c30f07f1b2e86e3c156ae495691"></a><!-- doxytag: member="spc_fluxcube.c::load_fluxcube" ref="ab4f88c30f07f1b2e86e3c156ae495691" args="(const char fcube_file[])" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structflux__cube.html">flux_cube</a>* load_fluxcube </td>
          <td>(</td>
          <td class="paramtype">const char&nbsp;</td>
          <td class="paramname"> <em>fcube_file</em>[]</td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>The function creates and loads a new <a class="el" href="structflux__cube.html">flux_cube</a> structure The data is taken from the file specified in the input.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>fcube_file</em>&nbsp;</td><td>- the file name of the fluxcube</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>ret - the new <a class="el" href="structflux__cube.html">flux_cube</a> structure </dd></dl>

<p><div class="fragment"><pre class="fragment"><a name="l00044"></a>00044 {
<a name="l00045"></a>00045   <a class="code" href="structflux__cube.html">flux_cube</a> *fcube;
<a name="l00046"></a>00046 
<a name="l00047"></a>00047   <span class="comment">//gsl_matrix *test;</span>
<a name="l00048"></a>00048 
<a name="l00049"></a>00049   <span class="keywordtype">int</span> nflux, n_ext=0;
<a name="l00050"></a>00050   <span class="keywordtype">int</span> i;
<a name="l00051"></a>00051 
<a name="l00052"></a>00052 
<a name="l00053"></a>00053   <span class="comment">// get the number of extensions</span>
<a name="l00054"></a>00054   n_ext = <a class="code" href="aXe__utils_8c.html#a791e8209e46381315c39a27890280053">FITSextnum</a>(fcube_file);
<a name="l00055"></a>00055   <span class="keywordflow">if</span> (n_ext &lt;3)
<a name="l00056"></a>00056     <a class="code" href="aXe__errors_8c.html#a7ef7588e5f91237ba7ce4084e6ed3c11">aXe_message</a>(<a class="code" href="aXe__errors_8h.html#a2556a67874555249b07691c37aa6d6e9">aXe_M_FATAL</a>, __FILE__, __LINE__,
<a name="l00057"></a>00057                 <span class="stringliteral">&quot;aXe_PETCONT: &quot;</span> <span class="stringliteral">&quot;the fluxcube file %s has only %i extensions!\n&quot;</span>,
<a name="l00058"></a>00058                 fcube_file, n_ext);
<a name="l00059"></a>00059 
<a name="l00060"></a>00060   <span class="comment">// determine the number of flux images and allocate</span>
<a name="l00061"></a>00061   <span class="comment">// the space for the fluxcube structure</span>
<a name="l00062"></a>00062   nflux = n_ext-2;
<a name="l00063"></a>00063   fcube = <a class="code" href="spc__fluxcube_8c.html#ad34f3325fb0c75b628a15f8dfb856b61">alloc_fluxcube</a>(nflux);
<a name="l00064"></a>00064 
<a name="l00065"></a>00065   <span class="comment">// load XOFFS and YOFFS</span>
<a name="l00066"></a>00066   <a class="code" href="spc__fluxcube_8c.html#a20041a83ddc2d8aa08695983981141ba">load_offsets</a>(fcube_file, fcube);
<a name="l00067"></a>00067 
<a name="l00068"></a>00068   <span class="comment">// load the segmentation image into the structure</span>
<a name="l00069"></a>00069   fcube-&gt;<a class="code" href="structflux__cube.html#a5003df20f749b61b1b9ba3818460ca0c">segmentation</a> = <a class="code" href="spc__fluxcube_8c.html#a80aa93013c03ce8ca7d5a2fddf0ed404">load_segmentation</a>(fcube_file);
<a name="l00070"></a>00070   <span class="comment">//  gsl_to_FITSimage (fcube-&gt;segmentation, &quot;gogo.fits&quot;, 1, &quot;MOO&quot;);</span>
<a name="l00071"></a>00071 
<a name="l00072"></a>00072   <span class="comment">// load the fluximages</span>
<a name="l00073"></a>00073   <span class="keywordflow">for</span> (i=0; i &lt; nflux; i++)
<a name="l00074"></a>00074     {
<a name="l00075"></a>00075       fcube-&gt;<a class="code" href="structflux__cube.html#ab8326cc76fb87ffb4aa998f1f3a11cc7">fluxims</a>[i] = <a class="code" href="spc__fluxcube_8c.html#ab25b98aa66e43bc8a965e7ee056795ed">load_fluximage</a>(fcube_file, i+3);
<a name="l00076"></a>00076     }
<a name="l00077"></a>00077 
<a name="l00078"></a>00078   <span class="comment">// fill the number of fluximages</span>
<a name="l00079"></a>00079   fcube-&gt;<a class="code" href="structflux__cube.html#ad2a0926e5395663598768f3e09a14c69">n_fimage</a> = nflux;
<a name="l00080"></a>00080 
<a name="l00081"></a>00081   <span class="comment">// order the fluximages and store the</span>
<a name="l00082"></a>00082   <span class="comment">// vector with the ordered indices</span>
<a name="l00083"></a>00083   fcube-&gt;<a class="code" href="structflux__cube.html#a4ec5facf29796f861f62aadd0661f946">fimage_order</a> = <a class="code" href="spc__fluxcube_8c.html#a5c1a750847b6040abc13eeabb47585b2">order_fluxims</a>(fcube);
<a name="l00084"></a>00084 
<a name="l00085"></a>00085   <span class="keywordflow">return</span> fcube;
<a name="l00086"></a>00086 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ab25b98aa66e43bc8a965e7ee056795ed"></a><!-- doxytag: member="spc_fluxcube.c::load_fluximage" ref="ab25b98aa66e43bc8a965e7ee056795ed" args="(const char fcube_file[], int hdunum)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structflux__image.html">flux_image</a>* load_fluximage </td>
          <td>(</td>
          <td class="paramtype">const char&nbsp;</td>
          <td class="paramname"> <em>fcube_file</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>hdunum</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>The function creates and loads a fluximage structure from an extention of a fluxcube file.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>fcube_file</em>&nbsp;</td><td>- the file name of the fluxcube </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>hdunum</em>&nbsp;</td><td>- the extension number to load in a fluximage</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>fimage - pointer to the fluximage structure loaded </dd></dl>

<p><div class="fragment"><pre class="fragment"><a name="l00212"></a>00212 {
<a name="l00213"></a>00213   <a class="code" href="structflux__image.html">flux_image</a> *fimage;
<a name="l00214"></a>00214 
<a name="l00215"></a>00215   <span class="keywordtype">char</span> tmp[<a class="code" href="aXe__grism_8h.html#ac1535592e39e7edf0cafbd5e695ea622">MAXCHAR</a>];
<a name="l00216"></a>00216 
<a name="l00217"></a>00217   <span class="keywordtype">double</span> wavelength;
<a name="l00218"></a>00218 
<a name="l00219"></a>00219   strcpy(tmp, fcube_file);
<a name="l00220"></a>00220 
<a name="l00221"></a>00221   <span class="comment">// allocate space for the fluximage structure</span>
<a name="l00222"></a>00222   fimage = (<a class="code" href="structflux__image.html">flux_image</a> *)malloc(<span class="keyword">sizeof</span>(<a class="code" href="structflux__image.html">flux_image</a>));
<a name="l00223"></a>00223 
<a name="l00224"></a>00224   <span class="comment">// load the array from the specified extension number</span>
<a name="l00225"></a>00225   fimage-&gt;<a class="code" href="structflux__image.html#a1913e83222367e56da001f9e27e1702b">flux</a> = <a class="code" href="aXe__utils_8c.html#ae608ee7bf2717c17c842cd3dfd327884">FITSimage_to_gsl</a>(fcube_file, hdunum, 1);
<a name="l00226"></a>00226 
<a name="l00227"></a>00227   <span class="comment">// get the keyword &quot;WAVELENG&apos; from the specified extension number</span>
<a name="l00228"></a>00228   wavelength = (double)<a class="code" href="aXe__utils_8c.html#a8817e86558786acb16965f3ac1215992">get_float_from_keyword</a>(tmp, hdunum, <span class="stringliteral">&quot;WAVELENG&quot;</span>);
<a name="l00229"></a>00229 
<a name="l00230"></a>00230   <span class="comment">// report an error in case that the extension does not have that keyword.</span>
<a name="l00231"></a>00231   <span class="comment">// Otherwise store its content in the fluximage structure</span>
<a name="l00232"></a>00232   <span class="keywordflow">if</span> (isnan(wavelength))
<a name="l00233"></a>00233     <a class="code" href="aXe__errors_8c.html#a7ef7588e5f91237ba7ce4084e6ed3c11">aXe_message</a>(<a class="code" href="aXe__errors_8h.html#a2556a67874555249b07691c37aa6d6e9">aXe_M_FATAL</a>, __FILE__, __LINE__,
<a name="l00234"></a>00234                 <span class="stringliteral">&quot;aXe_PETCONT: &quot;</span> <span class="stringliteral">&quot;Missing keyword WAVELENGTH in fluxcube %s, extension %i!\n&quot;</span>,
<a name="l00235"></a>00235                 fcube_file, hdunum);
<a name="l00236"></a>00236   <span class="keywordflow">else</span>
<a name="l00237"></a>00237     fimage-&gt;<a class="code" href="structflux__image.html#a5f1c5f618a37935d59c16a56afd5eba2">wavelength</a> = wavelength;
<a name="l00238"></a>00238 
<a name="l00239"></a>00239   <span class="keywordflow">return</span> fimage;
<a name="l00240"></a>00240 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a20041a83ddc2d8aa08695983981141ba"></a><!-- doxytag: member="spc_fluxcube.c::load_offsets" ref="a20041a83ddc2d8aa08695983981141ba" args="(const char fcube_file[], flux_cube *fcube)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int load_offsets </td>
          <td>(</td>
          <td class="paramtype">const char&nbsp;</td>
          <td class="paramname"> <em>fcube_file</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structflux__cube.html">flux_cube</a> *&nbsp;</td>
          <td class="paramname"> <em>fcube</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>The function fills the keywords XOFFS and YOFFS from the primary header of the fitscube file into the according items of the fitscube structure. In case that those keywords are not present, they are set to 0.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>fcube_file</em>&nbsp;</td><td>- the file name of the fluxcube </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>fcube</em>&nbsp;</td><td>- the fluxcube structure</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>1 - always true </dd></dl>

<p><div class="fragment"><pre class="fragment"><a name="l00125"></a>00125 {
<a name="l00126"></a>00126   <span class="keywordtype">char</span> tmp[<a class="code" href="aXe__grism_8h.html#ac1535592e39e7edf0cafbd5e695ea622">MAXCHAR</a>];
<a name="l00127"></a>00127 
<a name="l00128"></a>00128   <span class="keywordtype">double</span> dtmp=0.0;
<a name="l00129"></a>00129 
<a name="l00130"></a>00130   <span class="comment">// avoid problems with the &apos;const&apos; declaration</span>
<a name="l00131"></a>00131   strcpy(tmp, fcube_file);
<a name="l00132"></a>00132 
<a name="l00133"></a>00133   <span class="comment">// read XOFFS from the primary header</span>
<a name="l00134"></a>00134   dtmp = <a class="code" href="aXe__utils_8c.html#a8817e86558786acb16965f3ac1215992">get_float_from_keyword</a>(tmp, 1, <span class="stringliteral">&quot;XOFFS&quot;</span>);
<a name="l00135"></a>00135 
<a name="l00136"></a>00136   <span class="comment">// store the keyword value or 0 (if not present) in the fcube structure</span>
<a name="l00137"></a>00137   <span class="keywordflow">if</span> (isnan(dtmp))
<a name="l00138"></a>00138     fcube-&gt;<a class="code" href="structflux__cube.html#aed8b9a141c8fd3f09022f27ca0f7d670">xoffs</a> = 0;
<a name="l00139"></a>00139   <span class="keywordflow">else</span>
<a name="l00140"></a>00140     fcube-&gt;<a class="code" href="structflux__cube.html#aed8b9a141c8fd3f09022f27ca0f7d670">xoffs</a> = (int)dtmp;
<a name="l00141"></a>00141 
<a name="l00142"></a>00142   <span class="comment">// read XOFFS from the primary header</span>
<a name="l00143"></a>00143   dtmp = <a class="code" href="aXe__utils_8c.html#a8817e86558786acb16965f3ac1215992">get_float_from_keyword</a>(tmp, 1, <span class="stringliteral">&quot;YOFFS&quot;</span>);
<a name="l00144"></a>00144 
<a name="l00145"></a>00145   <span class="comment">// store the keyword value or 0 (if not present) in the fcube structure</span>
<a name="l00146"></a>00146   <span class="keywordflow">if</span> (isnan(dtmp))
<a name="l00147"></a>00147     fcube-&gt;<a class="code" href="structflux__cube.html#a0ac57c4e5fe235758efb4a7ca70e5d29">yoffs</a> = 0;
<a name="l00148"></a>00148   <span class="keywordflow">else</span>
<a name="l00149"></a>00149     fcube-&gt;<a class="code" href="structflux__cube.html#a0ac57c4e5fe235758efb4a7ca70e5d29">yoffs</a> = (int)dtmp;
<a name="l00150"></a>00150 
<a name="l00151"></a>00151   <span class="keywordflow">return</span> 1;
<a name="l00152"></a>00152 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a80aa93013c03ce8ca7d5a2fddf0ed404"></a><!-- doxytag: member="spc_fluxcube.c::load_segmentation" ref="a80aa93013c03ce8ca7d5a2fddf0ed404" args="(const char fcube_file[])" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gsl_matrix_int* load_segmentation </td>
          <td>(</td>
          <td class="paramtype">const char&nbsp;</td>
          <td class="paramname"> <em>fcube_file</em>[]</td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>The function creates and loads the segmentation image of a <a class="el" href="structflux__cube.html">flux_cube</a> file into a gsl_matrix_int structure.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>fcube_file</em>&nbsp;</td><td>- the file name of the fluxcube</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>ret - pointer to the gsl_matrix_int structure </dd></dl>

<p><div class="fragment"><pre class="fragment"><a name="l00164"></a>00164 {
<a name="l00165"></a>00165 
<a name="l00166"></a>00166   gsl_matrix_int *segmentation;
<a name="l00167"></a>00167   <a class="code" href="aXe__grism_8h.html#a6117e17bb3108107676f4486e62d40e5">gsl_matrix</a>     *dvals;
<a name="l00168"></a>00168 
<a name="l00169"></a>00169   <span class="keywordtype">int</span> i,j;
<a name="l00170"></a>00170 
<a name="l00171"></a>00171   <span class="keywordtype">double</span> diff;
<a name="l00172"></a>00172 
<a name="l00173"></a>00173   <span class="comment">// load the segmentation image into a gsl_matrix_(double)</span>
<a name="l00174"></a>00174   dvals = <a class="code" href="aXe__utils_8c.html#ae608ee7bf2717c17c842cd3dfd327884">FITSimage_to_gsl</a>(fcube_file, 2, 1);
<a name="l00175"></a>00175 
<a name="l00176"></a>00176   <span class="comment">// add 0.5 to get proper rounding with (int)</span>
<a name="l00177"></a>00177   <a class="code" href="aXe__grism_8h.html#a621493bf0b066fb614a23adea0f7a151">gsl_matrix_add_constant</a> (dvals, 0.5);
<a name="l00178"></a>00178 
<a name="l00179"></a>00179   <span class="comment">// allocate space for the integer matrix</span>
<a name="l00180"></a>00180   segmentation = gsl_matrix_int_alloc(dvals-&gt;size1,dvals-&gt;size2);
<a name="l00181"></a>00181 
<a name="l00182"></a>00182   <span class="comment">// fill the integer matrix with values from the double matrix</span>
<a name="l00183"></a>00183   <span class="keywordflow">for</span> (i=0; i &lt; dvals-&gt;size1; i++)
<a name="l00184"></a>00184     {
<a name="l00185"></a>00185       <span class="keywordflow">for</span> (j=0; j &lt; dvals-&gt;size2; j++)
<a name="l00186"></a>00186         {
<a name="l00187"></a>00187           gsl_matrix_int_set(segmentation, i, j, (<span class="keywordtype">int</span>)<a class="code" href="aXe__grism_8h.html#acf709ee71c580f1cd65d726ed03200ea">gsl_matrix_get</a>(dvals, i, j));
<a name="l00188"></a>00188 
<a name="l00189"></a>00189           diff = <a class="code" href="aXe__grism_8h.html#acf709ee71c580f1cd65d726ed03200ea">gsl_matrix_get</a>(dvals, i, j) - (double)gsl_matrix_int_get(segmentation, i, j);
<a name="l00190"></a>00190           <span class="keywordflow">if</span> (diff &gt; 0.6 || diff &lt; 0.4)
<a name="l00191"></a>00191             fprintf(stdout, <span class="stringliteral">&quot;diff %f; %f --&gt; %i, (%i, %i)\n&quot;</span>, diff, <a class="code" href="aXe__grism_8h.html#acf709ee71c580f1cd65d726ed03200ea">gsl_matrix_get</a>(dvals, i, j), gsl_matrix_int_get(segmentation, i, j), i, j);
<a name="l00192"></a>00192         }
<a name="l00193"></a>00193     }
<a name="l00194"></a>00194 
<a name="l00195"></a>00195   <span class="comment">// free the space for the double matrix</span>
<a name="l00196"></a>00196   <a class="code" href="aXe__grism_8h.html#a61aa1d37853a90711852146f18d0b85f">gsl_matrix_free</a>(dvals);
<a name="l00197"></a>00197 
<a name="l00198"></a>00198   <span class="keywordflow">return</span> segmentation;
<a name="l00199"></a>00199 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a5c1a750847b6040abc13eeabb47585b2"></a><!-- doxytag: member="spc_fluxcube.c::order_fluxims" ref="a5c1a750847b6040abc13eeabb47585b2" args="(flux_cube *fcube)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gsl_vector_int* order_fluxims </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structflux__cube.html">flux_cube</a> *&nbsp;</td>
          <td class="paramname"> <em>fcube</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>The function analyzes the fluximages in a fluxcube structure and sorts their indices in ascending wavelength. The vector with the ordered indices is given back.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>fcube</em>&nbsp;</td><td>- the pointer to the fluxcube structure </td></tr>
  </table>
  </dd>
</dl>

<p><div class="fragment"><pre class="fragment"><a name="l00254"></a>00254 {
<a name="l00255"></a>00255   gsl_vector     *fimage_wavelength;
<a name="l00256"></a>00256 
<a name="l00257"></a>00257   gsl_vector_int *fimage_order;
<a name="l00258"></a>00258 
<a name="l00259"></a>00259   <span class="keywordtype">int</span> i, j, k;
<a name="l00260"></a>00260 
<a name="l00261"></a>00261   <span class="comment">// allocate space for the order vector</span>
<a name="l00262"></a>00262   fimage_order = gsl_vector_int_alloc(fcube-&gt;<a class="code" href="structflux__cube.html#ad2a0926e5395663598768f3e09a14c69">n_fimage</a>);
<a name="l00263"></a>00263 
<a name="l00264"></a>00264   <span class="comment">// put a default order in the vector</span>
<a name="l00265"></a>00265   <span class="keywordflow">for</span> (i=0; i&lt;fcube-&gt;<a class="code" href="structflux__cube.html#ad2a0926e5395663598768f3e09a14c69">n_fimage</a>; i++)
<a name="l00266"></a>00266     gsl_vector_int_set(fimage_order, i, i);
<a name="l00267"></a>00267 
<a name="l00268"></a>00268   <span class="comment">// order the wavelength</span>
<a name="l00269"></a>00269   <span class="keywordflow">if</span> (fcube-&gt;<a class="code" href="structflux__cube.html#ad2a0926e5395663598768f3e09a14c69">n_fimage</a> &gt; 1)
<a name="l00270"></a>00270     {
<a name="l00271"></a>00271 
<a name="l00272"></a>00272       <span class="comment">// create a vector for the wavelengths</span>
<a name="l00273"></a>00273       fimage_wavelength = gsl_vector_alloc(fcube-&gt;<a class="code" href="structflux__cube.html#ad2a0926e5395663598768f3e09a14c69">n_fimage</a>);
<a name="l00274"></a>00274 
<a name="l00275"></a>00275       <span class="comment">// set the first entry for the wavelength</span>
<a name="l00276"></a>00276       gsl_vector_set(fimage_wavelength, 0, fcube-&gt;<a class="code" href="structflux__cube.html#ab8326cc76fb87ffb4aa998f1f3a11cc7">fluxims</a>[0]-&gt;<a class="code" href="structflux__image.html#a5f1c5f618a37935d59c16a56afd5eba2">wavelength</a>);
<a name="l00277"></a>00277 
<a name="l00278"></a>00278       <span class="comment">// go over all fluximages</span>
<a name="l00279"></a>00279       <span class="keywordflow">for</span> (i=1; i&lt;fcube-&gt;<a class="code" href="structflux__cube.html#ad2a0926e5395663598768f3e09a14c69">n_fimage</a>; i++)
<a name="l00280"></a>00280         {
<a name="l00281"></a>00281 
<a name="l00282"></a>00282           <span class="comment">// find the correct position of the fluximage</span>
<a name="l00283"></a>00283           j=0;
<a name="l00284"></a>00284           <span class="keywordflow">while</span> (j &lt; i &amp;&amp; gsl_vector_get(fimage_wavelength, j) &lt;= fcube-&gt;<a class="code" href="structflux__cube.html#ab8326cc76fb87ffb4aa998f1f3a11cc7">fluxims</a>[i]-&gt;<a class="code" href="structflux__image.html#a5f1c5f618a37935d59c16a56afd5eba2">wavelength</a>)
<a name="l00285"></a>00285             j++;
<a name="l00286"></a>00286 
<a name="l00287"></a>00287           <span class="comment">// check whether the correct poition of the fluximage is at the end</span>
<a name="l00288"></a>00288           <span class="keywordflow">if</span> (j == i)
<a name="l00289"></a>00289             {
<a name="l00290"></a>00290 
<a name="l00291"></a>00291               <span class="comment">// append the fluximage at the end</span>
<a name="l00292"></a>00292               gsl_vector_set(fimage_wavelength, j, fcube-&gt;<a class="code" href="structflux__cube.html#ab8326cc76fb87ffb4aa998f1f3a11cc7">fluxims</a>[i]-&gt;<a class="code" href="structflux__image.html#a5f1c5f618a37935d59c16a56afd5eba2">wavelength</a>);
<a name="l00293"></a>00293               gsl_vector_int_set(fimage_order, j, i);
<a name="l00294"></a>00294             }
<a name="l00295"></a>00295           <span class="keywordflow">else</span>
<a name="l00296"></a>00296             {
<a name="l00297"></a>00297 
<a name="l00298"></a>00298               <span class="comment">// move all fluximages one index up</span>
<a name="l00299"></a>00299               <span class="keywordflow">for</span> (k=i; k &gt; j; k--)
<a name="l00300"></a>00300                 {
<a name="l00301"></a>00301                   gsl_vector_set(fimage_wavelength, k, gsl_vector_get(fimage_wavelength, k-1));
<a name="l00302"></a>00302                   gsl_vector_int_set(fimage_order, k, gsl_vector_int_get(fimage_order, k-1));
<a name="l00303"></a>00303                 }
<a name="l00304"></a>00304 
<a name="l00305"></a>00305               <span class="comment">// place the flux image at the correct position</span>
<a name="l00306"></a>00306               gsl_vector_set(fimage_wavelength, j, fcube-&gt;<a class="code" href="structflux__cube.html#ab8326cc76fb87ffb4aa998f1f3a11cc7">fluxims</a>[i]-&gt;<a class="code" href="structflux__image.html#a5f1c5f618a37935d59c16a56afd5eba2">wavelength</a>);
<a name="l00307"></a>00307               gsl_vector_int_set(fimage_order, j, i);
<a name="l00308"></a>00308             }
<a name="l00309"></a>00309         }
<a name="l00310"></a>00310 
<a name="l00311"></a>00311       <span class="comment">// release the space for the wavelength vector</span>
<a name="l00312"></a>00312       gsl_vector_free(fimage_wavelength);
<a name="l00313"></a>00313     }
<a name="l00314"></a>00314 
<a name="l00315"></a>00315   <span class="comment">// return the order vector</span>
<a name="l00316"></a>00316   <span class="keywordflow">return</span> fimage_order;
<a name="l00317"></a>00317 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="aeb6a2b975b5359734fec27bef4d60d3e"></a><!-- doxytag: member="spc_fluxcube.c::print_fluxcube" ref="aeb6a2b975b5359734fec27bef4d60d3e" args="(const flux_cube *fcube)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void print_fluxcube </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structflux__cube.html">flux_cube</a> *&nbsp;</td>
          <td class="paramname"> <em>fcube</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>The function prints the main properties of a fluxcube structure onto the screen. This is mostly for debuggin/development purposes, and not for production</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>fcube</em>&nbsp;</td><td>- the fluxcube structure </td></tr>
  </table>
  </dd>
</dl>

<p><div class="fragment"><pre class="fragment"><a name="l00737"></a>00737 {
<a name="l00738"></a>00738   <span class="keywordtype">int</span> i;
<a name="l00739"></a>00739 
<a name="l00740"></a>00740   fprintf(stdout, <span class="stringliteral">&quot;XOFFS,YOFFS: %i,%i\n&quot;</span>, fcube-&gt;<a class="code" href="structflux__cube.html#aed8b9a141c8fd3f09022f27ca0f7d670">xoffs</a>, fcube-&gt;<a class="code" href="structflux__cube.html#a0ac57c4e5fe235758efb4a7ca70e5d29">yoffs</a>);
<a name="l00741"></a>00741   fprintf(stdout, <span class="stringliteral">&quot;Number of flux-extension: %i\n&quot;</span>, fcube-&gt;<a class="code" href="structflux__cube.html#ad2a0926e5395663598768f3e09a14c69">n_fimage</a>);
<a name="l00742"></a>00742 
<a name="l00743"></a>00743   <span class="keywordflow">for</span> (i=0; i&lt;fcube-&gt;<a class="code" href="structflux__cube.html#ad2a0926e5395663598768f3e09a14c69">n_fimage</a>; i++)
<a name="l00744"></a>00744     fprintf(stdout, <span class="stringliteral">&quot;Wavelength for flux extension %i: %f\n&quot;</span>, i,
<a name="l00745"></a>00745             fcube-&gt;<a class="code" href="structflux__cube.html#ab8326cc76fb87ffb4aa998f1f3a11cc7">fluxims</a>[gsl_vector_int_get(fcube-&gt;<a class="code" href="structflux__cube.html#a4ec5facf29796f861f62aadd0661f946">fimage_order</a>,i)]-&gt;<a class="code" href="structflux__image.html#a5f1c5f618a37935d59c16a56afd5eba2">wavelength</a>);
<a name="l00746"></a>00746 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ad90a902ccd2f90598490b151687c579a"></a><!-- doxytag: member="spc_fluxcube.c::update_dirobject" ref="ad90a902ccd2f90598490b151687c579a" args="(dirobject *actdir, const px_point flt_point)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void update_dirobject </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdirobject.html">dirobject</a> *&nbsp;</td>
          <td class="paramname"> <em>actdir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structpx__point.html">px_point</a>&nbsp;</td>
          <td class="paramname"> <em>flt_point</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>The function updates a <a class="el" href="structdirobject.html">dirobject</a> with a point belonging to the same <a class="el" href="structobject.html">object</a>. The new point may extend the <a class="el" href="structobject.html">object</a> size.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>actdir</em>&nbsp;</td><td>- the direct <a class="el" href="structobject.html">object</a> </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>flt_point</em>&nbsp;</td><td>- the new coordinate point </td></tr>
  </table>
  </dd>
</dl>

<p><div class="fragment"><pre class="fragment"><a name="l00581"></a>00581 {
<a name="l00582"></a>00582   <span class="comment">// check whether the new points extends the</span>
<a name="l00583"></a>00583   <span class="comment">// old min/max values in x or y.</span>
<a name="l00584"></a>00584   <span class="comment">// correct the values if necessary.</span>
<a name="l00585"></a>00585   actdir-&gt;<a class="code" href="structdirobject.html#ac068f35c585eec4cd1e5d3392c2dd698">ix_min</a> = <a class="code" href="aXe__utils_8c.html#a74e75242132eaabbc1c512488a135926">MIN</a>(actdir-&gt;<a class="code" href="structdirobject.html#ac068f35c585eec4cd1e5d3392c2dd698">ix_min</a>, flt_point.<a class="code" href="structpx__point.html#ab715a558731a820a25b50bd7797dd004">x</a>);
<a name="l00586"></a>00586   actdir-&gt;<a class="code" href="structdirobject.html#ac8c6104f2c2e1384c64bba61ecf40d69">ix_max</a> = <a class="code" href="aper__conf_8c.html#aacc3ee1a7f283f8ef65cea31f4436a95">MAX</a>(actdir-&gt;<a class="code" href="structdirobject.html#ac8c6104f2c2e1384c64bba61ecf40d69">ix_max</a>, flt_point.<a class="code" href="structpx__point.html#ab715a558731a820a25b50bd7797dd004">x</a>);
<a name="l00587"></a>00587   actdir-&gt;<a class="code" href="structdirobject.html#af24c9a92fa18516591e43d96eec13272">iy_min</a> = <a class="code" href="aXe__utils_8c.html#a74e75242132eaabbc1c512488a135926">MIN</a>(actdir-&gt;<a class="code" href="structdirobject.html#af24c9a92fa18516591e43d96eec13272">iy_min</a>, flt_point.<a class="code" href="structpx__point.html#a2d02b900722a71f22a8d5100822bda61">y</a>);
<a name="l00588"></a>00588   actdir-&gt;<a class="code" href="structdirobject.html#a3b36973dd52d158c059bfe6587a04244">iy_max</a> = <a class="code" href="aper__conf_8c.html#aacc3ee1a7f283f8ef65cea31f4436a95">MAX</a>(actdir-&gt;<a class="code" href="structdirobject.html#a3b36973dd52d158c059bfe6587a04244">iy_max</a>, flt_point.<a class="code" href="structpx__point.html#a2d02b900722a71f22a8d5100822bda61">y</a>);
<a name="l00589"></a>00589 }
</pre></div></p>

</div>
</div>
</div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&nbsp;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&nbsp;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&nbsp;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&nbsp;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&nbsp;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&nbsp;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&nbsp;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&nbsp;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&nbsp;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&nbsp;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr size="1"/><address style="text-align: right;"><small>Generated on 12 Oct 2014 for TIPS by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.1 </small></address>
</body>
</html>
