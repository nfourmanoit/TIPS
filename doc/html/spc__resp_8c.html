<!-- This comment will put IE 6, 7 and 8 in quirks mode -->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>TIPS: /renoir/fourmano/Desktop/OUSIM/TIPS/branches/tips_build/src/axesim/spc_resp.c File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.6.1 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <img id="MSearchSelect" src="search/search.png"
             onmouseover="return searchBox.OnSearchSelectShow()"
             onmouseout="return searchBox.OnSearchSelectHide()"
             alt=""/>
        <input type="text" id="MSearchField" value="Search" accesskey="S"
             onfocus="searchBox.OnSearchFieldFocus(true)" 
             onblur="searchBox.OnSearchFieldFocus(false)" 
             onkeyup="searchBox.OnSearchFieldChange(event)"/>
        <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
        </div>
      </li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>/renoir/fourmano/Desktop/OUSIM/TIPS/branches/tips_build/src/axesim/spc_resp.c File Reference</h1><code>#include &lt;gsl/gsl_matrix.h&gt;</code><br/>
<code>#include &lt;gsl/gsl_vector.h&gt;</code><br/>
<code>#include &lt;gsl/gsl_interp.h&gt;</code><br/>
<code>#include &lt;gsl/gsl_roots.h&gt;</code><br/>
<code>#include &quot;<a class="el" href="aXe__grism_8h_source.html">aXe_grism.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="disp__conf_8h_source.html">disp_conf.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="fringe__conf_8h_source.html">fringe_conf.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="spc__wl__calib_8h_source.html">spc_wl_calib.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="spc__resp_8h_source.html">spc_resp.h</a>&quot;</code><br/>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Namespaces</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacespc__resp.html">spc_resp</a></td></tr>
<tr><td colspan="2"><h2>Defines</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="spc__resp_8c.html#a74e75242132eaabbc1c512488a135926">MIN</a>(x, y)&nbsp;&nbsp;&nbsp;(((x)&lt;(y))?(x):(y))</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="spc__resp_8c.html#aacc3ee1a7f283f8ef65cea31f4436a95">MAX</a>(x, y)&nbsp;&nbsp;&nbsp;(((x)&gt;(y))?(x):(y))</td></tr>
<tr><td colspan="2"><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structspectrum.html">spectrum</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="spc__resp_8c.html#a5249f78ca40468a3e4634fe15c87da20">get_response_function_from_FITS</a> (char filename[], int hdunum)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="spc__resp_8c.html#a5f44fcc178b2da25927271b53d5d1f17">apply_response_function</a> (<a class="el" href="structspectrum.html">spectrum</a> *spec, <a class="el" href="structspectrum.html">spectrum</a> *resp, const int quant_cont)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="spc__resp_8c.html#a60eb0a59f94e070ca4f3ee71ee182ca9">apply_response_functionII</a> (<a class="el" href="structspectrum.html">spectrum</a> *spec, <a class="el" href="structresponse__function.html">response_function</a> *resp_func, const int quant_cont)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structd__point.html">d_point</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="spc__resp_8c.html#a157a1202bd6a233046e0bd6576bc61ca">get_smooth_pars_for_beam</a> (const <a class="el" href="structaperture__conf.html">aperture_conf</a> *conf, const int smooth_conv, <a class="el" href="structbeam.html">beam</a> actbeam)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="spc__resp_8c.html#a5fde07d1ba5295c2a04d17b9517c8b3f">check_conf_for_smoothing</a> (const <a class="el" href="structaperture__conf.html">aperture_conf</a> *conf, const int smooth_conv)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="spc__resp_8c.html#af2a378bacf12bd151d4b8d9d66e696a0">apply_smoothed_response</a> (const <a class="el" href="structcalib__function.html">calib_function</a> *wl_calibration, const int for_grism, const int quant_cont, <a class="el" href="structresponse__function.html">response_function</a> *resp_func, const <a class="el" href="structd__point.html">d_point</a> smooth_pars, <a class="el" href="structspectrum.html">spectrum</a> *spec)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="spc__resp_8c.html#a801a7c3ef4ee95658274156c6910a1cb">find_wavelength</a> (double x, void *params)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="spc__resp_8c.html#a8cc19f5af89c3055fc5b37110687a58d">get_tlength_prismwav</a> (const double wavelength, const <a class="el" href="structcalib__function.html">calib_function</a> *wl_calibration)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="spc__resp_8c.html#ab84a3c4ebe3efacf7c89a6833225eb9a">get_central_tracelength</a> (const double wavelength, const <a class="el" href="structcalib__function.html">calib_function</a> *wl_calibration, const int for_grism)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="spc__resp_8c.html#a1fd4f613775df35ada9d78832a1c0906">get_smoothed_response</a> (const double wavelength, const <a class="el" href="structd__point.html">d_point</a> smooth_pars, const <a class="el" href="structcalib__function.html">calib_function</a> *wl_calibration, const int for_grism, const gsl_vector *weights, <a class="el" href="structresponse__function.html">response_function</a> *resp_func, double *resp_vals)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="spc__resp_8c.html#a63e4d5535bbccf8346f35ed139018440">get_weighted_sensitivity</a> (const gsl_vector *pixvalues, const gsl_vector *errvalues, const gsl_vector *weights, const gsl_vector *pmask, double *resp_vals)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="spc__resp_8c.html#a49bc35d27187cb2fef40786e969743a7">fill_weight</a> (gsl_vector *weights)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="spc__resp_8c.html#add20ced757ce2623320cfa20db81e4ac">get_troughput_table_name</a> (char *filename, int beamID, char *table_name)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="spc__resp_8c.html#a92c6c9b541b7b862a2b9903e3587a8a2">get_response_value_plus</a> (const <a class="el" href="structspectrum.html">spectrum</a> *resp, const double wavelength, int *nguess)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="spc__resp_8c.html#a3e4ae40aa1401897ab1c66dffc99e0a4">get_response_values</a> (<a class="el" href="structresponse__function.html">response_function</a> *resp_func, double wavelength, double *resp_vals)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structresponse__function.html">response_function</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="spc__resp_8c.html#a7ac8453607987c5bac189f4e6a65ad35">create_response_function</a> (char *filename)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="spc__resp_8c.html#a0443087ea673f1af845bcdba1ed60a2a">free_response_function</a> (<a class="el" href="structresponse__function.html">response_function</a> *resp_func)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structcalib__function.html">calib_function</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="spc__resp_8c.html#a857611dff2d0a5a648328f76b16f1ab0">get_calfunc_for_beam</a> (const <a class="el" href="structbeam.html">beam</a> actbeam, const int for_grism, char CONF_file[], const <a class="el" href="structaperture__conf.html">aperture_conf</a> *conf)</td></tr>
</table>
<hr/><h2>Define Documentation</h2>
<a class="anchor" id="aacc3ee1a7f283f8ef65cea31f4436a95"></a><!-- doxytag: member="spc_resp.c::MAX" ref="aacc3ee1a7f283f8ef65cea31f4436a95" args="(x, y)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MAX</td>
          <td>(</td>
          <td class="paramtype">x, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">y&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td>&nbsp;&nbsp;&nbsp;(((x)&gt;(y))?(x):(y))</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a74e75242132eaabbc1c512488a135926"></a><!-- doxytag: member="spc_resp.c::MIN" ref="a74e75242132eaabbc1c512488a135926" args="(x, y)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MIN</td>
          <td>(</td>
          <td class="paramtype">x, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">y&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td>&nbsp;&nbsp;&nbsp;(((x)&lt;(y))?(x):(y))</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="a5f44fcc178b2da25927271b53d5d1f17"></a><!-- doxytag: member="spc_resp.c::apply_response_function" ref="a5f44fcc178b2da25927271b53d5d1f17" args="(spectrum *spec, spectrum *resp, const int quant_cont)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void apply_response_function </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structspectrum.html">spectrum</a> *&nbsp;</td>
          <td class="paramname"> <em>spec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structspectrum.html">spectrum</a> *&nbsp;</td>
          <td class="paramname"> <em>resp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>quant_cont</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Function: apply_response_function This function applies a thoughput curve to a given <a class="el" href="structspectrum.html">spectrum</a> by dividing the count attribute of the <a class="el" href="structspectrum.html">spectrum</a>. The flux and ferror attributes of the <a class="el" href="structspectrum.html">spectrum</a> are populated. gsl spline interpolation is used to compute the throughput curve at the needed spectral wavelengths.</p>
<p>Parameters: </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>spec</em>&nbsp;</td><td>- a pointer to an existing <a class="el" href="structspectrum.html">spectrum</a> array </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>resp</em>&nbsp;</td><td>- a pointer to a <a class="el" href="structspectrum.html">spectrum</a> structure containing a throughput curve previously loaded </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>exptime</em>&nbsp;</td><td>- the exposure time </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>gain</em>&nbsp;</td><td>- the gain</td></tr>
  </table>
  </dd>
</dl>
<p>Returns </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>- </dd></dl>

<p><div class="fragment"><pre class="fragment"><a name="l00245"></a>00245 {
<a name="l00246"></a>00246   gsl_interp_accel *acc1 = gsl_interp_accel_alloc();
<a name="l00247"></a>00247   gsl_spline *spline1 = gsl_spline_alloc (gsl_interp_cspline, resp-&gt;<a class="code" href="structspectrum.html#a7f1df316451ab775f47013bc7c556f08">spec_len</a>);
<a name="l00248"></a>00248 
<a name="l00249"></a>00249   gsl_interp_accel *acc2 = gsl_interp_accel_alloc();
<a name="l00250"></a>00250   gsl_spline *spline2 = gsl_spline_alloc (gsl_interp_cspline, resp-&gt;<a class="code" href="structspectrum.html#a7f1df316451ab775f47013bc7c556f08">spec_len</a>);
<a name="l00251"></a>00251 
<a name="l00252"></a>00252   <span class="keywordtype">double</span> *x1,*y1, *x2, *y2;
<a name="l00253"></a>00253   <span class="keywordtype">long</span> i,j;
<a name="l00254"></a>00254   <span class="keywordtype">double</span> r1, r2, fr, fr1, fr2;
<a name="l00255"></a>00255 
<a name="l00256"></a>00256   <span class="comment">// test</span>
<a name="l00257"></a>00257   <span class="comment">//  int nguess;</span>
<a name="l00258"></a>00258   <span class="comment">//  double tval=0.0;</span>
<a name="l00259"></a>00259 
<a name="l00260"></a>00260   <span class="keywordflow">if</span> ( spec==NULL)
<a name="l00261"></a>00261     {
<a name="l00262"></a>00262       <a class="code" href="aXe__errors_8c.html#a7ef7588e5f91237ba7ce4084e6ed3c11">aXe_message</a> (<a class="code" href="aXe__errors_8h.html#a3f3c2d017ceaf0b51cfb71efbcaeff44">aXe_M_WARN4</a>, __FILE__, __LINE__,
<a name="l00263"></a>00263                    <span class="stringliteral">&quot;apply_response_function: spectra empty.&quot;</span>);
<a name="l00264"></a>00264       gsl_spline_free(spline1);
<a name="l00265"></a>00265       gsl_interp_accel_free(acc1);
<a name="l00266"></a>00266       gsl_spline_free(spline2);
<a name="l00267"></a>00267       gsl_interp_accel_free(acc2);
<a name="l00268"></a>00268       <span class="keywordflow">return</span>;
<a name="l00269"></a>00269     }
<a name="l00270"></a>00270 
<a name="l00271"></a>00271   x1 = malloc(resp-&gt;<a class="code" href="structspectrum.html#a7f1df316451ab775f47013bc7c556f08">spec_len</a>*<span class="keyword">sizeof</span>(<span class="keywordtype">double</span>));
<a name="l00272"></a>00272   y1 = malloc(resp-&gt;<a class="code" href="structspectrum.html#a7f1df316451ab775f47013bc7c556f08">spec_len</a>*<span class="keyword">sizeof</span>(<span class="keywordtype">double</span>));
<a name="l00273"></a>00273   x2 = malloc(resp-&gt;<a class="code" href="structspectrum.html#a7f1df316451ab775f47013bc7c556f08">spec_len</a>*<span class="keyword">sizeof</span>(<span class="keywordtype">double</span>));
<a name="l00274"></a>00274   y2 = malloc(resp-&gt;<a class="code" href="structspectrum.html#a7f1df316451ab775f47013bc7c556f08">spec_len</a>*<span class="keyword">sizeof</span>(<span class="keywordtype">double</span>));
<a name="l00275"></a>00275 
<a name="l00276"></a>00276   <span class="keywordflow">for</span> (i=0;i&lt;resp-&gt;<a class="code" href="structspectrum.html#a7f1df316451ab775f47013bc7c556f08">spec_len</a>;i++) {
<a name="l00277"></a>00277     x1[i] = resp-&gt;<a class="code" href="structspectrum.html#a12640df5c0e35a9a377291dd11022bcf">spec</a>[i].<a class="code" href="structspc__entry.html#afabeeb9b94d4d47d65ade75c6ff82adc">lambda_mean</a>;
<a name="l00278"></a>00278     y1[i] = resp-&gt;<a class="code" href="structspectrum.html#a12640df5c0e35a9a377291dd11022bcf">spec</a>[i].<a class="code" href="structspc__entry.html#ab9baf671046970b64bc5e209815ef3ba">flux</a> - resp-&gt;<a class="code" href="structspectrum.html#a12640df5c0e35a9a377291dd11022bcf">spec</a>[i].<a class="code" href="structspc__entry.html#a68d27286e09aa4efa3acc087b171c125">ferror</a>;
<a name="l00279"></a>00279     x2[i] = resp-&gt;<a class="code" href="structspectrum.html#a12640df5c0e35a9a377291dd11022bcf">spec</a>[i].<a class="code" href="structspc__entry.html#afabeeb9b94d4d47d65ade75c6ff82adc">lambda_mean</a>;
<a name="l00280"></a>00280     y2[i] = resp-&gt;<a class="code" href="structspectrum.html#a12640df5c0e35a9a377291dd11022bcf">spec</a>[i].<a class="code" href="structspc__entry.html#ab9baf671046970b64bc5e209815ef3ba">flux</a> + resp-&gt;<a class="code" href="structspectrum.html#a12640df5c0e35a9a377291dd11022bcf">spec</a>[i].<a class="code" href="structspc__entry.html#a68d27286e09aa4efa3acc087b171c125">ferror</a>;
<a name="l00281"></a>00281   }
<a name="l00282"></a>00282 
<a name="l00283"></a>00283   gsl_spline_init (spline1, x1, y1, resp-&gt;<a class="code" href="structspectrum.html#a7f1df316451ab775f47013bc7c556f08">spec_len</a>);
<a name="l00284"></a>00284   gsl_spline_init (spline2, x2, y2, resp-&gt;<a class="code" href="structspectrum.html#a7f1df316451ab775f47013bc7c556f08">spec_len</a>);
<a name="l00285"></a>00285 
<a name="l00286"></a>00286   <span class="comment">// test</span>
<a name="l00287"></a>00287   <span class="comment">//  nguess = 0;</span>
<a name="l00288"></a>00288 
<a name="l00289"></a>00289   <span class="keywordflow">for</span> (j=0;j&lt;spec-&gt;<a class="code" href="structspectrum.html#a7f1df316451ab775f47013bc7c556f08">spec_len</a>;j++) {
<a name="l00290"></a>00290     r1 = gsl_spline_eval (spline1, spec-&gt;<a class="code" href="structspectrum.html#a12640df5c0e35a9a377291dd11022bcf">spec</a>[j].<a class="code" href="structspc__entry.html#afabeeb9b94d4d47d65ade75c6ff82adc">lambda_mean</a>, acc1);
<a name="l00291"></a>00291     r2 = gsl_spline_eval (spline2, spec-&gt;<a class="code" href="structspectrum.html#a12640df5c0e35a9a377291dd11022bcf">spec</a>[j].<a class="code" href="structspc__entry.html#afabeeb9b94d4d47d65ade75c6ff82adc">lambda_mean</a>, acc2);
<a name="l00292"></a>00292 
<a name="l00293"></a>00293     <span class="comment">// test</span>
<a name="l00294"></a>00294     <span class="comment">//    tval = get_response_value_plus(resp, spec-&gt;spec[j].lambda_mean, &amp;nguess);</span>
<a name="l00295"></a>00295 
<a name="l00296"></a>00296 
<a name="l00297"></a>00297     <span class="comment">/* Need to divide by the pixel width of the</span>
<a name="l00298"></a>00298 <span class="comment">       wavelength calibration at the given lambda */</span>
<a name="l00299"></a>00299 
<a name="l00300"></a>00300     <span class="keywordflow">if</span> ((r2+r1)!=0) {
<a name="l00301"></a>00301 
<a name="l00302"></a>00302       <span class="comment">// test</span>
<a name="l00303"></a>00303       <span class="comment">//      spec-&gt;spec[j].flux = spec-&gt;spec[j].count / tval;</span>
<a name="l00304"></a>00304       spec-&gt;<a class="code" href="structspectrum.html#a12640df5c0e35a9a377291dd11022bcf">spec</a>[j].<a class="code" href="structspc__entry.html#ab9baf671046970b64bc5e209815ef3ba">flux</a> = spec-&gt;<a class="code" href="structspectrum.html#a12640df5c0e35a9a377291dd11022bcf">spec</a>[j].<a class="code" href="structspc__entry.html#a80b739cd679fdd22fc316f86a210614b">count</a> / ((r2+r1)/2.);
<a name="l00305"></a>00305       spec-&gt;<a class="code" href="structspectrum.html#a12640df5c0e35a9a377291dd11022bcf">spec</a>[j].<a class="code" href="structspc__entry.html#ab9baf671046970b64bc5e209815ef3ba">flux</a> = spec-&gt;<a class="code" href="structspectrum.html#a12640df5c0e35a9a377291dd11022bcf">spec</a>[j].<a class="code" href="structspc__entry.html#ab9baf671046970b64bc5e209815ef3ba">flux</a>/spec-&gt;<a class="code" href="structspectrum.html#a12640df5c0e35a9a377291dd11022bcf">spec</a>[j].<a class="code" href="structspc__entry.html#a97f46ece62a58b05548668058ec97fb7">dlambda</a>;
<a name="l00306"></a>00306       <span class="comment">//      fprintf(stdout, &quot;# %f %f %f\n&quot;, spec-&gt;spec[j].lambda_mean, spec-&gt;spec[j].dlambda, spec-&gt;spec[j].weight);</span>
<a name="l00307"></a>00307 
<a name="l00308"></a>00308 
<a name="l00309"></a>00309       <span class="keywordflow">if</span> (quant_cont &amp;&amp; (<span class="keywordtype">int</span>)spec-&gt;<a class="code" href="structspectrum.html#a12640df5c0e35a9a377291dd11022bcf">spec</a>[j].<a class="code" href="structspc__entry.html#a8f512d7d02cbdceb5ef45430bec817ca">contam</a> != -1)
<a name="l00310"></a>00310         {
<a name="l00311"></a>00311           <span class="comment">// test</span>
<a name="l00312"></a>00312           <span class="comment">//      spec-&gt;spec[j].contam = spec-&gt;spec[j].contam / tval;</span>
<a name="l00313"></a>00313           spec-&gt;<a class="code" href="structspectrum.html#a12640df5c0e35a9a377291dd11022bcf">spec</a>[j].<a class="code" href="structspc__entry.html#a8f512d7d02cbdceb5ef45430bec817ca">contam</a> = spec-&gt;<a class="code" href="structspectrum.html#a12640df5c0e35a9a377291dd11022bcf">spec</a>[j].<a class="code" href="structspc__entry.html#a8f512d7d02cbdceb5ef45430bec817ca">contam</a> / ((r2+r1)/2.);
<a name="l00314"></a>00314           spec-&gt;<a class="code" href="structspectrum.html#a12640df5c0e35a9a377291dd11022bcf">spec</a>[j].<a class="code" href="structspc__entry.html#a8f512d7d02cbdceb5ef45430bec817ca">contam</a> = spec-&gt;<a class="code" href="structspectrum.html#a12640df5c0e35a9a377291dd11022bcf">spec</a>[j].<a class="code" href="structspc__entry.html#a8f512d7d02cbdceb5ef45430bec817ca">contam</a>/spec-&gt;<a class="code" href="structspectrum.html#a12640df5c0e35a9a377291dd11022bcf">spec</a>[j].<a class="code" href="structspc__entry.html#a97f46ece62a58b05548668058ec97fb7">dlambda</a>;
<a name="l00315"></a>00315         }
<a name="l00316"></a>00316     } <span class="keywordflow">else</span> {
<a name="l00317"></a>00317       spec-&gt;<a class="code" href="structspectrum.html#a12640df5c0e35a9a377291dd11022bcf">spec</a>[j].<a class="code" href="structspc__entry.html#ab9baf671046970b64bc5e209815ef3ba">flux</a> = GSL_NAN;
<a name="l00318"></a>00318     }
<a name="l00319"></a>00319 
<a name="l00320"></a>00320     fr1 = spec-&gt;<a class="code" href="structspectrum.html#a12640df5c0e35a9a377291dd11022bcf">spec</a>[j].<a class="code" href="structspc__entry.html#aa00854ac87415f7a7ce9f06018cecfe7">error</a> / spec-&gt;<a class="code" href="structspectrum.html#a12640df5c0e35a9a377291dd11022bcf">spec</a>[j].<a class="code" href="structspc__entry.html#a80b739cd679fdd22fc316f86a210614b">count</a>; <span class="comment">/* frac. error */</span>
<a name="l00321"></a>00321     fr2 = fabs((r2-r1)/((r1+r2)/2.0)); <span class="comment">/* frac. error in resp. */</span>
<a name="l00322"></a>00322     fr = sqrt(fr1*fr1+fr2*fr2);
<a name="l00323"></a>00323     spec-&gt;<a class="code" href="structspectrum.html#a12640df5c0e35a9a377291dd11022bcf">spec</a>[j].<a class="code" href="structspc__entry.html#a68d27286e09aa4efa3acc087b171c125">ferror</a> = fabs(spec-&gt;<a class="code" href="structspectrum.html#a12640df5c0e35a9a377291dd11022bcf">spec</a>[j].<a class="code" href="structspc__entry.html#ab9baf671046970b64bc5e209815ef3ba">flux</a>) * fr;
<a name="l00324"></a>00324   }
<a name="l00325"></a>00325 
<a name="l00326"></a>00326   gsl_spline_free(spline1);
<a name="l00327"></a>00327   gsl_interp_accel_free(acc1);
<a name="l00328"></a>00328   gsl_spline_free(spline2);
<a name="l00329"></a>00329   gsl_interp_accel_free(acc2);
<a name="l00330"></a>00330   free(x1);
<a name="l00331"></a>00331   free(x2);
<a name="l00332"></a>00332   free(y1);
<a name="l00333"></a>00333   free(y2);
<a name="l00334"></a>00334 
<a name="l00335"></a>00335 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a60eb0a59f94e070ca4f3ee71ee182ca9"></a><!-- doxytag: member="spc_resp.c::apply_response_functionII" ref="a60eb0a59f94e070ca4f3ee71ee182ca9" args="(spectrum *spec, response_function *resp_func, const int quant_cont)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void apply_response_functionII </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structspectrum.html">spectrum</a> *&nbsp;</td>
          <td class="paramname"> <em>spec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structresponse__function.html">response_function</a> *&nbsp;</td>
          <td class="paramname"> <em>resp_func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>quant_cont</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Function: apply_response_functionII This function applies a thoughput curve to a given <a class="el" href="structspectrum.html">spectrum</a> by dividing the count attribute of the <a class="el" href="structspectrum.html">spectrum</a>. The flux and ferror attributes of the <a class="el" href="structspectrum.html">spectrum</a> are populated.</p>
<p>Parameters: </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>spec</em>&nbsp;</td><td>- a pointer to an existing <a class="el" href="structspectrum.html">spectrum</a> array </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>resp_func</em>&nbsp;</td><td>- a pointer to a <a class="el" href="structspectrum.html">spectrum</a> structure containing a throughput curve previously loaded </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>quant_cont</em>&nbsp;</td><td>- the exposure time</td></tr>
  </table>
  </dd>
</dl>
<p>Returns </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>- </dd></dl>

<p><div class="fragment"><pre class="fragment"><a name="l00354"></a>00354 {
<a name="l00355"></a>00355   <span class="keywordtype">long</span> j;
<a name="l00356"></a>00356   <span class="keywordtype">double</span> fr, fr1, fr2;
<a name="l00357"></a>00357 
<a name="l00358"></a>00358   <span class="keywordtype">double</span> *resp_vals = malloc( 2 * <span class="keyword">sizeof</span>(<span class="keywordtype">double</span>));
<a name="l00359"></a>00359 
<a name="l00360"></a>00360   <span class="comment">// immediately return</span>
<a name="l00361"></a>00361   <span class="comment">// an empty spectrum</span>
<a name="l00362"></a>00362   <span class="keywordflow">if</span> ( spec==NULL)
<a name="l00363"></a>00363     {
<a name="l00364"></a>00364       <a class="code" href="aXe__errors_8c.html#a7ef7588e5f91237ba7ce4084e6ed3c11">aXe_message</a> (<a class="code" href="aXe__errors_8h.html#a3f3c2d017ceaf0b51cfb71efbcaeff44">aXe_M_WARN4</a>, __FILE__, __LINE__,
<a name="l00365"></a>00365                    <span class="stringliteral">&quot;apply_response_function: spectra empty.&quot;</span>);
<a name="l00366"></a>00366       <span class="keywordflow">return</span>;
<a name="l00367"></a>00367     }
<a name="l00368"></a>00368 
<a name="l00369"></a>00369   <span class="comment">// go over all elements</span>
<a name="l00370"></a>00370   <span class="keywordflow">for</span> (j=0;j&lt;spec-&gt;<a class="code" href="structspectrum.html#a7f1df316451ab775f47013bc7c556f08">spec_len</a>;j++)
<a name="l00371"></a>00371     {
<a name="l00372"></a>00372       <span class="comment">// get the sensitivity value plus error</span>
<a name="l00373"></a>00373       <a class="code" href="spc__resp_8c.html#a3e4ae40aa1401897ab1c66dffc99e0a4">get_response_values</a>(resp_func, spec-&gt;<a class="code" href="structspectrum.html#a12640df5c0e35a9a377291dd11022bcf">spec</a>[j].<a class="code" href="structspc__entry.html#afabeeb9b94d4d47d65ade75c6ff82adc">lambda_mean</a>, resp_vals);
<a name="l00374"></a>00374 
<a name="l00375"></a>00375       <span class="comment">// make sure you can compute the flux value</span>
<a name="l00376"></a>00376       <span class="keywordflow">if</span> (resp_vals[0] != 0.0)
<a name="l00377"></a>00377         {
<a name="l00378"></a>00378           <span class="comment">// compute the flux value</span>
<a name="l00379"></a>00379           spec-&gt;<a class="code" href="structspectrum.html#a12640df5c0e35a9a377291dd11022bcf">spec</a>[j].<a class="code" href="structspc__entry.html#ab9baf671046970b64bc5e209815ef3ba">flux</a> = spec-&gt;<a class="code" href="structspectrum.html#a12640df5c0e35a9a377291dd11022bcf">spec</a>[j].<a class="code" href="structspc__entry.html#a80b739cd679fdd22fc316f86a210614b">count</a> / resp_vals[0];
<a name="l00380"></a>00380           spec-&gt;<a class="code" href="structspectrum.html#a12640df5c0e35a9a377291dd11022bcf">spec</a>[j].<a class="code" href="structspc__entry.html#ab9baf671046970b64bc5e209815ef3ba">flux</a> = spec-&gt;<a class="code" href="structspectrum.html#a12640df5c0e35a9a377291dd11022bcf">spec</a>[j].<a class="code" href="structspc__entry.html#ab9baf671046970b64bc5e209815ef3ba">flux</a>/spec-&gt;<a class="code" href="structspectrum.html#a12640df5c0e35a9a377291dd11022bcf">spec</a>[j].<a class="code" href="structspc__entry.html#a97f46ece62a58b05548668058ec97fb7">dlambda</a>;
<a name="l00381"></a>00381 
<a name="l00382"></a>00382           <span class="comment">// compute the flux error</span>
<a name="l00383"></a>00383           fr1 = spec-&gt;<a class="code" href="structspectrum.html#a12640df5c0e35a9a377291dd11022bcf">spec</a>[j].<a class="code" href="structspc__entry.html#aa00854ac87415f7a7ce9f06018cecfe7">error</a> / spec-&gt;<a class="code" href="structspectrum.html#a12640df5c0e35a9a377291dd11022bcf">spec</a>[j].<a class="code" href="structspc__entry.html#a80b739cd679fdd22fc316f86a210614b">count</a>; <span class="comment">/* frac. error */</span>
<a name="l00384"></a>00384           fr2 = fabs(resp_vals[1] / resp_vals[0]); <span class="comment">/* frac. error in resp. */</span>
<a name="l00385"></a>00385           fr = sqrt(fr1*fr1+fr2*fr2);
<a name="l00386"></a>00386           spec-&gt;<a class="code" href="structspectrum.html#a12640df5c0e35a9a377291dd11022bcf">spec</a>[j].<a class="code" href="structspc__entry.html#a68d27286e09aa4efa3acc087b171c125">ferror</a> = fabs(spec-&gt;<a class="code" href="structspectrum.html#a12640df5c0e35a9a377291dd11022bcf">spec</a>[j].<a class="code" href="structspc__entry.html#ab9baf671046970b64bc5e209815ef3ba">flux</a>) * fr;
<a name="l00387"></a>00387 
<a name="l00388"></a>00388           <span class="comment">// check whether the contamination value is necessary</span>
<a name="l00389"></a>00389           <span class="keywordflow">if</span> (quant_cont &amp;&amp; (<span class="keywordtype">int</span>)spec-&gt;<a class="code" href="structspectrum.html#a12640df5c0e35a9a377291dd11022bcf">spec</a>[j].<a class="code" href="structspc__entry.html#a8f512d7d02cbdceb5ef45430bec817ca">contam</a> != -1)
<a name="l00390"></a>00390             {
<a name="l00391"></a>00391               <span class="comment">// compute the contamination value</span>
<a name="l00392"></a>00392               spec-&gt;<a class="code" href="structspectrum.html#a12640df5c0e35a9a377291dd11022bcf">spec</a>[j].<a class="code" href="structspc__entry.html#a8f512d7d02cbdceb5ef45430bec817ca">contam</a> = spec-&gt;<a class="code" href="structspectrum.html#a12640df5c0e35a9a377291dd11022bcf">spec</a>[j].<a class="code" href="structspc__entry.html#a8f512d7d02cbdceb5ef45430bec817ca">contam</a> / resp_vals[0];
<a name="l00393"></a>00393               spec-&gt;<a class="code" href="structspectrum.html#a12640df5c0e35a9a377291dd11022bcf">spec</a>[j].<a class="code" href="structspc__entry.html#a8f512d7d02cbdceb5ef45430bec817ca">contam</a> = spec-&gt;<a class="code" href="structspectrum.html#a12640df5c0e35a9a377291dd11022bcf">spec</a>[j].<a class="code" href="structspc__entry.html#a8f512d7d02cbdceb5ef45430bec817ca">contam</a>/spec-&gt;<a class="code" href="structspectrum.html#a12640df5c0e35a9a377291dd11022bcf">spec</a>[j].<a class="code" href="structspc__entry.html#a97f46ece62a58b05548668058ec97fb7">dlambda</a>;
<a name="l00394"></a>00394             }
<a name="l00395"></a>00395         }
<a name="l00396"></a>00396       <span class="keywordflow">else</span>
<a name="l00397"></a>00397         {
<a name="l00398"></a>00398           <span class="comment">// set the flux and the error to NaN</span>
<a name="l00399"></a>00399           spec-&gt;<a class="code" href="structspectrum.html#a12640df5c0e35a9a377291dd11022bcf">spec</a>[j].<a class="code" href="structspc__entry.html#ab9baf671046970b64bc5e209815ef3ba">flux</a> = GSL_NAN;
<a name="l00400"></a>00400           spec-&gt;<a class="code" href="structspectrum.html#a12640df5c0e35a9a377291dd11022bcf">spec</a>[j].<a class="code" href="structspc__entry.html#a68d27286e09aa4efa3acc087b171c125">ferror</a> = GSL_NAN;
<a name="l00401"></a>00401         }
<a name="l00402"></a>00402     }
<a name="l00403"></a>00403 
<a name="l00404"></a>00404   <span class="comment">// free the memory</span>
<a name="l00405"></a>00405   free(resp_vals);
<a name="l00406"></a>00406 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="af2a378bacf12bd151d4b8d9d66e696a0"></a><!-- doxytag: member="spc_resp.c::apply_smoothed_response" ref="af2a378bacf12bd151d4b8d9d66e696a0" args="(const calib_function *wl_calibration, const int for_grism, const int quant_cont, response_function *resp_func, const d_point smooth_pars, spectrum *spec)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void apply_smoothed_response </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structcalib__function.html">calib_function</a> *&nbsp;</td>
          <td class="paramname"> <em>wl_calibration</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>for_grism</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>quant_cont</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structresponse__function.html">response_function</a> *&nbsp;</td>
          <td class="paramname"> <em>resp_func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structd__point.html">d_point</a>&nbsp;</td>
          <td class="paramname"> <em>smooth_pars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structspectrum.html">spectrum</a> *&nbsp;</td>
          <td class="paramname"> <em>spec</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Function: apply_smoothed_response Convert a <a class="el" href="structspectrum.html">spectrum</a> from e/s to flux units in f_lambda. The conversion is done using smoothed sensitivity values that take the <a class="el" href="structobject.html">object</a> width into account by smoothing the sensitivity function. Gaussian smoothing is applied, taking into account that the original calibration function was derived for a point like <a class="el" href="structobject.html">object</a> with a finite size.</p>
<p>Parameters: </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>spec</em>&nbsp;</td><td>- a pointer to an existing <a class="el" href="structspectrum.html">spectrum</a> array </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>resp_func</em>&nbsp;</td><td>- a pointer to a <a class="el" href="structspectrum.html">spectrum</a> structure containing a throughput curve </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>quant_cont</em>&nbsp;</td><td>- indicator for quantitative contamination </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>bwidth</em>&nbsp;</td><td>- the B_IMAGE value of the <a class="el" href="structbeam.html">beam</a> </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>psf_ext</em>&nbsp;</td><td>- the width of a point-like <a class="el" href="structobject.html">object</a> </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>wl_calibration</em>&nbsp;</td><td>- the wavelength calibration structure</td></tr>
  </table>
  </dd>
</dl>
<p>Returns </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>- </dd></dl>

<p><div class="fragment"><pre class="fragment"><a name="l00513"></a>00513 {
<a name="l00514"></a>00514   <span class="keywordtype">long</span> j;
<a name="l00515"></a>00515   <span class="keywordtype">double</span> fr, fr1, fr2;
<a name="l00516"></a>00516   <span class="comment">//double sigma_wav=10.0;</span>
<a name="l00517"></a>00517 
<a name="l00518"></a>00518   <span class="keywordtype">double</span> *resp_vals = malloc( 2 * <span class="keyword">sizeof</span>(<span class="keywordtype">double</span>));
<a name="l00519"></a>00519   <span class="comment">//double *tmp_vals  = malloc( 2 * sizeof(double));</span>
<a name="l00520"></a>00520 
<a name="l00521"></a>00521   gsl_vector *weights;
<a name="l00522"></a>00522 
<a name="l00523"></a>00523   <span class="comment">// allocate memory for the vectors</span>
<a name="l00524"></a>00524   weights = gsl_vector_alloc(2 * <a class="code" href="spc__resp_8h.html#aa72ff6f8d89621381bba997b34673399">RESP_SMOOTH_LENGTH</a> + 1);
<a name="l00525"></a>00525 
<a name="l00526"></a>00526   <span class="comment">// immediately return</span>
<a name="l00527"></a>00527   <span class="comment">// an empty spectrum</span>
<a name="l00528"></a>00528   <span class="keywordflow">if</span> ( spec==NULL)
<a name="l00529"></a>00529     {
<a name="l00530"></a>00530       <a class="code" href="aXe__errors_8c.html#a7ef7588e5f91237ba7ce4084e6ed3c11">aXe_message</a> (<a class="code" href="aXe__errors_8h.html#a3f3c2d017ceaf0b51cfb71efbcaeff44">aXe_M_WARN4</a>, __FILE__, __LINE__,
<a name="l00531"></a>00531                    <span class="stringliteral">&quot;apply_response_function: spectra empty.&quot;</span>);
<a name="l00532"></a>00532       <span class="keywordflow">return</span>;
<a name="l00533"></a>00533     }
<a name="l00534"></a>00534 
<a name="l00535"></a>00535   <span class="comment">// fill the weight vector</span>
<a name="l00536"></a>00536   <span class="comment">// for smoothing</span>
<a name="l00537"></a>00537   <a class="code" href="spc__resp_8c.html#a49bc35d27187cb2fef40786e969743a7">fill_weight</a>(weights);
<a name="l00538"></a>00538 
<a name="l00539"></a>00539   <span class="comment">// output to screen</span>
<a name="l00540"></a>00540   fprintf(stdout, <span class="stringliteral">&quot;aXe_PET2SPC: Gaussian smoothing in tracelength: %.2f * %.2f = %.2f pix\n&quot;</span>, smooth_pars.<a class="code" href="structd__point.html#a922a3b5d82a119168ba85e5f939d02c3">x</a>, smooth_pars.<a class="code" href="structd__point.html#ad9846a025508bf8873a501ca5fcefbf4">y</a>, smooth_pars.<a class="code" href="structd__point.html#a922a3b5d82a119168ba85e5f939d02c3">x</a> * smooth_pars.<a class="code" href="structd__point.html#ad9846a025508bf8873a501ca5fcefbf4">y</a>);
<a name="l00541"></a>00541 
<a name="l00542"></a>00542   <span class="comment">// go over all elements</span>
<a name="l00543"></a>00543   <span class="keywordflow">for</span> (j=0;j&lt;spec-&gt;<a class="code" href="structspectrum.html#a7f1df316451ab775f47013bc7c556f08">spec_len</a>;j++)
<a name="l00544"></a>00544     {
<a name="l00545"></a>00545       <span class="comment">// get the smoothed sensitivity value plus error</span>
<a name="l00546"></a>00546       <a class="code" href="spc__resp_8c.html#a1fd4f613775df35ada9d78832a1c0906">get_smoothed_response</a>(spec-&gt;<a class="code" href="structspectrum.html#a12640df5c0e35a9a377291dd11022bcf">spec</a>[j].<a class="code" href="structspc__entry.html#afabeeb9b94d4d47d65ade75c6ff82adc">lambda_mean</a>, smooth_pars, wl_calibration,
<a name="l00547"></a>00547                             for_grism, weights, resp_func, resp_vals);
<a name="l00548"></a>00548 
<a name="l00549"></a>00549       <span class="comment">// make sure you can compute the flux value</span>
<a name="l00550"></a>00550       <span class="keywordflow">if</span> (resp_vals[0] != 0.0)
<a name="l00551"></a>00551         {
<a name="l00552"></a>00552           <span class="comment">// compute the flux value</span>
<a name="l00553"></a>00553           spec-&gt;<a class="code" href="structspectrum.html#a12640df5c0e35a9a377291dd11022bcf">spec</a>[j].<a class="code" href="structspc__entry.html#ab9baf671046970b64bc5e209815ef3ba">flux</a> = spec-&gt;<a class="code" href="structspectrum.html#a12640df5c0e35a9a377291dd11022bcf">spec</a>[j].<a class="code" href="structspc__entry.html#a80b739cd679fdd22fc316f86a210614b">count</a> / resp_vals[0];
<a name="l00554"></a>00554           spec-&gt;<a class="code" href="structspectrum.html#a12640df5c0e35a9a377291dd11022bcf">spec</a>[j].<a class="code" href="structspc__entry.html#ab9baf671046970b64bc5e209815ef3ba">flux</a> = spec-&gt;<a class="code" href="structspectrum.html#a12640df5c0e35a9a377291dd11022bcf">spec</a>[j].<a class="code" href="structspc__entry.html#ab9baf671046970b64bc5e209815ef3ba">flux</a>/spec-&gt;<a class="code" href="structspectrum.html#a12640df5c0e35a9a377291dd11022bcf">spec</a>[j].<a class="code" href="structspc__entry.html#a97f46ece62a58b05548668058ec97fb7">dlambda</a>;
<a name="l00555"></a>00555 
<a name="l00556"></a>00556           <span class="comment">// compute the flux error</span>
<a name="l00557"></a>00557           fr1 = spec-&gt;<a class="code" href="structspectrum.html#a12640df5c0e35a9a377291dd11022bcf">spec</a>[j].<a class="code" href="structspc__entry.html#aa00854ac87415f7a7ce9f06018cecfe7">error</a> / spec-&gt;<a class="code" href="structspectrum.html#a12640df5c0e35a9a377291dd11022bcf">spec</a>[j].<a class="code" href="structspc__entry.html#a80b739cd679fdd22fc316f86a210614b">count</a>; <span class="comment">/* frac. error */</span>
<a name="l00558"></a>00558           fr2 = fabs(resp_vals[1] / resp_vals[0]); <span class="comment">/* frac. error in resp. */</span>
<a name="l00559"></a>00559           fr = sqrt(fr1*fr1+fr2*fr2);
<a name="l00560"></a>00560           spec-&gt;<a class="code" href="structspectrum.html#a12640df5c0e35a9a377291dd11022bcf">spec</a>[j].<a class="code" href="structspc__entry.html#a68d27286e09aa4efa3acc087b171c125">ferror</a> = fabs(spec-&gt;<a class="code" href="structspectrum.html#a12640df5c0e35a9a377291dd11022bcf">spec</a>[j].<a class="code" href="structspc__entry.html#ab9baf671046970b64bc5e209815ef3ba">flux</a>) * fr;
<a name="l00561"></a>00561 
<a name="l00562"></a>00562           <span class="comment">// check whether the contamination value is necessary</span>
<a name="l00563"></a>00563           <span class="keywordflow">if</span> (quant_cont &amp;&amp; (<span class="keywordtype">int</span>)spec-&gt;<a class="code" href="structspectrum.html#a12640df5c0e35a9a377291dd11022bcf">spec</a>[j].<a class="code" href="structspc__entry.html#a8f512d7d02cbdceb5ef45430bec817ca">contam</a> != -1)
<a name="l00564"></a>00564             {
<a name="l00565"></a>00565               <span class="comment">// compute the contamination value</span>
<a name="l00566"></a>00566               spec-&gt;<a class="code" href="structspectrum.html#a12640df5c0e35a9a377291dd11022bcf">spec</a>[j].<a class="code" href="structspc__entry.html#a8f512d7d02cbdceb5ef45430bec817ca">contam</a> = spec-&gt;<a class="code" href="structspectrum.html#a12640df5c0e35a9a377291dd11022bcf">spec</a>[j].<a class="code" href="structspc__entry.html#a8f512d7d02cbdceb5ef45430bec817ca">contam</a> / resp_vals[0];
<a name="l00567"></a>00567               spec-&gt;<a class="code" href="structspectrum.html#a12640df5c0e35a9a377291dd11022bcf">spec</a>[j].<a class="code" href="structspc__entry.html#a8f512d7d02cbdceb5ef45430bec817ca">contam</a> = spec-&gt;<a class="code" href="structspectrum.html#a12640df5c0e35a9a377291dd11022bcf">spec</a>[j].<a class="code" href="structspc__entry.html#a8f512d7d02cbdceb5ef45430bec817ca">contam</a>/spec-&gt;<a class="code" href="structspectrum.html#a12640df5c0e35a9a377291dd11022bcf">spec</a>[j].<a class="code" href="structspc__entry.html#a97f46ece62a58b05548668058ec97fb7">dlambda</a>;
<a name="l00568"></a>00568             }
<a name="l00569"></a>00569         }
<a name="l00570"></a>00570       <span class="keywordflow">else</span>
<a name="l00571"></a>00571         {
<a name="l00572"></a>00572           <span class="comment">// set the flux and the error to NaN</span>
<a name="l00573"></a>00573           spec-&gt;<a class="code" href="structspectrum.html#a12640df5c0e35a9a377291dd11022bcf">spec</a>[j].<a class="code" href="structspc__entry.html#ab9baf671046970b64bc5e209815ef3ba">flux</a> = GSL_NAN;
<a name="l00574"></a>00574           spec-&gt;<a class="code" href="structspectrum.html#a12640df5c0e35a9a377291dd11022bcf">spec</a>[j].<a class="code" href="structspc__entry.html#a68d27286e09aa4efa3acc087b171c125">ferror</a> = GSL_NAN;
<a name="l00575"></a>00575         }
<a name="l00576"></a>00576     }
<a name="l00577"></a>00577 
<a name="l00578"></a>00578   <span class="comment">// free the memory</span>
<a name="l00579"></a>00579   free(resp_vals);
<a name="l00580"></a>00580   gsl_vector_free(weights);
<a name="l00581"></a>00581 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a5fde07d1ba5295c2a04d17b9517c8b3f"></a><!-- doxytag: member="spc_resp.c::check_conf_for_smoothing" ref="a5fde07d1ba5295c2a04d17b9517c8b3f" args="(const aperture_conf *conf, const int smooth_conv)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int check_conf_for_smoothing </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structaperture__conf.html">aperture_conf</a> *&nbsp;</td>
          <td class="paramname"> <em>conf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>smooth_conv</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Function: check_conf_for_smoothing The functions checks whether a smoothed flux conversion is possible or not. In case that keywords in the configuration files are missing, it is NOT possible, and 0 is returned.</p>
<p>Parameters: </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>conf</em>&nbsp;</td><td>- the configuarion file structure </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>smooth_conv</em>&nbsp;</td><td>- boolean for smooth conversion</td></tr>
  </table>
  </dd>
</dl>
<p>Returns </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>is_possible - the paramters used in the smoothing </dd></dl>

<p><div class="fragment"><pre class="fragment"><a name="l00476"></a>00476   {
<a name="l00477"></a>00477     <span class="keywordtype">int</span> is_possible=1;
<a name="l00478"></a>00478 
<a name="l00479"></a>00479     <span class="comment">// make sure that, if smoothed covnersion is requested,</span>
<a name="l00480"></a>00480     <span class="comment">// a point-like objects size and an adjustment factor is defined</span>
<a name="l00481"></a>00481     <span class="keywordflow">if</span> (smooth_conv &amp;&amp; (conf-&gt;<a class="code" href="structaperture__conf.html#a981e8e9f63a913f1ac34c864ec392024">pobjsize</a> &lt; 0.0 || conf-&gt;<a class="code" href="structaperture__conf.html#aca74009eb7d64af0ba7222e9dbb879c1">smfactor</a> &lt; 0.0))
<a name="l00482"></a>00482       <span class="comment">// change the switch</span>
<a name="l00483"></a>00483       is_possible = 0;
<a name="l00484"></a>00484 
<a name="l00485"></a>00485     <span class="comment">// return the pointer</span>
<a name="l00486"></a>00486     <span class="keywordflow">return</span> is_possible;
<a name="l00487"></a>00487   }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a7ac8453607987c5bac189f4e6a65ad35"></a><!-- doxytag: member="spc_resp.c::create_response_function" ref="a7ac8453607987c5bac189f4e6a65ad35" args="(char *filename)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structresponse__function.html">response_function</a>* create_response_function </td>
          <td>(</td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>filename</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Function: create_response_function Load the sensitivity file and creates a new response function. Relies heavily on other subroutines</p>
<p>Parameters: </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>filename</em>&nbsp;</td><td>- sensitivity file name</td></tr>
  </table>
  </dd>
</dl>
<p>Returns: </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>resp_func - the response function created </dd></dl>

<p><div class="fragment"><pre class="fragment"><a name="l01118"></a>01118 {
<a name="l01119"></a>01119   <a class="code" href="structresponse__function.html">response_function</a> *resp_func;
<a name="l01120"></a>01120 
<a name="l01121"></a>01121   <span class="comment">// allocate space for the return structure;</span>
<a name="l01122"></a>01122   <span class="comment">// complain if this fails</span>
<a name="l01123"></a>01123   resp_func = (<a class="code" href="structresponse__function.html">response_function</a> *)malloc (<span class="keyword">sizeof</span> (<a class="code" href="structresponse__function.html">response_function</a>));
<a name="l01124"></a>01124   <span class="keywordflow">if</span> (resp_func == NULL)
<a name="l01125"></a>01125     <a class="code" href="aXe__errors_8c.html#a7ef7588e5f91237ba7ce4084e6ed3c11">aXe_message</a> (<a class="code" href="aXe__errors_8h.html#a2556a67874555249b07691c37aa6d6e9">aXe_M_FATAL</a>, __FILE__, __LINE__,
<a name="l01126"></a>01126                  <span class="stringliteral">&quot;Could not allocate memory for response function&quot;</span>);
<a name="l01127"></a>01127 
<a name="l01128"></a>01128   <span class="comment">// load the two intgerpolators</span>
<a name="l01129"></a>01129   resp_func-&gt;<a class="code" href="structresponse__function.html#a67e56fb3a2affd39926091ff4fd57d5a">resp_values</a> = <a class="code" href="fringe__conf_8c.html#a4cddb24f157311f9a23ef00c3e279fc3">create_interp_ftable</a>(filename, 2, <span class="stringliteral">&quot;WAVELENGTH&quot;</span>, <span class="stringliteral">&quot;SENSITIVITY&quot;</span>, <a class="code" href="spc__spc_8h.html#a7501ed6347cdbad890d6a0f2fc9a92ea">RESP_FUNC_INTERP_TYPE</a>);
<a name="l01130"></a>01130   resp_func-&gt;<a class="code" href="structresponse__function.html#a4a8113d578a58810c2d396bd2ea31920">resp_errors</a> = <a class="code" href="fringe__conf_8c.html#a4cddb24f157311f9a23ef00c3e279fc3">create_interp_ftable</a>(filename, 2, <span class="stringliteral">&quot;WAVELENGTH&quot;</span>, <span class="stringliteral">&quot;ERROR&quot;</span>, <a class="code" href="spc__spc_8h.html#a7501ed6347cdbad890d6a0f2fc9a92ea">RESP_FUNC_INTERP_TYPE</a>);
<a name="l01131"></a>01131 
<a name="l01132"></a>01132   <span class="comment">// transfer the min and max values from the interpolator</span>
<a name="l01133"></a>01133   resp_func-&gt;<a class="code" href="structresponse__function.html#a75d90be05a1402c3afe4563a16289160">xmin</a> = resp_func-&gt;<a class="code" href="structresponse__function.html#a67e56fb3a2affd39926091ff4fd57d5a">resp_values</a>-&gt;<a class="code" href="structinterpolator.html#a09c1238a6c4be948ef51e29676074b6f">xmin</a>;
<a name="l01134"></a>01134   resp_func-&gt;<a class="code" href="structresponse__function.html#a5af3cf2a845502be139d4ecfb620c731">xmax</a> = resp_func-&gt;<a class="code" href="structresponse__function.html#a67e56fb3a2affd39926091ff4fd57d5a">resp_values</a>-&gt;<a class="code" href="structinterpolator.html#a4ccf4f1e42f5207f311bffcbebb7ea9c">xmax</a>;
<a name="l01135"></a>01135 
<a name="l01136"></a>01136   <span class="comment">// return the respons function</span>
<a name="l01137"></a>01137   <span class="keywordflow">return</span> resp_func;
<a name="l01138"></a>01138 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a49bc35d27187cb2fef40786e969743a7"></a><!-- doxytag: member="spc_resp.c::fill_weight" ref="a49bc35d27187cb2fef40786e969743a7" args="(gsl_vector *weights)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fill_weight </td>
          <td>(</td>
          <td class="paramtype">gsl_vector *&nbsp;</td>
          <td class="paramname"> <em>weights</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Function: fill_weight The function fills an array with Gaussian values. The number of points and the extend are all defined in global variables in the h-file.</p>
<p>Parameters: </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>weights</em>&nbsp;</td><td>- the weight vector</td></tr>
  </table>
  </dd>
</dl>
<p>Returns </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>- </dd></dl>

<p><div class="fragment"><pre class="fragment"><a name="l00937"></a>00937 {
<a name="l00938"></a>00938   <span class="keywordtype">int</span> j;
<a name="l00939"></a>00939 
<a name="l00940"></a>00940   <span class="keywordtype">double</span> d_incr;
<a name="l00941"></a>00941   <span class="keywordtype">double</span> value;
<a name="l00942"></a>00942 
<a name="l00943"></a>00943   <span class="comment">// determine the increments</span>
<a name="l00944"></a>00944   d_incr = (double)<a class="code" href="spc__resp_8h.html#a099bf5a5a124fe8705039105a8b79e83">RESP_SMOOTH_NSIG</a> / (<span class="keywordtype">double</span>)<a class="code" href="spc__resp_8h.html#aa72ff6f8d89621381bba997b34673399">RESP_SMOOTH_LENGTH</a>;
<a name="l00945"></a>00945 
<a name="l00946"></a>00946   <span class="comment">// compute the initial exponent</span>
<a name="l00947"></a>00947   <span class="comment">// go over the weights vector</span>
<a name="l00948"></a>00948   value = -(double)<a class="code" href="spc__resp_8h.html#a099bf5a5a124fe8705039105a8b79e83">RESP_SMOOTH_NSIG</a>;
<a name="l00949"></a>00949   <span class="keywordflow">for</span> (j=0; j &lt; weights-&gt;size; j++)
<a name="l00950"></a>00950     {
<a name="l00951"></a>00951       <span class="comment">// compute and set the weight</span>
<a name="l00952"></a>00952       gsl_vector_set(weights, j, exp(-1.0*value * value));
<a name="l00953"></a>00953 
<a name="l00954"></a>00954       <span class="comment">// increment the exponent</span>
<a name="l00955"></a>00955       value += d_incr;
<a name="l00956"></a>00956     }
<a name="l00957"></a>00957 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a801a7c3ef4ee95658274156c6910a1cb"></a><!-- doxytag: member="spc_resp.c::find_wavelength" ref="a801a7c3ef4ee95658274156c6910a1cb" args="(double x, void *params)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double find_wavelength </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>params</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Function: find_wavelength For a given trace-length value, the function returns the difference between the actual and the targeted wavelength. The function is designed t be called by a gsl root-solving procedure.</p>
<p>Parameters: </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>x</em>&nbsp;</td><td>- guess value for the tracelength </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>params</em>&nbsp;</td><td>- structure with input parameters</td></tr>
  </table>
  </dd>
</dl>
<p>Returns </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>wav_zero - difference between actual and targeted wavelength </dd></dl>

<p><div class="fragment"><pre class="fragment"><a name="l00598"></a>00598   {
<a name="l00599"></a>00599     <span class="keywordtype">double</span> wav_zero;
<a name="l00600"></a>00600 
<a name="l00601"></a>00601     <span class="comment">// extract the components from the parameter-structure</span>
<a name="l00602"></a>00602     <span class="keyword">const</span> <a class="code" href="structcalib__function.html">calib_function</a> *<a class="code" href="spc__wl__calib_8c.html#a83ff02c57744be22fec118377e2e3ec1">wl_calib</a> = ((<a class="code" href="structtrlength__search.html">trlength_search</a> *) params)-&gt;wl_calibration;
<a name="l00603"></a>00603     <span class="keywordtype">double</span> wavelength        = ((<a class="code" href="structtrlength__search.html">trlength_search</a> *) params)-&gt;wavelength;
<a name="l00604"></a>00604 
<a name="l00605"></a>00605     <span class="comment">// compute the function value</span>
<a name="l00606"></a>00606     wav_zero = wl_calib-&gt;<a class="code" href="structcalib__function.html#af3b6ef00cf4dfcfc75e8f129c555d99f">func</a> (x, wl_calib-&gt;<a class="code" href="structcalib__function.html#a0c2f4bb6aac5dbd2ce276ed8bee280da">order</a>, wl_calib-&gt;<a class="code" href="structcalib__function.html#af6161163d6abff34648d027533dbc89e">coeffs</a>) - wavelength;
<a name="l00607"></a>00607 
<a name="l00608"></a>00608     <span class="comment">// return the function value</span>
<a name="l00609"></a>00609     <span class="keywordflow">return</span> wav_zero;
<a name="l00610"></a>00610   }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a0443087ea673f1af845bcdba1ed60a2a"></a><!-- doxytag: member="spc_resp.c::free_response_function" ref="a0443087ea673f1af845bcdba1ed60a2a" args="(response_function *resp_func)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void free_response_function </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structresponse__function.html">response_function</a> *&nbsp;</td>
          <td class="paramname"> <em>resp_func</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Function: free_response_function Releases the memory allocated in a response function</p>
<p>Parameters: </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>resp_func</em>&nbsp;</td><td>- the response function</td></tr>
  </table>
  </dd>
</dl>
<p>Returns: </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>- </dd></dl>

<p><div class="fragment"><pre class="fragment"><a name="l01152"></a>01152 {
<a name="l01153"></a>01153   <span class="comment">// free the two interpolators</span>
<a name="l01154"></a>01154   <a class="code" href="fringe__conf_8c.html#a518a01a879febbaf974b85585defaf7c">free_interp</a>(resp_func-&gt;<a class="code" href="structresponse__function.html#a67e56fb3a2affd39926091ff4fd57d5a">resp_values</a>);
<a name="l01155"></a>01155   <a class="code" href="fringe__conf_8c.html#a518a01a879febbaf974b85585defaf7c">free_interp</a>(resp_func-&gt;<a class="code" href="structresponse__function.html#a4a8113d578a58810c2d396bd2ea31920">resp_errors</a>);
<a name="l01156"></a>01156 
<a name="l01157"></a>01157   <span class="comment">// free the rest</span>
<a name="l01158"></a>01158   free(resp_func);
<a name="l01159"></a>01159 
<a name="l01160"></a>01160   <span class="comment">// set it to NULL</span>
<a name="l01161"></a>01161   resp_func = NULL;
<a name="l01162"></a>01162 
<a name="l01163"></a>01163 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a857611dff2d0a5a648328f76b16f1ab0"></a><!-- doxytag: member="spc_resp.c::get_calfunc_for_beam" ref="a857611dff2d0a5a648328f76b16f1ab0" args="(const beam actbeam, const int for_grism, char CONF_file[], const aperture_conf *conf)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcalib__function.html">calib_function</a>* get_calfunc_for_beam </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structbeam.html">beam</a>&nbsp;</td>
          <td class="paramname"> <em>actbeam</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>for_grism</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&nbsp;</td>
          <td class="paramname"> <em>CONF_file</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structaperture__conf.html">aperture_conf</a> *&nbsp;</td>
          <td class="paramname"> <em>conf</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Function: get_calfunc_for_beam The subroutine determines and returns the calibration function for a certain <a class="el" href="structbeam.html">beam</a> and configuration file. The coefficients of the wavelength calibration are evaluated at the position of the <a class="el" href="structbeam.html">beam</a> <a class="el" href="structobject.html">object</a>.</p>
<p>Parameters: </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>actbeam</em>&nbsp;</td><td>- the current <a class="el" href="structbeam.html">beam</a> </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>for_grism</em>&nbsp;</td><td>- indicator for grism or prism dispersion </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>CONF_file</em>&nbsp;</td><td>- full pathname to configuration file </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>conf</em>&nbsp;</td><td>- the configuration structure</td></tr>
  </table>
  </dd>
</dl>
<p>Returns: </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>wl_calibration - the calibration function </dd></dl>

<p><div class="fragment"><pre class="fragment"><a name="l01184"></a>01184 {
<a name="l01185"></a>01185   <a class="code" href="structcalib__function.html">calib_function</a> *wl_calibration;
<a name="l01186"></a>01186   <a class="code" href="structdispstruct.html">dispstruct</a>     *disp;
<a name="l01187"></a>01187   <a class="code" href="structd__point.html">d_point</a>         pixel;
<a name="l01188"></a>01188 
<a name="l01189"></a>01189   <span class="comment">// get the reference point right</span>
<a name="l01190"></a>01190   pixel.<a class="code" href="structd__point.html#a922a3b5d82a119168ba85e5f939d02c3">x</a> = actbeam.<a class="code" href="structbeam.html#a54c64670a8b3e8732c1468d156ddb0ca">refpoint</a>.<a class="code" href="structd__point.html#a922a3b5d82a119168ba85e5f939d02c3">x</a> - conf-&gt;<a class="code" href="structaperture__conf.html#a5cdddf8dafb95b7a77458fbdbf74e5b9">refx</a>;
<a name="l01191"></a>01191   pixel.<a class="code" href="structd__point.html#ad9846a025508bf8873a501ca5fcefbf4">y</a> = actbeam.<a class="code" href="structbeam.html#a54c64670a8b3e8732c1468d156ddb0ca">refpoint</a>.<a class="code" href="structd__point.html#ad9846a025508bf8873a501ca5fcefbf4">y</a> - conf-&gt;<a class="code" href="structaperture__conf.html#ae48467c471e66355a90db41d8ce77bc6">refy</a>;
<a name="l01192"></a>01192 
<a name="l01193"></a>01193   <span class="comment">// get the dispersion structure</span>
<a name="l01194"></a>01194   disp = <a class="code" href="disp__conf_8c.html#a4b76887b807b37abcfc6eae3b15ddf4f">get_dispstruct_at_pos</a>(CONF_file, for_grism, actbeam.<a class="code" href="structbeam.html#a5c3f06b67e4cc3c79be539d1b515f3c6">ID</a>, pixel);
<a name="l01195"></a>01195 
<a name="l01196"></a>01196   <span class="comment">// transform the dispersion structure into the</span>
<a name="l01197"></a>01197   <span class="comment">// wavelength calibration</span>
<a name="l01198"></a>01198   wl_calibration = <a class="code" href="spc__wl__calib_8c.html#a99adb944646e98f75c71fa972290f8a3">create_calib_from_gsl_vector</a>(for_grism, disp-&gt;<a class="code" href="structdispstruct.html#aa3d9b87899d74411311e3a0ab60eeb20">pol</a>);
<a name="l01199"></a>01199   <span class="keywordflow">if</span> (!for_grism)
<a name="l01200"></a>01200     wl_calibration-&gt;<a class="code" href="structcalib__function.html#a585ddafa8bb9e1ac0b7a3da3410b5f80">pr_range</a> = <a class="code" href="disp__conf_8c.html#a689441b9d0c2037f5a6581423f8bfa88">get_prange</a> (CONF_file, actbeam.<a class="code" href="structbeam.html#a5c3f06b67e4cc3c79be539d1b515f3c6">ID</a>);
<a name="l01201"></a>01201 
<a name="l01202"></a>01202   <span class="comment">// free the whole structure</span>
<a name="l01203"></a>01203   <a class="code" href="disp__conf_8c.html#a4f56bf7087ee22ccb4b0a85a7fe7c1bd">free_dispstruct</a>(disp);
<a name="l01204"></a>01204 
<a name="l01205"></a>01205   <span class="comment">// return the wavelength calibration</span>
<a name="l01206"></a>01206   <span class="keywordflow">return</span> wl_calibration;
<a name="l01207"></a>01207 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ab84a3c4ebe3efacf7c89a6833225eb9a"></a><!-- doxytag: member="spc_resp.c::get_central_tracelength" ref="ab84a3c4ebe3efacf7c89a6833225eb9a" args="(const double wavelength, const calib_function *wl_calibration, const int for_grism)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double get_central_tracelength </td>
          <td>(</td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>wavelength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcalib__function.html">calib_function</a> *&nbsp;</td>
          <td class="paramname"> <em>wl_calibration</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>for_grism</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Function: get_tlength_prismwav The function determines the tracelength value for a given wavelength value and dispersion function. Should be called only for a prism dispersion. The gsl root solver is used.</p>
<p>Parameters: </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>wavelength</em>&nbsp;</td><td>- the wavelength value </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>wl_calibration</em>&nbsp;</td><td>- the dispersion solution </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>for_grism</em>&nbsp;</td><td>- boolean to indicate grism/prism dispersion solution</td></tr>
  </table>
  </dd>
</dl>
<p>Returns </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>wav_zero - difference between actual and targeted wavelength </dd></dl>

<p><div class="fragment"><pre class="fragment"><a name="l00709"></a>00709   {
<a name="l00710"></a>00710     <span class="keywordtype">double</span> tl_central=0.0;
<a name="l00711"></a>00711     <span class="keywordtype">double</span> a, b, c;
<a name="l00712"></a>00712 
<a name="l00713"></a>00713     <span class="comment">// checc whether it&apos;s a grism</span>
<a name="l00714"></a>00714     <span class="keywordflow">if</span> (for_grism)
<a name="l00715"></a>00715       {
<a name="l00716"></a>00716         <span class="comment">// solve a linear dispersion</span>
<a name="l00717"></a>00717         <span class="keywordflow">if</span> (wl_calibration-&gt;<a class="code" href="structcalib__function.html#a0c2f4bb6aac5dbd2ce276ed8bee280da">order</a> == 1)
<a name="l00718"></a>00718           {
<a name="l00719"></a>00719             tl_central = (wavelength - wl_calibration-&gt;<a class="code" href="structcalib__function.html#af6161163d6abff34648d027533dbc89e">coeffs</a>[0]) / wl_calibration-&gt;<a class="code" href="structcalib__function.html#af6161163d6abff34648d027533dbc89e">coeffs</a>[1];
<a name="l00720"></a>00720           }
<a name="l00721"></a>00721         <span class="comment">// solve a quadratic dispersion</span>
<a name="l00722"></a>00722         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (wl_calibration-&gt;<a class="code" href="structcalib__function.html#a0c2f4bb6aac5dbd2ce276ed8bee280da">order</a> == 2)
<a name="l00723"></a>00723           {
<a name="l00724"></a>00724             <span class="comment">// make the quantities</span>
<a name="l00725"></a>00725             a = wl_calibration-&gt;<a class="code" href="structcalib__function.html#af6161163d6abff34648d027533dbc89e">coeffs</a>[2];
<a name="l00726"></a>00726             b = wl_calibration-&gt;<a class="code" href="structcalib__function.html#af6161163d6abff34648d027533dbc89e">coeffs</a>[1];
<a name="l00727"></a>00727             c = wl_calibration-&gt;<a class="code" href="structcalib__function.html#af6161163d6abff34648d027533dbc89e">coeffs</a>[0] - wavelength;
<a name="l00728"></a>00728 
<a name="l00729"></a>00729             <span class="comment">// compute the central tracelength</span>
<a name="l00730"></a>00730             <span class="comment">//tl_central = (-b + sqrt(b*b - 4.0*a*c)) / (2.0*c);</span>
<a name="l00731"></a>00731             tl_central = (-b + sqrt(b*b - 4.0*a*c)) / (2.0*a);
<a name="l00732"></a>00732             <span class="comment">//fprintf(stdout, &quot;I should be here... %g %g %g %g\n&quot;, tl_central, a, b, c);</span>
<a name="l00733"></a>00733           }
<a name="l00734"></a>00734         <span class="keywordflow">else</span>
<a name="l00735"></a>00735           {
<a name="l00736"></a>00736             <span class="comment">// give error message</span>
<a name="l00737"></a>00737             <a class="code" href="aXe__errors_8c.html#a7ef7588e5f91237ba7ce4084e6ed3c11">aXe_message</a> (<a class="code" href="aXe__errors_8h.html#a2556a67874555249b07691c37aa6d6e9">aXe_M_FATAL</a>, __FILE__, __LINE__,
<a name="l00738"></a>00738                 <span class="stringliteral">&quot;Smoothed flux conversion is impossible for grism &quot;</span>
<a name="l00739"></a>00739                 <span class="stringliteral">&quot;data with dispersion solution of order: %i&quot;</span>, wl_calibration-&gt;<a class="code" href="structcalib__function.html#a0c2f4bb6aac5dbd2ce276ed8bee280da">order</a>);
<a name="l00740"></a>00740           }
<a name="l00741"></a>00741       }
<a name="l00742"></a>00742     <span class="keywordflow">else</span>
<a name="l00743"></a>00743       {
<a name="l00744"></a>00744         <span class="comment">// use the root finder to get the tace-length value</span>
<a name="l00745"></a>00745         <span class="comment">// for the given wavelength</span>
<a name="l00746"></a>00746         <span class="keywordflow">if</span> (isnan(wavelength))
<a name="l00747"></a>00747           tl_central = GSL_NAN;
<a name="l00748"></a>00748         <span class="keywordflow">else</span>
<a name="l00749"></a>00749           tl_central = <a class="code" href="spc__resp_8c.html#a8cc19f5af89c3055fc5b37110687a58d">get_tlength_prismwav</a>(wavelength, wl_calibration);
<a name="l00750"></a>00750       }
<a name="l00751"></a>00751 
<a name="l00752"></a>00752     <span class="comment">// return the central</span>
<a name="l00753"></a>00753     <span class="comment">// tracelength value</span>
<a name="l00754"></a>00754     <span class="keywordflow">return</span> tl_central;
<a name="l00755"></a>00755   }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a5249f78ca40468a3e4634fe15c87da20"></a><!-- doxytag: member="spc_resp.c::get_response_function_from_FITS" ref="a5249f78ca40468a3e4634fe15c87da20" args="(char filename[], int hdunum)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structspectrum.html">spectrum</a>* get_response_function_from_FITS </td>
          <td>(</td>
          <td class="paramtype">char&nbsp;</td>
          <td class="paramname"> <em>filename</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>hdunum</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Function: get_response_function_from_FITS This function reads a FITS table, reads the WAVELENGTH, SENSITIVITY, and ERROR columns and returns a <a class="el" href="structspectrum.html">spectrum</a> structure which has been populated with this throughput.</p>
<p>Parameters: </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>filename</em>&nbsp;</td><td>- a pointer to a char array containing the name of an existing FITS file </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>hdunum</em>&nbsp;</td><td>- the extension number to read (2 for STSDAS tables)</td></tr>
  </table>
  </dd>
</dl>
<p>Returns: </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>res - a pointer to a newly allocated <a class="el" href="structspectrum.html">spectrum</a> structure </dd></dl>

<p><div class="fragment"><pre class="fragment"><a name="l00045"></a>00045 {
<a name="l00046"></a>00046   fitsfile *input;
<a name="l00047"></a>00047   <span class="keywordtype">int</span> f_status = 0;
<a name="l00048"></a>00048   <span class="keywordtype">int</span> hdutype, anynul;
<a name="l00049"></a>00049   <span class="keywordtype">double</span> *lambda, *resp, *error;
<a name="l00050"></a>00050   <span class="keywordtype">double</span> tmp;
<a name="l00051"></a>00051   <span class="keywordtype">long</span> numrows;
<a name="l00052"></a>00052   <span class="keywordtype">int</span> colnum, i;
<a name="l00053"></a>00053   <a class="code" href="structspectrum.html">spectrum</a> *res;
<a name="l00054"></a>00054 
<a name="l00055"></a>00055   <span class="comment">//  Open the file for reading</span>
<a name="l00056"></a>00056   fits_open_file (&amp;input, filename, READONLY, &amp;f_status);
<a name="l00057"></a>00057   <span class="keywordflow">if</span> (f_status)
<a name="l00058"></a>00058     {
<a name="l00059"></a>00059       ffrprt (stderr, f_status);
<a name="l00060"></a>00060       <a class="code" href="aXe__errors_8c.html#a7ef7588e5f91237ba7ce4084e6ed3c11">aXe_message</a> (<a class="code" href="aXe__errors_8h.html#a2556a67874555249b07691c37aa6d6e9">aXe_M_FATAL</a>, __FILE__, __LINE__,
<a name="l00061"></a>00061                    <span class="stringliteral">&quot;get_response_function_fromFITS: &quot;</span>
<a name="l00062"></a>00062                    <span class="stringliteral">&quot;Could not open&quot;</span> <span class="stringliteral">&quot; file: %s&quot;</span>,
<a name="l00063"></a>00063                    filename);
<a name="l00064"></a>00064     }
<a name="l00065"></a>00065   <span class="comment">/* Move to first hdu */</span>
<a name="l00066"></a>00066   fits_movabs_hdu (input, hdunum, &amp;hdutype, &amp;f_status);
<a name="l00067"></a>00067   <span class="keywordflow">if</span> (f_status)
<a name="l00068"></a>00068     {
<a name="l00069"></a>00069       ffrprt (stderr, f_status);
<a name="l00070"></a>00070       <a class="code" href="aXe__errors_8c.html#a7ef7588e5f91237ba7ce4084e6ed3c11">aXe_message</a> (<a class="code" href="aXe__errors_8h.html#a2556a67874555249b07691c37aa6d6e9">aXe_M_FATAL</a>, __FILE__, __LINE__,
<a name="l00071"></a>00071                    <span class="stringliteral">&quot;get_response_function_fromFITS: &quot;</span>
<a name="l00072"></a>00072                    <span class="stringliteral">&quot;Could not read extention %d from file: %s&quot;</span>,
<a name="l00073"></a>00073                    hdunum, filename);
<a name="l00074"></a>00074     }
<a name="l00075"></a>00075 
<a name="l00076"></a>00076   <span class="comment">/* Get number of rows */</span>
<a name="l00077"></a>00077   fits_get_num_rows (input, &amp;numrows, &amp;f_status);
<a name="l00078"></a>00078   <span class="keywordflow">if</span> (f_status) {
<a name="l00079"></a>00079     ffrprt (stderr, f_status);
<a name="l00080"></a>00080     <a class="code" href="aXe__errors_8c.html#a7ef7588e5f91237ba7ce4084e6ed3c11">aXe_message</a> (<a class="code" href="aXe__errors_8h.html#a2556a67874555249b07691c37aa6d6e9">aXe_M_FATAL</a>, __FILE__, __LINE__,
<a name="l00081"></a>00081                  <span class="stringliteral">&quot;get_response_function_fromFITS: &quot;</span>
<a name="l00082"></a>00082                  <span class="stringliteral">&quot;Could not determine the number of rows in&quot;</span>
<a name="l00083"></a>00083                  <span class="stringliteral">&quot; table %s&quot;</span>,filename);
<a name="l00084"></a>00084   }
<a name="l00085"></a>00085 
<a name="l00086"></a>00086   <span class="comment">/* Allocate temporary memory space */</span>
<a name="l00087"></a>00087   lambda = (<span class="keywordtype">double</span> *) malloc(numrows*<span class="keyword">sizeof</span>(<span class="keywordtype">double</span>));
<a name="l00088"></a>00088   <span class="keywordflow">if</span> (!lambda) {
<a name="l00089"></a>00089     <a class="code" href="aXe__errors_8c.html#a7ef7588e5f91237ba7ce4084e6ed3c11">aXe_message</a> (<a class="code" href="aXe__errors_8h.html#ad247dca204a2964327532d0359b59ad8">aXe_M_ERROR</a>, __FILE__, __LINE__,
<a name="l00090"></a>00090                  <span class="stringliteral">&quot;Memory allocation failed&quot;</span>);
<a name="l00091"></a>00091   }
<a name="l00092"></a>00092   resp = (<span class="keywordtype">double</span> *) malloc(numrows*<span class="keyword">sizeof</span>(<span class="keywordtype">double</span>));
<a name="l00093"></a>00093   <span class="keywordflow">if</span> (!resp) {
<a name="l00094"></a>00094     <a class="code" href="aXe__errors_8c.html#a7ef7588e5f91237ba7ce4084e6ed3c11">aXe_message</a> (<a class="code" href="aXe__errors_8h.html#ad247dca204a2964327532d0359b59ad8">aXe_M_ERROR</a>, __FILE__, __LINE__,
<a name="l00095"></a>00095                  <span class="stringliteral">&quot;Memory allocation failed&quot;</span>);
<a name="l00096"></a>00096   }
<a name="l00097"></a>00097   error = (<span class="keywordtype">double</span> *) malloc(numrows*<span class="keyword">sizeof</span>(<span class="keywordtype">double</span>));
<a name="l00098"></a>00098   <span class="keywordflow">if</span> (!error) {
<a name="l00099"></a>00099     <a class="code" href="aXe__errors_8c.html#a7ef7588e5f91237ba7ce4084e6ed3c11">aXe_message</a> (<a class="code" href="aXe__errors_8h.html#ad247dca204a2964327532d0359b59ad8">aXe_M_ERROR</a>, __FILE__, __LINE__,
<a name="l00100"></a>00100                  <span class="stringliteral">&quot;Memory allocation failed&quot;</span>);
<a name="l00101"></a>00101   }
<a name="l00102"></a>00102 
<a name="l00103"></a>00103   <span class="comment">/**************************/</span>
<a name="l00104"></a>00104   <span class="comment">/* Read the WAVELENGTH column */</span>
<a name="l00105"></a>00105   <span class="comment">/**************************/</span>
<a name="l00106"></a>00106   <span class="comment">/* Get column number */</span>
<a name="l00107"></a>00107   fits_get_colnum (input, CASEINSEN, <span class="stringliteral">&quot;WAVELENGTH&quot;</span>, &amp;colnum, &amp;f_status);
<a name="l00108"></a>00108   <span class="keywordflow">if</span> (f_status)
<a name="l00109"></a>00109     {
<a name="l00110"></a>00110       ffrprt (stderr, f_status);
<a name="l00111"></a>00111       <a class="code" href="aXe__errors_8c.html#a7ef7588e5f91237ba7ce4084e6ed3c11">aXe_message</a> (<a class="code" href="aXe__errors_8h.html#a2556a67874555249b07691c37aa6d6e9">aXe_M_FATAL</a>, __FILE__, __LINE__,
<a name="l00112"></a>00112                    <span class="stringliteral">&quot;get_response_function_fromFITS: &quot;</span>
<a name="l00113"></a>00113                    <span class="stringliteral">&quot;Could not determine WAVELENGTH column number in &quot;</span>
<a name="l00114"></a>00114                    <span class="stringliteral">&quot; table %s&quot;</span>,filename);
<a name="l00115"></a>00115     }
<a name="l00116"></a>00116 
<a name="l00117"></a>00117   <span class="comment">/* Read the data */</span>
<a name="l00118"></a>00118   fits_read_col (input, TDOUBLE, colnum, 1, 1, numrows, NULL, lambda,
<a name="l00119"></a>00119                     &amp;anynul, &amp;f_status);
<a name="l00120"></a>00120   <span class="keywordflow">if</span> (f_status)
<a name="l00121"></a>00121     {
<a name="l00122"></a>00122       ffrprt (stderr, f_status);
<a name="l00123"></a>00123       <a class="code" href="aXe__errors_8c.html#a7ef7588e5f91237ba7ce4084e6ed3c11">aXe_message</a> (<a class="code" href="aXe__errors_8h.html#a2556a67874555249b07691c37aa6d6e9">aXe_M_FATAL</a>, __FILE__, __LINE__,
<a name="l00124"></a>00124                    <span class="stringliteral">&quot;get_response_function_fromFITS: &quot;</span>
<a name="l00125"></a>00125                    <span class="stringliteral">&quot;Could not read content of WAVELENGTH column &quot;</span>
<a name="l00126"></a>00126                    <span class="stringliteral">&quot; from BINARY table %s&quot;</span>,filename);
<a name="l00127"></a>00127     }
<a name="l00128"></a>00128 
<a name="l00129"></a>00129   <span class="comment">/**************************/</span>
<a name="l00130"></a>00130   <span class="comment">/* Read the SENSITIVITY column */</span>
<a name="l00131"></a>00131   <span class="comment">/**************************/</span>
<a name="l00132"></a>00132   <span class="comment">/* Get column number */</span>
<a name="l00133"></a>00133   fits_get_colnum (input, CASEINSEN, <span class="stringliteral">&quot;SENSITIVITY&quot;</span>, &amp;colnum, &amp;f_status);
<a name="l00134"></a>00134   <span class="keywordflow">if</span> (f_status)
<a name="l00135"></a>00135     {
<a name="l00136"></a>00136       ffrprt (stderr, f_status);
<a name="l00137"></a>00137       <a class="code" href="aXe__errors_8c.html#a7ef7588e5f91237ba7ce4084e6ed3c11">aXe_message</a> (<a class="code" href="aXe__errors_8h.html#a2556a67874555249b07691c37aa6d6e9">aXe_M_FATAL</a>, __FILE__, __LINE__,
<a name="l00138"></a>00138                    <span class="stringliteral">&quot;get_response_function_fromFITS: &quot;</span>
<a name="l00139"></a>00139                    <span class="stringliteral">&quot;Could not determine SENSITIVITY column number in &quot;</span>
<a name="l00140"></a>00140                    <span class="stringliteral">&quot; table %s&quot;</span>,filename);
<a name="l00141"></a>00141     }
<a name="l00142"></a>00142   <span class="comment">/* Read the data */</span>
<a name="l00143"></a>00143   fits_read_col (input, TDOUBLE, colnum, 1, 1, numrows, NULL, resp,
<a name="l00144"></a>00144                     &amp;anynul, &amp;f_status);
<a name="l00145"></a>00145   <span class="keywordflow">if</span> (f_status)
<a name="l00146"></a>00146     {
<a name="l00147"></a>00147       ffrprt (stderr, f_status);
<a name="l00148"></a>00148       <a class="code" href="aXe__errors_8c.html#a7ef7588e5f91237ba7ce4084e6ed3c11">aXe_message</a> (<a class="code" href="aXe__errors_8h.html#a2556a67874555249b07691c37aa6d6e9">aXe_M_FATAL</a>, __FILE__, __LINE__,
<a name="l00149"></a>00149                    <span class="stringliteral">&quot;get_response_function_fromFITS: &quot;</span>
<a name="l00150"></a>00150                    <span class="stringliteral">&quot;Could not read content of SENSITIVITY column &quot;</span>
<a name="l00151"></a>00151                    <span class="stringliteral">&quot; from BINARY table %s&quot;</span>,filename);
<a name="l00152"></a>00152     }
<a name="l00153"></a>00153   <span class="comment">/**************************/</span>
<a name="l00154"></a>00154   <span class="comment">/* Read the ERROR column */</span>
<a name="l00155"></a>00155   <span class="comment">/**************************/</span>
<a name="l00156"></a>00156   <span class="comment">/* Get column number */</span>
<a name="l00157"></a>00157   fits_get_colnum (input, CASEINSEN, <span class="stringliteral">&quot;ERROR&quot;</span>, &amp;colnum, &amp;f_status);
<a name="l00158"></a>00158   <span class="keywordflow">if</span> (f_status)
<a name="l00159"></a>00159     {
<a name="l00160"></a>00160       ffrprt (stderr, f_status);
<a name="l00161"></a>00161       <a class="code" href="aXe__errors_8c.html#a7ef7588e5f91237ba7ce4084e6ed3c11">aXe_message</a> (<a class="code" href="aXe__errors_8h.html#a2556a67874555249b07691c37aa6d6e9">aXe_M_FATAL</a>, __FILE__, __LINE__,
<a name="l00162"></a>00162                    <span class="stringliteral">&quot;get_response_function_fromFITS: &quot;</span>
<a name="l00163"></a>00163                    <span class="stringliteral">&quot;Could not determine ERROR column number in &quot;</span>
<a name="l00164"></a>00164                    <span class="stringliteral">&quot; table %s&quot;</span>,filename);
<a name="l00165"></a>00165     }
<a name="l00166"></a>00166   <span class="comment">/* Read the data */</span>
<a name="l00167"></a>00167   fits_read_col (input, TDOUBLE, colnum, 1, 1, numrows, NULL, error,
<a name="l00168"></a>00168                     &amp;anynul, &amp;f_status);
<a name="l00169"></a>00169   <span class="keywordflow">if</span> (f_status)
<a name="l00170"></a>00170     {
<a name="l00171"></a>00171       ffrprt (stderr, f_status);
<a name="l00172"></a>00172       <a class="code" href="aXe__errors_8c.html#a7ef7588e5f91237ba7ce4084e6ed3c11">aXe_message</a> (<a class="code" href="aXe__errors_8h.html#a2556a67874555249b07691c37aa6d6e9">aXe_M_FATAL</a>, __FILE__, __LINE__,
<a name="l00173"></a>00173                    <span class="stringliteral">&quot;get_response_function_fromFITS: &quot;</span>
<a name="l00174"></a>00174                    <span class="stringliteral">&quot;Could not read content of ERROR column &quot;</span>
<a name="l00175"></a>00175                    <span class="stringliteral">&quot; from BINARY table %s&quot;</span>,filename);
<a name="l00176"></a>00176     }
<a name="l00177"></a>00177 
<a name="l00178"></a>00178 
<a name="l00179"></a>00179   <span class="comment">/* Allocate memory */</span>
<a name="l00180"></a>00180   res = (<a class="code" href="structspectrum.html">spectrum</a> *) malloc(<span class="keyword">sizeof</span>(<a class="code" href="structspectrum.html">spectrum</a>));
<a name="l00181"></a>00181   <span class="keywordflow">if</span>(!res) {
<a name="l00182"></a>00182       <a class="code" href="aXe__errors_8c.html#a7ef7588e5f91237ba7ce4084e6ed3c11">aXe_message</a> (<a class="code" href="aXe__errors_8h.html#ad247dca204a2964327532d0359b59ad8">aXe_M_ERROR</a>, __FILE__, __LINE__,
<a name="l00183"></a>00183                    <span class="stringliteral">&quot;Memory allocation failed&quot;</span>);
<a name="l00184"></a>00184   }
<a name="l00185"></a>00185   res-&gt;<a class="code" href="structspectrum.html#a12640df5c0e35a9a377291dd11022bcf">spec</a> = (<a class="code" href="structspc__entry.html">spc_entry</a> *) malloc(numrows*<span class="keyword">sizeof</span>(<a class="code" href="structspc__entry.html">spc_entry</a>));
<a name="l00186"></a>00186   <span class="keywordflow">if</span>(!(res-&gt;<a class="code" href="structspectrum.html#a12640df5c0e35a9a377291dd11022bcf">spec</a>)) {
<a name="l00187"></a>00187       <a class="code" href="aXe__errors_8c.html#a7ef7588e5f91237ba7ce4084e6ed3c11">aXe_message</a> (<a class="code" href="aXe__errors_8h.html#ad247dca204a2964327532d0359b59ad8">aXe_M_ERROR</a>, __FILE__, __LINE__,
<a name="l00188"></a>00188                    <span class="stringliteral">&quot;Memory allocation failed&quot;</span>);
<a name="l00189"></a>00189   }
<a name="l00190"></a>00190 
<a name="l00191"></a>00191   <span class="keywordflow">for</span> (i=0;i&lt;numrows;i++) {
<a name="l00192"></a>00192     res-&gt;<a class="code" href="structspectrum.html#a12640df5c0e35a9a377291dd11022bcf">spec</a>[i].<a class="code" href="structspc__entry.html#afabeeb9b94d4d47d65ade75c6ff82adc">lambda_mean</a> = lambda[i];
<a name="l00193"></a>00193     res-&gt;<a class="code" href="structspectrum.html#a12640df5c0e35a9a377291dd11022bcf">spec</a>[i].<a class="code" href="structspc__entry.html#ab9baf671046970b64bc5e209815ef3ba">flux</a> = resp[i];
<a name="l00194"></a>00194     res-&gt;<a class="code" href="structspectrum.html#a12640df5c0e35a9a377291dd11022bcf">spec</a>[i].<a class="code" href="structspc__entry.html#a68d27286e09aa4efa3acc087b171c125">ferror</a> = error[i];
<a name="l00195"></a>00195   }
<a name="l00196"></a>00196 
<a name="l00197"></a>00197   res-&gt;<a class="code" href="structspectrum.html#a7f1df316451ab775f47013bc7c556f08">spec_len</a>=i;
<a name="l00198"></a>00198 
<a name="l00199"></a>00199   <span class="comment">// define the minimum and maximum wavelength</span>
<a name="l00200"></a>00200   res-&gt;<a class="code" href="structspectrum.html#a0c1fc08d8e906a2cf2309c7a88761fd6">lambdamin</a>=res-&gt;<a class="code" href="structspectrum.html#a12640df5c0e35a9a377291dd11022bcf">spec</a>[0].<a class="code" href="structspc__entry.html#afabeeb9b94d4d47d65ade75c6ff82adc">lambda_mean</a>;
<a name="l00201"></a>00201   res-&gt;<a class="code" href="structspectrum.html#af417db865af6ae56481377ad9b0f0eff">lambdamax</a>=res-&gt;<a class="code" href="structspectrum.html#a12640df5c0e35a9a377291dd11022bcf">spec</a>[numrows-1].<a class="code" href="structspc__entry.html#afabeeb9b94d4d47d65ade75c6ff82adc">lambda_mean</a>;
<a name="l00202"></a>00202 
<a name="l00203"></a>00203   <span class="comment">// check whether the wavelength is raising.</span>
<a name="l00204"></a>00204   <span class="comment">// switch minimum and maximum for falling spectrum</span>
<a name="l00205"></a>00205   <span class="keywordflow">if</span> (res-&gt;<a class="code" href="structspectrum.html#a0c1fc08d8e906a2cf2309c7a88761fd6">lambdamin</a> &gt; res-&gt;<a class="code" href="structspectrum.html#af417db865af6ae56481377ad9b0f0eff">lambdamax</a>)
<a name="l00206"></a>00206     {
<a name="l00207"></a>00207       tmp = res-&gt;<a class="code" href="structspectrum.html#a0c1fc08d8e906a2cf2309c7a88761fd6">lambdamin</a>;
<a name="l00208"></a>00208       res-&gt;<a class="code" href="structspectrum.html#a0c1fc08d8e906a2cf2309c7a88761fd6">lambdamin</a> = res-&gt;<a class="code" href="structspectrum.html#af417db865af6ae56481377ad9b0f0eff">lambdamax</a>;
<a name="l00209"></a>00209       res-&gt;<a class="code" href="structspectrum.html#af417db865af6ae56481377ad9b0f0eff">lambdamax</a> = tmp;
<a name="l00210"></a>00210     }
<a name="l00211"></a>00211 
<a name="l00212"></a>00212   fits_close_file(input,&amp;f_status);
<a name="l00213"></a>00213   <span class="keywordflow">if</span> (f_status) {
<a name="l00214"></a>00214       <a class="code" href="aXe__errors_8c.html#a7ef7588e5f91237ba7ce4084e6ed3c11">aXe_message</a> (<a class="code" href="aXe__errors_8h.html#ad247dca204a2964327532d0359b59ad8">aXe_M_ERROR</a>, __FILE__, __LINE__,
<a name="l00215"></a>00215                    <span class="stringliteral">&quot;Could not close %s&quot;</span>,filename);
<a name="l00216"></a>00216   }
<a name="l00217"></a>00217 
<a name="l00218"></a>00218   free(lambda);
<a name="l00219"></a>00219   free(resp);
<a name="l00220"></a>00220   free(error);
<a name="l00221"></a>00221 
<a name="l00222"></a>00222   <span class="keywordflow">return</span> res;
<a name="l00223"></a>00223 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a92c6c9b541b7b862a2b9903e3587a8a2"></a><!-- doxytag: member="spc_resp.c::get_response_value_plus" ref="a92c6c9b541b7b862a2b9903e3587a8a2" args="(const spectrum *resp, const double wavelength, int *nguess)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double get_response_value_plus </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structspectrum.html">spectrum</a> *&nbsp;</td>
          <td class="paramname"> <em>resp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>wavelength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>nguess</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Function: get_response_value_plus The function determines the sensitivity at a given wavelength in a sensitivity curve. A guess value helps to start searching around the estimated position of the wavelength in the vector of the sensitifity curve. This should considerably speed up the code. the guess value is updated in case that a sensitivity value could be determined. The return value is interpolated between the adjacent tabulated values.</p>
<p>Parameters: </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>resp</em>&nbsp;</td><td>- the sensitivity <a class="el" href="structspectrum.html">spectrum</a> </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>wavelength</em>&nbsp;</td><td>- the wavelength to determine the sensitivity for </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nguess</em>&nbsp;</td><td>- the guess value for the array to start searching from</td></tr>
  </table>
  </dd>
</dl>
<p>Returns: </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>ret - the sensitivity value at the input wavelength </dd></dl>

<p><div class="fragment"><pre class="fragment"><a name="l01027"></a>01027 {
<a name="l01028"></a>01028   <span class="keywordtype">double</span> ret;
<a name="l01029"></a>01029   <span class="keywordtype">double</span> factor;
<a name="l01030"></a>01030 
<a name="l01031"></a>01031   <span class="keywordtype">int</span> nact;
<a name="l01032"></a>01032 
<a name="l01033"></a>01033   <span class="comment">// check whether the wavelength is within the range of</span>
<a name="l01034"></a>01034   <span class="comment">//the sensitivity curve return GSL_NAN if not</span>
<a name="l01035"></a>01035   <span class="keywordflow">if</span> (wavelength &lt; resp-&gt;lambdamin || wavelength &gt; resp-&gt;<a class="code" href="structspectrum.html#af417db865af6ae56481377ad9b0f0eff">lambdamax</a>)
<a name="l01036"></a>01036     <span class="keywordflow">return</span> GSL_NAN;
<a name="l01037"></a>01037 
<a name="l01038"></a>01038   <span class="comment">// check whether you have to search upwards or downwards</span>
<a name="l01039"></a>01039   <span class="keywordflow">if</span> (wavelength &gt;= resp-&gt;<a class="code" href="structspectrum.html#a12640df5c0e35a9a377291dd11022bcf">spec</a>[*nguess].<a class="code" href="structspc__entry.html#afabeeb9b94d4d47d65ade75c6ff82adc">lambda_mean</a>)
<a name="l01040"></a>01040     {
<a name="l01041"></a>01041 
<a name="l01042"></a>01042       <span class="comment">// in case that you search upwards, go up</span>
<a name="l01043"></a>01043       <span class="comment">// the spectrum until you find the right interval</span>
<a name="l01044"></a>01044       nact = *nguess + 1;
<a name="l01045"></a>01045       <span class="keywordflow">while</span>(wavelength &gt; resp-&gt;<a class="code" href="structspectrum.html#a12640df5c0e35a9a377291dd11022bcf">spec</a>[nact].<a class="code" href="structspc__entry.html#afabeeb9b94d4d47d65ade75c6ff82adc">lambda_mean</a>)
<a name="l01046"></a>01046         nact++;
<a name="l01047"></a>01047     }
<a name="l01048"></a>01048   <span class="keywordflow">else</span>
<a name="l01049"></a>01049     {
<a name="l01050"></a>01050 
<a name="l01051"></a>01051       <span class="comment">// in case that you search upwards, go up</span>
<a name="l01052"></a>01052       <span class="comment">// the spectrum until you find the right interval</span>
<a name="l01053"></a>01053       nact = *nguess;
<a name="l01054"></a>01054       <span class="keywordflow">while</span>(wavelength &lt; resp-&gt;spec[nact-1].lambda_mean)
<a name="l01055"></a>01055         nact--;
<a name="l01056"></a>01056     }
<a name="l01057"></a>01057 
<a name="l01058"></a>01058   <span class="comment">// interpolate within the interval to calculate the</span>
<a name="l01059"></a>01059   <span class="comment">// sensitivity</span>
<a name="l01060"></a>01060   factor = (wavelength - resp-&gt;<a class="code" href="structspectrum.html#a12640df5c0e35a9a377291dd11022bcf">spec</a>[nact-1].<a class="code" href="structspc__entry.html#afabeeb9b94d4d47d65ade75c6ff82adc">lambda_mean</a>) /
<a name="l01061"></a>01061     (resp-&gt;<a class="code" href="structspectrum.html#a12640df5c0e35a9a377291dd11022bcf">spec</a>[nact].<a class="code" href="structspc__entry.html#afabeeb9b94d4d47d65ade75c6ff82adc">lambda_mean</a> - resp-&gt;<a class="code" href="structspectrum.html#a12640df5c0e35a9a377291dd11022bcf">spec</a>[nact-1].<a class="code" href="structspc__entry.html#afabeeb9b94d4d47d65ade75c6ff82adc">lambda_mean</a>);
<a name="l01062"></a>01062   ret = resp-&gt;<a class="code" href="structspectrum.html#a12640df5c0e35a9a377291dd11022bcf">spec</a>[nact-1].<a class="code" href="structspc__entry.html#ab9baf671046970b64bc5e209815ef3ba">flux</a> + factor * (resp-&gt;<a class="code" href="structspectrum.html#a12640df5c0e35a9a377291dd11022bcf">spec</a>[nact].<a class="code" href="structspc__entry.html#ab9baf671046970b64bc5e209815ef3ba">flux</a> - resp-&gt;<a class="code" href="structspectrum.html#a12640df5c0e35a9a377291dd11022bcf">spec</a>[nact-1].<a class="code" href="structspc__entry.html#ab9baf671046970b64bc5e209815ef3ba">flux</a>);
<a name="l01063"></a>01063 
<a name="l01064"></a>01064   <span class="comment">// update the guess value</span>
<a name="l01065"></a>01065   *nguess = nact;
<a name="l01066"></a>01066 
<a name="l01067"></a>01067   <span class="comment">// return the sensitivity value</span>
<a name="l01068"></a>01068   <span class="keywordflow">return</span> ret;
<a name="l01069"></a>01069 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a3e4ae40aa1401897ab1c66dffc99e0a4"></a><!-- doxytag: member="spc_resp.c::get_response_values" ref="a3e4ae40aa1401897ab1c66dffc99e0a4" args="(response_function *resp_func, double wavelength, double *resp_vals)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void get_response_values </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structresponse__function.html">response_function</a> *&nbsp;</td>
          <td class="paramname"> <em>resp_func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>wavelength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>resp_vals</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Function: get_response_values The function evaluates the response function at the desired independent value. The sensitivity and it error are returned in an array parameter.</p>
<p>Parameters: </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>resp_func</em>&nbsp;</td><td>- the response function </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>wavelength</em>&nbsp;</td><td>- the independent value </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>resp_vals</em>&nbsp;</td><td>- the dependent value and its error</td></tr>
  </table>
  </dd>
</dl>
<p>Returns: </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>- </dd></dl>

<p><div class="fragment"><pre class="fragment"><a name="l01087"></a>01087 {
<a name="l01088"></a>01088   <span class="comment">// check whether the independent value is outside the deifned range</span>
<a name="l01089"></a>01089   <span class="keywordflow">if</span> (wavelength &lt; resp_func-&gt;xmin || wavelength &gt; resp_func-&gt;<a class="code" href="structresponse__function.html#a5af3cf2a845502be139d4ecfb620c731">xmax</a>)
<a name="l01090"></a>01090     {
<a name="l01091"></a>01091       <span class="comment">// give the default</span>
<a name="l01092"></a>01092       <span class="comment">// outside values</span>
<a name="l01093"></a>01093       resp_vals[0] = 0.0;
<a name="l01094"></a>01094       resp_vals[1] = 0.0;
<a name="l01095"></a>01095     }
<a name="l01096"></a>01096   <span class="keywordflow">else</span>
<a name="l01097"></a>01097     {
<a name="l01098"></a>01098       <span class="comment">// get the response value and its error</span>
<a name="l01099"></a>01099       resp_vals[0] = <a class="code" href="fringe__conf_8c.html#ace9546cd2761b6436b8295f6ce94fba1">eval_interp</a>(resp_func-&gt;<a class="code" href="structresponse__function.html#a67e56fb3a2affd39926091ff4fd57d5a">resp_values</a>, wavelength);
<a name="l01100"></a>01100       resp_vals[1] = <a class="code" href="fringe__conf_8c.html#ace9546cd2761b6436b8295f6ce94fba1">eval_interp</a>(resp_func-&gt;<a class="code" href="structresponse__function.html#a4a8113d578a58810c2d396bd2ea31920">resp_errors</a>, wavelength);
<a name="l01101"></a>01101     }
<a name="l01102"></a>01102 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a157a1202bd6a233046e0bd6576bc61ca"></a><!-- doxytag: member="spc_resp.c::get_smooth_pars_for_beam" ref="a157a1202bd6a233046e0bd6576bc61ca" args="(const aperture_conf *conf, const int smooth_conv, beam actbeam)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structd__point.html">d_point</a> get_smooth_pars_for_beam </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structaperture__conf.html">aperture_conf</a> *&nbsp;</td>
          <td class="paramname"> <em>conf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>smooth_conv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbeam.html">beam</a>&nbsp;</td>
          <td class="paramname"> <em>actbeam</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Function: get_smooth_pars_for_beam The function determines the smoothing parameters for an <a class="el" href="structobject.html">object</a> <a class="el" href="structbeam.html">beam</a> and a given indicator. If smoothed calibration is requested, the source size (in dispersion direction) is compared to the poin-like <a class="el" href="structobject.html">object</a> size. For non poin-like objects, the adjustment factor is extracted and the smoothing size from the <a class="el" href="structobject.html">object</a> is derived.</p>
<p>Parameters: </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>conf</em>&nbsp;</td><td>- the configuarion file structure </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>smooth_conv</em>&nbsp;</td><td>- boolean for smooth conversion </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>actbeam</em>&nbsp;</td><td>- the <a class="el" href="structbeam.html">beam</a> to be calibrated</td></tr>
  </table>
  </dd>
</dl>
<p>Returns </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>smooth_pars - the paramters used in the smoothing </dd></dl>

<p><div class="fragment"><pre class="fragment"><a name="l00426"></a>00426   {
<a name="l00427"></a>00427     <a class="code" href="structd__point.html">d_point</a> smooth_pars;
<a name="l00428"></a>00428 
<a name="l00429"></a>00429     <span class="comment">// initialize the return</span>
<a name="l00430"></a>00430     smooth_pars.<a class="code" href="structd__point.html#a922a3b5d82a119168ba85e5f939d02c3">x</a> = -1.0;
<a name="l00431"></a>00431     smooth_pars.<a class="code" href="structd__point.html#ad9846a025508bf8873a501ca5fcefbf4">y</a> = -1.0;
<a name="l00432"></a>00432 
<a name="l00433"></a>00433     <span class="comment">// if there is nothing to</span>
<a name="l00434"></a>00434     <span class="comment">// do, return the default</span>
<a name="l00435"></a>00435     <span class="keywordflow">if</span> (!smooth_conv)
<a name="l00436"></a>00436       <span class="keywordflow">return</span> smooth_pars;
<a name="l00437"></a>00437 
<a name="l00438"></a>00438     <span class="comment">// check whether the relevant information</span>
<a name="l00439"></a>00439     <span class="comment">// does exist</span>
<a name="l00440"></a>00440     <span class="keywordflow">if</span> (smooth_conv &amp;&amp; actbeam.<a class="code" href="structbeam.html#acc5dfdc4ba4457869ecb2a9395d1273e">slitgeom</a>[2] &lt; 0.0)
<a name="l00441"></a>00441       <a class="code" href="aXe__errors_8c.html#a7ef7588e5f91237ba7ce4084e6ed3c11">aXe_message</a> (<a class="code" href="aXe__errors_8h.html#a2556a67874555249b07691c37aa6d6e9">aXe_M_FATAL</a>, __FILE__, __LINE__,
<a name="l00442"></a>00442           <span class="stringliteral">&quot;Smoothed flux conversion is impossible&quot;</span>
<a name="l00443"></a>00443           <span class="stringliteral">&quot; since the OAF\ndoes not contain the slit width!\n&quot;</span>);
<a name="l00444"></a>00444 
<a name="l00445"></a>00445     <span class="comment">//fprintf(stdout, &quot;smoothing factor: %f, point-like size: %f\n&quot;, conf-&gt;smfactor, conf-&gt;pobjsize);</span>
<a name="l00446"></a>00446     <span class="comment">// check whether the objects is smaller than a psf-object</span>
<a name="l00447"></a>00447     <span class="comment">// in dispersion direction</span>
<a name="l00448"></a>00448     <span class="keywordflow">if</span> (conf-&gt;<a class="code" href="structaperture__conf.html#a981e8e9f63a913f1ac34c864ec392024">pobjsize</a> &lt; actbeam.<a class="code" href="structbeam.html#acc5dfdc4ba4457869ecb2a9395d1273e">slitgeom</a>[2])
<a name="l00449"></a>00449       {
<a name="l00450"></a>00450         <span class="comment">// compute the smoothing size from the objects;</span>
<a name="l00451"></a>00451         <span class="comment">// transfer the adjustment factor</span>
<a name="l00452"></a>00452         smooth_pars.<a class="code" href="structd__point.html#a922a3b5d82a119168ba85e5f939d02c3">x</a> = pow((actbeam.<a class="code" href="structbeam.html#acc5dfdc4ba4457869ecb2a9395d1273e">slitgeom</a>[2]* actbeam.<a class="code" href="structbeam.html#acc5dfdc4ba4457869ecb2a9395d1273e">slitgeom</a>[2]) - (conf-&gt;<a class="code" href="structaperture__conf.html#a981e8e9f63a913f1ac34c864ec392024">pobjsize</a>*conf-&gt;<a class="code" href="structaperture__conf.html#a981e8e9f63a913f1ac34c864ec392024">pobjsize</a>), 0.5);
<a name="l00453"></a>00453         smooth_pars.<a class="code" href="structd__point.html#ad9846a025508bf8873a501ca5fcefbf4">y</a> = conf-&gt;<a class="code" href="structaperture__conf.html#aca74009eb7d64af0ba7222e9dbb879c1">smfactor</a>;
<a name="l00454"></a>00454       }
<a name="l00455"></a>00455 
<a name="l00456"></a>00456     <span class="comment">// return the</span>
<a name="l00457"></a>00457     <span class="comment">// smoothing parameters</span>
<a name="l00458"></a>00458     <span class="keywordflow">return</span> smooth_pars;
<a name="l00459"></a>00459   }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a1fd4f613775df35ada9d78832a1c0906"></a><!-- doxytag: member="spc_resp.c::get_smoothed_response" ref="a1fd4f613775df35ada9d78832a1c0906" args="(const double wavelength, const d_point smooth_pars, const calib_function *wl_calibration, const int for_grism, const gsl_vector *weights, response_function *resp_func, double *resp_vals)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void get_smoothed_response </td>
          <td>(</td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>wavelength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structd__point.html">d_point</a>&nbsp;</td>
          <td class="paramname"> <em>smooth_pars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcalib__function.html">calib_function</a> *&nbsp;</td>
          <td class="paramname"> <em>wl_calibration</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>for_grism</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const gsl_vector *&nbsp;</td>
          <td class="paramname"> <em>weights</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structresponse__function.html">response_function</a> *&nbsp;</td>
          <td class="paramname"> <em>resp_func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>resp_vals</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Function: get_smoothed_response The function determine a smoothe sensitivity value and its error. Gaussian smoothing is applied, but the Gaussian weights are delivered as a function paramter (for perfomrance reasons). The function detemines the response values over the weight window and then combines these values with the weights to get one weighted sensitivity value at the desired wavelength.</p>
<p>Parameters: </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>wavelength</em>&nbsp;</td><td>- the central wavelength </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>smooth_pars</em>&nbsp;</td><td>- the smoothing parameters </td></tr>
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="structcalib__function.html">calib_function</a></em>&nbsp;</td><td>- the wavelength calibration function </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>for_grism</em>&nbsp;</td><td>- boolean to indicate grism/prism solution </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>weights</em>&nbsp;</td><td>- the weight vector </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>resp_func</em>&nbsp;</td><td>- the response function </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>resp_vals</em>&nbsp;</td><td>- vector for the response values</td></tr>
  </table>
  </dd>
</dl>
<p>Returns </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>- </dd></dl>

<p><div class="fragment"><pre class="fragment"><a name="l00782"></a>00782 {
<a name="l00783"></a>00783   <span class="keywordtype">int</span> j;
<a name="l00784"></a>00784 
<a name="l00785"></a>00785   <span class="keywordtype">double</span> tl_incr;
<a name="l00786"></a>00786   <span class="keywordtype">double</span> tl_act;
<a name="l00787"></a>00787   <span class="keywordtype">double</span> tl_central;
<a name="l00788"></a>00788   <span class="keywordtype">double</span> lambda_act;
<a name="l00789"></a>00789 
<a name="l00790"></a>00790   gsl_vector *pixvalues;
<a name="l00791"></a>00791   gsl_vector *errvalues;
<a name="l00792"></a>00792   gsl_vector *pmask;
<a name="l00793"></a>00793 
<a name="l00794"></a>00794   <span class="keywordtype">double</span> *tmp_vals = malloc( 2 * <span class="keyword">sizeof</span>(<span class="keywordtype">double</span>));
<a name="l00795"></a>00795 
<a name="l00796"></a>00796   <span class="comment">// allocate memory for the vectors</span>
<a name="l00797"></a>00797   pixvalues = gsl_vector_alloc(2 * <a class="code" href="spc__resp_8h.html#aa72ff6f8d89621381bba997b34673399">RESP_SMOOTH_LENGTH</a> + 1);
<a name="l00798"></a>00798   errvalues = gsl_vector_alloc(2 * <a class="code" href="spc__resp_8h.html#aa72ff6f8d89621381bba997b34673399">RESP_SMOOTH_LENGTH</a> + 1);
<a name="l00799"></a>00799   pmask     = gsl_vector_alloc(2 * <a class="code" href="spc__resp_8h.html#aa72ff6f8d89621381bba997b34673399">RESP_SMOOTH_LENGTH</a> + 1);
<a name="l00800"></a>00800 
<a name="l00801"></a>00801   <span class="comment">// set all mask points to zero</span>
<a name="l00802"></a>00802   gsl_vector_set_all(pmask, 0.0);
<a name="l00803"></a>00803 
<a name="l00804"></a>00804   <span class="comment">// determine the tracelength value</span>
<a name="l00805"></a>00805   tl_central = <a class="code" href="spc__resp_8c.html#ab84a3c4ebe3efacf7c89a6833225eb9a">get_central_tracelength</a>(wavelength, wl_calibration, for_grism);
<a name="l00806"></a>00806 
<a name="l00807"></a>00807   <span class="comment">// determine the wavelength increments</span>
<a name="l00808"></a>00808   <span class="comment">//wav_incr = (double)RESP_SMOOTH_NSIG * sigma_wav / (double)RESP_SMOOTH_LENGTH;</span>
<a name="l00809"></a>00809   tl_incr = smooth_pars.<a class="code" href="structd__point.html#a922a3b5d82a119168ba85e5f939d02c3">x</a> * smooth_pars.<a class="code" href="structd__point.html#ad9846a025508bf8873a501ca5fcefbf4">y</a> * (double)<a class="code" href="spc__resp_8h.html#a099bf5a5a124fe8705039105a8b79e83">RESP_SMOOTH_NSIG</a> / (<span class="keywordtype">double</span>)<a class="code" href="spc__resp_8h.html#aa72ff6f8d89621381bba997b34673399">RESP_SMOOTH_LENGTH</a>;
<a name="l00810"></a>00810 
<a name="l00811"></a>00811   <span class="comment">// set the initial wavelength value</span>
<a name="l00812"></a>00812   <span class="comment">//value = wavelength - sigma_wav * (double)RESP_SMOOTH_NSIG;</span>
<a name="l00813"></a>00813   tl_act = tl_central - 1.0 * smooth_pars.<a class="code" href="structd__point.html#a922a3b5d82a119168ba85e5f939d02c3">x</a> * smooth_pars.<a class="code" href="structd__point.html#ad9846a025508bf8873a501ca5fcefbf4">y</a> * (double)<a class="code" href="spc__resp_8h.html#a099bf5a5a124fe8705039105a8b79e83">RESP_SMOOTH_NSIG</a>;
<a name="l00814"></a>00814 
<a name="l00815"></a>00815   <span class="comment">// print the starting and central wavelength</span>
<a name="l00816"></a>00816   <span class="comment">//fprintf(stdout, &quot; %.5g &lt; %.5g&quot;,</span>
<a name="l00817"></a>00817   <span class="comment">//    wl_calibration-&gt;func(tl_act, wl_calibration-&gt;order, wl_calibration-&gt;coeffs),</span>
<a name="l00818"></a>00818   <span class="comment">//    wl_calibration-&gt;func(tl_central, wl_calibration-&gt;order, wl_calibration-&gt;coeffs));</span>
<a name="l00819"></a>00819 
<a name="l00820"></a>00820   <span class="comment">// go over the array</span>
<a name="l00821"></a>00821   <span class="keywordflow">for</span> (j=0; j &lt; pixvalues-&gt;size; j++)
<a name="l00822"></a>00822     {
<a name="l00823"></a>00823       <span class="comment">// determine the wavelength value</span>
<a name="l00824"></a>00824       lambda_act = wl_calibration-&gt;<a class="code" href="structcalib__function.html#af3b6ef00cf4dfcfc75e8f129c555d99f">func</a>(tl_act, wl_calibration-&gt;<a class="code" href="structcalib__function.html#a0c2f4bb6aac5dbd2ce276ed8bee280da">order</a>, wl_calibration-&gt;<a class="code" href="structcalib__function.html#af6161163d6abff34648d027533dbc89e">coeffs</a>);
<a name="l00825"></a>00825 
<a name="l00826"></a>00826       <span class="comment">// check whether the actual wavelength is inside</span>
<a name="l00827"></a>00827       <span class="comment">// the defined sensitivity interval</span>
<a name="l00828"></a>00828       <span class="keywordflow">if</span>  (lambda_act &lt; resp_func-&gt;xmin || lambda_act &gt; resp_func-&gt;<a class="code" href="structresponse__function.html#a5af3cf2a845502be139d4ecfb620c731">xmax</a>)
<a name="l00829"></a>00829         {
<a name="l00830"></a>00830           <span class="comment">// for outside values:</span>
<a name="l00831"></a>00831           <span class="comment">// set everything to zero</span>
<a name="l00832"></a>00832           gsl_vector_set(pixvalues, j, 0.0);
<a name="l00833"></a>00833           gsl_vector_set(errvalues, j, 0.0);
<a name="l00834"></a>00834           gsl_vector_set(pmask, j, 0.0);
<a name="l00835"></a>00835         }
<a name="l00836"></a>00836       <span class="keywordflow">else</span>
<a name="l00837"></a>00837         {
<a name="l00838"></a>00838           <span class="comment">// for inside values:</span>
<a name="l00839"></a>00839           <span class="comment">// compute and set the response</span>
<a name="l00840"></a>00840           <a class="code" href="spc__resp_8c.html#a3e4ae40aa1401897ab1c66dffc99e0a4">get_response_values</a>(resp_func, lambda_act, tmp_vals);
<a name="l00841"></a>00841           gsl_vector_set(pixvalues, j, tmp_vals[0]);
<a name="l00842"></a>00842           gsl_vector_set(errvalues, j, tmp_vals[1]);
<a name="l00843"></a>00843           gsl_vector_set(pmask, j, 1.0);
<a name="l00844"></a>00844         }
<a name="l00845"></a>00845 
<a name="l00846"></a>00846       <span class="comment">// increment trace length</span>
<a name="l00847"></a>00847       tl_act += tl_incr;
<a name="l00848"></a>00848     }
<a name="l00849"></a>00849   <span class="comment">// print the ending wavelength</span>
<a name="l00850"></a>00850   <span class="comment">//fprintf(stdout, &quot; &gt; %.5g;&quot;, wl_calibration-&gt;func(tl_act, wl_calibration-&gt;order, wl_calibration-&gt;coeffs));</span>
<a name="l00851"></a>00851 
<a name="l00852"></a>00852   <span class="comment">// get the weighted response values</span>
<a name="l00853"></a>00853   <a class="code" href="spc__resp_8c.html#a63e4d5535bbccf8346f35ed139018440">get_weighted_sensitivity</a>(pixvalues, errvalues, weights, pmask, resp_vals);
<a name="l00854"></a>00854 
<a name="l00855"></a>00855   <span class="comment">// free the memory</span>
<a name="l00856"></a>00856   free(tmp_vals);
<a name="l00857"></a>00857   gsl_vector_free(pixvalues);
<a name="l00858"></a>00858   gsl_vector_free(errvalues);
<a name="l00859"></a>00859   gsl_vector_free(pmask);
<a name="l00860"></a>00860 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a8cc19f5af89c3055fc5b37110687a58d"></a><!-- doxytag: member="spc_resp.c::get_tlength_prismwav" ref="a8cc19f5af89c3055fc5b37110687a58d" args="(const double wavelength, const calib_function *wl_calibration)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double get_tlength_prismwav </td>
          <td>(</td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>wavelength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcalib__function.html">calib_function</a> *&nbsp;</td>
          <td class="paramname"> <em>wl_calibration</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Function: get_tlength_prismwav The function determines the tracelength value for a given wavelength value and dispersion function. Should be called only for a prism dispersion. The gsl root solver is used.</p>
<p>Parameters: </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>wavelength</em>&nbsp;</td><td>- the wavelength value </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>wl_calibration</em>&nbsp;</td><td>- the dispersion solution</td></tr>
  </table>
  </dd>
</dl>
<p>Returns </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>wav_zero - difference between actual and targeted wavelength </dd></dl>

<p><div class="fragment"><pre class="fragment"><a name="l00627"></a>00627 {
<a name="l00628"></a>00628   <span class="keywordtype">int</span> iter=0;
<a name="l00629"></a>00629   <span class="keywordtype">int</span> status;
<a name="l00630"></a>00630 
<a name="l00631"></a>00631   <a class="code" href="structd__point.html">d_point</a> x_interv;
<a name="l00632"></a>00632 
<a name="l00633"></a>00633   <span class="keywordtype">double</span> tr_length=0.0;
<a name="l00634"></a>00634 
<a name="l00635"></a>00635 
<a name="l00636"></a>00636   <span class="comment">// define and initialize the solver</span>
<a name="l00637"></a>00637   <span class="keyword">const</span> gsl_root_fsolver_type *T = gsl_root_fsolver_brent;
<a name="l00638"></a>00638   gsl_root_fsolver            *s = gsl_root_fsolver_alloc (T);
<a name="l00639"></a>00639 
<a name="l00640"></a>00640   gsl_function F;
<a name="l00641"></a>00641   <a class="code" href="structtrlength__search.html">trlength_search</a> *tr_pars;
<a name="l00642"></a>00642 
<a name="l00643"></a>00643   <span class="comment">// allocate and fill the parameters</span>
<a name="l00644"></a>00644   tr_pars = (<a class="code" href="structtrlength__search.html">trlength_search</a> *) malloc(<span class="keyword">sizeof</span>(<a class="code" href="structtrlength__search.html">trlength_search</a>));
<a name="l00645"></a>00645   tr_pars-&gt;<a class="code" href="structtrlength__search.html#a970eb5524953dfc84f84db744ed64c35">wl_calibration</a> = wl_calibration;
<a name="l00646"></a>00646   tr_pars-&gt;<a class="code" href="structtrlength__search.html#a745f8eade655538209b55f0aa6c68f91">wavelength</a>     = wavelength;
<a name="l00647"></a>00647 
<a name="l00648"></a>00648   <span class="comment">// fille the GSL-function</span>
<a name="l00649"></a>00649   F.function = &amp;<a class="code" href="spc__resp_8c.html#a801a7c3ef4ee95658274156c6910a1cb">find_wavelength</a>;
<a name="l00650"></a>00650   F.params =   tr_pars;
<a name="l00651"></a>00651 
<a name="l00652"></a>00652   <span class="comment">// initialize the intervall variable</span>
<a name="l00653"></a>00653   x_interv.<a class="code" href="structd__point.html#a922a3b5d82a119168ba85e5f939d02c3">x</a> = gsl_vector_get(wl_calibration-&gt;<a class="code" href="structcalib__function.html#a585ddafa8bb9e1ac0b7a3da3410b5f80">pr_range</a>, 0) + wl_calibration-&gt;<a class="code" href="structcalib__function.html#af6161163d6abff34648d027533dbc89e">coeffs</a>[0];
<a name="l00654"></a>00654   x_interv.<a class="code" href="structd__point.html#ad9846a025508bf8873a501ca5fcefbf4">y</a> = gsl_vector_get(wl_calibration-&gt;<a class="code" href="structcalib__function.html#a585ddafa8bb9e1ac0b7a3da3410b5f80">pr_range</a>, 1) + wl_calibration-&gt;<a class="code" href="structcalib__function.html#af6161163d6abff34648d027533dbc89e">coeffs</a>[0];
<a name="l00655"></a>00655 
<a name="l00656"></a>00656   <span class="comment">// set the boundaries for the solver</span>
<a name="l00657"></a>00657   gsl_root_fsolver_set (s, &amp;F, x_interv.<a class="code" href="structd__point.html#a922a3b5d82a119168ba85e5f939d02c3">x</a>, x_interv.<a class="code" href="structd__point.html#ad9846a025508bf8873a501ca5fcefbf4">y</a>);
<a name="l00658"></a>00658 
<a name="l00659"></a>00659   <span class="comment">// iterate to find the zeropoint</span>
<a name="l00660"></a>00660   <span class="keywordflow">do</span>
<a name="l00661"></a>00661     {
<a name="l00662"></a>00662       <span class="comment">// increment the iteration counter</span>
<a name="l00663"></a>00663       iter++;
<a name="l00664"></a>00664 
<a name="l00665"></a>00665       <span class="comment">// iterate on the solver</span>
<a name="l00666"></a>00666       status = gsl_root_fsolver_iterate (s);
<a name="l00667"></a>00667 
<a name="l00668"></a>00668       <span class="comment">// get a new guess from the solver</span>
<a name="l00669"></a>00669       tr_length = gsl_root_fsolver_root (s);
<a name="l00670"></a>00670 
<a name="l00671"></a>00671       <span class="comment">// derive and set new boundaries</span>
<a name="l00672"></a>00672       x_interv.<a class="code" href="structd__point.html#a922a3b5d82a119168ba85e5f939d02c3">x</a> = gsl_root_fsolver_x_lower (s);
<a name="l00673"></a>00673       x_interv.<a class="code" href="structd__point.html#ad9846a025508bf8873a501ca5fcefbf4">y</a> = gsl_root_fsolver_x_upper (s);
<a name="l00674"></a>00674 
<a name="l00675"></a>00675       <span class="comment">// check the accuracy</span>
<a name="l00676"></a>00676       status = gsl_root_test_interval (x_interv.<a class="code" href="structd__point.html#a922a3b5d82a119168ba85e5f939d02c3">x</a>, x_interv.<a class="code" href="structd__point.html#ad9846a025508bf8873a501ca5fcefbf4">y</a>,
<a name="l00677"></a>00677                                        0, 0.0001);
<a name="l00678"></a>00678     }
<a name="l00679"></a>00679   <span class="comment">// check for the break condition</span>
<a name="l00680"></a>00680   <span class="keywordflow">while</span> (status == GSL_CONTINUE &amp;&amp; iter &lt; <a class="code" href="spc__resp_8h.html#aa94b4f63b483d88c0f30c4c6aaba3c48">MAX_ITER_TL</a>);
<a name="l00681"></a>00681 
<a name="l00682"></a>00682   <span class="comment">// free the memory</span>
<a name="l00683"></a>00683   free(tr_pars);
<a name="l00684"></a>00684 
<a name="l00685"></a>00685   <span class="comment">// free the memory</span>
<a name="l00686"></a>00686   gsl_root_fsolver_free (s);
<a name="l00687"></a>00687 
<a name="l00688"></a>00688   <span class="comment">// return the result</span>
<a name="l00689"></a>00689   <span class="keywordflow">return</span> tr_length;
<a name="l00690"></a>00690 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="add20ced757ce2623320cfa20db81e4ac"></a><!-- doxytag: member="spc_resp.c::get_troughput_table_name" ref="add20ced757ce2623320cfa20db81e4ac" args="(char *filename, int beamID, char *table_name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void get_troughput_table_name </td>
          <td>(</td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>beamID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>table_name</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Function: get_troughput_table_name Parses a configuration file and get the name of the SENSITIVITY curve defined for a wanted beamID</p>
<p>Parameters: </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>filename</em>&nbsp;</td><td>- a pointer to a string containing the name of the configuration file </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>beamID</em>&nbsp;</td><td>- the <a class="el" href="structbeam.html">beam</a> ID number (see <a class="el" href="aXe__grism_8h.html#a7d90dabb6016bb0e09b6ab84087b70a7">BEAM()</a>) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>table_name</em>&nbsp;</td><td>- a pointer pointing to a string to contain the name of the file.</td></tr>
  </table>
  </dd>
</dl>
<p>Returns: </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>- </dd></dl>

<p><div class="fragment"><pre class="fragment"><a name="l00976"></a>00976 {
<a name="l00977"></a>00977   <span class="keywordtype">char</span> <a class="code" href="structbeam.html">beam</a>[<a class="code" href="aXe__grism_8h.html#ac1535592e39e7edf0cafbd5e695ea622">MAXCHAR</a>];
<a name="l00978"></a>00978   <span class="keywordtype">char</span> <a class="code" href="structCfgStrings.html#ae242595a7e81b71aa7778196fad8c08a">name</a>[<a class="code" href="aXe__grism_8h.html#ac1535592e39e7edf0cafbd5e695ea622">MAXCHAR</a>];
<a name="l00979"></a>00979   <span class="keywordtype">int</span> i=0;
<a name="l00980"></a>00980 
<a name="l00981"></a>00981   <span class="keyword">struct </span><a class="code" href="structCfgStrings.html">CfgStrings</a> ThrConfig[] = {
<a name="l00982"></a>00982     {NULL, NULL},
<a name="l00983"></a>00983     {NULL,NULL}
<a name="l00984"></a>00984   };
<a name="l00985"></a>00985   ThrConfig[0].<a class="code" href="structCfgStrings.html#ae242595a7e81b71aa7778196fad8c08a">name</a> = beam;
<a name="l00986"></a>00986   sprintf (beam, <span class="stringliteral">&quot;SENSITIVITY_%c&quot;</span>, <a class="code" href="aXe__grism_8h.html#a7d90dabb6016bb0e09b6ab84087b70a7">BEAM</a>(beamID));
<a name="l00987"></a>00987 
<a name="l00988"></a>00988   <a class="code" href="spc__cfg_8c.html#a5c6339a8a6dee72ee5aa6ef36833abe7">CfgRead</a> (filename, ThrConfig);
<a name="l00989"></a>00989   <span class="keywordflow">if</span> ((ThrConfig[0].name == beam) &amp;&amp; (ThrConfig[0].<a class="code" href="structCfgStrings.html#ab4ed123e084f001ff0dadb43979d8837">data</a> != NULL))
<a name="l00990"></a>00990     {
<a name="l00991"></a>00991       strcpy(name,ThrConfig[0].<a class="code" href="structCfgStrings.html#ab4ed123e084f001ff0dadb43979d8837">data</a>);
<a name="l00992"></a>00992     } <span class="keywordflow">else</span> {
<a name="l00993"></a>00993       <a class="code" href="aXe__errors_8c.html#a7ef7588e5f91237ba7ce4084e6ed3c11">aXe_message</a> (<a class="code" href="aXe__errors_8h.html#a2556a67874555249b07691c37aa6d6e9">aXe_M_FATAL</a>, __FILE__, __LINE__,
<a name="l00994"></a>00994                    <span class="stringliteral">&quot;get_throughput_table_name: %s was not found in &quot;</span>
<a name="l00995"></a>00995                    <span class="stringliteral">&quot;%s&quot;</span>,beam,filename);
<a name="l00996"></a>00996     }
<a name="l00997"></a>00997 
<a name="l00998"></a>00998   <span class="comment">// release memory</span>
<a name="l00999"></a>00999   i=0;
<a name="l01000"></a>01000   <span class="keywordflow">while</span>(ThrConfig[i].name!=NULL)
<a name="l01001"></a>01001     free(ThrConfig[i++].<a class="code" href="structCfgStrings.html#ab4ed123e084f001ff0dadb43979d8837">data</a>);
<a name="l01002"></a>01002 
<a name="l01003"></a>01003   strcpy(table_name,name);
<a name="l01004"></a>01004 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a63e4d5535bbccf8346f35ed139018440"></a><!-- doxytag: member="spc_resp.c::get_weighted_sensitivity" ref="a63e4d5535bbccf8346f35ed139018440" args="(const gsl_vector *pixvalues, const gsl_vector *errvalues, const gsl_vector *weights, const gsl_vector *pmask, double *resp_vals)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void get_weighted_sensitivity </td>
          <td>(</td>
          <td class="paramtype">const gsl_vector *&nbsp;</td>
          <td class="paramname"> <em>pixvalues</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const gsl_vector *&nbsp;</td>
          <td class="paramname"> <em>errvalues</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const gsl_vector *&nbsp;</td>
          <td class="paramname"> <em>weights</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const gsl_vector *&nbsp;</td>
          <td class="paramname"> <em>pmask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>resp_vals</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Function: get_weighted_sensitivity Combines the weihg values, the sensitivity and error at the weight point to a single sensitivity value plus error. A mask array defines at which points values do exist.</p>
<p>Parameters: </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pixvalues</em>&nbsp;</td><td>- the central wavelength </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>errvalues</em>&nbsp;</td><td>- the Gaussian sigma used in smoothing </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>weights</em>&nbsp;</td><td>- the weight vector </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pmask</em>&nbsp;</td><td>- the response function </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>resp_vals</em>&nbsp;</td><td>- vector for the response values</td></tr>
  </table>
  </dd>
</dl>
<p>Returns </p>
<dl class="return"><dt><b>Returns:</b></dt><dd></dd></dl>

<p><div class="fragment"><pre class="fragment"><a name="l00881"></a>00881 {
<a name="l00882"></a>00882   <span class="keywordtype">int</span> index;
<a name="l00883"></a>00883 
<a name="l00884"></a>00884   <span class="comment">// initialize the total</span>
<a name="l00885"></a>00885   <span class="comment">// sum and weight</span>
<a name="l00886"></a>00886   <span class="keywordtype">double</span> val_sum = 0.0;
<a name="l00887"></a>00887   <span class="keywordtype">double</span> err_sum = 0.0;
<a name="l00888"></a>00888   <span class="keywordtype">double</span> www=0.0;
<a name="l00889"></a>00889 
<a name="l00890"></a>00890   <span class="comment">// go over all indices of an array</span>
<a name="l00891"></a>00891   <span class="keywordflow">for</span> (index=0; index &lt; pixvalues-&gt;size; index ++)
<a name="l00892"></a>00892     {
<a name="l00893"></a>00893       <span class="comment">// check whether the index is masked</span>
<a name="l00894"></a>00894       <span class="keywordflow">if</span> (gsl_vector_get(pmask, index) != 0.0)
<a name="l00895"></a>00895         {
<a name="l00896"></a>00896           <span class="comment">// enhance the total sum</span>
<a name="l00897"></a>00897           val_sum += gsl_vector_get(pixvalues, index) * gsl_vector_get(weights, index);
<a name="l00898"></a>00898           err_sum += gsl_vector_get(errvalues, index) * gsl_vector_get(errvalues, index)
<a name="l00899"></a>00899             * gsl_vector_get(weights, index) * gsl_vector_get(weights, index);
<a name="l00900"></a>00900 
<a name="l00901"></a>00901           <span class="comment">// enhance the total weight</span>
<a name="l00902"></a>00902           www += gsl_vector_get(weights, index);
<a name="l00903"></a>00903         }
<a name="l00904"></a>00904     }
<a name="l00905"></a>00905 
<a name="l00906"></a>00906   <span class="comment">// check whether there</span>
<a name="l00907"></a>00907   <span class="comment">// were weights at all</span>
<a name="l00908"></a>00908   <span class="keywordflow">if</span> (www)
<a name="l00909"></a>00909     {
<a name="l00910"></a>00910       <span class="comment">// return the total sum,</span>
<a name="l00911"></a>00911       <span class="comment">// divided by the total weight</span>
<a name="l00912"></a>00912       resp_vals[0] =  val_sum / www;
<a name="l00913"></a>00913       resp_vals[1] =  sqrt(err_sum) / www;
<a name="l00914"></a>00914     }
<a name="l00915"></a>00915   <span class="keywordflow">else</span>
<a name="l00916"></a>00916     {
<a name="l00917"></a>00917       <span class="comment">// set zero sensitivity</span>
<a name="l00918"></a>00918       resp_vals[0] = 0.0;
<a name="l00919"></a>00919       resp_vals[1] = 0.0;
<a name="l00920"></a>00920     }
<a name="l00921"></a>00921 }
</pre></div></p>

</div>
</div>
</div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&nbsp;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&nbsp;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&nbsp;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&nbsp;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&nbsp;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&nbsp;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&nbsp;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&nbsp;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&nbsp;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&nbsp;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr size="1"/><address style="text-align: right;"><small>Generated on 12 Oct 2014 for TIPS by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.1 </small></address>
</body>
</html>
