<!-- This comment will put IE 6, 7 and 8 in quirks mode -->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>TIPS: /renoir/fourmano/Desktop/OUSIM/TIPS/branches/tips_build/src/axesim/spc_back.c File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.6.1 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <img id="MSearchSelect" src="search/search.png"
             onmouseover="return searchBox.OnSearchSelectShow()"
             onmouseout="return searchBox.OnSearchSelectHide()"
             alt=""/>
        <input type="text" id="MSearchField" value="Search" accesskey="S"
             onfocus="searchBox.OnSearchFieldFocus(true)" 
             onblur="searchBox.OnSearchFieldFocus(false)" 
             onkeyup="searchBox.OnSearchFieldChange(event)"/>
        <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
        </div>
      </li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>/renoir/fourmano/Desktop/OUSIM/TIPS/branches/tips_build/src/axesim/spc_back.c File Reference</h1><code>#include &lt;stdio.h&gt;</code><br/>
<code>#include &lt;stdlib.h&gt;</code><br/>
<code>#include &lt;string.h&gt;</code><br/>
<code>#include &lt;math.h&gt;</code><br/>
<code>#include &lt;limits.h&gt;</code><br/>
<code>#include &lt;unistd.h&gt;</code><br/>
<code>#include &lt;gsl/gsl_vector.h&gt;</code><br/>
<code>#include &lt;gsl/gsl_sort_vector.h&gt;</code><br/>
<code>#include &lt;gsl/gsl_statistics.h&gt;</code><br/>
<code>#include &lt;gsl/gsl_fit.h&gt;</code><br/>
<code>#include &lt;gsl/gsl_multifit.h&gt;</code><br/>
<code>#include &lt;gsl/gsl_sort_double.h&gt;</code><br/>
<code>#include &lt;fitsio.h&gt;</code><br/>
<code>#include &quot;<a class="el" href="aXe__grism_8h_source.html">aXe_grism.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="aXe__utils_8h_source.html">aXe_utils.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="spce__sect_8h_source.html">spce_sect.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="spce__fitting_8h_source.html">spce_fitting.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="spce__is__in_8h_source.html">spce_is_in.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="spc__back_8h_source.html">spc_back.h</a>&quot;</code><br/>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Namespaces</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacespc__back.html">spc_back</a></td></tr>
<tr><td colspan="2"><h2>Defines</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="spc__back_8c.html#aa7866fa5e4e0ee9b034e9dab6599a9cc">SQR</a>(x)&nbsp;&nbsp;&nbsp;((x)*(x))</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="spc__back_8c.html#a74e75242132eaabbc1c512488a135926">MIN</a>(x, y)&nbsp;&nbsp;&nbsp;(((x)&lt;(y))?(x):(y))</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="spc__back_8c.html#aacc3ee1a7f283f8ef65cea31f4436a95">MAX</a>(x, y)&nbsp;&nbsp;&nbsp;(((x)&gt;(y))?(x):(y))</td></tr>
<tr><td colspan="2"><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="spc__back_8c.html#ac1c2518944b7c7dbaa14041f46c07187">is_pt_in_a_beam</a> (const <a class="el" href="structpx__point.html">px_point</a> *const apoint, const <a class="el" href="structis__in__descriptor.html">is_in_descriptor</a> *const iids, const int tnbeams)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">gsl_vector_int *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="spc__back_8c.html#a55bae5da45fa33dec8efc0f57981f1e4">get_interp_points</a> (<a class="el" href="structobservation.html">observation</a> *obs, gsl_matrix *bck_mask, int np, <a class="el" href="structpx__point.html">px_point</a> tr_point)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="spc__back_8c.html#ad45826f8c0ede1b55ed2f5d6fd67e875">compute_background</a> (<a class="el" href="structobservation.html">observation</a> *obs, <a class="el" href="structbeam.html">beam</a> actbeam, gsl_matrix *bck_mask, <a class="el" href="structfullimg__background.html">fullimg_background</a> *fib, int npoints, int interporder, const int niter_med, const int niter_fit, const double kappa)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structpx__point.html">px_point</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="spc__back_8c.html#ad7c9963cb80da0010581906c46dde765">get_xrange</a> (<a class="el" href="structobservation.html">observation</a> *obs, <a class="el" href="structbeam.html">beam</a> actbeam)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="spc__back_8c.html#a135c17132984f8af8cf6d4f13ee9dbb7">comp_kappasigma_interp</a> (const double *const xs, double *const ys, double *const ws, const int n, const int interp, const int niter, const double kappa, <a class="el" href="structobservation.html">observation</a> *obs, int colnum)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="spc__back_8c.html#afe2e18a7ee7b967b8d71d7e1fb316ea7">kappa_sigma_clipp</a> (const double *const xs, double *const ys, double *const ws, const int n, const double kappa, <a class="el" href="structobservation.html">observation</a> *obs, int colnum)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="spc__back_8c.html#a17d5c8763243b26091aceb119ac98557">comp_vector_interp</a> (const double *const xs, double *const ys, double *const ws, double *const yi, const int n, const int interp, const int final)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="spc__back_8c.html#ac5915dcfa3d4bd357a95fcd4f827c3a1">compute_global_background</a> (<a class="el" href="structobject.html">object</a> **oblist, const int obj_index, gsl_matrix *bck_mask, <a class="el" href="structfullimg__background.html">fullimg_background</a> *fib, int interporder)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="spc__back_8c.html#a312989afed586d6646f6c5e46d94c5b2">fullimg_background_function</a> (const int x, const int y, PIXEL_T *const val, PIXEL_T *const err, const <a class="el" href="structs__background.html">background</a> *const back)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structs__background.html">background</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="spc__back_8c.html#ac8525170561017c1ebf7946f1e37b57b">compute_fullimg_background</a> (<a class="el" href="structobservation.html">observation</a> *obs, <a class="el" href="structobject.html">object</a> **oblist, int npoints, int interporder, const int niter_med, const int niter_fit, const double kappa, int nor_flag, const int sm_length, const double fwhm)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structs__background.html">background</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="spc__back_8c.html#ae8622f5f1124511fcbc7ddf2205d4e0f">compute_backsub_mask</a> (<a class="el" href="structobservation.html">observation</a> *obs, <a class="el" href="structobject.html">object</a> **oblist)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structs__background.html">background</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="spc__back_8c.html#af64d42951a54cd249fcbb6f793096acd">compute_fullimg_global_background</a> (<a class="el" href="structobservation.html">observation</a> *obs, <a class="el" href="structobject.html">object</a> **oblist, int interporder, const int sm_length, const double fwhm)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="spc__back_8c.html#a88d31193027d2eaefacbc2bc1bb7f6d1">free_fullimg_background</a> (<a class="el" href="structs__background.html">background</a> *backg)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">gsl_matrix *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="spc__back_8c.html#a84505bc11501c5f2abc6c1f45d68e79b">aperture_mask</a> (<a class="el" href="structobservation.html">observation</a> *const obs, <a class="el" href="structobject.html">object</a> **oblist)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="spc__back_8c.html#a5244945f780b5c1e41997c970df2ee49">background_to_FITSimage</a> (char filename[], <a class="el" href="structs__background.html">background</a> *bck, <a class="el" href="structobservation.html">observation</a> *obs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="spc__back_8c.html#a7e25af7fc45ffda6d9b8c6612219a32f">gsmooth_background</a> (const gsl_matrix *bck_mask, const int smooth_length, const double fwhm, <a class="el" href="structfullimg__background.html">fullimg_background</a> *fib)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="spc__back_8c.html#ace0c3cfc253b812f88ed84838d0abec2">get_weighted_mean</a> (const gsl_vector *pixvalues, const gsl_vector *weights, const gsl_vector *pmask)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="spc__back_8c.html#afa7a0622ef0b42500dbce17be8f268a4">fill_pixvalues</a> (const gsl_matrix *bck_mask, const int smooth_length, const <a class="el" href="structfullimg__background.html">fullimg_background</a> *fib, const int ix, const int iy, gsl_vector *pixvalues, gsl_vector *pmask)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="spc__back_8c.html#abf5f23ed5ff402f6f7f71fd32eed9164">compute_gvalue</a> (const double xdiff, const double efactor)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="spc__back_8c.html#ad1ce027d8c85366289610daf4ee9ac12">compute_efactor</a> (const double fwhm)</td></tr>
</table>
<hr/><h2>Define Documentation</h2>
<a class="anchor" id="aacc3ee1a7f283f8ef65cea31f4436a95"></a><!-- doxytag: member="spc_back.c::MAX" ref="aacc3ee1a7f283f8ef65cea31f4436a95" args="(x, y)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MAX</td>
          <td>(</td>
          <td class="paramtype">x, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">y&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td>&nbsp;&nbsp;&nbsp;(((x)&gt;(y))?(x):(y))</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a74e75242132eaabbc1c512488a135926"></a><!-- doxytag: member="spc_back.c::MIN" ref="a74e75242132eaabbc1c512488a135926" args="(x, y)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MIN</td>
          <td>(</td>
          <td class="paramtype">x, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">y&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td>&nbsp;&nbsp;&nbsp;(((x)&lt;(y))?(x):(y))</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="aa7866fa5e4e0ee9b034e9dab6599a9cc"></a><!-- doxytag: member="spc_back.c::SQR" ref="aa7866fa5e4e0ee9b034e9dab6599a9cc" args="(x)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SQR</td>
          <td>(</td>
          <td class="paramtype">x&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td>&nbsp;&nbsp;&nbsp;((x)*(x))</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="a84505bc11501c5f2abc6c1f45d68e79b"></a><!-- doxytag: member="spc_back.c::aperture_mask" ref="a84505bc11501c5f2abc6c1f45d68e79b" args="(observation *const obs, object **oblist)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gsl_matrix* aperture_mask </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structobservation.html">observation</a> *const &nbsp;</td>
          <td class="paramname"> <em>obs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structobject.html">object</a> **&nbsp;</td>
          <td class="paramname"> <em>oblist</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Function: aperture_mask This functions returns an image mask where pixels that are within an aperture are set to the number of aperture they appear. Skips any beams which are set to be ignored (ignore=1)</p>
<p>Parameters: </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>obs</em>&nbsp;</td><td>- a pointer to an <a class="el" href="structobservation.html">observation</a> structure </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>oblist</em>&nbsp;</td><td>- a pointer to an <a class="el" href="structobject.html">object</a> list</td></tr>
  </table>
  </dd>
</dl>
<p>Returns: </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>bck - a pointer to a gsl_matrix </dd></dl>

<p><div class="fragment"><pre class="fragment"><a name="l01336"></a>01336 {
<a name="l01337"></a>01337 
<a name="l01338"></a>01338   <span class="keywordtype">int</span> x, y,i=0,j;
<a name="l01339"></a>01339 
<a name="l01340"></a>01340   <span class="keywordtype">double</span> xrel, yrel, width;
<a name="l01341"></a>01341 
<a name="l01342"></a>01342   <a class="code" href="structis__in__descriptor.html">is_in_descriptor</a> iid;
<a name="l01343"></a>01343   <a class="code" href="structpx__point.html">px_point</a> ll, ur;
<a name="l01344"></a>01344   <a class="code" href="aXe__grism_8h.html#a6117e17bb3108107676f4486e62d40e5">gsl_matrix</a> *bck;
<a name="l01345"></a>01345   <a class="code" href="structsectionfun.html">sectionfun</a> sf;
<a name="l01346"></a>01346 
<a name="l01347"></a>01347   <span class="comment">// create the image,</span>
<a name="l01348"></a>01348   <span class="comment">// set all values to zero</span>
<a name="l01349"></a>01349   bck = <a class="code" href="aXe__grism_8h.html#a1214ab1bea5fd80474d7a27db0bfb429">gsl_matrix_alloc</a>(obs-&gt;<a class="code" href="structobservation.html#a012c0ff489fbb74fc6c9abfbd7c6e320">grism</a>-&gt;size1,obs-&gt;<a class="code" href="structobservation.html#a012c0ff489fbb74fc6c9abfbd7c6e320">grism</a>-&gt;size2);
<a name="l01350"></a>01350   <a class="code" href="aXe__grism_8h.html#af6161aeb008a1ffa7d888df6ccbef7cc">gsl_matrix_set_all</a>(bck,0.0);
<a name="l01351"></a>01351   
<a name="l01352"></a>01352   <span class="comment">// Return a zero image when there is no</span>
<a name="l01353"></a>01353   <span class="comment">// beam in the list</span>
<a name="l01354"></a>01354   <span class="keywordflow">if</span> (oblist==NULL)
<a name="l01355"></a>01355     <span class="keywordflow">return</span> bck;
<a name="l01356"></a>01356 
<a name="l01357"></a>01357   <span class="comment">// go over each object</span>
<a name="l01358"></a>01358   <span class="keywordflow">while</span>(oblist[i]!=NULL) 
<a name="l01359"></a>01359     {
<a name="l01360"></a>01360       <span class="comment">// go over each beam</span>
<a name="l01361"></a>01361       <span class="keywordflow">for</span>(j=0;j&lt;oblist[i]-&gt;<a class="code" href="structobject.html#a14120e3b048a2118f7acd75ea1571c60">nbeams</a>;j++)
<a name="l01362"></a>01362         {         
<a name="l01363"></a>01363           <span class="comment">// continue if the beam is to be ignored</span>
<a name="l01364"></a>01364           <span class="keywordflow">if</span> ((oblist[i]-&gt;beams[j]).ignore==1)
<a name="l01365"></a>01365             <span class="keywordflow">continue</span>;
<a name="l01366"></a>01366 
<a name="l01367"></a>01367           <span class="comment">// check whther the trace is second order or</span>
<a name="l01368"></a>01368           <span class="comment">// even higher</span>
<a name="l01369"></a>01369           <span class="keywordflow">if</span> ((oblist[i]-&gt;beams[j]).spec_trace-&gt;type &gt; 1)
<a name="l01370"></a>01370             {
<a name="l01371"></a>01371               <span class="comment">// create the section function for second order</span>
<a name="l01372"></a>01372               <span class="comment">// traces such as FORSII</span>
<a name="l01373"></a>01373               <a class="code" href="spce__sect_8c.html#ae2cd18c10f324ea7c2f50a1fa7864709">fill_in_sectionfun</a> (&amp;sf, (oblist[i]-&gt;beams[j]).orient,
<a name="l01374"></a>01374                                   &amp;(oblist[i]-&gt;beams[j]));
<a name="l01375"></a>01375             }
<a name="l01376"></a>01376           <span class="keywordflow">else</span>
<a name="l01377"></a>01377             {
<a name="l01378"></a>01378               <span class="comment">// create the descriptor to set up the quadrangle routines</span>
<a name="l01379"></a>01379               <a class="code" href="spce__is__in_8c.html#aea6b944b77bec44a66189391cdeeada1">fill_is_in_descriptor</a> (&amp;iid, (oblist[i]-&gt;beams[j]).corners);
<a name="l01380"></a>01380             }
<a name="l01381"></a>01381           
<a name="l01382"></a>01382           <span class="comment">// check for the corners of the quadrangle.</span>
<a name="l01383"></a>01383           <span class="comment">// go over each point in x and y.</span>
<a name="l01384"></a>01384           <a class="code" href="aXe__utils_8c.html#a40b0ba7efd067d860b4f2a6948fea20b">quad_to_bbox</a> ((oblist[i]-&gt;beams[j]).corners, &amp;ll, &amp;ur);
<a name="l01385"></a>01385           <span class="keywordflow">for</span> (x = ll.<a class="code" href="structpx__point.html#ab715a558731a820a25b50bd7797dd004">x</a>; x &lt;= ur.<a class="code" href="structpx__point.html#ab715a558731a820a25b50bd7797dd004">x</a>; x++)
<a name="l01386"></a>01386             {
<a name="l01387"></a>01387               <span class="keywordflow">for</span> (y = ll.<a class="code" href="structpx__point.html#a2d02b900722a71f22a8d5100822bda61">y</a>; y &lt;= ur.<a class="code" href="structpx__point.html#a2d02b900722a71f22a8d5100822bda61">y</a>; y++)
<a name="l01388"></a>01388                 {
<a name="l01389"></a>01389 
<a name="l01390"></a>01390                   <span class="comment">// neglect the pixel if it is a]outside the</span>
<a name="l01391"></a>01391                   <span class="comment">// image area</span>
<a name="l01392"></a>01392                   <span class="keywordflow">if</span> ((x &lt; 0) || (y &lt; 0) || (x &gt;= obs-&gt;<a class="code" href="structobservation.html#a012c0ff489fbb74fc6c9abfbd7c6e320">grism</a>-&gt;size1)
<a name="l01393"></a>01393                       || (y &gt;= obs-&gt;<a class="code" href="structobservation.html#a012c0ff489fbb74fc6c9abfbd7c6e320">grism</a>-&gt;size2))
<a name="l01394"></a>01394                     <span class="keywordflow">continue</span>;
<a name="l01395"></a>01395 
<a name="l01396"></a>01396                   <span class="comment">// check the order of the trace polynomial</span>
<a name="l01397"></a>01397                   <span class="keywordflow">if</span> ((oblist[i]-&gt;beams[j]).spec_trace-&gt;type &gt; 1)
<a name="l01398"></a>01398                     {
<a name="l01399"></a>01399 
<a name="l01400"></a>01400                       <span class="comment">// determine the trace distance and</span>
<a name="l01401"></a>01401                       <span class="comment">// enhance the image value if the pixel</span>
<a name="l01402"></a>01402                       <span class="comment">// satisfies the distance criterium</span>
<a name="l01403"></a>01403                       xrel = x-(oblist[i]-&gt;<a class="code" href="structobject.html#ad643757142781f8265b430e19700cfe5">beams</a>[j]).refpoint.x;
<a name="l01404"></a>01404                       yrel = y-(oblist[i]-&gt;<a class="code" href="structobject.html#ad643757142781f8265b430e19700cfe5">beams</a>[j]).refpoint.y;
<a name="l01405"></a>01405                       width = (oblist[i]-&gt;<a class="code" href="structobject.html#ad643757142781f8265b430e19700cfe5">beams</a>[j]).width+0.5;
<a name="l01406"></a>01406                       <span class="keywordflow">if</span> (<a class="code" href="spce__is__in_8c.html#abce25363efe229bc8b56395baac38d60">tracedist_criteria</a>(xrel, yrel, &amp;sf, (oblist[i]-&gt;beams[j]).spec_trace, width))
<a name="l01407"></a>01407                         <a class="code" href="aXe__grism_8h.html#a1f386ef5cd5a3b916246c2bee80f083a">gsl_matrix_set</a> (bck,x,y,<a class="code" href="aXe__grism_8h.html#acf709ee71c580f1cd65d726ed03200ea">gsl_matrix_get</a> (bck,x,y)+1);
<a name="l01408"></a>01408                     }
<a name="l01409"></a>01409                   <span class="keywordflow">else</span>
<a name="l01410"></a>01410                     {
<a name="l01411"></a>01411                       <span class="comment">//                      if (oblist[i]-&gt;ID == 11 &amp;&amp; x == 59)</span>
<a name="l01412"></a>01412                       <span class="comment">//                        fprintf(stdout, &quot;xx: %i, yy: %i: %i\n&quot;, x, y, is_in (x, y, &amp;iid));</span>
<a name="l01413"></a>01413 
<a name="l01414"></a>01414                       <span class="comment">// check whether the pixel is inside the quadrangle</span>
<a name="l01415"></a>01415                       <span class="comment">// which defines the beam are, and enhance the image</span>
<a name="l01416"></a>01416                       <span class="comment">// value if yes.</span>
<a name="l01417"></a>01417                       <span class="keywordflow">if</span> (<a class="code" href="spce__is__in_8c.html#a3dffa5865ba3264ef10bed7249bac60e">is_in</a> (x, y, &amp;iid))
<a name="l01418"></a>01418                         <a class="code" href="aXe__grism_8h.html#a1f386ef5cd5a3b916246c2bee80f083a">gsl_matrix_set</a> (bck,x,y,<a class="code" href="aXe__grism_8h.html#acf709ee71c580f1cd65d726ed03200ea">gsl_matrix_get</a> (bck,x,y)+1);
<a name="l01419"></a>01419                     }
<a name="l01420"></a>01420                 }
<a name="l01421"></a>01421             }
<a name="l01422"></a>01422         }
<a name="l01423"></a>01423       
<a name="l01424"></a>01424       <span class="comment">// enhance the object counter</span>
<a name="l01425"></a>01425       i++;
<a name="l01426"></a>01426     }
<a name="l01427"></a>01427 
<a name="l01428"></a>01428   <span class="comment">// return the resulting image  </span>
<a name="l01429"></a>01429   <span class="keywordflow">return</span> bck;
<a name="l01430"></a>01430 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a5244945f780b5c1e41997c970df2ee49"></a><!-- doxytag: member="spc_back.c::background_to_FITSimage" ref="a5244945f780b5c1e41997c970df2ee49" args="(char filename[], background *bck, observation *obs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void background_to_FITSimage </td>
          <td>(</td>
          <td class="paramtype">char&nbsp;</td>
          <td class="paramname"> <em>filename</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structs__background.html">background</a> *&nbsp;</td>
          <td class="paramname"> <em>bck</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structobservation.html">observation</a> *&nbsp;</td>
          <td class="paramname"> <em>obs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Function: background_to_FITSimage Function to write the data and error content of a backgound <a class="el" href="structobservation.html">observation</a> pars component (if it is of type <a class="el" href="structfullimg__background.html">fullimg_background</a> only) into the main HDU (data) and first extension (error) of a FITS file. A GQ array can be appended if an <a class="el" href="structobservation.html">observation</a> with a non NULL DQ is passed to this function</p>
<p>Parameters: </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>filename</em>&nbsp;</td><td>- name of the image </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>bck</em>&nbsp;</td><td>- filled background structure </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>obs</em>&nbsp;</td><td>- the <a class="el" href="structobservation.html">observation</a> the background is based upon </td></tr>
  </table>
  </dd>
</dl>

<p><div class="fragment"><pre class="fragment"><a name="l01448"></a>01448 {
<a name="l01449"></a>01449   fitsfile *output;
<a name="l01450"></a>01450   <span class="keywordtype">long</span> naxes[2];
<a name="l01451"></a>01451   <span class="keywordtype">int</span> f_status = 0;
<a name="l01452"></a>01452   <a class="code" href="aXe__grism_8h.html#ab4472600f4f77bd72e51d116ed5138ed">PIXEL_T</a> *storage, *dp;
<a name="l01453"></a>01453   <span class="keywordtype">int</span> x, y;
<a name="l01454"></a>01454   <a class="code" href="structfullimg__background.html">fullimg_background</a> *pars;
<a name="l01455"></a>01455   <span class="keywordtype">int</span> hdunum,hdutype;
<a name="l01456"></a>01456   
<a name="l01457"></a>01457   pars = (<a class="code" href="structfullimg__background.html">fullimg_background</a> *) bck-&gt;<a class="code" href="structs__background.html#a4d8837d7be9de01330a6fb4c24a2bf75">pars</a>;
<a name="l01458"></a>01458   
<a name="l01459"></a>01459   <span class="comment">// Open the file for creating/appending</span>
<a name="l01460"></a>01460   <a class="code" href="aXe__utils_8c.html#a56c8dcf357ffe98624d185a96d0922e4">create_FITSimage</a> (filename, 1);
<a name="l01461"></a>01461   fits_open_file (&amp;output, filename, READWRITE, &amp;f_status);
<a name="l01462"></a>01462   <span class="keywordflow">if</span> (f_status)
<a name="l01463"></a>01463     {
<a name="l01464"></a>01464       ffrprt (stderr, f_status);
<a name="l01465"></a>01465       <a class="code" href="aXe__errors_8c.html#a7ef7588e5f91237ba7ce4084e6ed3c11">aXe_message</a> (<a class="code" href="aXe__errors_8h.html#a2556a67874555249b07691c37aa6d6e9">aXe_M_FATAL</a>, __FILE__, __LINE__,
<a name="l01466"></a>01466                    <span class="stringliteral">&quot;gsl_to_FITSimage: &quot;</span> <span class="stringliteral">&quot;Could not open file: %s&quot;</span>,
<a name="l01467"></a>01467                    filename);
<a name="l01468"></a>01468     }
<a name="l01469"></a>01469 
<a name="l01470"></a>01470   <span class="comment">// count the number of extentions</span>
<a name="l01471"></a>01471   fits_get_num_hdus (output, &amp;hdunum, &amp;f_status);
<a name="l01472"></a>01472   <span class="keywordflow">if</span> (f_status)
<a name="l01473"></a>01473     {
<a name="l01474"></a>01474       ffrprt (stderr, f_status);
<a name="l01475"></a>01475       <a class="code" href="aXe__errors_8c.html#a7ef7588e5f91237ba7ce4084e6ed3c11">aXe_message</a> (<a class="code" href="aXe__errors_8h.html#a2556a67874555249b07691c37aa6d6e9">aXe_M_FATAL</a>, __FILE__, __LINE__,
<a name="l01476"></a>01476                    <span class="stringliteral">&quot;gsl_to_FITSimage: Could not get&quot;</span>
<a name="l01477"></a>01477                    <span class="stringliteral">&quot; number of HDU from: %s&quot;</span>, filename);
<a name="l01478"></a>01478     }
<a name="l01479"></a>01479   
<a name="l01480"></a>01480   <span class="comment">// Move to last HDU</span>
<a name="l01481"></a>01481   fits_movabs_hdu (output, hdunum, &amp;hdutype, &amp;f_status);
<a name="l01482"></a>01482   <span class="keywordflow">if</span> (f_status)
<a name="l01483"></a>01483     {
<a name="l01484"></a>01484       ffrprt (stderr, f_status);
<a name="l01485"></a>01485       <a class="code" href="aXe__errors_8c.html#a7ef7588e5f91237ba7ce4084e6ed3c11">aXe_message</a> (<a class="code" href="aXe__errors_8h.html#a2556a67874555249b07691c37aa6d6e9">aXe_M_FATAL</a>, __FILE__, __LINE__,
<a name="l01486"></a>01486                    <span class="stringliteral">&quot;gsl_to_FITSimage: Could not mov&quot;</span>
<a name="l01487"></a>01487                    <span class="stringliteral">&quot; to HDU number %d in file: %s&quot;</span>, hdunum, filename);
<a name="l01488"></a>01488     }
<a name="l01489"></a>01489   <span class="comment">/* Get current HDU number */</span>
<a name="l01490"></a>01490   fits_get_hdu_num (output, &amp;hdunum);
<a name="l01491"></a>01491   
<a name="l01492"></a>01492   <span class="comment">// Deal with the SCI part of the background</span>
<a name="l01493"></a>01493   naxes[0] = pars-&gt;<a class="code" href="structfullimg__background.html#aa7b506968cfc22160ce55d63121311c4">bck</a>-&gt;size1;
<a name="l01494"></a>01494   naxes[1] = pars-&gt;<a class="code" href="structfullimg__background.html#aa7b506968cfc22160ce55d63121311c4">bck</a>-&gt;size2;
<a name="l01495"></a>01495 
<a name="l01496"></a>01496   <span class="comment">// Allocate storage room</span>
<a name="l01497"></a>01497   <span class="keywordflow">if</span> (!(storage = malloc (naxes[0] * naxes[1] * <span class="keyword">sizeof</span> (<span class="keywordtype">double</span>))))
<a name="l01498"></a>01498     <a class="code" href="aXe__errors_8c.html#a7ef7588e5f91237ba7ce4084e6ed3c11">aXe_message</a> (<a class="code" href="aXe__errors_8h.html#a2556a67874555249b07691c37aa6d6e9">aXe_M_FATAL</a>, __FILE__, __LINE__, <span class="stringliteral">&quot;Out of memory&quot;</span>);
<a name="l01499"></a>01499 
<a name="l01500"></a>01500   <span class="comment">// Populate the storage array</span>
<a name="l01501"></a>01501   dp = storage;
<a name="l01502"></a>01502   <span class="keywordflow">for</span> (y = 0; y &lt; naxes[1]; y++)
<a name="l01503"></a>01503     {
<a name="l01504"></a>01504       <span class="keywordflow">for</span> (x = 0; x &lt; naxes[0]; x++)
<a name="l01505"></a>01505         {
<a name="l01506"></a>01506           *dp = <a class="code" href="aXe__grism_8h.html#acf709ee71c580f1cd65d726ed03200ea">gsl_matrix_get</a> (pars-&gt;<a class="code" href="structfullimg__background.html#aa7b506968cfc22160ce55d63121311c4">bck</a>, x, y);
<a name="l01507"></a>01507           dp++;
<a name="l01508"></a>01508         }
<a name="l01509"></a>01509     }
<a name="l01510"></a>01510   <span class="comment">/* create HDU extname */</span>
<a name="l01511"></a>01511   fits_create_img (output, -32, 2, naxes, &amp;f_status);
<a name="l01512"></a>01512   <span class="keywordflow">if</span> (f_status)
<a name="l01513"></a>01513     {
<a name="l01514"></a>01514       ffrprt (stderr, f_status);
<a name="l01515"></a>01515       <a class="code" href="aXe__errors_8c.html#a7ef7588e5f91237ba7ce4084e6ed3c11">aXe_message</a> (<a class="code" href="aXe__errors_8h.html#a2556a67874555249b07691c37aa6d6e9">aXe_M_FATAL</a>, __FILE__, __LINE__,
<a name="l01516"></a>01516                    <span class="stringliteral">&quot;gsl_to_FITSimage: Could create SCI HDU in file: %s&quot;</span>, filename);
<a name="l01517"></a>01517     }
<a name="l01518"></a>01518   fits_write_img (output, TFLOAT, 1, naxes[0] * naxes[1], storage,
<a name="l01519"></a>01519                   &amp;f_status);
<a name="l01520"></a>01520   <span class="keywordflow">if</span> (f_status)
<a name="l01521"></a>01521     {
<a name="l01522"></a>01522       ffrprt (stderr, f_status);
<a name="l01523"></a>01523       <a class="code" href="aXe__errors_8c.html#a7ef7588e5f91237ba7ce4084e6ed3c11">aXe_message</a> (<a class="code" href="aXe__errors_8h.html#a2556a67874555249b07691c37aa6d6e9">aXe_M_FATAL</a>, __FILE__, __LINE__,
<a name="l01524"></a>01524                    <span class="stringliteral">&quot;gsl_to_FITSimage: Could write SCI HDU in file: %s&quot;</span>, filename);
<a name="l01525"></a>01525     }
<a name="l01526"></a>01526 
<a name="l01527"></a>01527   <span class="comment">/* write the HDU EXTNAME */</span>
<a name="l01528"></a>01528   {
<a name="l01529"></a>01529     <span class="keywordtype">char</span> comment[FLEN_COMMENT];
<a name="l01530"></a>01530     <span class="keywordtype">char</span> str[FLEN_KEYWORD];
<a name="l01531"></a>01531     strcpy (str, <span class="stringliteral">&quot;SCI&quot;</span>);
<a name="l01532"></a>01532     strcpy (comment, <span class="stringliteral">&quot;Extension name&quot;</span>);
<a name="l01533"></a>01533     fits_write_key_str (output, <span class="stringliteral">&quot;EXTNAME&quot;</span>, str, comment, &amp;f_status);
<a name="l01534"></a>01534   }
<a name="l01535"></a>01535   free (storage);
<a name="l01536"></a>01536   storage = NULL;
<a name="l01537"></a>01537   
<a name="l01538"></a>01538   <span class="keywordflow">if</span> (pars-&gt;<a class="code" href="structfullimg__background.html#a6c52119d1f340304f50e8f4b99ab89dc">err</a>)
<a name="l01539"></a>01539     {
<a name="l01540"></a>01540       <span class="comment">/* Deal with the error part of the background */</span>
<a name="l01541"></a>01541       naxes[0] = pars-&gt;<a class="code" href="structfullimg__background.html#a6c52119d1f340304f50e8f4b99ab89dc">err</a>-&gt;size1;
<a name="l01542"></a>01542       naxes[1] = pars-&gt;<a class="code" href="structfullimg__background.html#a6c52119d1f340304f50e8f4b99ab89dc">err</a>-&gt;size2;
<a name="l01543"></a>01543       <span class="comment">/* Allocate storage room */</span>
<a name="l01544"></a>01544       <span class="keywordflow">if</span> (!(storage = malloc (naxes[0] * naxes[1] * <span class="keyword">sizeof</span> (<span class="keywordtype">double</span>))))
<a name="l01545"></a>01545         {
<a name="l01546"></a>01546           <a class="code" href="aXe__errors_8c.html#a7ef7588e5f91237ba7ce4084e6ed3c11">aXe_message</a> (<a class="code" href="aXe__errors_8h.html#a2556a67874555249b07691c37aa6d6e9">aXe_M_FATAL</a>, __FILE__, __LINE__, <span class="stringliteral">&quot;Out of memory&quot;</span>);
<a name="l01547"></a>01547         }
<a name="l01548"></a>01548       <span class="comment">/* Populate the storage array */</span>
<a name="l01549"></a>01549       dp = storage;
<a name="l01550"></a>01550       <span class="keywordflow">for</span> (y = 0; y &lt; naxes[1]; y++)
<a name="l01551"></a>01551         {
<a name="l01552"></a>01552           <span class="keywordflow">for</span> (x = 0; x &lt; naxes[0]; x++)
<a name="l01553"></a>01553             {
<a name="l01554"></a>01554               *dp = <a class="code" href="aXe__grism_8h.html#acf709ee71c580f1cd65d726ed03200ea">gsl_matrix_get</a> (pars-&gt;<a class="code" href="structfullimg__background.html#a6c52119d1f340304f50e8f4b99ab89dc">err</a>, x, y);
<a name="l01555"></a>01555               dp++;
<a name="l01556"></a>01556             }
<a name="l01557"></a>01557         }
<a name="l01558"></a>01558       <span class="comment">/* create HDU extname */</span>
<a name="l01559"></a>01559       <span class="comment">/* Get current HDU number */</span>
<a name="l01560"></a>01560       fits_get_hdu_num (output, &amp;hdunum);
<a name="l01561"></a>01561       
<a name="l01562"></a>01562       fits_create_img (output, -32, 2, naxes, &amp;f_status);
<a name="l01563"></a>01563       fits_write_img (output, TFLOAT, 1, naxes[0] * naxes[1], storage,
<a name="l01564"></a>01564                       &amp;f_status);
<a name="l01565"></a>01565       
<a name="l01566"></a>01566       <span class="comment">/* Get current HDU number */</span>
<a name="l01567"></a>01567       fits_get_hdu_num (output, &amp;hdunum);
<a name="l01568"></a>01568       <span class="comment">/* write the HDU EXTNAME */</span>
<a name="l01569"></a>01569       {
<a name="l01570"></a>01570         <span class="keywordtype">char</span> comment[FLEN_COMMENT];
<a name="l01571"></a>01571         <span class="keywordtype">char</span> str[FLEN_KEYWORD];
<a name="l01572"></a>01572         strcpy (str, <span class="stringliteral">&quot;ERR&quot;</span>);
<a name="l01573"></a>01573         strcpy (comment, <span class="stringliteral">&quot;Extension name&quot;</span>);
<a name="l01574"></a>01574         fits_write_key_str (output, <span class="stringliteral">&quot;EXTNAME&quot;</span>, str, comment, &amp;f_status);
<a name="l01575"></a>01575       }
<a name="l01576"></a>01576       free (storage);
<a name="l01577"></a>01577       storage = NULL;
<a name="l01578"></a>01578     }
<a name="l01579"></a>01579 
<a name="l01580"></a>01580   <span class="comment">/* Deal with the DQ part of the background */</span>
<a name="l01581"></a>01581   <span class="keywordflow">if</span> (obs-&gt;<a class="code" href="structobservation.html#a6698fa09a4524a5928ad9f98d620ba4e">dq</a> != NULL) 
<a name="l01582"></a>01582     {
<a name="l01583"></a>01583       naxes[0] = obs-&gt;<a class="code" href="structobservation.html#a6698fa09a4524a5928ad9f98d620ba4e">dq</a>-&gt;size1;
<a name="l01584"></a>01584       naxes[1] = obs-&gt;<a class="code" href="structobservation.html#a6698fa09a4524a5928ad9f98d620ba4e">dq</a>-&gt;size2;
<a name="l01585"></a>01585       <span class="comment">/* Allocate storage room */</span>
<a name="l01586"></a>01586       <span class="keywordflow">if</span> (!(storage = malloc (naxes[0] * naxes[1] * <span class="keyword">sizeof</span> (<span class="keywordtype">double</span>))))
<a name="l01587"></a>01587         {
<a name="l01588"></a>01588           <a class="code" href="aXe__errors_8c.html#a7ef7588e5f91237ba7ce4084e6ed3c11">aXe_message</a> (<a class="code" href="aXe__errors_8h.html#a2556a67874555249b07691c37aa6d6e9">aXe_M_FATAL</a>, __FILE__, __LINE__, <span class="stringliteral">&quot;Out of memory&quot;</span>);
<a name="l01589"></a>01589         }
<a name="l01590"></a>01590       <span class="comment">/* Populate the storage array */</span>
<a name="l01591"></a>01591       dp = storage;
<a name="l01592"></a>01592       <span class="keywordflow">for</span> (y = 0; y &lt; naxes[1]; y++)
<a name="l01593"></a>01593         {
<a name="l01594"></a>01594           <span class="keywordflow">for</span> (x = 0; x &lt; naxes[0]; x++)
<a name="l01595"></a>01595             {
<a name="l01596"></a>01596               *dp = <a class="code" href="aXe__grism_8h.html#acf709ee71c580f1cd65d726ed03200ea">gsl_matrix_get</a> (obs-&gt;<a class="code" href="structobservation.html#a6698fa09a4524a5928ad9f98d620ba4e">dq</a>, x, y);
<a name="l01597"></a>01597               dp++;
<a name="l01598"></a>01598             }
<a name="l01599"></a>01599         }
<a name="l01600"></a>01600       <span class="comment">/* create HDU extname */</span>
<a name="l01601"></a>01601       fits_create_img (output, 16, 2, naxes, &amp;f_status);
<a name="l01602"></a>01602       fits_write_img (output, TFLOAT, 1, naxes[0] * naxes[1], storage,
<a name="l01603"></a>01603                       &amp;f_status);
<a name="l01604"></a>01604       <span class="comment">/* write the HDU EXTNAME */</span>
<a name="l01605"></a>01605       {
<a name="l01606"></a>01606         <span class="keywordtype">char</span> comment[FLEN_COMMENT];
<a name="l01607"></a>01607         <span class="keywordtype">char</span> str[FLEN_KEYWORD];
<a name="l01608"></a>01608         strcpy (str, <span class="stringliteral">&quot;DQ&quot;</span>);
<a name="l01609"></a>01609         strcpy (comment, <span class="stringliteral">&quot;Extension name&quot;</span>);
<a name="l01610"></a>01610         fits_write_key_str (output, <span class="stringliteral">&quot;EXTNAME&quot;</span>, str, comment, &amp;f_status);
<a name="l01611"></a>01611       }
<a name="l01612"></a>01612       free (storage);
<a name="l01613"></a>01613       storage = NULL;    
<a name="l01614"></a>01614     } 
<a name="l01615"></a>01615 
<a name="l01616"></a>01616   <span class="comment">/* close file */</span>
<a name="l01617"></a>01617   fits_close_file (output, &amp;f_status);
<a name="l01618"></a>01618 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a135c17132984f8af8cf6d4f13ee9dbb7"></a><!-- doxytag: member="spc_back.c::comp_kappasigma_interp" ref="a135c17132984f8af8cf6d4f13ee9dbb7" args="(const double *const xs, double *const ys, double *const ws, const int n, const int interp, const int niter, const double kappa, observation *obs, int colnum)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void comp_kappasigma_interp </td>
          <td>(</td>
          <td class="paramtype">const double *const &nbsp;</td>
          <td class="paramname"> <em>xs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *const &nbsp;</td>
          <td class="paramname"> <em>ys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *const &nbsp;</td>
          <td class="paramname"> <em>ws</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>interp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>niter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>kappa</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structobservation.html">observation</a> *&nbsp;</td>
          <td class="paramname"> <em>obs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>colnum</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Function: comp_kappasigma_interp The function performs a kappa-sigma clipping rejection on a set of data given in vectors for indipendent, dipendent and weight values. The differences to base the clipping on is "true value minus background value", where background value is determined using the identical algorithm as the final background determination.</p>
<p>Parameters: </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>xs</em>&nbsp;</td><td>- array for independent values </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ys</em>&nbsp;</td><td>- array for dependent values </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ws</em>&nbsp;</td><td>- weight array </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>n</em>&nbsp;</td><td>- number of pixels </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>interp</em>&nbsp;</td><td>- number indicating the interpolation scheme </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>niter</em>&nbsp;</td><td>- the number of iterations </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>kappa</em>&nbsp;</td><td>- the kappa value for rejection </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>obs</em>&nbsp;</td><td>- the <a class="el" href="structobject.html">object</a> list </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>colnum</em>&nbsp;</td><td>- the column number </td></tr>
  </table>
  </dd>
</dl>

<p><div class="fragment"><pre class="fragment"><a name="l00613"></a>00613 {
<a name="l00614"></a>00614   <span class="keywordtype">double</span> *ys_tmp;
<a name="l00615"></a>00615   <span class="keywordtype">double</span> *yi_tmp;
<a name="l00616"></a>00616   <span class="keywordtype">double</span> *y_diff;
<a name="l00617"></a>00617 
<a name="l00618"></a>00618   <span class="keywordtype">double</span> stdev;
<a name="l00619"></a>00619 
<a name="l00620"></a>00620   <span class="keywordtype">int</span> *iindex;
<a name="l00621"></a>00621 
<a name="l00622"></a>00622 
<a name="l00623"></a>00623   <span class="keywordtype">int</span> i, m, j;
<a name="l00624"></a>00624 
<a name="l00625"></a>00625   <span class="comment">// allocate temporary vectors</span>
<a name="l00626"></a>00626   ys_tmp = (<span class="keywordtype">double</span> *) malloc (n * <span class="keyword">sizeof</span> (<span class="keywordtype">double</span>));
<a name="l00627"></a>00627   yi_tmp = (<span class="keywordtype">double</span> *) malloc (n * <span class="keyword">sizeof</span> (<span class="keywordtype">double</span>));
<a name="l00628"></a>00628   y_diff = (<span class="keywordtype">double</span> *) malloc (n * <span class="keyword">sizeof</span> (<span class="keywordtype">double</span>));
<a name="l00629"></a>00629   iindex = (<span class="keywordtype">int</span> *) malloc (n * <span class="keyword">sizeof</span> (<span class="keywordtype">int</span>));
<a name="l00630"></a>00630 
<a name="l00631"></a>00631   <span class="comment">// transfer the dependent value</span>
<a name="l00632"></a>00632   <span class="comment">// to the tmp vector</span>
<a name="l00633"></a>00633   <span class="keywordflow">for</span> (i=0; i &lt; n; i++)
<a name="l00634"></a>00634     ys_tmp[i] = ys[i];
<a name="l00635"></a>00635 
<a name="l00636"></a>00636 
<a name="l00637"></a>00637   <span class="comment">// do niter times</span>
<a name="l00638"></a>00638   <span class="keywordflow">for</span> (j=0; j &lt; niter; j++)
<a name="l00639"></a>00639     {
<a name="l00640"></a>00640       
<a name="l00641"></a>00641       <span class="comment">// make the background determination</span>
<a name="l00642"></a>00642       <a class="code" href="spc__back_8c.html#a17d5c8763243b26091aceb119ac98557">comp_vector_interp</a>(xs, ys_tmp, ws, yi_tmp, n, interp, 0);
<a name="l00643"></a>00643 
<a name="l00644"></a>00644       <span class="comment">// calculate for all background</span>
<a name="l00645"></a>00645       <span class="comment">// pixels the differences between</span>
<a name="l00646"></a>00646       <span class="comment">// the original and background value</span>
<a name="l00647"></a>00647       m=0;
<a name="l00648"></a>00648       <span class="keywordflow">for</span> (i=0; i &lt; n; i++)
<a name="l00649"></a>00649         {
<a name="l00650"></a>00650           <span class="keywordflow">if</span> (ws[i] != 0.0)
<a name="l00651"></a>00651             {
<a name="l00652"></a>00652               y_diff[m] = ys[i] - yi_tmp[i];
<a name="l00653"></a>00653               iindex[m] = i;
<a name="l00654"></a>00654               m++;
<a name="l00655"></a>00655             }
<a name="l00656"></a>00656         }
<a name="l00657"></a>00657 
<a name="l00658"></a>00658       <span class="comment">// compute the standard deviation</span>
<a name="l00659"></a>00659       <span class="comment">// on the differences</span>
<a name="l00660"></a>00660       stdev = gsl_stats_sd (y_diff, 1, m);
<a name="l00661"></a>00661 
<a name="l00662"></a>00662       <span class="comment">// do the clipping</span>
<a name="l00663"></a>00663       <span class="keywordflow">for</span> (i=0; i &lt; m; i++)
<a name="l00664"></a>00664         {
<a name="l00665"></a>00665           <span class="comment">// check for pixels to exclude</span>
<a name="l00666"></a>00666           <span class="keywordflow">if</span> (fabs(y_diff[i]) &gt; kappa*stdev)
<a name="l00667"></a>00667             {
<a name="l00668"></a>00668               <span class="comment">// set its weight to 0.0</span>
<a name="l00669"></a>00669               ws[iindex[i]] = 0.0;
<a name="l00670"></a>00670               <span class="comment">// mark the pixel in the dq-array</span>
<a name="l00671"></a>00671               <span class="keywordflow">if</span> ( xs[iindex[i]] &gt;= 0 &amp;&amp;  xs[iindex[i]] &lt; obs-&gt;<a class="code" href="structobservation.html#a6698fa09a4524a5928ad9f98d620ba4e">dq</a>-&gt;size2)
<a name="l00672"></a>00672                 <a class="code" href="aXe__grism_8h.html#a1f386ef5cd5a3b916246c2bee80f083a">gsl_matrix_set</a>(obs-&gt;<a class="code" href="structobservation.html#a6698fa09a4524a5928ad9f98d620ba4e">dq</a>, colnum, xs[iindex[i]], <a class="code" href="spc__back_8h.html#a84af820cbb7ca83ada7bf0c1aba8d02f">DQ_KAPPA_SIGMA</a>);
<a name="l00673"></a>00673             }
<a name="l00674"></a>00674         }
<a name="l00675"></a>00675     }
<a name="l00676"></a>00676 
<a name="l00677"></a>00677 
<a name="l00678"></a>00678   <span class="keywordflow">for</span> (i=0; i &lt; n; i++)    
<a name="l00679"></a>00679     ys[i] = ys_tmp[i];
<a name="l00680"></a>00680   
<a name="l00681"></a>00681   <span class="comment">// free memory</span>
<a name="l00682"></a>00682   free(ys_tmp);
<a name="l00683"></a>00683   free(yi_tmp);
<a name="l00684"></a>00684   free(y_diff);
<a name="l00685"></a>00685   free(iindex);
<a name="l00686"></a>00686 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a17d5c8763243b26091aceb119ac98557"></a><!-- doxytag: member="spc_back.c::comp_vector_interp" ref="a17d5c8763243b26091aceb119ac98557" args="(const double *const xs, double *const ys, double *const ws, double *const yi, const int n, const int interp, const int final)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void comp_vector_interp </td>
          <td>(</td>
          <td class="paramtype">const double *const &nbsp;</td>
          <td class="paramname"> <em>xs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *const &nbsp;</td>
          <td class="paramname"> <em>ys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *const &nbsp;</td>
          <td class="paramname"> <em>ws</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *const &nbsp;</td>
          <td class="paramname"> <em>yi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>interp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>final</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Function: comp_vector_interp The function passes the interpolation data to the desired interpolating function.</p>
<p>Parameters: </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>xs</em>&nbsp;</td><td>- double vector containing the x values </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ys</em>&nbsp;</td><td>- double vector containing the y values </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ws</em>&nbsp;</td><td>- double vector containing the weights associated with ys </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>n</em>&nbsp;</td><td>- number of points in xs,ys, and ws (must be greater than m!) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>interp</em>&nbsp;</td><td>- desired interpolation type </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>final</em>&nbsp;</td><td>- indicates a final interpolation </td></tr>
  </table>
  </dd>
</dl>

<p><div class="fragment"><pre class="fragment"><a name="l00784"></a>00784 {
<a name="l00785"></a>00785   <span class="comment">/* Median the background */</span>
<a name="l00786"></a>00786   <span class="keywordflow">if</span> (interp == -1)
<a name="l00787"></a>00787     {
<a name="l00788"></a>00788       <a class="code" href="spce__fitting_8c.html#ad77a41562c50e1fbe924bc44a4df7779">comp_vector_median</a>(xs, ys, ws, yi, n, <span class="keyword">final</span>);
<a name="l00789"></a>00789     }
<a name="l00790"></a>00790   <span class="comment">/* Straight average of the background */</span>
<a name="l00791"></a>00791   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (interp == 0)
<a name="l00792"></a>00792     {
<a name="l00793"></a>00793       <a class="code" href="spce__fitting_8c.html#a621fe9c9c80ba0e0ec7a91bcde5abe7e">comp_vector_average</a>(xs, ys, ws, yi, n, <span class="keyword">final</span>);
<a name="l00794"></a>00794     }
<a name="l00795"></a>00795   <span class="comment">/* Linear interpolation of the background */</span>
<a name="l00796"></a>00796   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (interp == 1)
<a name="l00797"></a>00797     {
<a name="l00798"></a>00798       <a class="code" href="spce__fitting_8c.html#afee691c36e9b3fc77fd08f9aee86f1b8">comp_vector_linear</a>(xs, ys, ws, yi, n, <span class="keyword">final</span>);
<a name="l00799"></a>00799     }
<a name="l00800"></a>00800   <span class="comment">/* n(&gt;1) order interpolation of the background */</span>
<a name="l00801"></a>00801   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (interp &gt; 1)
<a name="l00802"></a>00802     {
<a name="l00803"></a>00803       <a class="code" href="spce__fitting_8c.html#add50c2f8186c3978ef12800257daa954">comp_vector_polyN</a> (interp + 1, xs, ys, ws, yi, n, <span class="keyword">final</span>);
<a name="l00804"></a>00804     }
<a name="l00805"></a>00805   <span class="keywordflow">else</span>
<a name="l00806"></a>00806     {
<a name="l00807"></a>00807       <a class="code" href="aXe__errors_8c.html#a7ef7588e5f91237ba7ce4084e6ed3c11">aXe_message</a>(<a class="code" href="aXe__errors_8h.html#a2556a67874555249b07691c37aa6d6e9">aXe_M_FATAL</a>, __FILE__, __LINE__,
<a name="l00808"></a>00808                   <span class="stringliteral">&quot;Do not know what to do with interpolation: %i %s\n&quot;</span>, interp);
<a name="l00809"></a>00809     }
<a name="l00810"></a>00810 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ad45826f8c0ede1b55ed2f5d6fd67e875"></a><!-- doxytag: member="spc_back.c::compute_background" ref="ad45826f8c0ede1b55ed2f5d6fd67e875" args="(observation *obs, beam actbeam, gsl_matrix *bck_mask, fullimg_background *fib, int npoints, int interporder, const int niter_med, const int niter_fit, const double kappa)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void compute_background </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structobservation.html">observation</a> *&nbsp;</td>
          <td class="paramname"> <em>obs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbeam.html">beam</a>&nbsp;</td>
          <td class="paramname"> <em>actbeam</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gsl_matrix *&nbsp;</td>
          <td class="paramname"> <em>bck_mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structfullimg__background.html">fullimg_background</a> *&nbsp;</td>
          <td class="paramname"> <em>fib</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>npoints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>interporder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>niter_med</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>niter_fit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>kappa</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Function: compute_background The function extracts possible background pixels for a given <a class="el" href="structbeam.html">beam</a> using a specified interpolation functions. After possibly rejecting cosmics, the background is interpolated on the areas which are masked out. The interpolated values are filled into a background structure. If kappa-sigma klipping is applied, the clipped pixels are flagged in the dq-array of the background image.</p>
<p>Parameters: </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>obs</em>&nbsp;</td><td>- the <a class="el" href="structobject.html">object</a> list </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>actbeam</em>&nbsp;</td><td>- the <a class="el" href="structbeam.html">beam</a> to compute the background for </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>bck_mask</em>&nbsp;</td><td>- the background mask </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>fib</em>&nbsp;</td><td>- the baground structure </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>npoints</em>&nbsp;</td><td>- the number of interpolation points </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>interporder</em>&nbsp;</td><td>- the interpolation order </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>niter_med</em>&nbsp;</td><td>- the number of iterations around the median </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>niter_fit</em>&nbsp;</td><td>- the number of iterations around the fit </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>kappa</em>&nbsp;</td><td>- the kappa value </td></tr>
  </table>
  </dd>
</dl>

<p><div class="fragment"><pre class="fragment"><a name="l00398"></a>00398 {
<a name="l00399"></a>00399   <a class="code" href="structpx__point.html">px_point</a> xborder;  
<a name="l00400"></a>00400   gsl_vector_int *yvec;
<a name="l00401"></a>00401   <a class="code" href="structtrace__func.html">trace_func</a> *tracefun;
<a name="l00402"></a>00402   <a class="code" href="structpx__point.html">px_point</a> tpoint;
<a name="l00403"></a>00403   <span class="keywordtype">double</span> *ys, *fs, *ws, *yi;
<a name="l00404"></a>00404   <span class="comment">//double var;</span>
<a name="l00405"></a>00405   
<a name="l00406"></a>00406   <span class="keywordtype">int</span> i, ii;
<a name="l00407"></a>00407   <span class="keywordtype">int</span> j, n;
<a name="l00408"></a>00408   <span class="keywordtype">int</span> min_y, max_y;
<a name="l00409"></a>00409 
<a name="l00410"></a>00410 
<a name="l00411"></a>00411   <span class="comment">// define the beam and the trace function</span>
<a name="l00412"></a>00412   tracefun = actbeam.<a class="code" href="structbeam.html#a918b8655ff4142f173ca73226ce27922">spec_trace</a>;
<a name="l00413"></a>00413 
<a name="l00414"></a>00414   <span class="comment">/* If this beam&apos;s ignore flag is set to 1 then do nothing */</span>
<a name="l00415"></a>00415   <span class="keywordflow">if</span> (actbeam.<a class="code" href="structbeam.html#a8c7dc459dedfd957741d35c59440972f">ignore</a> == 1)
<a name="l00416"></a>00416     <span class="keywordflow">return</span>;
<a name="l00417"></a>00417     
<a name="l00418"></a>00418   <span class="comment">// determine the start and end point in x</span>
<a name="l00419"></a>00419   xborder = <a class="code" href="spc__back_8c.html#ad7c9963cb80da0010581906c46dde765">get_xrange</a>(obs, actbeam);
<a name="l00420"></a>00420 
<a name="l00421"></a>00421 
<a name="l00422"></a>00422   <span class="comment">// Loop over all columns</span>
<a name="l00423"></a>00423   <span class="keywordflow">for</span> (i = xborder.<a class="code" href="structpx__point.html#ab715a558731a820a25b50bd7797dd004">x</a>; i &lt; xborder.<a class="code" href="structpx__point.html#a2d02b900722a71f22a8d5100822bda61">y</a>; i++)
<a name="l00424"></a>00424     {
<a name="l00425"></a>00425 
<a name="l00426"></a>00426       <span class="comment">// determine the pixel closest to the trace</span>
<a name="l00427"></a>00427       tpoint.<a class="code" href="structpx__point.html#ab715a558731a820a25b50bd7797dd004">x</a> = i;
<a name="l00428"></a>00428       tpoint.<a class="code" href="structpx__point.html#a2d02b900722a71f22a8d5100822bda61">y</a> = (int)floor(tracefun-&gt;<a class="code" href="structtrace__func.html#a7c1a538b7ae1293d6e0fc1bdd4c2739c">func</a>((<span class="keywordtype">double</span>)i-actbeam.<a class="code" href="structbeam.html#a54c64670a8b3e8732c1468d156ddb0ca">refpoint</a>.<a class="code" href="structd__point.html#a922a3b5d82a119168ba85e5f939d02c3">x</a>,
<a name="l00429"></a>00429                                            tracefun-&gt;<a class="code" href="structtrace__func.html#aa610d641940ef4a567aef884dd0b32da">data</a>)
<a name="l00430"></a>00430                             + actbeam.<a class="code" href="structbeam.html#a54c64670a8b3e8732c1468d156ddb0ca">refpoint</a>.<a class="code" href="structd__point.html#ad9846a025508bf8873a501ca5fcefbf4">y</a>+0.5);
<a name="l00431"></a>00431       
<a name="l00432"></a>00432       <span class="comment">// determine the interpolation points</span>
<a name="l00433"></a>00433       <span class="comment">// around the trace</span>
<a name="l00434"></a>00434       yvec = <a class="code" href="spc__back_8c.html#a55bae5da45fa33dec8efc0f57981f1e4">get_interp_points</a>(obs, bck_mask, npoints, tpoint);
<a name="l00435"></a>00435 
<a name="l00436"></a>00436       <span class="comment">//-----------------------------------------------------------------</span>
<a name="l00437"></a>00437       <span class="comment">//   some code for FORS2 MXU</span>
<a name="l00438"></a>00438       <span class="comment">//      if (actbeam.backwindow.x &lt; 0.0)</span>
<a name="l00439"></a>00439       <span class="comment">//        yvec = get_interp_points(obs, bck_mask, npoints, tpoint);</span>
<a name="l00440"></a>00440       <span class="comment">//      else</span>
<a name="l00441"></a>00441       <span class="comment">//        yvec = get_window_points(obs, bck_mask, actbeam, tpoint);</span>
<a name="l00442"></a>00442         
<a name="l00443"></a>00443 
<a name="l00444"></a>00444       <span class="comment">// give a warning and go to the next</span>
<a name="l00445"></a>00445       <span class="comment">// column if there are no background points</span>
<a name="l00446"></a>00446       <span class="keywordflow">if</span> (!yvec)
<a name="l00447"></a>00447         {
<a name="l00448"></a>00448           <a class="code" href="aXe__errors_8c.html#a7ef7588e5f91237ba7ce4084e6ed3c11">aXe_message</a> (<a class="code" href="aXe__errors_8h.html#a3f3c2d017ceaf0b51cfb71efbcaeff44">aXe_M_WARN4</a>, __FILE__, __LINE__,
<a name="l00449"></a>00449                        <span class="stringliteral">&quot;No backgound points could be found for beam %C. &quot;</span>
<a name="l00450"></a>00450                        <span class="stringliteral">&quot;at collumn %d %d&quot;</span>,
<a name="l00451"></a>00451                        <a class="code" href="aXe__grism_8h.html#a7d90dabb6016bb0e09b6ab84087b70a7">BEAM</a>(actbeam.<a class="code" href="structbeam.html#a5c3f06b67e4cc3c79be539d1b515f3c6">ID</a>), i, tpoint.<a class="code" href="structpx__point.html#a2d02b900722a71f22a8d5100822bda61">y</a> );
<a name="l00452"></a>00452           <span class="keywordflow">continue</span>;
<a name="l00453"></a>00453         }
<a name="l00454"></a>00454 
<a name="l00455"></a>00455       <span class="comment">// extract maximum and minimum 0f the y-values</span>
<a name="l00456"></a>00456       min_y = gsl_vector_int_get(yvec, 0);
<a name="l00457"></a>00457       max_y = gsl_vector_int_get(yvec, yvec-&gt;size-1);
<a name="l00458"></a>00458       <span class="comment">//      if (actbeam.backwindow.x == 23.3 &amp;&amp; actbeam.backwindow.y == 4.0)</span>
<a name="l00459"></a>00459       <span class="comment">//        {</span>
<a name="l00460"></a>00460           <span class="comment">//    fprintf(stdout, &quot;%i &lt;--&gt; %i; &quot;, min_y, max_y);</span>
<a name="l00461"></a>00461       <span class="comment">//      if (min_y &gt; tpoint.y - actbeam.width </span>
<a name="l00462"></a>00462       <span class="comment">//          || max_y &lt; tpoint.y + actbeam.width)</span>
<a name="l00463"></a>00463       <span class="comment">//        fprintf(stdout, &quot;%i %f &lt;--&gt; %f %i;  &quot;, min_y, tpoint.y - actbeam.width,</span>
<a name="l00464"></a>00464       <span class="comment">//                tpoint.y + actbeam.width, max_y);</span>
<a name="l00465"></a>00465               <span class="comment">//        }</span>
<a name="l00466"></a>00466 
<a name="l00467"></a>00467       <span class="comment">// determine the size of the double vectors</span>
<a name="l00468"></a>00468       <span class="comment">// to make the background determination</span>
<a name="l00469"></a>00469       <span class="comment">// allocater the space and initialize</span>
<a name="l00470"></a>00470       <span class="comment">// all values to default</span>
<a name="l00471"></a>00471       n = max_y - min_y + 1;
<a name="l00472"></a>00472       ys = (<span class="keywordtype">double</span> *) malloc (n * <span class="keyword">sizeof</span> (<span class="keywordtype">double</span>));
<a name="l00473"></a>00473       fs = (<span class="keywordtype">double</span> *) malloc (n * <span class="keyword">sizeof</span> (<span class="keywordtype">double</span>));
<a name="l00474"></a>00474       ws = (<span class="keywordtype">double</span> *) malloc (n * <span class="keyword">sizeof</span> (<span class="keywordtype">double</span>));
<a name="l00475"></a>00475       yi = (<span class="keywordtype">double</span> *) malloc (n * <span class="keyword">sizeof</span> (<span class="keywordtype">double</span>));
<a name="l00476"></a>00476       <span class="keywordflow">for</span> (ii = 0; ii &lt; n; ii++)
<a name="l00477"></a>00477         {
<a name="l00478"></a>00478           ys[ii] = min_y + ii;
<a name="l00479"></a>00479           fs[ii] = 0.0;
<a name="l00480"></a>00480           ws[ii] = 0.0;
<a name="l00481"></a>00481         }
<a name="l00482"></a>00482 
<a name="l00483"></a>00483 
<a name="l00484"></a>00484       <span class="comment">// transfer the values from the image column</span>
<a name="l00485"></a>00485       <span class="comment">// to the double vectors, set the weight</span>
<a name="l00486"></a>00486       <span class="keywordflow">for</span> (ii = 0; ii &lt; yvec-&gt;size; ii++)
<a name="l00487"></a>00487         {
<a name="l00488"></a>00488           <span class="comment">// extract the row number </span>
<a name="l00489"></a>00489           j = gsl_vector_int_get (yvec, ii);
<a name="l00490"></a>00490 
<a name="l00491"></a>00491           <span class="comment">// check whether the row is inside the imag</span>
<a name="l00492"></a>00492           <span class="comment">// and whether the is no object on the pixel</span>
<a name="l00493"></a>00493           <span class="keywordflow">if</span> ((j != -1) &amp;&amp; (j != obs-&gt;<a class="code" href="structobservation.html#a012c0ff489fbb74fc6c9abfbd7c6e320">grism</a>-&gt;size2)
<a name="l00494"></a>00494               &amp;&amp; !<a class="code" href="aXe__grism_8h.html#acf709ee71c580f1cd65d726ed03200ea">gsl_matrix_get</a>(bck_mask, tpoint.<a class="code" href="structpx__point.html#ab715a558731a820a25b50bd7797dd004">x</a>, j))
<a name="l00495"></a>00495             {
<a name="l00496"></a>00496               <span class="comment">// set the values and the weight</span>
<a name="l00497"></a>00497               fs[j - min_y] = <a class="code" href="aXe__grism_8h.html#acf709ee71c580f1cd65d726ed03200ea">gsl_matrix_get</a> (obs-&gt;<a class="code" href="structobservation.html#a012c0ff489fbb74fc6c9abfbd7c6e320">grism</a>, tpoint.<a class="code" href="structpx__point.html#ab715a558731a820a25b50bd7797dd004">x</a>, j);
<a name="l00498"></a>00498               ws[j - min_y] = <a class="code" href="aXe__grism_8h.html#acf709ee71c580f1cd65d726ed03200ea">gsl_matrix_get</a> (obs-&gt;<a class="code" href="structobservation.html#a79ef486b081fa7b1973c39323f163010">pixerrs</a>, tpoint.<a class="code" href="structpx__point.html#ab715a558731a820a25b50bd7797dd004">x</a>, j);
<a name="l00499"></a>00499             }
<a name="l00500"></a>00500         }
<a name="l00501"></a>00501 
<a name="l00502"></a>00502       <span class="comment">// iterate on the background points to</span>
<a name="l00503"></a>00503       <span class="comment">// reject e.g. cosmics</span>
<a name="l00504"></a>00504       <span class="keywordflow">if</span> (niter_med &gt; 0 || niter_fit &gt; 0)
<a name="l00505"></a>00505         {
<a name="l00506"></a>00506           <span class="comment">// iterate on the median</span>
<a name="l00507"></a>00507           <span class="keywordflow">for</span> (j=0; j &lt; niter_med; j++)
<a name="l00508"></a>00508             <a class="code" href="spc__back_8c.html#afe2e18a7ee7b967b8d71d7e1fb316ea7">kappa_sigma_clipp</a>(ys, fs,ws, n,kappa, obs, tpoint.<a class="code" href="structpx__point.html#ab715a558731a820a25b50bd7797dd004">x</a>);
<a name="l00509"></a>00509 
<a name="l00510"></a>00510           <span class="comment">// iterate on the fit</span>
<a name="l00511"></a>00511           <span class="keywordflow">if</span> (niter_fit &gt; 0)
<a name="l00512"></a>00512             <a class="code" href="spc__back_8c.html#a135c17132984f8af8cf6d4f13ee9dbb7">comp_kappasigma_interp</a>( ys, fs, ws, n, interporder,
<a name="l00513"></a>00513                                     niter_fit, kappa, obs, tpoint.<a class="code" href="structpx__point.html#ab715a558731a820a25b50bd7797dd004">x</a>);
<a name="l00514"></a>00514         }
<a name="l00515"></a>00515 
<a name="l00516"></a>00516       <span class="comment">// do the final background determination</span>
<a name="l00517"></a>00517       <a class="code" href="spc__back_8c.html#a17d5c8763243b26091aceb119ac98557">comp_vector_interp</a>( ys, fs, ws, yi, n, interporder, 1);
<a name="l00518"></a>00518   
<a name="l00519"></a>00519       <span class="comment">// copy the intepolated values </span>
<a name="l00520"></a>00520       <span class="comment">// to the background matrix</span>
<a name="l00521"></a>00521       <span class="keywordflow">for</span> (j = 0; j &lt; n; j++)
<a name="l00522"></a>00522         {
<a name="l00523"></a>00523           <span class="keywordflow">if</span> ((ys[j] &lt; 0) || (ys[j] &gt;= obs-&gt;<a class="code" href="structobservation.html#a012c0ff489fbb74fc6c9abfbd7c6e320">grism</a>-&gt;size2))
<a name="l00524"></a>00524             <span class="keywordflow">continue</span>;
<a name="l00525"></a>00525           <a class="code" href="aXe__grism_8h.html#a1f386ef5cd5a3b916246c2bee80f083a">gsl_matrix_set</a> (fib-&gt;<a class="code" href="structfullimg__background.html#aa7b506968cfc22160ce55d63121311c4">bck</a>, tpoint.<a class="code" href="structpx__point.html#ab715a558731a820a25b50bd7797dd004">x</a>, (<span class="keywordtype">int</span>) floor (ys[j]), fs[j]);
<a name="l00526"></a>00526           <a class="code" href="aXe__grism_8h.html#a1f386ef5cd5a3b916246c2bee80f083a">gsl_matrix_set</a> (fib-&gt;<a class="code" href="structfullimg__background.html#a6c52119d1f340304f50e8f4b99ab89dc">err</a>, tpoint.<a class="code" href="structpx__point.html#ab715a558731a820a25b50bd7797dd004">x</a>, (<span class="keywordtype">int</span>) floor (ys[j]), ws[j]);
<a name="l00527"></a>00527         }
<a name="l00528"></a>00528 
<a name="l00529"></a>00529       <span class="comment">// release memory</span>
<a name="l00530"></a>00530       free (ys);
<a name="l00531"></a>00531       ys = NULL;
<a name="l00532"></a>00532       free (fs);
<a name="l00533"></a>00533       fs = NULL;
<a name="l00534"></a>00534       free (yi);
<a name="l00535"></a>00535       yi = NULL;
<a name="l00536"></a>00536       free (ws);
<a name="l00537"></a>00537       ws = NULL;
<a name="l00538"></a>00538 
<a name="l00539"></a>00539       <span class="comment">// release memory</span>
<a name="l00540"></a>00540       gsl_vector_int_free(yvec);
<a name="l00541"></a>00541     }
<a name="l00542"></a>00542 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ae8622f5f1124511fcbc7ddf2205d4e0f"></a><!-- doxytag: member="spc_back.c::compute_backsub_mask" ref="ae8622f5f1124511fcbc7ddf2205d4e0f" args="(observation *obs, object **oblist)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structs__background.html">background</a>* compute_backsub_mask </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structobservation.html">observation</a> *&nbsp;</td>
          <td class="paramname"> <em>obs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structobject.html">object</a> **&nbsp;</td>
          <td class="paramname"> <em>oblist</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Function: compute_backsub_mask Computes a mask image for the background subtraction. All pixels covered by at least one <a class="el" href="structbeam.html">beam</a> are set to a vale -100000 to distinguish them from pixels which are part of the background.</p>
<p>Parameters: </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>obs</em>&nbsp;</td><td>a pointer to the <a class="el" href="structobservation.html">observation</a> structure to fill out </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>oblist</em>&nbsp;</td><td>a list of all objects of the <a class="el" href="structobservation.html">observation</a> </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>npoints</em>&nbsp;</td><td>number of points to examine when fitting the background </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>interporder</em>&nbsp;</td><td>order of the polynomial to fit to the background</td></tr>
  </table>
  </dd>
</dl>
<p>Returns: </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>an allocated background structure </dd></dl>

<p><div class="fragment"><pre class="fragment"><a name="l01144"></a>01144 {
<a name="l01145"></a>01145   <a class="code" href="structfullimg__background.html">fullimg_background</a> *fib;<span class="comment">// = malloc (sizeof (fullimg_background));</span>
<a name="l01146"></a>01146   <a class="code" href="structs__background.html">background</a> *backg; <span class="comment">// = malloc (sizeof (background));</span>
<a name="l01147"></a>01147   <a class="code" href="aXe__grism_8h.html#a6117e17bb3108107676f4486e62d40e5">gsl_matrix</a> *bck_mask;
<a name="l01148"></a>01148   <span class="keywordtype">int</span> i, j;
<a name="l01149"></a>01149   <span class="comment">//object *const *obp;</span>
<a name="l01150"></a>01150   <span class="comment">//int tnbeams;</span>
<a name="l01151"></a>01151   
<a name="l01152"></a>01152   <span class="comment">// make the mask image</span>
<a name="l01153"></a>01153   bck_mask = <a class="code" href="spc__back_8c.html#a84505bc11501c5f2abc6c1f45d68e79b">aperture_mask</a>(obs,oblist);
<a name="l01154"></a>01154 
<a name="l01155"></a>01155   <span class="comment">// allocate memory for the return structure</span>
<a name="l01156"></a>01156   <span class="comment">// and fill in some dummy values</span>
<a name="l01157"></a>01157   fib = malloc (<span class="keyword">sizeof</span> (<a class="code" href="structfullimg__background.html">fullimg_background</a>));
<a name="l01158"></a>01158   fib-&gt;<a class="code" href="structfullimg__background.html#aa7b506968cfc22160ce55d63121311c4">bck</a> = <a class="code" href="aXe__grism_8h.html#a1214ab1bea5fd80474d7a27db0bfb429">gsl_matrix_alloc</a> (obs-&gt;<a class="code" href="structobservation.html#a012c0ff489fbb74fc6c9abfbd7c6e320">grism</a>-&gt;size1, obs-&gt;<a class="code" href="structobservation.html#a012c0ff489fbb74fc6c9abfbd7c6e320">grism</a>-&gt;size2);
<a name="l01159"></a>01159   <a class="code" href="aXe__grism_8h.html#af6161aeb008a1ffa7d888df6ccbef7cc">gsl_matrix_set_all</a> (fib-&gt;<a class="code" href="structfullimg__background.html#aa7b506968cfc22160ce55d63121311c4">bck</a>, 0.);
<a name="l01160"></a>01160   fib-&gt;<a class="code" href="structfullimg__background.html#a6c52119d1f340304f50e8f4b99ab89dc">err</a> = NULL;
<a name="l01161"></a>01161 
<a name="l01162"></a>01162   <span class="comment">// allocate memory for the return structure</span>
<a name="l01163"></a>01163   backg = malloc (<span class="keyword">sizeof</span> (<a class="code" href="structs__background.html">background</a>));
<a name="l01164"></a>01164 
<a name="l01165"></a>01165   <span class="comment">// transfer the pixel values from the grism image</span>
<a name="l01166"></a>01166   <span class="comment">// to the mask image</span>
<a name="l01167"></a>01167   <span class="keywordflow">for</span> (i = 0; i &lt; fib-&gt;<a class="code" href="structfullimg__background.html#aa7b506968cfc22160ce55d63121311c4">bck</a>-&gt;size1; i++)
<a name="l01168"></a>01168     {
<a name="l01169"></a>01169       <span class="keywordflow">for</span> (j = 0; j &lt; fib-&gt;<a class="code" href="structfullimg__background.html#aa7b506968cfc22160ce55d63121311c4">bck</a>-&gt;size2; j++)
<a name="l01170"></a>01170         {
<a name="l01171"></a>01171           <a class="code" href="aXe__grism_8h.html#a1f386ef5cd5a3b916246c2bee80f083a">gsl_matrix_set</a> (fib-&gt;<a class="code" href="structfullimg__background.html#aa7b506968cfc22160ce55d63121311c4">bck</a>, i, j,
<a name="l01172"></a>01172                           <a class="code" href="aXe__grism_8h.html#acf709ee71c580f1cd65d726ed03200ea">gsl_matrix_get</a> (obs-&gt;<a class="code" href="structobservation.html#a012c0ff489fbb74fc6c9abfbd7c6e320">grism</a>, i, j));
<a name="l01173"></a>01173         }
<a name="l01174"></a>01174     }
<a name="l01175"></a>01175 
<a name="l01176"></a>01176   <span class="comment">// set pixels occupied by beams </span>
<a name="l01177"></a>01177   <span class="comment">// to the value -10000000</span>
<a name="l01178"></a>01178   <span class="keywordflow">for</span> (i = 0; i &lt; fib-&gt;<a class="code" href="structfullimg__background.html#aa7b506968cfc22160ce55d63121311c4">bck</a>-&gt;size1; i++)
<a name="l01179"></a>01179     {
<a name="l01180"></a>01180       <span class="keywordflow">for</span> (j = 0; j &lt; fib-&gt;<a class="code" href="structfullimg__background.html#aa7b506968cfc22160ce55d63121311c4">bck</a>-&gt;size2; j++)
<a name="l01181"></a>01181         {
<a name="l01182"></a>01182 
<a name="l01183"></a>01183           <span class="keywordflow">if</span> (<a class="code" href="aXe__grism_8h.html#acf709ee71c580f1cd65d726ed03200ea">gsl_matrix_get</a> (bck_mask, i, j))
<a name="l01184"></a>01184             <a class="code" href="aXe__grism_8h.html#a1f386ef5cd5a3b916246c2bee80f083a">gsl_matrix_set</a> (fib-&gt;<a class="code" href="structfullimg__background.html#aa7b506968cfc22160ce55d63121311c4">bck</a>, i, j, -1000000.0);
<a name="l01185"></a>01185         }
<a name="l01186"></a>01186     }
<a name="l01187"></a>01187 
<a name="l01188"></a>01188   <span class="comment">// release the dq-structure,</span>
<a name="l01189"></a>01189   <span class="comment">// otherwise it is saved to</span>
<a name="l01190"></a>01190   <span class="comment">// the mask image</span>
<a name="l01191"></a>01191   <span class="keywordflow">if</span> (obs-&gt;<a class="code" href="structobservation.html#a6698fa09a4524a5928ad9f98d620ba4e">dq</a> != NULL)
<a name="l01192"></a>01192     {
<a name="l01193"></a>01193       <a class="code" href="aXe__grism_8h.html#a61aa1d37853a90711852146f18d0b85f">gsl_matrix_free</a> (obs-&gt;<a class="code" href="structobservation.html#a6698fa09a4524a5928ad9f98d620ba4e">dq</a>);
<a name="l01194"></a>01194       obs-&gt;<a class="code" href="structobservation.html#a6698fa09a4524a5928ad9f98d620ba4e">dq</a>=NULL;
<a name="l01195"></a>01195     } 
<a name="l01196"></a>01196 
<a name="l01197"></a>01197   <span class="comment">// release memory</span>
<a name="l01198"></a>01198   <a class="code" href="aXe__grism_8h.html#a61aa1d37853a90711852146f18d0b85f">gsl_matrix_free</a>(bck_mask);
<a name="l01199"></a>01199 
<a name="l01200"></a>01200   <span class="comment">// assemble the return structure</span>
<a name="l01201"></a>01201   backg-&gt;<a class="code" href="structs__background.html#a4d8837d7be9de01330a6fb4c24a2bf75">pars</a> = fib;
<a name="l01202"></a>01202   backg-&gt;<a class="code" href="structs__background.html#ab2dc7068b6aff54492caa363238c372e">bck_func</a> = &amp;<a class="code" href="spc__back_8c.html#a312989afed586d6646f6c5e46d94c5b2">fullimg_background_function</a>;
<a name="l01203"></a>01203 
<a name="l01204"></a>01204   <span class="comment">// return the result</span>
<a name="l01205"></a>01205   <span class="keywordflow">return</span> backg;
<a name="l01206"></a>01206 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ad1ce027d8c85366289610daf4ee9ac12"></a><!-- doxytag: member="spc_back.c::compute_efactor" ref="ad1ce027d8c85366289610daf4ee9ac12" args="(const double fwhm)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double compute_efactor </td>
          <td>(</td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>fwhm</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Function: compute_efactor The function computes the appropriate factor of the Gaussian for any FWHM given as input. This speeds up any later computation of the Gaussian.</p>
<p>Parameters: </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>fwhm</em>&nbsp;</td><td>- the input FWHM</td></tr>
  </table>
  </dd>
</dl>
<p>Returns: </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>expfactor - the factor for the Gaussian </dd></dl>

<p><div class="fragment"><pre class="fragment"><a name="l01841"></a>01841 {
<a name="l01842"></a>01842   <span class="keywordtype">double</span> sigma;
<a name="l01843"></a>01843   <span class="keywordtype">double</span> expfactor;
<a name="l01844"></a>01844 
<a name="l01845"></a>01845   <span class="comment">// get the sigma value [sig = fwhm / (2 sqrt(2 ln(2)))]</span>
<a name="l01846"></a>01846   sigma = fwhm / 2.3458;
<a name="l01847"></a>01847 
<a name="l01848"></a>01848   <span class="comment">// compute the factor for the Gaussian</span>
<a name="l01849"></a>01849   expfactor =  -1.0 / (2.0* sigma * sigma);
<a name="l01850"></a>01850 
<a name="l01851"></a>01851   <span class="comment">// return the factor</span>
<a name="l01852"></a>01852   <span class="keywordflow">return</span> expfactor;
<a name="l01853"></a>01853 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ac8525170561017c1ebf7946f1e37b57b"></a><!-- doxytag: member="spc_back.c::compute_fullimg_background" ref="ac8525170561017c1ebf7946f1e37b57b" args="(observation *obs, object **oblist, int npoints, int interporder, const int niter_med, const int niter_fit, const double kappa, int nor_flag, const int sm_length, const double fwhm)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structs__background.html">background</a>* compute_fullimg_background </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structobservation.html">observation</a> *&nbsp;</td>
          <td class="paramname"> <em>obs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structobject.html">object</a> **&nbsp;</td>
          <td class="paramname"> <em>oblist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>npoints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>interporder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>niter_med</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>niter_fit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>kappa</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>nor_flag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>sm_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>fwhm</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Function: compute_fullimg_background Computes a background image. All beams with ignore=1 are completely ignored. Anything else is not.</p>
<p>Parameters: </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>obs</em>&nbsp;</td><td>- a pointer to the <a class="el" href="structobservation.html">observation</a> structure to fill out </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>oblist</em>&nbsp;</td><td>- a list of all objects of the <a class="el" href="structobservation.html">observation</a> </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>npoints</em>&nbsp;</td><td>- number of points to examine when fitting the background </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>interporder</em>&nbsp;</td><td>- order of the polynomial to fit to the background </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>niter_med</em>&nbsp;</td><td>- order of the polynomial to fit to the background </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>niter_fit</em>&nbsp;</td><td>- order of the polynomial to fit to the background </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>kappa</em>&nbsp;</td><td>- order of the polynomial to fit to the background</td></tr>
  </table>
  </dd>
</dl>
<p>Returns: </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>background - an allocated background structure </dd></dl>

<p><div class="fragment"><pre class="fragment"><a name="l01025"></a>01025 {
<a name="l01026"></a>01026   <a class="code" href="structfullimg__background.html">fullimg_background</a> *fib;
<a name="l01027"></a>01027   <a class="code" href="structs__background.html">background</a> *backg;
<a name="l01028"></a>01028   <a class="code" href="aXe__grism_8h.html#a6117e17bb3108107676f4486e62d40e5">gsl_matrix</a> *bck_mask;
<a name="l01029"></a>01029   <span class="keywordtype">int</span> i, j;
<a name="l01030"></a>01030   <span class="comment">//object *const *obp;</span>
<a name="l01031"></a>01031 
<a name="l01032"></a>01032   <span class="comment">// allocate space for the backgrounds</span>
<a name="l01033"></a>01033   fib   = (<a class="code" href="structfullimg__background.html">fullimg_background</a> *)malloc (<span class="keyword">sizeof</span> (<a class="code" href="structfullimg__background.html">fullimg_background</a>));
<a name="l01034"></a>01034   fib-&gt;<a class="code" href="structfullimg__background.html#aa7b506968cfc22160ce55d63121311c4">bck</a> = <a class="code" href="aXe__grism_8h.html#a1214ab1bea5fd80474d7a27db0bfb429">gsl_matrix_alloc</a> (obs-&gt;<a class="code" href="structobservation.html#a012c0ff489fbb74fc6c9abfbd7c6e320">grism</a>-&gt;size1, obs-&gt;<a class="code" href="structobservation.html#a012c0ff489fbb74fc6c9abfbd7c6e320">grism</a>-&gt;size2);
<a name="l01035"></a>01035   <a class="code" href="aXe__grism_8h.html#af6161aeb008a1ffa7d888df6ccbef7cc">gsl_matrix_set_all</a> (fib-&gt;<a class="code" href="structfullimg__background.html#aa7b506968cfc22160ce55d63121311c4">bck</a>, 0.);
<a name="l01036"></a>01036   fib-&gt;<a class="code" href="structfullimg__background.html#a6c52119d1f340304f50e8f4b99ab89dc">err</a> = <a class="code" href="aXe__grism_8h.html#a1214ab1bea5fd80474d7a27db0bfb429">gsl_matrix_alloc</a> (obs-&gt;<a class="code" href="structobservation.html#a012c0ff489fbb74fc6c9abfbd7c6e320">grism</a>-&gt;size1, obs-&gt;<a class="code" href="structobservation.html#a012c0ff489fbb74fc6c9abfbd7c6e320">grism</a>-&gt;size2);
<a name="l01037"></a>01037   <a class="code" href="aXe__grism_8h.html#af6161aeb008a1ffa7d888df6ccbef7cc">gsl_matrix_set_all</a> (fib-&gt;<a class="code" href="structfullimg__background.html#a6c52119d1f340304f50e8f4b99ab89dc">err</a>, 0.);
<a name="l01038"></a>01038 
<a name="l01039"></a>01039   <span class="keywordflow">if</span> (nor_flag)
<a name="l01040"></a>01040     {
<a name="l01041"></a>01041       <span class="keywordflow">for</span> (i = 0; i &lt; fib-&gt;<a class="code" href="structfullimg__background.html#aa7b506968cfc22160ce55d63121311c4">bck</a>-&gt;size1; i++)
<a name="l01042"></a>01042         {
<a name="l01043"></a>01043           <span class="keywordflow">for</span> (j = 0; j &lt; fib-&gt;<a class="code" href="structfullimg__background.html#aa7b506968cfc22160ce55d63121311c4">bck</a>-&gt;size2; j++)
<a name="l01044"></a>01044             {
<a name="l01045"></a>01045               <a class="code" href="aXe__grism_8h.html#a1f386ef5cd5a3b916246c2bee80f083a">gsl_matrix_set</a> (fib-&gt;<a class="code" href="structfullimg__background.html#aa7b506968cfc22160ce55d63121311c4">bck</a>, i, j,
<a name="l01046"></a>01046                               <a class="code" href="aXe__grism_8h.html#acf709ee71c580f1cd65d726ed03200ea">gsl_matrix_get</a> (obs-&gt;<a class="code" href="structobservation.html#a012c0ff489fbb74fc6c9abfbd7c6e320">grism</a>, i, j));
<a name="l01047"></a>01047               <a class="code" href="aXe__grism_8h.html#a1f386ef5cd5a3b916246c2bee80f083a">gsl_matrix_set</a> (fib-&gt;<a class="code" href="structfullimg__background.html#a6c52119d1f340304f50e8f4b99ab89dc">err</a>, i, j,
<a name="l01048"></a>01048                               <a class="code" href="aXe__grism_8h.html#acf709ee71c580f1cd65d726ed03200ea">gsl_matrix_get</a> (obs-&gt;<a class="code" href="structobservation.html#a79ef486b081fa7b1973c39323f163010">pixerrs</a>, i, j));
<a name="l01049"></a>01049             }
<a name="l01050"></a>01050         }
<a name="l01051"></a>01051     }
<a name="l01052"></a>01052 
<a name="l01053"></a>01053   <span class="comment">// allocate memory</span>
<a name="l01054"></a>01054   backg = (<a class="code" href="structs__background.html">background</a> *)malloc (<span class="keyword">sizeof</span> (<a class="code" href="structs__background.html">background</a>));
<a name="l01055"></a>01055 
<a name="l01056"></a>01056   <span class="comment">// create the mask image</span>
<a name="l01057"></a>01057   bck_mask = <a class="code" href="spc__back_8c.html#a84505bc11501c5f2abc6c1f45d68e79b">aperture_mask</a>(obs,oblist);
<a name="l01058"></a>01058 
<a name="l01059"></a>01059   <span class="comment">// in case that pixels may get dq values,</span>
<a name="l01060"></a>01060   <span class="comment">// make sure that there will be a dq-array</span>
<a name="l01061"></a>01061   <span class="comment">//  if (niter_med &gt; 0 || niter_fit &gt; 0)</span>
<a name="l01062"></a>01062   <span class="comment">//    {</span>
<a name="l01063"></a>01063   <span class="keywordflow">if</span> (!obs-&gt;<a class="code" href="structobservation.html#a6698fa09a4524a5928ad9f98d620ba4e">dq</a>)
<a name="l01064"></a>01064     obs-&gt;<a class="code" href="structobservation.html#a6698fa09a4524a5928ad9f98d620ba4e">dq</a> = <a class="code" href="aXe__grism_8h.html#a1214ab1bea5fd80474d7a27db0bfb429">gsl_matrix_alloc</a> (obs-&gt;<a class="code" href="structobservation.html#a012c0ff489fbb74fc6c9abfbd7c6e320">grism</a>-&gt;size1, obs-&gt;<a class="code" href="structobservation.html#a012c0ff489fbb74fc6c9abfbd7c6e320">grism</a>-&gt;size2);
<a name="l01065"></a>01065 
<a name="l01066"></a>01066   <span class="comment">// initialize the dq-array</span>
<a name="l01067"></a>01067   <span class="comment">//      gsl_matrix_set_all (obs-&gt;dq, 0.0);</span>
<a name="l01068"></a>01068   <span class="comment">//    }</span>
<a name="l01069"></a>01069   
<a name="l01070"></a>01070   <span class="keywordflow">if</span> (oblist != NULL)
<a name="l01071"></a>01071     {
<a name="l01072"></a>01072       <span class="comment">// Now compute background for each beam, one after the other</span>
<a name="l01073"></a>01073       <span class="comment">// go over the whole object list</span>
<a name="l01074"></a>01074       i=0;
<a name="l01075"></a>01075       <span class="keywordflow">while</span> (oblist[i] != NULL) {
<a name="l01076"></a>01076         <span class="comment">// go over each beam</span>
<a name="l01077"></a>01077         <span class="keywordflow">for</span> (j = 0; j &lt; oblist[i]-&gt;<a class="code" href="structobject.html#a14120e3b048a2118f7acd75ea1571c60">nbeams</a>; j++)
<a name="l01078"></a>01078           {
<a name="l01079"></a>01079             <span class="comment">// check for beams to be neglected</span>
<a name="l01080"></a>01080             <span class="keywordflow">if</span> (oblist[i]-&gt;beams[j].ignore == 1)
<a name="l01081"></a>01081               {
<a name="l01082"></a>01082                 <span class="keywordflow">continue</span>;
<a name="l01083"></a>01083               }
<a name="l01084"></a>01084             <span class="keywordflow">else</span>
<a name="l01085"></a>01085               {
<a name="l01086"></a>01086                 <span class="comment">// start the background interpolation</span>
<a name="l01087"></a>01087                 <span class="comment">// for a specific beam</span>
<a name="l01088"></a>01088                 fprintf(stdout,<span class="stringliteral">&quot;Computing background of BEAM %d%c.&quot;</span>,
<a name="l01089"></a>01089                         oblist[i]-&gt;ID,<a class="code" href="aXe__grism_8h.html#a7d90dabb6016bb0e09b6ab84087b70a7">BEAM</a>(oblist[i]-&gt;beams[j].ID));
<a name="l01090"></a>01090                 <a class="code" href="spc__back_8c.html#ad45826f8c0ede1b55ed2f5d6fd67e875">compute_background</a>(obs, oblist[i]-&gt;beams[j], bck_mask,
<a name="l01091"></a>01091                                    fib, npoints, interporder, niter_med,
<a name="l01092"></a>01092                                    niter_fit, kappa);
<a name="l01093"></a>01093                 fprintf(stdout,<span class="stringliteral">&quot; Done.\n&quot;</span>);
<a name="l01094"></a>01094               }     
<a name="l01095"></a>01095           }
<a name="l01096"></a>01096         <span class="comment">// increment the counter</span>
<a name="l01097"></a>01097         i++;
<a name="l01098"></a>01098       }
<a name="l01099"></a>01099     }
<a name="l01100"></a>01100   <span class="comment">// replace all NAN&apos;s with values 0.0</span>
<a name="l01101"></a>01101   <span class="keywordflow">for</span> (i = 0; i &lt; fib-&gt;<a class="code" href="structfullimg__background.html#aa7b506968cfc22160ce55d63121311c4">bck</a>-&gt;size1; i++)
<a name="l01102"></a>01102     {
<a name="l01103"></a>01103       <span class="keywordflow">for</span> (j = 0; j &lt; fib-&gt;<a class="code" href="structfullimg__background.html#aa7b506968cfc22160ce55d63121311c4">bck</a>-&gt;size2; j++)
<a name="l01104"></a>01104         {
<a name="l01105"></a>01105           <span class="keywordflow">if</span>(isnan(<a class="code" href="aXe__grism_8h.html#acf709ee71c580f1cd65d726ed03200ea">gsl_matrix_get</a> (fib-&gt;<a class="code" href="structfullimg__background.html#aa7b506968cfc22160ce55d63121311c4">bck</a>, i, j))) 
<a name="l01106"></a>01106             <a class="code" href="aXe__grism_8h.html#a1f386ef5cd5a3b916246c2bee80f083a">gsl_matrix_set</a> (fib-&gt;<a class="code" href="structfullimg__background.html#aa7b506968cfc22160ce55d63121311c4">bck</a>, i, j,0.0);
<a name="l01107"></a>01107           <span class="keywordflow">if</span>(isnan(<a class="code" href="aXe__grism_8h.html#acf709ee71c580f1cd65d726ed03200ea">gsl_matrix_get</a> (fib-&gt;<a class="code" href="structfullimg__background.html#a6c52119d1f340304f50e8f4b99ab89dc">err</a>, i, j))) 
<a name="l01108"></a>01108             <a class="code" href="aXe__grism_8h.html#a1f386ef5cd5a3b916246c2bee80f083a">gsl_matrix_set</a> (fib-&gt;<a class="code" href="structfullimg__background.html#a6c52119d1f340304f50e8f4b99ab89dc">err</a>, i, j,0.0);
<a name="l01109"></a>01109         }
<a name="l01110"></a>01110     }
<a name="l01111"></a>01111 
<a name="l01112"></a>01112   <span class="keywordflow">if</span> (sm_length &amp;&amp; fwhm)
<a name="l01113"></a>01113     <a class="code" href="spc__back_8c.html#a7e25af7fc45ffda6d9b8c6612219a32f">gsmooth_background</a> (bck_mask, sm_length, fwhm, fib);
<a name="l01114"></a>01114 
<a name="l01115"></a>01115   <span class="comment">// put together the result</span>
<a name="l01116"></a>01116   backg-&gt;<a class="code" href="structs__background.html#a4d8837d7be9de01330a6fb4c24a2bf75">pars</a> = fib;
<a name="l01117"></a>01117   backg-&gt;<a class="code" href="structs__background.html#ab2dc7068b6aff54492caa363238c372e">bck_func</a> = &amp;<a class="code" href="spc__back_8c.html#a312989afed586d6646f6c5e46d94c5b2">fullimg_background_function</a>;
<a name="l01118"></a>01118 
<a name="l01119"></a>01119   <span class="comment">// free space</span>
<a name="l01120"></a>01120   <a class="code" href="aXe__grism_8h.html#a61aa1d37853a90711852146f18d0b85f">gsl_matrix_free</a>(bck_mask);
<a name="l01121"></a>01121 
<a name="l01122"></a>01122   <span class="comment">// return the result</span>
<a name="l01123"></a>01123   <span class="keywordflow">return</span> backg;
<a name="l01124"></a>01124 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="af64d42951a54cd249fcbb6f793096acd"></a><!-- doxytag: member="spc_back.c::compute_fullimg_global_background" ref="af64d42951a54cd249fcbb6f793096acd" args="(observation *obs, object **oblist, int interporder, const int sm_length, const double fwhm)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structs__background.html">background</a>* compute_fullimg_global_background </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structobservation.html">observation</a> *&nbsp;</td>
          <td class="paramname"> <em>obs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structobject.html">object</a> **&nbsp;</td>
          <td class="paramname"> <em>oblist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>interporder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>sm_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>fwhm</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Function: compute_fullimg_global_background The subroutine computes the background image based on all pixels in a column which are not part of an <a class="el" href="structobject.html">object</a>.</p>
<p>Parameters: </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>obs</em>&nbsp;</td><td>- a pointer to the <a class="el" href="structobservation.html">observation</a> structure to fill out </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>oblist</em>&nbsp;</td><td>- a list of all objects of the <a class="el" href="structobservation.html">observation</a> </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>interporder</em>&nbsp;</td><td>- order of the polynomial to fit to the background</td></tr>
  </table>
  </dd>
</dl>
<p>Returns: </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>background - an allocated background structure </dd></dl>

<p><div class="fragment"><pre class="fragment"><a name="l01226"></a>01226 {
<a name="l01227"></a>01227   <a class="code" href="structfullimg__background.html">fullimg_background</a> *fib;
<a name="l01228"></a>01228   <a class="code" href="structs__background.html">background</a> *backg;
<a name="l01229"></a>01229   <a class="code" href="aXe__grism_8h.html#a6117e17bb3108107676f4486e62d40e5">gsl_matrix</a> *bck_mask;
<a name="l01230"></a>01230   <span class="keywordtype">int</span> i, j;
<a name="l01231"></a>01231   <span class="keywordtype">object</span> *<span class="keyword">const</span> *obp;
<a name="l01232"></a>01232   <span class="keywordtype">int</span> tnbeams;
<a name="l01233"></a>01233   
<a name="l01234"></a>01234   <span class="comment">// allocate memory</span>
<a name="l01235"></a>01235   fib = (<a class="code" href="structfullimg__background.html">fullimg_background</a> *)malloc (<span class="keyword">sizeof</span> (<a class="code" href="structfullimg__background.html">fullimg_background</a>));
<a name="l01236"></a>01236   backg = (<a class="code" href="structs__background.html">background</a> *)malloc (<span class="keyword">sizeof</span> (<a class="code" href="structs__background.html">background</a>));
<a name="l01237"></a>01237 
<a name="l01238"></a>01238   <span class="comment">// allocate memory</span>
<a name="l01239"></a>01239   bck_mask = <a class="code" href="spc__back_8c.html#a84505bc11501c5f2abc6c1f45d68e79b">aperture_mask</a>(obs,oblist);
<a name="l01240"></a>01240   fib-&gt;<a class="code" href="structfullimg__background.html#aa7b506968cfc22160ce55d63121311c4">bck</a> = <a class="code" href="aXe__grism_8h.html#a1214ab1bea5fd80474d7a27db0bfb429">gsl_matrix_alloc</a> (obs-&gt;<a class="code" href="structobservation.html#a012c0ff489fbb74fc6c9abfbd7c6e320">grism</a>-&gt;size1, obs-&gt;<a class="code" href="structobservation.html#a012c0ff489fbb74fc6c9abfbd7c6e320">grism</a>-&gt;size2);
<a name="l01241"></a>01241   fib-&gt;<a class="code" href="structfullimg__background.html#a6c52119d1f340304f50e8f4b99ab89dc">err</a> = <a class="code" href="aXe__grism_8h.html#a1214ab1bea5fd80474d7a27db0bfb429">gsl_matrix_alloc</a> (obs-&gt;<a class="code" href="structobservation.html#a012c0ff489fbb74fc6c9abfbd7c6e320">grism</a>-&gt;size1, obs-&gt;<a class="code" href="structobservation.html#a012c0ff489fbb74fc6c9abfbd7c6e320">grism</a>-&gt;size2);
<a name="l01242"></a>01242 
<a name="l01243"></a>01243   <span class="comment">// initialize the new arrays</span>
<a name="l01244"></a>01244   <a class="code" href="aXe__grism_8h.html#af6161aeb008a1ffa7d888df6ccbef7cc">gsl_matrix_set_all</a> (fib-&gt;<a class="code" href="structfullimg__background.html#aa7b506968cfc22160ce55d63121311c4">bck</a>, 0.);
<a name="l01245"></a>01245   <a class="code" href="aXe__grism_8h.html#af6161aeb008a1ffa7d888df6ccbef7cc">gsl_matrix_set_all</a> (fib-&gt;<a class="code" href="structfullimg__background.html#a6c52119d1f340304f50e8f4b99ab89dc">err</a>, 0.);
<a name="l01246"></a>01246   
<a name="l01247"></a>01247   <span class="comment">/* Count beams in observation */</span>
<a name="l01248"></a>01248   <span class="keywordflow">if</span> (oblist!=NULL) 
<a name="l01249"></a>01249     {
<a name="l01250"></a>01250       tnbeams = 0;
<a name="l01251"></a>01251       <span class="keywordflow">for</span> (obp = oblist; *obp; obp++)
<a name="l01252"></a>01252         {
<a name="l01253"></a>01253           <span class="keywordflow">for</span> (i = 0; i &lt; (*obp)-&gt;nbeams; i++)
<a name="l01254"></a>01254             {
<a name="l01255"></a>01255               <span class="comment">// if (((*obp)-&gt;beams[i]).ignore!=1)</span>
<a name="l01256"></a>01256               tnbeams++; <span class="comment">/* Count ALL the beams */</span>
<a name="l01257"></a>01257             }
<a name="l01258"></a>01258         }
<a name="l01259"></a>01259     }
<a name="l01260"></a>01260   
<a name="l01261"></a>01261 
<a name="l01262"></a>01262   <span class="comment">/* Now compute global background using first beam grism info */</span>
<a name="l01263"></a>01263   <span class="keywordflow">if</span> (oblist != NULL) {
<a name="l01264"></a>01264     <a class="code" href="spc__back_8c.html#ac5915dcfa3d4bd357a95fcd4f827c3a1">compute_global_background</a> (oblist, 0, bck_mask,
<a name="l01265"></a>01265                                fib, interporder);
<a name="l01266"></a>01266   }
<a name="l01267"></a>01267 
<a name="l01268"></a>01268 
<a name="l01269"></a>01269   <span class="comment">// replace all NAN&apos;s with values 0.0</span>
<a name="l01270"></a>01270   <span class="keywordflow">for</span> (i = 0; i &lt; fib-&gt;<a class="code" href="structfullimg__background.html#aa7b506968cfc22160ce55d63121311c4">bck</a>-&gt;size1; i++)
<a name="l01271"></a>01271     {
<a name="l01272"></a>01272       <span class="keywordflow">for</span> (j = 0; j &lt; fib-&gt;<a class="code" href="structfullimg__background.html#aa7b506968cfc22160ce55d63121311c4">bck</a>-&gt;size2; j++)
<a name="l01273"></a>01273         {
<a name="l01274"></a>01274           <span class="keywordflow">if</span>(isnan(<a class="code" href="aXe__grism_8h.html#acf709ee71c580f1cd65d726ed03200ea">gsl_matrix_get</a> (fib-&gt;<a class="code" href="structfullimg__background.html#aa7b506968cfc22160ce55d63121311c4">bck</a>, i, j))) 
<a name="l01275"></a>01275             {
<a name="l01276"></a>01276               <a class="code" href="aXe__grism_8h.html#a1f386ef5cd5a3b916246c2bee80f083a">gsl_matrix_set</a> (fib-&gt;<a class="code" href="structfullimg__background.html#aa7b506968cfc22160ce55d63121311c4">bck</a>, i, j,0.0);
<a name="l01277"></a>01277             }
<a name="l01278"></a>01278           <span class="keywordflow">if</span>(isnan(<a class="code" href="aXe__grism_8h.html#acf709ee71c580f1cd65d726ed03200ea">gsl_matrix_get</a> (fib-&gt;<a class="code" href="structfullimg__background.html#a6c52119d1f340304f50e8f4b99ab89dc">err</a>, i, j))) 
<a name="l01279"></a>01279             {
<a name="l01280"></a>01280               <a class="code" href="aXe__grism_8h.html#a1f386ef5cd5a3b916246c2bee80f083a">gsl_matrix_set</a> (fib-&gt;<a class="code" href="structfullimg__background.html#a6c52119d1f340304f50e8f4b99ab89dc">err</a>, i, j,0.0);
<a name="l01281"></a>01281             }
<a name="l01282"></a>01282         }
<a name="l01283"></a>01283     }
<a name="l01284"></a>01284 
<a name="l01285"></a>01285   <span class="comment">// make a Gaussian smoothing</span>
<a name="l01286"></a>01286   <span class="comment">// if requested</span>
<a name="l01287"></a>01287   <span class="keywordflow">if</span> (sm_length &amp;&amp; fwhm)
<a name="l01288"></a>01288     <a class="code" href="spc__back_8c.html#a7e25af7fc45ffda6d9b8c6612219a32f">gsmooth_background</a> (bck_mask, sm_length, fwhm, fib);
<a name="l01289"></a>01289 
<a name="l01290"></a>01290   <span class="comment">// compose the result structure</span>
<a name="l01291"></a>01291   backg-&gt;<a class="code" href="structs__background.html#a4d8837d7be9de01330a6fb4c24a2bf75">pars</a> = fib;
<a name="l01292"></a>01292   backg-&gt;<a class="code" href="structs__background.html#ab2dc7068b6aff54492caa363238c372e">bck_func</a> = &amp;<a class="code" href="spc__back_8c.html#a312989afed586d6646f6c5e46d94c5b2">fullimg_background_function</a>;
<a name="l01293"></a>01293 
<a name="l01294"></a>01294   <span class="comment">// return the result</span>
<a name="l01295"></a>01295   <span class="keywordflow">return</span> backg;
<a name="l01296"></a>01296 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ac5915dcfa3d4bd357a95fcd4f827c3a1"></a><!-- doxytag: member="spc_back.c::compute_global_background" ref="ac5915dcfa3d4bd357a95fcd4f827c3a1" args="(object **oblist, const int obj_index, gsl_matrix *bck_mask, fullimg_background *fib, int interporder)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void compute_global_background </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structobject.html">object</a> **&nbsp;</td>
          <td class="paramname"> <em>oblist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>obj_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gsl_matrix *&nbsp;</td>
          <td class="paramname"> <em>bck_mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structfullimg__background.html">fullimg_background</a> *&nbsp;</td>
          <td class="paramname"> <em>fib</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>interporder</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><div class="fragment"><pre class="fragment"><a name="l00817"></a>00817 {
<a name="l00818"></a>00818   <span class="keywordtype">int</span> i, j, n;
<a name="l00819"></a>00819   <span class="keywordtype">double</span> *ys, *fs, *ws, *yi;
<a name="l00820"></a>00820   <span class="comment">//double *ws0;</span>
<a name="l00821"></a>00821   <a class="code" href="structobservation.html">observation</a> *grism = oblist[obj_index]-&gt;<a class="code" href="structobject.html#a90d2a68e430a65d8b022b7abd9491e3e">grism_obs</a>;
<a name="l00822"></a>00822   <span class="comment">//long ma;</span>
<a name="l00823"></a>00823   <span class="comment">//double var;</span>
<a name="l00824"></a>00824   
<a name="l00825"></a>00825   <span class="keywordflow">for</span> (i = 0; i &lt; grism-&gt;<a class="code" href="structobservation.html#a012c0ff489fbb74fc6c9abfbd7c6e320">grism</a>-&gt;size1; i++)
<a name="l00826"></a>00826     {                   
<a name="l00827"></a>00827       <span class="comment">/* Loop over the columns of interest */</span>
<a name="l00828"></a>00828       
<a name="l00829"></a>00829       n = grism-&gt;<a class="code" href="structobservation.html#a012c0ff489fbb74fc6c9abfbd7c6e320">grism</a>-&gt;size2;
<a name="l00830"></a>00830       
<a name="l00831"></a>00831       ys = (<span class="keywordtype">double</span> *) malloc (n * <span class="keyword">sizeof</span> (<span class="keywordtype">double</span>));
<a name="l00832"></a>00832       fs = (<span class="keywordtype">double</span> *) malloc (n * <span class="keyword">sizeof</span> (<span class="keywordtype">double</span>));
<a name="l00833"></a>00833       ws = (<span class="keywordtype">double</span> *) malloc (n * <span class="keyword">sizeof</span> (<span class="keywordtype">double</span>));
<a name="l00834"></a>00834       yi = (<span class="keywordtype">double</span> *) malloc (n * <span class="keyword">sizeof</span> (<span class="keywordtype">double</span>));
<a name="l00835"></a>00835 
<a name="l00836"></a>00836       <span class="keywordflow">for</span> (j = 0; j &lt; n; j++)
<a name="l00837"></a>00837         {
<a name="l00838"></a>00838           ys[j] = j;
<a name="l00839"></a>00839           fs[j] = 0.0;
<a name="l00840"></a>00840           ws[j] = 0.0;
<a name="l00841"></a>00841           <span class="keywordflow">if</span> ((<a class="code" href="aXe__grism_8h.html#acf709ee71c580f1cd65d726ed03200ea">gsl_matrix_get</a>(bck_mask,i,j)==0) &amp;&amp;
<a name="l00842"></a>00842               (!(isnan(<a class="code" href="aXe__grism_8h.html#acf709ee71c580f1cd65d726ed03200ea">gsl_matrix_get</a>(grism-&gt;<a class="code" href="structobservation.html#a012c0ff489fbb74fc6c9abfbd7c6e320">grism</a>, i,j)))))
<a name="l00843"></a>00843             {
<a name="l00844"></a>00844               fs[j]=<a class="code" href="aXe__grism_8h.html#acf709ee71c580f1cd65d726ed03200ea">gsl_matrix_get</a> (grism-&gt;<a class="code" href="structobservation.html#a012c0ff489fbb74fc6c9abfbd7c6e320">grism</a>,i,j);
<a name="l00845"></a>00845               ws[j]=<a class="code" href="aXe__grism_8h.html#acf709ee71c580f1cd65d726ed03200ea">gsl_matrix_get</a> (grism-&gt;<a class="code" href="structobservation.html#a012c0ff489fbb74fc6c9abfbd7c6e320">grism</a>,i,j);
<a name="l00846"></a>00846             }
<a name="l00847"></a>00847         }
<a name="l00848"></a>00848 
<a name="l00849"></a>00849                 
<a name="l00850"></a>00850       <span class="comment">/* Median the background */</span>
<a name="l00851"></a>00851       <span class="keywordflow">if</span> (interporder == -1)
<a name="l00852"></a>00852         {
<a name="l00853"></a>00853           <span class="keywordtype">double</span> *tmp, med, std;
<a name="l00854"></a>00854           <span class="keywordtype">int</span> nn = 0;
<a name="l00855"></a>00855           <span class="keywordflow">for</span> (j = 0; j &lt; n; j++)
<a name="l00856"></a>00856             {
<a name="l00857"></a>00857               <span class="keywordflow">if</span> (ws[j] != 0.0)
<a name="l00858"></a>00858                 {
<a name="l00859"></a>00859                   nn++;
<a name="l00860"></a>00860                 }
<a name="l00861"></a>00861             }
<a name="l00862"></a>00862           tmp = malloc (nn * <span class="keyword">sizeof</span> (<span class="keywordtype">double</span>));
<a name="l00863"></a>00863           nn = 0;
<a name="l00864"></a>00864           <span class="keywordflow">for</span> (j = 0; j &lt; n; j++)
<a name="l00865"></a>00865             {
<a name="l00866"></a>00866               <span class="keywordflow">if</span> (ws[j] != 0.0)
<a name="l00867"></a>00867                 {
<a name="l00868"></a>00868                   tmp[nn] = fs[j];
<a name="l00869"></a>00869                   nn++;
<a name="l00870"></a>00870                 }
<a name="l00871"></a>00871             }
<a name="l00872"></a>00872           gsl_sort (tmp, 1, nn);
<a name="l00873"></a>00873           med = gsl_stats_median_from_sorted_data (tmp, 1, nn);
<a name="l00874"></a>00874           std = gsl_stats_sd (tmp, 1, nn);
<a name="l00875"></a>00875           <span class="comment">//fprintf(stderr,&quot;med: %g\n&quot;,med);</span>
<a name="l00876"></a>00876           <span class="keywordflow">for</span> (j = 0; j &lt; n; j++)
<a name="l00877"></a>00877             {
<a name="l00878"></a>00878               <span class="keywordflow">if</span> (ws[j] == 0.0)
<a name="l00879"></a>00879                 {
<a name="l00880"></a>00880                   fs[j] = med;
<a name="l00881"></a>00881                   ws[j] = std;
<a name="l00882"></a>00882                 }
<a name="l00883"></a>00883               <span class="comment">//              else</span>
<a name="l00884"></a>00884               <span class="comment">//                {</span>
<a name="l00885"></a>00885               <span class="comment">//                  ws[j] = 1.0/sqrt(ws[j]);</span>
<a name="l00886"></a>00886               <span class="comment">//                }</span>
<a name="l00887"></a>00887             }
<a name="l00888"></a>00888           free (tmp);
<a name="l00889"></a>00889           tmp = NULL;
<a name="l00890"></a>00890         }
<a name="l00891"></a>00891 
<a name="l00892"></a>00892       <span class="comment">/* Straight average of the background */</span>
<a name="l00893"></a>00893       <span class="keywordflow">if</span> (interporder == 0)
<a name="l00894"></a>00894         {
<a name="l00895"></a>00895           <span class="keywordtype">double</span> *tmp, sum = 0.0, avg = 0.0, std = 0.0;
<a name="l00896"></a>00896           <span class="keywordtype">int</span> nn = 0;
<a name="l00897"></a>00897           
<a name="l00898"></a>00898           nn = 0;
<a name="l00899"></a>00899           <span class="keywordflow">for</span> (j = 0; j &lt; n; j++)
<a name="l00900"></a>00900             {
<a name="l00901"></a>00901               <span class="keywordflow">if</span> (ws[j] != 0.0)
<a name="l00902"></a>00902                 {
<a name="l00903"></a>00903                   nn++;
<a name="l00904"></a>00904                 }
<a name="l00905"></a>00905             }
<a name="l00906"></a>00906           tmp = malloc (nn * <span class="keyword">sizeof</span> (<span class="keywordtype">double</span>));
<a name="l00907"></a>00907           nn = 0;
<a name="l00908"></a>00908           <span class="keywordflow">for</span> (j = 0; j &lt; n; j++)
<a name="l00909"></a>00909             {
<a name="l00910"></a>00910               <span class="keywordflow">if</span> (ws[j] != 0.0)
<a name="l00911"></a>00911                 {
<a name="l00912"></a>00912                   sum += fs[j];
<a name="l00913"></a>00913                   tmp[nn] = fs[j];
<a name="l00914"></a>00914                   nn++;
<a name="l00915"></a>00915                 }
<a name="l00916"></a>00916             }
<a name="l00917"></a>00917           <span class="keywordflow">if</span> (nn &gt; 0)
<a name="l00918"></a>00918             avg = sum / nn;
<a name="l00919"></a>00919           std = gsl_stats_sd (tmp, 1, nn);
<a name="l00920"></a>00920           <span class="keywordflow">for</span> (j = 0; j &lt; n; j++)
<a name="l00921"></a>00921             {
<a name="l00922"></a>00922               <span class="keywordflow">if</span> (ws[j] == 0.0)
<a name="l00923"></a>00923                 {
<a name="l00924"></a>00924                   fs[j] = avg;
<a name="l00925"></a>00925                   ws[j] = std;
<a name="l00926"></a>00926                 }
<a name="l00927"></a>00927               <span class="comment">//              else</span>
<a name="l00928"></a>00928               <span class="comment">//                {</span>
<a name="l00929"></a>00929               <span class="comment">//                  ws[j] = 1.0/sqrt(ws[j]);</span>
<a name="l00930"></a>00930               <span class="comment">//                }</span>
<a name="l00931"></a>00931             }
<a name="l00932"></a>00932           free (tmp);
<a name="l00933"></a>00933           tmp = NULL;
<a name="l00934"></a>00934         }
<a name="l00935"></a>00935 
<a name="l00936"></a>00936       <span class="comment">/* Linear interpolation of the background */</span>
<a name="l00937"></a>00937       <span class="keywordflow">if</span> (interporder == 1)
<a name="l00938"></a>00938         {
<a name="l00939"></a>00939           <a class="code" href="spce__fitting_8c.html#afee691c36e9b3fc77fd08f9aee86f1b8">comp_vector_linear</a> (ys, fs, ws, yi, n, 1);
<a name="l00940"></a>00940           <span class="comment">//      fit_vector_linear_t (ys, fs, ws, n);</span>
<a name="l00941"></a>00941         }
<a name="l00942"></a>00942       
<a name="l00943"></a>00943       <span class="comment">/* n(&gt;1) order interpolation of the background */</span>
<a name="l00944"></a>00944       <span class="keywordflow">if</span> (interporder &gt; 1)
<a name="l00945"></a>00945         {
<a name="l00946"></a>00946           <a class="code" href="spce__fitting_8c.html#add50c2f8186c3978ef12800257daa954">comp_vector_polyN</a> (interporder + 1, ys,fs, ws, yi, n, 1);
<a name="l00947"></a>00947       <span class="comment">//          fit_vector_poly_N_t (interporder + 1, ys, fs, ws, n);</span>
<a name="l00948"></a>00948         }
<a name="l00949"></a>00949       
<a name="l00950"></a>00950       <span class="keywordflow">for</span> (j = 0; j &lt; n; j++)
<a name="l00951"></a>00951         {
<a name="l00952"></a>00952           <span class="keywordflow">if</span> ((ys[j] &lt; 0) || (ys[j] &gt;= grism-&gt;<a class="code" href="structobservation.html#a012c0ff489fbb74fc6c9abfbd7c6e320">grism</a>-&gt;size2))
<a name="l00953"></a>00953             <span class="keywordflow">continue</span>;
<a name="l00954"></a>00954             <a class="code" href="aXe__grism_8h.html#a1f386ef5cd5a3b916246c2bee80f083a">gsl_matrix_set</a> (fib-&gt;<a class="code" href="structfullimg__background.html#aa7b506968cfc22160ce55d63121311c4">bck</a>, i, j,fs[j]);
<a name="l00955"></a>00955             <a class="code" href="aXe__grism_8h.html#a1f386ef5cd5a3b916246c2bee80f083a">gsl_matrix_set</a> (fib-&gt;<a class="code" href="structfullimg__background.html#a6c52119d1f340304f50e8f4b99ab89dc">err</a>, i, j,ws[j]);
<a name="l00956"></a>00956         }
<a name="l00957"></a>00957       free (ys);
<a name="l00958"></a>00958       ys = NULL;
<a name="l00959"></a>00959       free (fs);
<a name="l00960"></a>00960       fs = NULL;
<a name="l00961"></a>00961       free (ws);
<a name="l00962"></a>00962       ws = NULL;
<a name="l00963"></a>00963     }  
<a name="l00964"></a>00964 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="abf5f23ed5ff402f6f7f71fd32eed9164"></a><!-- doxytag: member="spc_back.c::compute_gvalue" ref="abf5f23ed5ff402f6f7f71fd32eed9164" args="(const double xdiff, const double efactor)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double compute_gvalue </td>
          <td>(</td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>xdiff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>efactor</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Function: compute_gvalue The function computes the values of a Gauss function [exp(factor * xdiff^2)]. NO normalization factor is applied.</p>
<p>Parameters: </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>xdiff</em>&nbsp;</td><td>- the value [x-x_0] </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>efactor</em>&nbsp;</td><td>- the factor for the exponent</td></tr>
  </table>
  </dd>
</dl>
<p>Returns: </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>value - the Gaussian value </dd></dl>

<p><div class="fragment"><pre class="fragment"><a name="l01817"></a>01817 {
<a name="l01818"></a>01818   <span class="keywordtype">double</span> value;
<a name="l01819"></a>01819     
<a name="l01820"></a>01820   <span class="comment">// just compose the exp-function</span>
<a name="l01821"></a>01821   value = exp(efactor * xdiff * xdiff);
<a name="l01822"></a>01822 
<a name="l01823"></a>01823   <span class="comment">// return the value</span>
<a name="l01824"></a>01824   <span class="keywordflow">return</span> value;
<a name="l01825"></a>01825 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="afa7a0622ef0b42500dbce17be8f268a4"></a><!-- doxytag: member="spc_back.c::fill_pixvalues" ref="afa7a0622ef0b42500dbce17be8f268a4" args="(const gsl_matrix *bck_mask, const int smooth_length, const fullimg_background *fib, const int ix, const int iy, gsl_vector *pixvalues, gsl_vector *pmask)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fill_pixvalues </td>
          <td>(</td>
          <td class="paramtype">const gsl_matrix *&nbsp;</td>
          <td class="paramname"> <em>bck_mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>smooth_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structfullimg__background.html">fullimg_background</a> *&nbsp;</td>
          <td class="paramname"> <em>fib</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>ix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>iy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gsl_vector *&nbsp;</td>
          <td class="paramname"> <em>pixvalues</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gsl_vector *&nbsp;</td>
          <td class="paramname"> <em>pmask</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Function: fill_pixvalues The function provides the essential information for Gaussian smoothing for a single pixel. It fills a vector with the values of all pixels within the smoothing length. Not interpolated pixels are excluded. A mask vector provides the information on which position is filled with pixel values.</p>
<p>Parameters: </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>bck_mask</em>&nbsp;</td><td>- the background mask </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>smoot_length</em>&nbsp;</td><td>- number of pixels on either side to use for smoothing </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>fib</em>&nbsp;</td><td>- the background structure </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>bck_mask</em>&nbsp;</td><td>- the background mask </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ix</em>&nbsp;</td><td>- x-value of central pixel </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>iy</em>&nbsp;</td><td>- y-value of central pixel </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pixvalues</em>&nbsp;</td><td>- vector for pixel values </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pmask</em>&nbsp;</td><td>- vector for pixel mask </td></tr>
  </table>
  </dd>
</dl>

<p><div class="fragment"><pre class="fragment"><a name="l01771"></a>01771 {
<a name="l01772"></a>01772   <span class="keywordtype">int</span> iact;
<a name="l01773"></a>01773   <span class="keywordtype">int</span> index;
<a name="l01774"></a>01774   
<a name="l01775"></a>01775   <span class="comment">// initialize the pixel values </span>
<a name="l01776"></a>01776   <span class="comment">// and the mask</span>
<a name="l01777"></a>01777   gsl_vector_set_all(pixvalues, 0.0);
<a name="l01778"></a>01778   gsl_vector_set_all(pmask, 0.0);
<a name="l01779"></a>01779 
<a name="l01780"></a>01780   <span class="comment">// iterate over the x-direction</span>
<a name="l01781"></a>01781   index=0;
<a name="l01782"></a>01782   <span class="keywordflow">for</span> (iact=ix-smooth_length; iact&lt;=ix+smooth_length; iact++)
<a name="l01783"></a>01783     {
<a name="l01784"></a>01784       <span class="comment">// check if you are within the chip</span>
<a name="l01785"></a>01785       <span class="keywordflow">if</span> (iact &gt; -1 &amp;&amp; iact &lt; bck_mask-&gt;size1)
<a name="l01786"></a>01786         {
<a name="l01787"></a>01787           <span class="comment">// check whether the pixel was interpolated</span>
<a name="l01788"></a>01788           <span class="comment">// and whether the background is non-zero</span>
<a name="l01789"></a>01789           <span class="keywordflow">if</span> (<a class="code" href="aXe__grism_8h.html#acf709ee71c580f1cd65d726ed03200ea">gsl_matrix_get</a>(bck_mask, iact, iy) != 0.0
<a name="l01790"></a>01790                &amp;&amp; <a class="code" href="aXe__grism_8h.html#acf709ee71c580f1cd65d726ed03200ea">gsl_matrix_get</a>(fib-&gt;<a class="code" href="structfullimg__background.html#aa7b506968cfc22160ce55d63121311c4">bck</a>, iact, iy) != 0.0)
<a name="l01791"></a>01791             {
<a name="l01792"></a>01792               <span class="comment">// if yes, get the pixel value and set the mask</span>
<a name="l01793"></a>01793               gsl_vector_set(pixvalues, index, <a class="code" href="aXe__grism_8h.html#acf709ee71c580f1cd65d726ed03200ea">gsl_matrix_get</a>(fib-&gt;<a class="code" href="structfullimg__background.html#aa7b506968cfc22160ce55d63121311c4">bck</a>, iact, iy));
<a name="l01794"></a>01794               gsl_vector_set(pmask,     index, 1.0);
<a name="l01795"></a>01795             }
<a name="l01796"></a>01796         }
<a name="l01797"></a>01797       <span class="comment">// enhance the vector index</span>
<a name="l01798"></a>01798       index++;
<a name="l01799"></a>01799     }
<a name="l01800"></a>01800 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a88d31193027d2eaefacbc2bc1bb7f6d1"></a><!-- doxytag: member="spc_back.c::free_fullimg_background" ref="a88d31193027d2eaefacbc2bc1bb7f6d1" args="(background *backg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void free_fullimg_background </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structs__background.html">background</a> *&nbsp;</td>
          <td class="paramname"> <em>backg</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Function: free_fullimg_background Frees a background structure allocated using make_fullimg_background</p>
<p>Parameters: </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>backg</em>&nbsp;</td><td>- a pointer to the background structure to free </td></tr>
  </table>
  </dd>
</dl>

<p><div class="fragment"><pre class="fragment"><a name="l01307"></a>01307 {
<a name="l01308"></a>01308   <a class="code" href="structfullimg__background.html">fullimg_background</a> *fib = backg-&gt;<a class="code" href="structs__background.html#a4d8837d7be9de01330a6fb4c24a2bf75">pars</a>;
<a name="l01309"></a>01309   
<a name="l01310"></a>01310   <a class="code" href="aXe__grism_8h.html#a61aa1d37853a90711852146f18d0b85f">gsl_matrix_free</a> (fib-&gt;<a class="code" href="structfullimg__background.html#aa7b506968cfc22160ce55d63121311c4">bck</a>);
<a name="l01311"></a>01311   <span class="keywordflow">if</span> (fib-&gt;<a class="code" href="structfullimg__background.html#a6c52119d1f340304f50e8f4b99ab89dc">err</a>)
<a name="l01312"></a>01312     {
<a name="l01313"></a>01313       <a class="code" href="aXe__grism_8h.html#a61aa1d37853a90711852146f18d0b85f">gsl_matrix_free</a> (fib-&gt;<a class="code" href="structfullimg__background.html#a6c52119d1f340304f50e8f4b99ab89dc">err</a>);
<a name="l01314"></a>01314     }
<a name="l01315"></a>01315   free (backg);
<a name="l01316"></a>01316   backg = NULL;
<a name="l01317"></a>01317 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a312989afed586d6646f6c5e46d94c5b2"></a><!-- doxytag: member="spc_back.c::fullimg_background_function" ref="a312989afed586d6646f6c5e46d94c5b2" args="(const int x, const int y, PIXEL_T *const val, PIXEL_T *const err, const background *const back)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fullimg_background_function </td>
          <td>(</td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PIXEL_T *const &nbsp;</td>
          <td class="paramname"> <em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PIXEL_T *const &nbsp;</td>
          <td class="paramname"> <em>err</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structs__background.html">background</a> *const &nbsp;</td>
          <td class="paramname"> <em>back</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Function: fullimg_background_function Returns the background level for the point x, y if a complete gsl_matrix of the background is available. This function is exposed to the outside through a pointer in the <a class="el" href="structobservation.html">observation</a> structure.</p>
<p>Parameters: </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>x</em>&nbsp;</td><td>ad nauseam </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>y</em>&nbsp;</td><td>ad nauseam </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>val</em>&nbsp;</td><td>pointer to a double to leave the background value in </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>err</em>&nbsp;</td><td>pointer to a double to leave the absolute error of val in </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pars</em>&nbsp;</td><td>a gsl_matrix containing the background </td></tr>
  </table>
  </dd>
</dl>

<p><div class="fragment"><pre class="fragment"><a name="l00986"></a>00986 {
<a name="l00987"></a>00987   <span class="keyword">const</span> <a class="code" href="structfullimg__background.html">fullimg_background</a> *<span class="keyword">const</span> fib = back-&gt;<a class="code" href="structs__background.html#a4d8837d7be9de01330a6fb4c24a2bf75">pars</a>;
<a name="l00988"></a>00988   
<a name="l00989"></a>00989   *val = <a class="code" href="aXe__grism_8h.html#acf709ee71c580f1cd65d726ed03200ea">gsl_matrix_get</a> (fib-&gt;<a class="code" href="structfullimg__background.html#aa7b506968cfc22160ce55d63121311c4">bck</a>, (<span class="keywordtype">int</span>) rint (x), (<span class="keywordtype">int</span>) rint (y));
<a name="l00990"></a>00990   <span class="keywordflow">if</span> (fib-&gt;<a class="code" href="structfullimg__background.html#a6c52119d1f340304f50e8f4b99ab89dc">err</a>)
<a name="l00991"></a>00991     {
<a name="l00992"></a>00992       *err = <a class="code" href="aXe__grism_8h.html#acf709ee71c580f1cd65d726ed03200ea">gsl_matrix_get</a> (fib-&gt;<a class="code" href="structfullimg__background.html#a6c52119d1f340304f50e8f4b99ab89dc">err</a>, (<span class="keywordtype">int</span>) rint (x), (<span class="keywordtype">int</span>) rint (y));
<a name="l00993"></a>00993     }
<a name="l00994"></a>00994   <span class="keywordflow">else</span>
<a name="l00995"></a>00995     {
<a name="l00996"></a>00996       *err = 0;
<a name="l00997"></a>00997     }
<a name="l00998"></a>00998 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a55bae5da45fa33dec8efc0f57981f1e4"></a><!-- doxytag: member="spc_back.c::get_interp_points" ref="a55bae5da45fa33dec8efc0f57981f1e4" args="(observation *obs, gsl_matrix *bck_mask, int np, px_point tr_point)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gsl_vector_int* get_interp_points </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structobservation.html">observation</a> *&nbsp;</td>
          <td class="paramname"> <em>obs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gsl_matrix *&nbsp;</td>
          <td class="paramname"> <em>bck_mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>np</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structpx__point.html">px_point</a>&nbsp;</td>
          <td class="paramname"> <em>tr_point</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Function: get_window_points The subroutine searches in a window around the tracepoint for pixels which are suited for the background determination. The extend of the window is specified in the <a class="el" href="structbeam.html">beam</a> structured, and pixel which are part of any <a class="el" href="structbeam.html">beam</a> can not be used.</p>
<p>Parameters: </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>obs</em>&nbsp;</td><td>- the <a class="el" href="structobservation.html">observation</a> </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>bck_mask</em>&nbsp;</td><td>- the background mask </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>actbeam</em>&nbsp;</td><td>- the <a class="el" href="structbeam.html">beam</a> to search interp points for </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>tr_point</em>&nbsp;</td><td>- the integer trace point</td></tr>
  </table>
  </dd>
</dl>
<p>Returns: </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>ret - the vector with the row numbers Function: get_interp_points The function searches for 2*n interpolation points above and below the trace. The search is iteratively from the trace in both directions. In case that the fram borders are met, the respective direction is "closed". The subroutine then tries to get more background pixels on the other size to reach the desired number.</dd></dl>
<p>Parameters: </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>obs</em>&nbsp;</td><td>- the <a class="el" href="structobservation.html">observation</a> </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>bck_mask</em>&nbsp;</td><td>- the background mask </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>np</em>&nbsp;</td><td>- the desired number of interp. points </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>tr_point</em>&nbsp;</td><td>- the integer trace point</td></tr>
  </table>
  </dd>
</dl>
<p>Returns: </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>ret - the vector with the row numbers </dd></dl>

<p><div class="fragment"><pre class="fragment"><a name="l00251"></a>00251 {
<a name="l00252"></a>00252   gsl_vector_int *tmp;
<a name="l00253"></a>00253   gsl_vector_int *ret;
<a name="l00254"></a>00254   <span class="keywordtype">int</span> np_act=0;
<a name="l00255"></a>00255   <span class="comment">//int y_low;</span>
<a name="l00256"></a>00256   <span class="comment">//int y_upp;</span>
<a name="l00257"></a>00257   <span class="keywordtype">int</span> l_space=1;
<a name="l00258"></a>00258   <span class="keywordtype">int</span> u_space=1;
<a name="l00259"></a>00259   <span class="keywordtype">int</span> l_act;
<a name="l00260"></a>00260   <span class="keywordtype">int</span> u_act;
<a name="l00261"></a>00261   <span class="keywordtype">int</span> l_np=0;
<a name="l00262"></a>00262   <span class="keywordtype">int</span> u_np=0;
<a name="l00263"></a>00263   <span class="keywordtype">int</span> ncols=obs-&gt;<a class="code" href="structobservation.html#a012c0ff489fbb74fc6c9abfbd7c6e320">grism</a>-&gt;size2;
<a name="l00264"></a>00264   <span class="keywordtype">int</span> ii;
<a name="l00265"></a>00265 
<a name="l00266"></a>00266   <span class="comment">// allocate the vector</span>
<a name="l00267"></a>00267   tmp = gsl_vector_int_alloc(2*np+2);
<a name="l00268"></a>00268   
<a name="l00269"></a>00269   <span class="comment">// limit the starting ppoint of the search </span>
<a name="l00270"></a>00270   <span class="comment">// to values within the image dimension</span>
<a name="l00271"></a>00271   tr_point.<a class="code" href="structpx__point.html#a2d02b900722a71f22a8d5100822bda61">y</a> = <a class="code" href="aper__conf_8c.html#aacc3ee1a7f283f8ef65cea31f4436a95">MAX</a>(0,tr_point.<a class="code" href="structpx__point.html#a2d02b900722a71f22a8d5100822bda61">y</a>);
<a name="l00272"></a>00272   tr_point.<a class="code" href="structpx__point.html#a2d02b900722a71f22a8d5100822bda61">y</a> = <a class="code" href="aXe__utils_8c.html#a74e75242132eaabbc1c512488a135926">MIN</a>((<span class="keywordtype">int</span>)obs-&gt;<a class="code" href="structobservation.html#a012c0ff489fbb74fc6c9abfbd7c6e320">grism</a>-&gt;size2,tr_point.<a class="code" href="structpx__point.html#a2d02b900722a71f22a8d5100822bda61">y</a>);
<a name="l00273"></a>00273 
<a name="l00274"></a>00274   <span class="comment">// initialize the row numbers</span>
<a name="l00275"></a>00275   <span class="comment">// to search up- and downwards</span>
<a name="l00276"></a>00276   l_act = tr_point.<a class="code" href="structpx__point.html#a2d02b900722a71f22a8d5100822bda61">y</a> -1;
<a name="l00277"></a>00277   u_act = tr_point.<a class="code" href="structpx__point.html#a2d02b900722a71f22a8d5100822bda61">y</a>;
<a name="l00278"></a>00278 
<a name="l00279"></a>00279   <span class="comment">// as long as interpolation points are missing </span>
<a name="l00280"></a>00280   <span class="comment">// and one direction, either up or down,</span>
<a name="l00281"></a>00281   <span class="comment">// is &apos;open&apos;, continue searching</span>
<a name="l00282"></a>00282   <span class="keywordflow">while</span> (np_act &lt; 2*np &amp;&amp; (l_space || u_space))
<a name="l00283"></a>00283     {
<a name="l00284"></a>00284 
<a name="l00285"></a>00285       <span class="comment">// check whether the direction</span>
<a name="l00286"></a>00286       <span class="comment">// downwards is still open</span>
<a name="l00287"></a>00287       <span class="keywordflow">if</span> (l_space)
<a name="l00288"></a>00288         {
<a name="l00289"></a>00289           <span class="comment">// move downward until you either find </span>
<a name="l00290"></a>00290           <span class="comment">// and interp. point or the end of the frame</span>
<a name="l00291"></a>00291           <span class="keywordflow">while</span> (l_act &gt; -1 &amp;&amp; (<a class="code" href="aXe__grism_8h.html#acf709ee71c580f1cd65d726ed03200ea">gsl_matrix_get</a>(bck_mask,tr_point.<a class="code" href="structpx__point.html#ab715a558731a820a25b50bd7797dd004">x</a>,l_act)
<a name="l00292"></a>00292                                 !=0 ||
<a name="l00293"></a>00293                                 isnan(<a class="code" href="aXe__grism_8h.html#acf709ee71c580f1cd65d726ed03200ea">gsl_matrix_get</a>(obs-&gt;<a class="code" href="structobservation.html#a012c0ff489fbb74fc6c9abfbd7c6e320">grism</a>,
<a name="l00294"></a>00294                                                      tr_point.<a class="code" href="structpx__point.html#ab715a558731a820a25b50bd7797dd004">x</a>, l_act))))
<a name="l00295"></a>00295             {
<a name="l00296"></a>00296               l_act--;
<a name="l00297"></a>00297             }
<a name="l00298"></a>00298 
<a name="l00299"></a>00299           <span class="comment">// if you are at the end of the frame</span>
<a name="l00300"></a>00300           <span class="keywordflow">if</span> (l_act &lt; 0)
<a name="l00301"></a>00301             {
<a name="l00302"></a>00302               <span class="comment">// close the direction downwards</span>
<a name="l00303"></a>00303               l_space=0;
<a name="l00304"></a>00304             }
<a name="l00305"></a>00305           <span class="keywordflow">else</span>
<a name="l00306"></a>00306             {
<a name="l00307"></a>00307               <span class="comment">// else store the interpolation point,</span>
<a name="l00308"></a>00308               <span class="comment">// do the various increments</span>
<a name="l00309"></a>00309               gsl_vector_int_set(tmp, np_act, l_act);
<a name="l00310"></a>00310               np_act++;
<a name="l00311"></a>00311               l_np++;
<a name="l00312"></a>00312               l_act--;
<a name="l00313"></a>00313             }
<a name="l00314"></a>00314         }
<a name="l00315"></a>00315       
<a name="l00316"></a>00316       <span class="comment">// check whether the direction</span>
<a name="l00317"></a>00317       <span class="comment">// upwards is still open</span>
<a name="l00318"></a>00318       <span class="keywordflow">if</span> (u_space)
<a name="l00319"></a>00319         {
<a name="l00320"></a>00320           <span class="comment">// move upward until you either find </span>
<a name="l00321"></a>00321           <span class="comment">// and interp. point or the end of the frame</span>
<a name="l00322"></a>00322           <span class="keywordflow">while</span> (u_act &lt; ncols &amp;&amp; (<a class="code" href="aXe__grism_8h.html#acf709ee71c580f1cd65d726ed03200ea">gsl_matrix_get</a>(bck_mask,tr_point.<a class="code" href="structpx__point.html#ab715a558731a820a25b50bd7797dd004">x</a>,u_act)
<a name="l00323"></a>00323                                    !=0 ||
<a name="l00324"></a>00324                                    isnan(<a class="code" href="aXe__grism_8h.html#acf709ee71c580f1cd65d726ed03200ea">gsl_matrix_get</a>(obs-&gt;<a class="code" href="structobservation.html#a012c0ff489fbb74fc6c9abfbd7c6e320">grism</a>,
<a name="l00325"></a>00325                                                         tr_point.<a class="code" href="structpx__point.html#ab715a558731a820a25b50bd7797dd004">x</a>, u_act))))
<a name="l00326"></a>00326             {
<a name="l00327"></a>00327               u_act++;
<a name="l00328"></a>00328             }
<a name="l00329"></a>00329 
<a name="l00330"></a>00330           <span class="comment">// if you are at the end of the frame</span>
<a name="l00331"></a>00331           <span class="keywordflow">if</span> (u_act &gt;= ncols)
<a name="l00332"></a>00332             {
<a name="l00333"></a>00333               <span class="comment">// close the direction upwards</span>
<a name="l00334"></a>00334               u_space=0;
<a name="l00335"></a>00335             }
<a name="l00336"></a>00336           <span class="keywordflow">else</span>
<a name="l00337"></a>00337             {
<a name="l00338"></a>00338               <span class="comment">// else store the interpolation point,</span>
<a name="l00339"></a>00339               <span class="comment">// do the various increments</span>
<a name="l00340"></a>00340               gsl_vector_int_set(tmp, np_act, u_act);
<a name="l00341"></a>00341               np_act++;
<a name="l00342"></a>00342               u_np++;
<a name="l00343"></a>00343               u_act++;
<a name="l00344"></a>00344             }     
<a name="l00345"></a>00345         }
<a name="l00346"></a>00346     }
<a name="l00347"></a>00347   
<a name="l00348"></a>00348   <span class="comment">// check whether the beam extends over</span>
<a name="l00349"></a>00349   <span class="comment">// the image. Add an artificial start or</span>
<a name="l00350"></a>00350   <span class="comment">// end point if necessary</span>
<a name="l00351"></a>00351   <span class="keywordflow">if</span> (!l_np)
<a name="l00352"></a>00352     gsl_vector_int_set(tmp, np_act++, -1);
<a name="l00353"></a>00353   <span class="keywordflow">if</span> (!u_np)
<a name="l00354"></a>00354     gsl_vector_int_set(tmp, np_act++, ncols);
<a name="l00355"></a>00355 
<a name="l00356"></a>00356   <span class="comment">// transfer the row numbers to a</span>
<a name="l00357"></a>00357   <span class="comment">// vector of the right size</span>
<a name="l00358"></a>00358   ret = gsl_vector_int_alloc(np_act);
<a name="l00359"></a>00359   <span class="keywordflow">for</span> (ii=0; ii &lt; np_act; ii++)
<a name="l00360"></a>00360     gsl_vector_int_set(ret, ii, gsl_vector_int_get(tmp, ii));
<a name="l00361"></a>00361 
<a name="l00362"></a>00362   <span class="comment">// sort the row numbers</span>
<a name="l00363"></a>00363   gsl_sort_vector_int(ret);
<a name="l00364"></a>00364 
<a name="l00365"></a>00365   <span class="comment">// release memory</span>
<a name="l00366"></a>00366   gsl_vector_int_free(tmp);
<a name="l00367"></a>00367 
<a name="l00368"></a>00368   <span class="comment">//  return the result</span>
<a name="l00369"></a>00369   <span class="keywordflow">return</span> ret;
<a name="l00370"></a>00370 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ace0c3cfc253b812f88ed84838d0abec2"></a><!-- doxytag: member="spc_back.c::get_weighted_mean" ref="ace0c3cfc253b812f88ed84838d0abec2" args="(const gsl_vector *pixvalues, const gsl_vector *weights, const gsl_vector *pmask)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double get_weighted_mean </td>
          <td>(</td>
          <td class="paramtype">const gsl_vector *&nbsp;</td>
          <td class="paramname"> <em>pixvalues</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const gsl_vector *&nbsp;</td>
          <td class="paramname"> <em>weights</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const gsl_vector *&nbsp;</td>
          <td class="paramname"> <em>pmask</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Function: get_weighted_mean The function computes the weighted mean of values stored in a value vector and a weight vector. As mask vector marks values pixels not to be considered. Using a separate mask vectorhas the advantage the weights can be kept constant and do not have to be re-calculated in repeated runs.</p>
<p>Parameters: </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pixvalues</em>&nbsp;</td><td>- vector with pixel values </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>weights</em>&nbsp;</td><td>- vector with weights </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pmask</em>&nbsp;</td><td>- mask vector</td></tr>
  </table>
  </dd>
</dl>
<p>Returns: </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>sum/www - the weighted mean </dd></dl>

<p><div class="fragment"><pre class="fragment"><a name="l01722"></a>01722 {
<a name="l01723"></a>01723   <span class="keywordtype">int</span> index;
<a name="l01724"></a>01724 
<a name="l01725"></a>01725   <span class="comment">// initialize the total</span>
<a name="l01726"></a>01726   <span class="comment">// sum and weight</span>
<a name="l01727"></a>01727   <span class="keywordtype">double</span> sum=0.0;
<a name="l01728"></a>01728   <span class="keywordtype">double</span> www=0.0;
<a name="l01729"></a>01729 
<a name="l01730"></a>01730   <span class="keywordflow">for</span> (index=0; index &lt; pixvalues-&gt;size; index ++)
<a name="l01731"></a>01731     {
<a name="l01732"></a>01732 
<a name="l01733"></a>01733       <span class="keywordflow">if</span> (gsl_vector_get(pmask, index))
<a name="l01734"></a>01734         {
<a name="l01735"></a>01735           <span class="comment">// enhance the total sum</span>
<a name="l01736"></a>01736           sum += gsl_vector_get(pixvalues, index) * gsl_vector_get(weights, index);
<a name="l01737"></a>01737           
<a name="l01738"></a>01738           <span class="comment">// enhance the total weight</span>
<a name="l01739"></a>01739           www += gsl_vector_get(weights, index);
<a name="l01740"></a>01740         }
<a name="l01741"></a>01741     }
<a name="l01742"></a>01742 
<a name="l01743"></a>01743   <span class="comment">// return the total sum,</span>
<a name="l01744"></a>01744   <span class="comment">// divided by the total weight</span>
<a name="l01745"></a>01745   <span class="keywordflow">return</span> sum / www;
<a name="l01746"></a>01746 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ad7c9963cb80da0010581906c46dde765"></a><!-- doxytag: member="spc_back.c::get_xrange" ref="ad7c9963cb80da0010581906c46dde765" args="(observation *obs, beam actbeam)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structpx__point.html">px_point</a> get_xrange </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structobservation.html">observation</a> *&nbsp;</td>
          <td class="paramname"> <em>obs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbeam.html">beam</a>&nbsp;</td>
          <td class="paramname"> <em>actbeam</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Function: get_xrange The subroutine determines the extend of a <a class="el" href="structbeam.html">beam</a> in x-direction. The minimum and maximum value in x of pixels which are part of the particular <a class="el" href="structbeam.html">beam</a> are determined and returned.</p>
<p>Parameters: </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>obs</em>&nbsp;</td><td>- the <a class="el" href="structobject.html">object</a> list </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>actbeam</em>&nbsp;</td><td>- the <a class="el" href="structbeam.html">beam</a> to determine the extent for</td></tr>
  </table>
  </dd>
</dl>
<p>Returns: </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>ret - Min/Max values of the <a class="el" href="structbeam.html">beam</a> in x </dd></dl>

<p><div class="fragment"><pre class="fragment"><a name="l00559"></a>00559 {
<a name="l00560"></a>00560 
<a name="l00561"></a>00561   <a class="code" href="structpx__point.html">px_point</a> ret;
<a name="l00562"></a>00562 
<a name="l00563"></a>00563   <span class="comment">// Find the object starting and ending column</span>
<a name="l00564"></a>00564   <span class="comment">// for the beam of interest actbeam.corners</span>
<a name="l00565"></a>00565   ret.<a class="code" href="structpx__point.html#ab715a558731a820a25b50bd7797dd004">x</a> = <a class="code" href="aXe__utils_8c.html#a74e75242132eaabbc1c512488a135926">MIN</a> (<a class="code" href="aXe__utils_8c.html#a74e75242132eaabbc1c512488a135926">MIN</a> (<a class="code" href="aXe__utils_8c.html#a74e75242132eaabbc1c512488a135926">MIN</a> (actbeam.<a class="code" href="structbeam.html#a785bab6bf808db6a8841654312d20899">corners</a>[0].<a class="code" href="structpx__point.html#ab715a558731a820a25b50bd7797dd004">x</a>, actbeam.<a class="code" href="structbeam.html#a785bab6bf808db6a8841654312d20899">corners</a>[1].<a class="code" href="structpx__point.html#ab715a558731a820a25b50bd7797dd004">x</a>),
<a name="l00566"></a>00566                     actbeam.<a class="code" href="structbeam.html#a785bab6bf808db6a8841654312d20899">corners</a>[2].<a class="code" href="structpx__point.html#ab715a558731a820a25b50bd7797dd004">x</a>), actbeam.<a class="code" href="structbeam.html#a785bab6bf808db6a8841654312d20899">corners</a>[3].<a class="code" href="structpx__point.html#ab715a558731a820a25b50bd7797dd004">x</a>);
<a name="l00567"></a>00567   ret.<a class="code" href="structpx__point.html#a2d02b900722a71f22a8d5100822bda61">y</a>  = <a class="code" href="aper__conf_8c.html#aacc3ee1a7f283f8ef65cea31f4436a95">MAX</a> (<a class="code" href="aper__conf_8c.html#aacc3ee1a7f283f8ef65cea31f4436a95">MAX</a> (<a class="code" href="aper__conf_8c.html#aacc3ee1a7f283f8ef65cea31f4436a95">MAX</a> (actbeam.<a class="code" href="structbeam.html#a785bab6bf808db6a8841654312d20899">corners</a>[0].<a class="code" href="structpx__point.html#ab715a558731a820a25b50bd7797dd004">x</a>, actbeam.<a class="code" href="structbeam.html#a785bab6bf808db6a8841654312d20899">corners</a>[1].<a class="code" href="structpx__point.html#ab715a558731a820a25b50bd7797dd004">x</a>),
<a name="l00568"></a>00568                      actbeam.<a class="code" href="structbeam.html#a785bab6bf808db6a8841654312d20899">corners</a>[2].<a class="code" href="structpx__point.html#ab715a558731a820a25b50bd7797dd004">x</a>), actbeam.<a class="code" href="structbeam.html#a785bab6bf808db6a8841654312d20899">corners</a>[3].<a class="code" href="structpx__point.html#ab715a558731a820a25b50bd7797dd004">x</a>);
<a name="l00569"></a>00569   
<a name="l00570"></a>00570   <span class="comment">// limit the start and end column</span>
<a name="l00571"></a>00571   <span class="comment">// to the image size</span>
<a name="l00572"></a>00572   ret.<a class="code" href="structpx__point.html#ab715a558731a820a25b50bd7797dd004">x</a> = <a class="code" href="aper__conf_8c.html#aacc3ee1a7f283f8ef65cea31f4436a95">MAX</a>(ret.<a class="code" href="structpx__point.html#ab715a558731a820a25b50bd7797dd004">x</a>, 0);
<a name="l00573"></a>00573   ret.<a class="code" href="structpx__point.html#a2d02b900722a71f22a8d5100822bda61">y</a> = <a class="code" href="aXe__utils_8c.html#a74e75242132eaabbc1c512488a135926">MIN</a>(ret.<a class="code" href="structpx__point.html#a2d02b900722a71f22a8d5100822bda61">y</a>, (<span class="keywordtype">int</span>)obs-&gt;<a class="code" href="structobservation.html#a012c0ff489fbb74fc6c9abfbd7c6e320">grism</a>-&gt;size1);
<a name="l00574"></a>00574 
<a name="l00575"></a>00575   <span class="comment">// warn if the beam is completely outside</span>
<a name="l00576"></a>00576   <span class="comment">// the grism image</span>
<a name="l00577"></a>00577   <span class="keywordflow">if</span> (ret.<a class="code" href="structpx__point.html#ab715a558731a820a25b50bd7797dd004">x</a> &gt; obs-&gt;<a class="code" href="structobservation.html#a012c0ff489fbb74fc6c9abfbd7c6e320">grism</a>-&gt;size1 || ret.<a class="code" href="structpx__point.html#a2d02b900722a71f22a8d5100822bda61">y</a> &lt; 0)
<a name="l00578"></a>00578     {
<a name="l00579"></a>00579       <a class="code" href="aXe__errors_8c.html#a7ef7588e5f91237ba7ce4084e6ed3c11">aXe_message</a> (<a class="code" href="aXe__errors_8h.html#a3f3c2d017ceaf0b51cfb71efbcaeff44">aXe_M_WARN4</a>, __FILE__, __LINE__,
<a name="l00580"></a>00580                    <span class="stringliteral">&quot;Object  is not in the image start_i:%d end_i:%d&quot;</span>,
<a name="l00581"></a>00581                    ret.<a class="code" href="structpx__point.html#ab715a558731a820a25b50bd7797dd004">x</a>, ret.<a class="code" href="structpx__point.html#a2d02b900722a71f22a8d5100822bda61">y</a>);
<a name="l00582"></a>00582     }
<a name="l00583"></a>00583 
<a name="l00584"></a>00584   <span class="comment">// return the result</span>
<a name="l00585"></a>00585   <span class="keywordflow">return</span> ret;
<a name="l00586"></a>00586 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a7e25af7fc45ffda6d9b8c6612219a32f"></a><!-- doxytag: member="spc_back.c::gsmooth_background" ref="a7e25af7fc45ffda6d9b8c6612219a32f" args="(const gsl_matrix *bck_mask, const int smooth_length, const double fwhm, fullimg_background *fib)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void gsmooth_background </td>
          <td>(</td>
          <td class="paramtype">const gsl_matrix *&nbsp;</td>
          <td class="paramname"> <em>bck_mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>smooth_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>fwhm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structfullimg__background.html">fullimg_background</a> *&nbsp;</td>
          <td class="paramname"> <em>fib</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Function: gsmooth_background Smooth all interpolated pixel in the background using a Gaussian function. The smoothing is done exclusively towards the x-values. The smoothing should help to reduce the noise from the limited number of background pixels.</p>
<p>Parameters: </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>bck_mask</em>&nbsp;</td><td>- the background mask </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>smoot_length</em>&nbsp;</td><td>- number of pixels on either side to use for smoothing </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>fwhm</em>&nbsp;</td><td>- fwhm of the Gaussian </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>fib</em>&nbsp;</td><td>- the background structure </td></tr>
  </table>
  </dd>
</dl>

<p><div class="fragment"><pre class="fragment"><a name="l01637"></a>01637 {
<a name="l01638"></a>01638   <span class="keywordtype">double</span> efactor;
<a name="l01639"></a>01639 
<a name="l01640"></a>01640   <span class="keywordtype">int</span> ix, iy;
<a name="l01641"></a>01641 
<a name="l01642"></a>01642   gsl_vector *pixvalues;
<a name="l01643"></a>01643   gsl_vector *weights;
<a name="l01644"></a>01644   gsl_vector *pmask;
<a name="l01645"></a>01645 
<a name="l01646"></a>01646   <a class="code" href="aXe__grism_8h.html#a6117e17bb3108107676f4486e62d40e5">gsl_matrix</a> *new_bck;
<a name="l01647"></a>01647 
<a name="l01648"></a>01648   <span class="comment">// allocate memory for the vectors</span>
<a name="l01649"></a>01649   pixvalues = gsl_vector_alloc(2 * smooth_length + 1);
<a name="l01650"></a>01650   weights   = gsl_vector_alloc(2 * smooth_length + 1);
<a name="l01651"></a>01651   pmask     = gsl_vector_alloc(2 * smooth_length + 1);
<a name="l01652"></a>01652 
<a name="l01653"></a>01653   <span class="comment">// allocate the new background</span>
<a name="l01654"></a>01654   <span class="comment">// and initialize it</span>
<a name="l01655"></a>01655   new_bck = <a class="code" href="aXe__grism_8h.html#a1214ab1bea5fd80474d7a27db0bfb429">gsl_matrix_alloc</a>(bck_mask-&gt;size1, bck_mask-&gt;size2);
<a name="l01656"></a>01656   <a class="code" href="aXe__grism_8h.html#af6161aeb008a1ffa7d888df6ccbef7cc">gsl_matrix_set_all</a>(new_bck, 0.0);
<a name="l01657"></a>01657 
<a name="l01658"></a>01658   <span class="comment">// prepare the Gaussian</span>
<a name="l01659"></a>01659   efactor = <a class="code" href="spc__back_8c.html#ad1ce027d8c85366289610daf4ee9ac12">compute_efactor</a>(fwhm);
<a name="l01660"></a>01660 
<a name="l01661"></a>01661   <span class="comment">// fill the weights</span>
<a name="l01662"></a>01662   <span class="keywordflow">for</span> (ix=0; ix &lt; weights-&gt;size; ix++)
<a name="l01663"></a>01663     gsl_vector_set(weights, ix, <a class="code" href="spc__back_8c.html#abf5f23ed5ff402f6f7f71fd32eed9164">compute_gvalue</a>((<span class="keywordtype">double</span>)ix - (<span class="keywordtype">double</span>)smooth_length, efactor));
<a name="l01664"></a>01664   
<a name="l01665"></a>01665 
<a name="l01666"></a>01666   <span class="comment">// go over all rows</span>
<a name="l01667"></a>01667   <span class="keywordflow">for</span> (iy=0; iy &lt; fib-&gt;<a class="code" href="structfullimg__background.html#aa7b506968cfc22160ce55d63121311c4">bck</a>-&gt;size2; iy++)
<a name="l01668"></a>01668     {
<a name="l01669"></a>01669       <span class="comment">// go over all columns</span>
<a name="l01670"></a>01670       <span class="keywordflow">for</span> (ix=0; ix &lt; fib-&gt;<a class="code" href="structfullimg__background.html#aa7b506968cfc22160ce55d63121311c4">bck</a>-&gt;size1; ix++)
<a name="l01671"></a>01671         {
<a name="l01672"></a>01672           <span class="comment">// check whether the pixel IS part of a beam</span>
<a name="l01673"></a>01673           <span class="keywordflow">if</span> (!(<a class="code" href="aXe__grism_8h.html#acf709ee71c580f1cd65d726ed03200ea">gsl_matrix_get</a>(bck_mask, ix, iy) != 0.0
<a name="l01674"></a>01674                 &amp;&amp; <a class="code" href="aXe__grism_8h.html#acf709ee71c580f1cd65d726ed03200ea">gsl_matrix_get</a>(fib-&gt;<a class="code" href="structfullimg__background.html#aa7b506968cfc22160ce55d63121311c4">bck</a>, ix, iy) !=0.0))
<a name="l01675"></a>01675             {
<a name="l01676"></a>01676               <span class="comment">// transfer the old background value</span>
<a name="l01677"></a>01677               <a class="code" href="aXe__grism_8h.html#a1f386ef5cd5a3b916246c2bee80f083a">gsl_matrix_set</a>(new_bck, ix, iy, <a class="code" href="aXe__grism_8h.html#acf709ee71c580f1cd65d726ed03200ea">gsl_matrix_get</a>(fib-&gt;<a class="code" href="structfullimg__background.html#aa7b506968cfc22160ce55d63121311c4">bck</a>, ix, iy));
<a name="l01678"></a>01678             }
<a name="l01679"></a>01679           <span class="keywordflow">else</span>
<a name="l01680"></a>01680             {
<a name="l01681"></a>01681               <span class="comment">// fill the pixel and mask values</span>
<a name="l01682"></a>01682               <a class="code" href="spc__back_8c.html#afa7a0622ef0b42500dbce17be8f268a4">fill_pixvalues</a>(bck_mask, smooth_length, fib, ix, iy, pixvalues, pmask);
<a name="l01683"></a>01683 
<a name="l01684"></a>01684               <span class="comment">// fill in the weighted mean</span>
<a name="l01685"></a>01685               <a class="code" href="aXe__grism_8h.html#a1f386ef5cd5a3b916246c2bee80f083a">gsl_matrix_set</a>(new_bck, ix, iy, <a class="code" href="spc__back_8c.html#ace0c3cfc253b812f88ed84838d0abec2">get_weighted_mean</a>(pixvalues, weights, pmask));
<a name="l01686"></a>01686             }
<a name="l01687"></a>01687         } 
<a name="l01688"></a>01688     }
<a name="l01689"></a>01689 
<a name="l01690"></a>01690   <span class="comment">// release the allocated dspace</span>
<a name="l01691"></a>01691   gsl_vector_free(pixvalues);
<a name="l01692"></a>01692   gsl_vector_free(weights);
<a name="l01693"></a>01693   gsl_vector_free(pmask);
<a name="l01694"></a>01694 
<a name="l01695"></a>01695   <span class="comment">// release the memory of the</span>
<a name="l01696"></a>01696   <span class="comment">// old background</span>
<a name="l01697"></a>01697   <a class="code" href="aXe__grism_8h.html#a61aa1d37853a90711852146f18d0b85f">gsl_matrix_free</a>(fib-&gt;<a class="code" href="structfullimg__background.html#aa7b506968cfc22160ce55d63121311c4">bck</a>);
<a name="l01698"></a>01698 
<a name="l01699"></a>01699   <span class="comment">// transfer the new background</span>
<a name="l01700"></a>01700   <span class="comment">// to the background structure</span>
<a name="l01701"></a>01701   fib-&gt;<a class="code" href="structfullimg__background.html#aa7b506968cfc22160ce55d63121311c4">bck</a> = new_bck;
<a name="l01702"></a>01702 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ac1c2518944b7c7dbaa14041f46c07187"></a><!-- doxytag: member="spc_back.c::is_pt_in_a_beam" ref="ac1c2518944b7c7dbaa14041f46c07187" args="(const px_point *const apoint, const is_in_descriptor *const iids, const int tnbeams)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int is_pt_in_a_beam </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structpx__point.html">px_point</a> *const &nbsp;</td>
          <td class="paramname"> <em>apoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structis__in__descriptor.html">is_in_descriptor</a> *const &nbsp;</td>
          <td class="paramname"> <em>iids</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>tnbeams</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Function: is_pt_in_a_beam The function checks whether a particular image pixel is part of a <a class="el" href="structbeam.html">beam</a> or not. The pixel is checked against an array of beams it could be part of.</p>
<p>Parameters: </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>apoint</em>&nbsp;</td><td>- the point to check </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>iids</em>&nbsp;</td><td>- an array of is_in_descriptors for all the beams that should be checked </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>tnbeams</em>&nbsp;</td><td>- number of beams in iids</td></tr>
  </table>
  </dd>
</dl>
<p>Returns: </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>1/0 - fixed values </dd></dl>

<p><div class="fragment"><pre class="fragment"><a name="l00055"></a>00055 {
<a name="l00056"></a>00056   <span class="keywordtype">int</span> i;
<a name="l00057"></a>00057   
<a name="l00058"></a>00058   <span class="keywordflow">for</span> (i = 0; i &lt; tnbeams; i++)
<a name="l00059"></a>00059     {
<a name="l00060"></a>00060       <span class="keywordflow">if</span> (apoint-&gt;<a class="code" href="structpx__point.html#ab715a558731a820a25b50bd7797dd004">x</a> &lt; (iids + i)-&gt;mini)
<a name="l00061"></a>00061         <span class="keywordflow">continue</span>;
<a name="l00062"></a>00062       <span class="keywordflow">if</span> (apoint-&gt;<a class="code" href="structpx__point.html#ab715a558731a820a25b50bd7797dd004">x</a> &gt; (iids + i)-&gt;maxi)
<a name="l00063"></a>00063         <span class="keywordflow">continue</span>;
<a name="l00064"></a>00064       <span class="keywordflow">if</span> (apoint-&gt;<a class="code" href="structpx__point.html#a2d02b900722a71f22a8d5100822bda61">y</a> &lt; (iids + i)-&gt;minj)
<a name="l00065"></a>00065         <span class="keywordflow">continue</span>;
<a name="l00066"></a>00066       <span class="keywordflow">if</span> (apoint-&gt;<a class="code" href="structpx__point.html#a2d02b900722a71f22a8d5100822bda61">y</a> &gt; (iids + i)-&gt;maxj)
<a name="l00067"></a>00067         <span class="keywordflow">continue</span>;
<a name="l00068"></a>00068       <span class="keywordflow">if</span> (<a class="code" href="spce__is__in_8c.html#a3dffa5865ba3264ef10bed7249bac60e">is_in</a> (apoint-&gt;<a class="code" href="structpx__point.html#ab715a558731a820a25b50bd7797dd004">x</a>, apoint-&gt;<a class="code" href="structpx__point.html#a2d02b900722a71f22a8d5100822bda61">y</a>, iids + i))
<a name="l00069"></a>00069         {
<a name="l00070"></a>00070           <span class="keywordflow">return</span> 1;
<a name="l00071"></a>00071         }
<a name="l00072"></a>00072     }
<a name="l00073"></a>00073   <span class="keywordflow">return</span> 0;
<a name="l00074"></a>00074 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="afe2e18a7ee7b967b8d71d7e1fb316ea7"></a><!-- doxytag: member="spc_back.c::kappa_sigma_clipp" ref="afe2e18a7ee7b967b8d71d7e1fb316ea7" args="(const double *const xs, double *const ys, double *const ws, const int n, const double kappa, observation *obs, int colnum)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void kappa_sigma_clipp </td>
          <td>(</td>
          <td class="paramtype">const double *const &nbsp;</td>
          <td class="paramname"> <em>xs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *const &nbsp;</td>
          <td class="paramname"> <em>ys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *const &nbsp;</td>
          <td class="paramname"> <em>ws</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>kappa</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structobservation.html">observation</a> *&nbsp;</td>
          <td class="paramname"> <em>obs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>colnum</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Function: kappa_sigma_clipp The subroutine performs one kappa-sigma step on the data given in various vectors for independent, dipendent and weight data. The difference to apply the clipping on is "original value &lt;minus&gt; median of the data set".</p>
<p>Parameters: </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>xs</em>&nbsp;</td><td>- array for independent values </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ys</em>&nbsp;</td><td>- array for dependent values </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ws</em>&nbsp;</td><td>- weight array </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>n</em>&nbsp;</td><td>- number of pixels </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>kappa</em>&nbsp;</td><td>- the kappa value for rejection </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>obs</em>&nbsp;</td><td>- the <a class="el" href="structobject.html">object</a> list </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>colnum</em>&nbsp;</td><td>- the column number </td></tr>
  </table>
  </dd>
</dl>

<p><div class="fragment"><pre class="fragment"><a name="l00709"></a>00709 {
<a name="l00710"></a>00710   <span class="keywordtype">double</span> *ys_tmp, *ys_med;
<a name="l00711"></a>00711 
<a name="l00712"></a>00712   <span class="keywordtype">int</span> *iindex;
<a name="l00713"></a>00713 
<a name="l00714"></a>00714   <span class="keywordtype">int</span> ii, m=0, npixel=0;
<a name="l00715"></a>00715 
<a name="l00716"></a>00716   <span class="keywordtype">double</span> median=0.0, stdev=0.0;
<a name="l00717"></a>00717 
<a name="l00718"></a>00718   <span class="comment">// allocate memory for temporay vectors</span>
<a name="l00719"></a>00719   ys_tmp = (<span class="keywordtype">double</span> *) malloc (n * <span class="keyword">sizeof</span> (<span class="keywordtype">double</span>));
<a name="l00720"></a>00720   ys_med = (<span class="keywordtype">double</span> *) malloc (n * <span class="keyword">sizeof</span> (<span class="keywordtype">double</span>));
<a name="l00721"></a>00721   iindex = (<span class="keywordtype">int</span> *) malloc (n * <span class="keyword">sizeof</span> (<span class="keywordtype">int</span>));
<a name="l00722"></a>00722 
<a name="l00723"></a>00723   <span class="comment">// store the background values </span>
<a name="l00724"></a>00724   <span class="comment">// in the temporary vectors</span>
<a name="l00725"></a>00725   <span class="keywordflow">for</span> (ii=0; ii &lt; n; ii++)
<a name="l00726"></a>00726     {
<a name="l00727"></a>00727       <span class="keywordflow">if</span> (ws[ii] != 0.0)
<a name="l00728"></a>00728         {
<a name="l00729"></a>00729           ys_tmp[m] = ys[ii];
<a name="l00730"></a>00730           ys_med[m] = ys[ii];
<a name="l00731"></a>00731           iindex[m] = ii;
<a name="l00732"></a>00732           m++;
<a name="l00733"></a>00733         }
<a name="l00734"></a>00734     }
<a name="l00735"></a>00735 
<a name="l00736"></a>00736   <span class="comment">// derive median and standard deviation</span>
<a name="l00737"></a>00737   gsl_sort (ys_tmp, 1, m);
<a name="l00738"></a>00738   median = gsl_stats_median_from_sorted_data(ys_tmp, 1, m); 
<a name="l00739"></a>00739   stdev = gsl_stats_sd_m (ys_med, 1, m, median);
<a name="l00740"></a>00740 
<a name="l00741"></a>00741   <span class="comment">// apply the clipping</span>
<a name="l00742"></a>00742   npixel=0;
<a name="l00743"></a>00743   <span class="keywordflow">for</span> (ii=0; ii &lt; m; ii++)
<a name="l00744"></a>00744     {
<a name="l00745"></a>00745       <span class="comment">// check whether the pixel should</span>
<a name="l00746"></a>00746       <span class="comment">// be clipped</span>
<a name="l00747"></a>00747       <span class="keywordflow">if</span> (fabs(ys_med[ii]-median) &gt; kappa*stdev)
<a name="l00748"></a>00748         {
<a name="l00749"></a>00749           <span class="comment">// set the weight of a clipped pixel to 0.0</span>
<a name="l00750"></a>00750           ws[iindex[ii]] = 0.0;
<a name="l00751"></a>00751           <span class="comment">// mark the clipped pixel in the dq-array</span>
<a name="l00752"></a>00752           <a class="code" href="aXe__grism_8h.html#a1f386ef5cd5a3b916246c2bee80f083a">gsl_matrix_set</a>(obs-&gt;<a class="code" href="structobservation.html#a6698fa09a4524a5928ad9f98d620ba4e">dq</a>, colnum, xs[iindex[ii]], <a class="code" href="spc__back_8h.html#a84af820cbb7ca83ada7bf0c1aba8d02f">DQ_KAPPA_SIGMA</a>);
<a name="l00753"></a>00753         }
<a name="l00754"></a>00754       <span class="keywordflow">else</span>
<a name="l00755"></a>00755         {
<a name="l00756"></a>00756           npixel++;
<a name="l00757"></a>00757         }
<a name="l00758"></a>00758 
<a name="l00759"></a>00759     }
<a name="l00760"></a>00760 
<a name="l00761"></a>00761   <span class="comment">// release memory</span>
<a name="l00762"></a>00762   free(ys_med);
<a name="l00763"></a>00763   free(ys_tmp);
<a name="l00764"></a>00764   free(iindex);
<a name="l00765"></a>00765 }
</pre></div></p>

</div>
</div>
</div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&nbsp;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&nbsp;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&nbsp;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&nbsp;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&nbsp;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&nbsp;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&nbsp;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&nbsp;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&nbsp;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&nbsp;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr size="1"/><address style="text-align: right;"><small>Generated on 12 Oct 2014 for TIPS by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.1 </small></address>
</body>
</html>
