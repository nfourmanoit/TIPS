<!-- This comment will put IE 6, 7 and 8 in quirks mode -->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>TIPS: /renoir/fourmano/Desktop/OUSIM/TIPS/branches/tips_build/include/axesim/fringe_utils.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.6.1 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <img id="MSearchSelect" src="search/search.png"
             onmouseover="return searchBox.OnSearchSelectShow()"
             onmouseout="return searchBox.OnSearchSelectHide()"
             alt=""/>
        <input type="text" id="MSearchField" value="Search" accesskey="S"
             onfocus="searchBox.OnSearchFieldFocus(true)" 
             onblur="searchBox.OnSearchFieldFocus(false)" 
             onkeyup="searchBox.OnSearchFieldChange(event)"/>
        <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
        </div>
      </li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>/renoir/fourmano/Desktop/OUSIM/TIPS/branches/tips_build/include/axesim/fringe_utils.h File Reference</h1>
<p><a href="fringe__utils_8h_source.html">Go to the source code of this file.</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Data Structures</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpixel__tput.html">pixel_tput</a></td></tr>
<tr><td colspan="2"><h2>Namespaces</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefringe__utils.html">fringe_utils</a></td></tr>
<tr><td colspan="2"><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="fringe__utils_8h.html#a0402175e645c022e7a90b0bbd64547a2">fringe_correct_PET</a> (const <a class="el" href="structfringe__conf.html">fringe_conf</a> *fconf, const <a class="el" href="structbeam.html">beam</a> act_beam, <a class="el" href="structap__pixel.html">ap_pixel</a> *obj_pet, <a class="el" href="structap__pixel.html">ap_pixel</a> *bck_pet)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">gsl_vector **&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="fringe__utils_8h.html#af355623cf6639eebf7762b3586e7fd30">evaluate_pixel_throughput</a> (const <a class="el" href="structfringe__conf.html">fringe_conf</a> *fconf, const <a class="el" href="structbeam.html">beam</a> act_beam, const <a class="el" href="structap__pixel.html">ap_pixel</a> *obj_pix)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">gsl_vector **&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="fringe__utils_8h.html#a00c596a71399f5efbfba60c5afd12a14">get_gauss_throughput</a> (const <a class="el" href="structfringe__conf.html">fringe_conf</a> *fconf, const <a class="el" href="structap__pixel.html">ap_pixel</a> *obj_pix, const double fwhm)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structinterpolator.html">interpolator</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="fringe__utils_8h.html#a5cc6f161f0e2a24a14a40e0ccc11d7b5">create_interp_tput</a> (const <a class="el" href="structpixel__tput.html">pixel_tput</a> *p_tput)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="fringe__utils_8h.html#a1f78b41444483fcce4645f0604c6228e">compute_pixel_tput</a> (const <a class="el" href="structbeam.html">beam</a> act_beam, const <a class="el" href="structap__pixel.html">ap_pixel</a> *obj_pix, <a class="el" href="structpixel__tput.html">pixel_tput</a> *p_tput)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structd__point.html">d_point</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="fringe__utils_8h.html#a900ec9c280d1f89d01b43fb28d2db9b3">compute_tput_angles</a> (const <a class="el" href="structbeam.html">beam</a> act_beam, const <a class="el" href="structap__pixel.html">ap_pixel</a> *act_pet)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structpixel__tput.html">pixel_tput</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="fringe__utils_8h.html#a2771bb1bda09da356c808194651cff4c">alloc_pixel_tput</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="fringe__utils_8h.html#a99e32a5f7e3cdc9a250e41c83b4b0cc2">print_pixel_tput</a> (<a class="el" href="structpixel__tput.html">pixel_tput</a> *p_tput)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="fringe__utils_8h.html#a5e1ffec6cdcba89f4d0ccc7d68a7ba2e">free_pixel_tput</a> (<a class="el" href="structpixel__tput.html">pixel_tput</a> *p_tput)</td></tr>
</table>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="a2771bb1bda09da356c808194651cff4c"></a><!-- doxytag: member="fringe_utils.h::alloc_pixel_tput" ref="a2771bb1bda09da356c808194651cff4c" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structpixel__tput.html">pixel_tput</a>* alloc_pixel_tput </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Function: alloc_pixel_tput The function allocates and returns memory for a pixel throughput function</p>
<p>Returns: </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>p_tput -the new allocated pixel throughput structure </dd></dl>

<p><div class="fragment"><pre class="fragment"><a name="l00621"></a>00621 {
<a name="l00622"></a>00622   <a class="code" href="structpixel__tput.html">pixel_tput</a> *p_tput;
<a name="l00623"></a>00623 
<a name="l00624"></a>00624   <span class="comment">// allcoate the pointer</span>
<a name="l00625"></a>00625   p_tput = (<a class="code" href="structpixel__tput.html">pixel_tput</a> *) malloc(<span class="keyword">sizeof</span>(<a class="code" href="structpixel__tput.html">pixel_tput</a>));
<a name="l00626"></a>00626 
<a name="l00627"></a>00627   <span class="comment">// allocate the vector in the structure</span>
<a name="l00628"></a>00628   p_tput-&gt;<a class="code" href="structpixel__tput.html#a3355adc4f4a25d3490180424541e466a">lambda_values</a> = gsl_vector_alloc(4);
<a name="l00629"></a>00629 
<a name="l00630"></a>00630   <span class="comment">// return the structure</span>
<a name="l00631"></a>00631   <span class="keywordflow">return</span> p_tput;
<a name="l00632"></a>00632 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a1f78b41444483fcce4645f0604c6228e"></a><!-- doxytag: member="fringe_utils.h::compute_pixel_tput" ref="a1f78b41444483fcce4645f0604c6228e" args="(const beam act_beam, const ap_pixel *obj_pix, pixel_tput *p_tput)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void compute_pixel_tput </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structbeam.html">beam</a>&nbsp;</td>
          <td class="paramname"> <em>act_beam</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structap__pixel.html">ap_pixel</a> *&nbsp;</td>
          <td class="paramname"> <em>obj_pix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structpixel__tput.html">pixel_tput</a> *&nbsp;</td>
          <td class="paramname"> <em>p_tput</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Function: compute_pixel_tput The function computes all relevant data to characterize the pixel throughput function for an individual PET pixel. The information is written into a pixel throughput structure.</p>
<p>Parameters: </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>act_beam</em>&nbsp;</td><td>- the <a class="el" href="structbeam.html">beam</a> aperture </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>obj_pix</em>&nbsp;</td><td>- the PET pixel </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>p_tput</em>&nbsp;</td><td>- the pixel throughput structure </td></tr>
  </table>
  </dd>
</dl>

<p><div class="fragment"><pre class="fragment"><a name="l00514"></a>00514 {
<a name="l00515"></a>00515   <a class="code" href="structd__point.html">d_point</a> angles;
<a name="l00516"></a>00516 
<a name="l00517"></a>00517   <span class="keywordtype">double</span> theta_2a;
<a name="l00518"></a>00518   <span class="keywordtype">double</span> theta_3a;
<a name="l00519"></a>00519 
<a name="l00520"></a>00520   <span class="keywordtype">double</span> theta_1b;
<a name="l00521"></a>00521   <span class="keywordtype">double</span> theta_2b;
<a name="l00522"></a>00522 
<a name="l00523"></a>00523   <span class="keywordtype">double</span> sin_theta_2a;
<a name="l00524"></a>00524   <span class="keywordtype">double</span> sin_theta_3a;
<a name="l00525"></a>00525 
<a name="l00526"></a>00526   <span class="keywordtype">double</span> sin_theta_1b;
<a name="l00527"></a>00527   <span class="keywordtype">double</span> cos_theta_1b;
<a name="l00528"></a>00528   <span class="keywordtype">double</span> sin_theta_2b;
<a name="l00529"></a>00529 
<a name="l00530"></a>00530   <span class="keywordtype">double</span> dist1;
<a name="l00531"></a>00531   <span class="keywordtype">double</span> dist2;
<a name="l00532"></a>00532 
<a name="l00533"></a>00533   <span class="comment">// compute the anngles alpha and beta</span>
<a name="l00534"></a>00534   angles = <a class="code" href="fringe__utils_8c.html#a900ec9c280d1f89d01b43fb28d2db9b3">compute_tput_angles</a>(act_beam, obj_pix);
<a name="l00535"></a>00535 
<a name="l00536"></a>00536   <span class="comment">// the computation of p_min-p3 in the</span>
<a name="l00537"></a>00537   <span class="comment">// design document</span>
<a name="l00538"></a>00538   theta_1b = M_PI_2 + angles.<a class="code" href="structd__point.html#a922a3b5d82a119168ba85e5f939d02c3">x</a> - angles.<a class="code" href="structd__point.html#ad9846a025508bf8873a501ca5fcefbf4">y</a>;
<a name="l00539"></a>00539   theta_2b = angles.<a class="code" href="structd__point.html#ad9846a025508bf8873a501ca5fcefbf4">y</a>;
<a name="l00540"></a>00540 
<a name="l00541"></a>00541   <span class="comment">// compute the sin&apos;s and cos&apos;s neede</span>
<a name="l00542"></a>00542   sin_theta_1b = sin(theta_1b);
<a name="l00543"></a>00543   cos_theta_1b = cos(theta_1b);
<a name="l00544"></a>00544   sin_theta_2b = sin(theta_2b);
<a name="l00545"></a>00545 
<a name="l00546"></a>00546   <span class="comment">// compute one delta</span>
<a name="l00547"></a>00547   dist2 = obj_pix-&gt;<a class="code" href="structap__pixel.html#a8c1c7b5a35a04145fccfc3f84c420cde">dlambda</a> * sin_theta_1b / sin_theta_2b;
<a name="l00548"></a>00548 
<a name="l00549"></a>00549   <span class="comment">// the computation of p_h-p0 in the</span>
<a name="l00550"></a>00550   <span class="comment">// design document</span>
<a name="l00551"></a>00551   theta_2a = M_PI - angles.<a class="code" href="structd__point.html#ad9846a025508bf8873a501ca5fcefbf4">y</a>;
<a name="l00552"></a>00552   theta_3a = angles.<a class="code" href="structd__point.html#ad9846a025508bf8873a501ca5fcefbf4">y</a> - angles.<a class="code" href="structd__point.html#a922a3b5d82a119168ba85e5f939d02c3">x</a> - M_PI_4;
<a name="l00553"></a>00553 
<a name="l00554"></a>00554   <span class="comment">// next line due to sin(angle) = sin(180-angle)</span>
<a name="l00555"></a>00555   sin_theta_2a = sin_theta_2b;
<a name="l00556"></a>00556   sin_theta_3a = sin(theta_3a);
<a name="l00557"></a>00557 
<a name="l00558"></a>00558   <span class="comment">// compute the second delta </span>
<a name="l00559"></a>00559   dist1 = obj_pix-&gt;<a class="code" href="structap__pixel.html#a8c1c7b5a35a04145fccfc3f84c420cde">dlambda</a> * M_SQRT1_2 * sin_theta_3a / sin_theta_2a;
<a name="l00560"></a>00560 
<a name="l00561"></a>00561   <span class="comment">// determine the maximum throughput</span>
<a name="l00562"></a>00562   p_tput-&gt;<a class="code" href="structpixel__tput.html#a7a54412b8ca33d821512bfaef1420fbc">tp_max</a> = 1.0/<a class="code" href="aper__conf_8c.html#aacc3ee1a7f283f8ef65cea31f4436a95">MAX</a>(fabs(sin_theta_1b), fabs(cos_theta_1b));
<a name="l00563"></a>00563 
<a name="l00564"></a>00564   <span class="comment">// put together the distances, using</span>
<a name="l00565"></a>00565   <span class="comment">// the deltas and the dispersion</span>
<a name="l00566"></a>00566   gsl_vector_set(p_tput-&gt;<a class="code" href="structpixel__tput.html#a3355adc4f4a25d3490180424541e466a">lambda_values</a>, 0, obj_pix-&gt;<a class="code" href="structap__pixel.html#ac36fd281b7d91081490e41ce07a60501">lambda</a> - dist1 - dist2);
<a name="l00567"></a>00567   gsl_vector_set(p_tput-&gt;<a class="code" href="structpixel__tput.html#a3355adc4f4a25d3490180424541e466a">lambda_values</a>, 1, obj_pix-&gt;<a class="code" href="structap__pixel.html#ac36fd281b7d91081490e41ce07a60501">lambda</a> - dist1);
<a name="l00568"></a>00568   gsl_vector_set(p_tput-&gt;<a class="code" href="structpixel__tput.html#a3355adc4f4a25d3490180424541e466a">lambda_values</a>, 2, obj_pix-&gt;<a class="code" href="structap__pixel.html#ac36fd281b7d91081490e41ce07a60501">lambda</a> + dist1);
<a name="l00569"></a>00569   gsl_vector_set(p_tput-&gt;<a class="code" href="structpixel__tput.html#a3355adc4f4a25d3490180424541e466a">lambda_values</a>, 3, obj_pix-&gt;<a class="code" href="structap__pixel.html#ac36fd281b7d91081490e41ce07a60501">lambda</a> + dist1 + dist2);
<a name="l00570"></a>00570 
<a name="l00571"></a>00571   <span class="comment">// sort the distances</span>
<a name="l00572"></a>00572   gsl_sort_vector(p_tput-&gt;<a class="code" href="structpixel__tput.html#a3355adc4f4a25d3490180424541e466a">lambda_values</a>);
<a name="l00573"></a>00573 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a900ec9c280d1f89d01b43fb28d2db9b3"></a><!-- doxytag: member="fringe_utils.h::compute_tput_angles" ref="a900ec9c280d1f89d01b43fb28d2db9b3" args="(const beam act_beam, const ap_pixel *act_pet)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structd__point.html">d_point</a> compute_tput_angles </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structbeam.html">beam</a>&nbsp;</td>
          <td class="paramname"> <em>act_beam</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structap__pixel.html">ap_pixel</a> *&nbsp;</td>
          <td class="paramname"> <em>act_pet</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Function: compute_tput_angles The function computes the angles which characterize a pixel in the lambda-cross dispersion plane. In detail this is the angle between the lambda-axis and the x-axis, and the angle between the lambda abd the cross dispersion axis. The two angles are computed from the basic pixel and <a class="el" href="structbeam.html">beam</a> data.</p>
<p>Parameters: </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>act_beam</em>&nbsp;</td><td>- the <a class="el" href="structbeam.html">beam</a> aperture </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>act_pet</em>&nbsp;</td><td>- the PET pixel</td></tr>
  </table>
  </dd>
</dl>
<p>Returns: </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>angles - the relevant pixel angles </dd></dl>

<p><div class="fragment"><pre class="fragment"><a name="l00596"></a>00596 {
<a name="l00597"></a>00597   <a class="code" href="structd__point.html">d_point</a> angles;
<a name="l00598"></a>00598 
<a name="l00599"></a>00599   <span class="comment">// compute the angle &apos;alpha&apos; between lambda-axis and</span>
<a name="l00600"></a>00600   <span class="comment">// x-axis</span>
<a name="l00601"></a>00601   angles.<a class="code" href="structd__point.html#a922a3b5d82a119168ba85e5f939d02c3">x</a> = -atan2(act_beam.<a class="code" href="structbeam.html#a918b8655ff4142f173ca73226ce27922">spec_trace</a>-&gt;<a class="code" href="structtrace__func.html#acdda34da0c92344832184081c6f41718">deriv</a>(act_pet-&gt;<a class="code" href="structap__pixel.html#aeae2e14e0f53bd1090acb2a8758104a5">xi</a>,
<a name="l00602"></a>00602                                                act_beam.<a class="code" href="structbeam.html#a918b8655ff4142f173ca73226ce27922">spec_trace</a>-&gt;<a class="code" href="structtrace__func.html#aa610d641940ef4a567aef884dd0b32da">data</a>),1.0);
<a name="l00603"></a>00603   <span class="comment">// compute the angle beta between lambda and cross dispersion axis</span>
<a name="l00604"></a>00604   angles.<a class="code" href="structd__point.html#ad9846a025508bf8873a501ca5fcefbf4">y</a> = act_beam.<a class="code" href="structbeam.html#a362f20c7f29a9d08731a03939103c8c1">orient</a> + angles.<a class="code" href="structd__point.html#a922a3b5d82a119168ba85e5f939d02c3">x</a>;
<a name="l00605"></a>00605 
<a name="l00606"></a>00606   <span class="comment">// return the two angles</span>
<a name="l00607"></a>00607   <span class="keywordflow">return</span> angles;
<a name="l00608"></a>00608 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a5cc6f161f0e2a24a14a40e0ccc11d7b5"></a><!-- doxytag: member="fringe_utils.h::create_interp_tput" ref="a5cc6f161f0e2a24a14a40e0ccc11d7b5" args="(const pixel_tput *p_tput)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structinterpolator.html">interpolator</a>* create_interp_tput </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structpixel__tput.html">pixel_tput</a> *&nbsp;</td>
          <td class="paramname"> <em>p_tput</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Function: create_interp_tput The function creates and returns an <a class="el" href="structinterpolator.html">interpolator</a> for a pixel throughput function. The <a class="el" href="structinterpolator.html">interpolator</a> structure is allocated, data is filled in and finally initialized.</p>
<p>Parameters: </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>p_tput</em>&nbsp;</td><td>- the pixel throughput structure</td></tr>
  </table>
  </dd>
</dl>
<p>Returns: </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>interp - the new <a class="el" href="structinterpolator.html">interpolator</a> </dd></dl>

<p><div class="fragment"><pre class="fragment"><a name="l00459"></a>00459 {
<a name="l00460"></a>00460   <a class="code" href="structinterpolator.html">interpolator</a> *interp;
<a name="l00461"></a>00461 
<a name="l00462"></a>00462   <span class="keywordtype">double</span> *xvals;
<a name="l00463"></a>00463   <span class="keywordtype">double</span> *yvals;
<a name="l00464"></a>00464 
<a name="l00465"></a>00465   <span class="comment">// allocate memory for the independent values </span>
<a name="l00466"></a>00466   xvals = (<span class="keywordtype">double</span> *) malloc(4 * <span class="keyword">sizeof</span>(<span class="keywordtype">double</span>));
<a name="l00467"></a>00467   <span class="keywordflow">if</span> (!xvals) { 
<a name="l00468"></a>00468     <a class="code" href="aXe__errors_8c.html#a7ef7588e5f91237ba7ce4084e6ed3c11">aXe_message</a> (<a class="code" href="aXe__errors_8h.html#ad247dca204a2964327532d0359b59ad8">aXe_M_ERROR</a>, __FILE__, __LINE__,
<a name="l00469"></a>00469                  <span class="stringliteral">&quot;Memory allocation failed&quot;</span>);
<a name="l00470"></a>00470   }
<a name="l00471"></a>00471 
<a name="l00472"></a>00472   <span class="comment">// allocate memory for the dependent values </span>
<a name="l00473"></a>00473   yvals = (<span class="keywordtype">double</span> *) malloc(4 * <span class="keyword">sizeof</span>(<span class="keywordtype">double</span>));
<a name="l00474"></a>00474   <span class="keywordflow">if</span> (!yvals) {
<a name="l00475"></a>00475     <a class="code" href="aXe__errors_8c.html#a7ef7588e5f91237ba7ce4084e6ed3c11">aXe_message</a> (<a class="code" href="aXe__errors_8h.html#ad247dca204a2964327532d0359b59ad8">aXe_M_ERROR</a>, __FILE__, __LINE__,
<a name="l00476"></a>00476                  <span class="stringliteral">&quot;Memory allocation failed&quot;</span>);
<a name="l00477"></a>00477   }
<a name="l00478"></a>00478 
<a name="l00479"></a>00479   <span class="comment">// set the independent vector values </span>
<a name="l00480"></a>00480   xvals[0] = gsl_vector_get(p_tput-&gt;<a class="code" href="structpixel__tput.html#a3355adc4f4a25d3490180424541e466a">lambda_values</a>, 0);
<a name="l00481"></a>00481   xvals[1] = gsl_vector_get(p_tput-&gt;<a class="code" href="structpixel__tput.html#a3355adc4f4a25d3490180424541e466a">lambda_values</a>, 1);
<a name="l00482"></a>00482   xvals[2] = gsl_vector_get(p_tput-&gt;<a class="code" href="structpixel__tput.html#a3355adc4f4a25d3490180424541e466a">lambda_values</a>, 2);
<a name="l00483"></a>00483   xvals[3] = gsl_vector_get(p_tput-&gt;<a class="code" href="structpixel__tput.html#a3355adc4f4a25d3490180424541e466a">lambda_values</a>, 3);
<a name="l00484"></a>00484 
<a name="l00485"></a>00485   <span class="comment">// set the dependent vector values</span>
<a name="l00486"></a>00486   yvals[0] = 0.0;
<a name="l00487"></a>00487   yvals[1] = p_tput-&gt;<a class="code" href="structpixel__tput.html#a7a54412b8ca33d821512bfaef1420fbc">tp_max</a>;
<a name="l00488"></a>00488   yvals[2] = p_tput-&gt;<a class="code" href="structpixel__tput.html#a7a54412b8ca33d821512bfaef1420fbc">tp_max</a>;
<a name="l00489"></a>00489   yvals[3] = 0.0;
<a name="l00490"></a>00490 
<a name="l00491"></a>00491 
<a name="l00492"></a>00492   <span class="comment">// create the interpolator</span>
<a name="l00493"></a>00493   interp = <a class="code" href="fringe__conf_8c.html#a970b309082c5565bd69f416eef888c2f">create_interp</a>(4, <a class="code" href="fringe__conf_8h.html#a71212969dcee17149ade8393c642f454">FILTER_INTERP_TYPE</a>, xvals, yvals);
<a name="l00494"></a>00494 
<a name="l00495"></a>00495   <span class="comment">// return the interpolator</span>
<a name="l00496"></a>00496   <span class="keywordflow">return</span> interp;
<a name="l00497"></a>00497 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="af355623cf6639eebf7762b3586e7fd30"></a><!-- doxytag: member="fringe_utils.h::evaluate_pixel_throughput" ref="af355623cf6639eebf7762b3586e7fd30" args="(const fringe_conf *fconf, const beam act_beam, const ap_pixel *obj_pix)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gsl_vector** evaluate_pixel_throughput </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structfringe__conf.html">fringe_conf</a> *&nbsp;</td>
          <td class="paramname"> <em>fconf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structbeam.html">beam</a>&nbsp;</td>
          <td class="paramname"> <em>act_beam</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structap__pixel.html">ap_pixel</a> *&nbsp;</td>
          <td class="paramname"> <em>obj_pix</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Function: evaluate_pixel_throughput Computes the wavelength and filter throughputs for a PET pixel.</p>
<p>The function computes and returns two vector, one with wavelength steps and the second with the pixel throughputs at those wavelengths. This data is computed to a single PET pixel according to the settings in the fringe configuration file.</p>
<p>Parameters: </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>fconf</em>&nbsp;</td><td>- the fringe configuration file </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>act_beam</em>&nbsp;</td><td>- the <a class="el" href="structbeam.html">beam</a> aperture </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>obj_pix</em>&nbsp;</td><td>- the PET pixel</td></tr>
  </table>
  </dd>
</dl>
<p>Returns: </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>double_vector - the wavelength and filter throughput steps </dd></dl>

<p><div class="fragment"><pre class="fragment"><a name="l00207"></a>00207 {
<a name="l00208"></a>00208   <a class="code" href="structpixel__tput.html">pixel_tput</a> *p_tput ;
<a name="l00209"></a>00209 
<a name="l00210"></a>00210   gsl_vector **double_vector;
<a name="l00211"></a>00211   gsl_vector *lambda_values;
<a name="l00212"></a>00212   gsl_vector *through_values;
<a name="l00213"></a>00213 
<a name="l00214"></a>00214   <a class="code" href="structinterpolator.html">interpolator</a> *interp;
<a name="l00215"></a>00215 
<a name="l00216"></a>00216   <span class="keywordtype">double</span> stepsize;
<a name="l00217"></a>00217   <span class="keywordtype">double</span> lambda_act;
<a name="l00218"></a>00218   <span class="keywordtype">double</span> through_act;
<a name="l00219"></a>00219   <span class="keywordtype">double</span> through_tot;
<a name="l00220"></a>00220 
<a name="l00221"></a>00221   <span class="keywordtype">double</span> abs_min;
<a name="l00222"></a>00222   <span class="keywordtype">double</span> abs_max;
<a name="l00223"></a>00223 
<a name="l00224"></a>00224   <span class="keywordtype">int</span> index;
<a name="l00225"></a>00225 
<a name="l00226"></a>00226   <span class="comment">// allocate the pixel throughput structure</span>
<a name="l00227"></a>00227   p_tput = <a class="code" href="fringe__utils_8c.html#a2771bb1bda09da356c808194651cff4c">alloc_pixel_tput</a>();
<a name="l00228"></a>00228 
<a name="l00229"></a>00229   <span class="comment">// allocate the space for the vectors</span>
<a name="l00230"></a>00230   lambda_values  = gsl_vector_alloc(fconf-&gt;<a class="code" href="structfringe__conf.html#a0a5158dd39ecd3e68e88853f6b33014c">num_steps</a> + 1);
<a name="l00231"></a>00231   through_values = gsl_vector_alloc(fconf-&gt;<a class="code" href="structfringe__conf.html#a0a5158dd39ecd3e68e88853f6b33014c">num_steps</a> + 1);
<a name="l00232"></a>00232 
<a name="l00233"></a>00233   <span class="comment">// allocate space for the return vector</span>
<a name="l00234"></a>00234   double_vector  = (gsl_vector **)malloc(2*<span class="keyword">sizeof</span> (gsl_vector *));
<a name="l00235"></a>00235 
<a name="l00236"></a>00236   <a class="code" href="fringe__utils_8c.html#a1f78b41444483fcce4645f0604c6228e">compute_pixel_tput</a>(act_beam, obj_pix, p_tput);
<a name="l00237"></a>00237 <span class="preprocessor">#ifdef DEBUGFCONF</span>
<a name="l00238"></a>00238 <span class="preprocessor"></span>  <a class="code" href="fringe__utils_8c.html#a99e32a5f7e3cdc9a250e41c83b4b0cc2">print_pixel_tput</a>(p_tput);
<a name="l00239"></a>00239 <span class="preprocessor">#endif</span>
<a name="l00240"></a>00240 <span class="preprocessor"></span>  <span class="comment">// convert the pixel throughput information</span>
<a name="l00241"></a>00241   <span class="comment">// into an interplator </span>
<a name="l00242"></a>00242   interp = <a class="code" href="fringe__utils_8c.html#a5cc6f161f0e2a24a14a40e0ccc11d7b5">create_interp_tput</a>(p_tput);
<a name="l00243"></a>00243 
<a name="l00244"></a>00244   abs_min = <a class="code" href="aper__conf_8c.html#aacc3ee1a7f283f8ef65cea31f4436a95">MAX</a>(interp-&gt;<a class="code" href="structinterpolator.html#a09c1238a6c4be948ef51e29676074b6f">xmin</a>, gsl_vector_get(fconf-&gt;<a class="code" href="structfringe__conf.html#aa96d6742b1e0009ca830907949e8875b">fringe_range</a>, 0));
<a name="l00245"></a>00245   abs_max = <a class="code" href="aXe__utils_8c.html#a74e75242132eaabbc1c512488a135926">MIN</a>(interp-&gt;<a class="code" href="structinterpolator.html#a4ccf4f1e42f5207f311bffcbebb7ea9c">xmax</a>, gsl_vector_get(fconf-&gt;<a class="code" href="structfringe__conf.html#aa96d6742b1e0009ca830907949e8875b">fringe_range</a>, 1));
<a name="l00246"></a>00246   
<a name="l00247"></a>00247   <span class="comment">// compute the steps in wavelength</span>
<a name="l00248"></a>00248   stepsize = (abs_max - abs_min)/(<span class="keywordtype">double</span>)fconf-&gt;<a class="code" href="structfringe__conf.html#a0a5158dd39ecd3e68e88853f6b33014c">num_steps</a>;
<a name="l00249"></a>00249 
<a name="l00250"></a>00250   <span class="comment">// set the lower wavelength end</span>
<a name="l00251"></a>00251   lambda_act = abs_min;
<a name="l00252"></a>00252 
<a name="l00253"></a>00253   <span class="comment">// loop over the wavelength</span>
<a name="l00254"></a>00254   through_tot = 0.0;
<a name="l00255"></a>00255   <span class="keywordflow">for</span> (index=0; index &lt; fconf-&gt;<a class="code" href="structfringe__conf.html#a0a5158dd39ecd3e68e88853f6b33014c">num_steps</a>; index++)
<a name="l00256"></a>00256     {
<a name="l00257"></a>00257       <span class="comment">// set the wavelength value</span>
<a name="l00258"></a>00258       gsl_vector_set(lambda_values, index, lambda_act);
<a name="l00259"></a>00259 
<a name="l00260"></a>00260       <span class="comment">// compute the throughput</span>
<a name="l00261"></a>00261       through_act = <a class="code" href="fringe__conf_8c.html#ace9546cd2761b6436b8295f6ce94fba1">eval_interp</a>(interp, lambda_act);
<a name="l00262"></a>00262 
<a name="l00263"></a>00263       <span class="comment">// compute the total throughput</span>
<a name="l00264"></a>00264       through_tot += through_act;
<a name="l00265"></a>00265 
<a name="l00266"></a>00266       <span class="comment">// set the thoughput value</span>
<a name="l00267"></a>00267       gsl_vector_set(through_values, index, through_act);
<a name="l00268"></a>00268 
<a name="l00269"></a>00269       lambda_act +=  stepsize;
<a name="l00270"></a>00270     }
<a name="l00271"></a>00271 
<a name="l00272"></a>00272   <span class="comment">// treat the last step separately, avoiding</span>
<a name="l00273"></a>00273   <span class="comment">// to leave the allowed interpolation range</span>
<a name="l00274"></a>00274   <span class="comment">// due to rounding errors </span>
<a name="l00275"></a>00275   gsl_vector_set(lambda_values, fconf-&gt;<a class="code" href="structfringe__conf.html#a0a5158dd39ecd3e68e88853f6b33014c">num_steps</a>, abs_max);
<a name="l00276"></a>00276   through_act = <a class="code" href="fringe__conf_8c.html#ace9546cd2761b6436b8295f6ce94fba1">eval_interp</a>(interp, abs_max);
<a name="l00277"></a>00277   through_tot += through_act;
<a name="l00278"></a>00278   gsl_vector_set(through_values, fconf-&gt;<a class="code" href="structfringe__conf.html#a0a5158dd39ecd3e68e88853f6b33014c">num_steps</a>, through_act);
<a name="l00279"></a>00279 
<a name="l00280"></a>00280   <span class="keywordflow">for</span> (index=0; index &lt; through_values-&gt;size; index++)
<a name="l00281"></a>00281     {
<a name="l00282"></a>00282       <span class="comment">// normalize the filter throughput values</span>
<a name="l00283"></a>00283       gsl_vector_set(through_values, index,
<a name="l00284"></a>00284                      gsl_vector_get(through_values, index)/through_tot);
<a name="l00285"></a>00285 
<a name="l00286"></a>00286       <span class="comment">// convert the wavelength from AA to micron</span>
<a name="l00287"></a>00287       gsl_vector_set(lambda_values, index,
<a name="l00288"></a>00288                      gsl_vector_get(lambda_values, index)*1.0e-04);
<a name="l00289"></a>00289     }
<a name="l00290"></a>00290 <span class="preprocessor">#ifdef DEBUGFCONF</span>
<a name="l00291"></a>00291 <span class="preprocessor"></span>  through_tot = 0.0;
<a name="l00292"></a>00292   <span class="keywordflow">for</span> (index=0; index &lt; through_values-&gt;size; index++)
<a name="l00293"></a>00293     {
<a name="l00294"></a>00294       fprintf(stderr, <span class="stringliteral">&quot;Wavelength: %f, Throughput: %f\n&quot;</span>,
<a name="l00295"></a>00295               gsl_vector_get(lambda_values, index),
<a name="l00296"></a>00296               gsl_vector_get(through_values, index));
<a name="l00297"></a>00297       through_tot += gsl_vector_get(through_values, index);
<a name="l00298"></a>00298     }
<a name="l00299"></a>00299   fprintf(stderr, <span class="stringliteral">&quot;Total throughput: %f\n&quot;</span>, through_tot);
<a name="l00300"></a>00300 <span class="preprocessor">#endif</span>
<a name="l00301"></a>00301 <span class="preprocessor"></span>  
<a name="l00302"></a>00302   <span class="comment">// build up the output array</span>
<a name="l00303"></a>00303   double_vector[0] = lambda_values;
<a name="l00304"></a>00304   double_vector[1] = through_values;
<a name="l00305"></a>00305 
<a name="l00306"></a>00306   
<a name="l00307"></a>00307   <span class="comment">// free the memory of the interpolator</span>
<a name="l00308"></a>00308   <a class="code" href="fringe__conf_8c.html#a518a01a879febbaf974b85585defaf7c">free_interp</a>(interp);
<a name="l00309"></a>00309 
<a name="l00310"></a>00310   <span class="comment">// free the memory of the pixel throughput</span>
<a name="l00311"></a>00311   <a class="code" href="fringe__utils_8c.html#a5e1ffec6cdcba89f4d0ccc7d68a7ba2e">free_pixel_tput</a>(p_tput);
<a name="l00312"></a>00312 
<a name="l00313"></a>00313   <span class="comment">// return the two gsl vectors</span>
<a name="l00314"></a>00314   <span class="keywordflow">return</span> double_vector;
<a name="l00315"></a>00315 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a5e1ffec6cdcba89f4d0ccc7d68a7ba2e"></a><!-- doxytag: member="fringe_utils.h::free_pixel_tput" ref="a5e1ffec6cdcba89f4d0ccc7d68a7ba2e" args="(pixel_tput *p_tput)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void free_pixel_tput </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpixel__tput.html">pixel_tput</a> *&nbsp;</td>
          <td class="paramname"> <em>p_tput</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Function: free_pixel_tput The function releases the memory allocated in a pixel throughput function.</p>
<p>Parameters: </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>p_tput</em>&nbsp;</td><td>- the pixel throughput structure </td></tr>
  </table>
  </dd>
</dl>

<p><div class="fragment"><pre class="fragment"><a name="l00664"></a>00664 {
<a name="l00665"></a>00665   <span class="comment">// free the gsl-vector</span>
<a name="l00666"></a>00666   gsl_vector_free(p_tput-&gt;<a class="code" href="structpixel__tput.html#a3355adc4f4a25d3490180424541e466a">lambda_values</a>);
<a name="l00667"></a>00667 
<a name="l00668"></a>00668   <span class="comment">// free everything</span>
<a name="l00669"></a>00669   free(p_tput);
<a name="l00670"></a>00670 
<a name="l00671"></a>00671   <span class="comment">// set it to NULL</span>
<a name="l00672"></a>00672   p_tput = NULL;
<a name="l00673"></a>00673 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a0402175e645c022e7a90b0bbd64547a2"></a><!-- doxytag: member="fringe_utils.h::fringe_correct_PET" ref="a0402175e645c022e7a90b0bbd64547a2" args="(const fringe_conf *fconf, const beam act_beam, ap_pixel *obj_pet, ap_pixel *bck_pet)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fringe_correct_PET </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structfringe__conf.html">fringe_conf</a> *&nbsp;</td>
          <td class="paramname"> <em>fconf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structbeam.html">beam</a>&nbsp;</td>
          <td class="paramname"> <em>act_beam</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structap__pixel.html">ap_pixel</a> *&nbsp;</td>
          <td class="paramname"> <em>obj_pet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structap__pixel.html">ap_pixel</a> *&nbsp;</td>
          <td class="paramname"> <em>bck_pet</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Function: fringe_correct_PET Performs fringe corrections to PET pixel lists</p>
<p>The main function to compute and perform the fringe correction to a list of PET pixels. for every pixel in the PET list the pixel throughput function is computed, and the relevant information from the fringing model is extracted. Then the fringe amplitude is computed and the count value of the pixel is corrected. Also the PET pixel list is simultaneously parsed and corrected for the fringing.</p>
<p>Parameters: </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>fconf</em>&nbsp;</td><td>- the fringe configuration file </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>act_beam</em>&nbsp;</td><td>- the <a class="el" href="structbeam.html">beam</a> aperture </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>obj_pet</em>&nbsp;</td><td>- the PET pixel </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>bck_pet</em>&nbsp;</td><td>- the PET pixel </td></tr>
  </table>
  </dd>
</dl>

<p><div class="fragment"><pre class="fragment"><a name="l00046"></a>00046 {
<a name="l00047"></a>00047   <a class="code" href="structap__pixel.html">ap_pixel</a> *obj_pix=NULL;
<a name="l00048"></a>00048   <a class="code" href="structap__pixel.html">ap_pixel</a> *bck_pix=NULL;
<a name="l00049"></a>00049 
<a name="l00050"></a>00050   <span class="comment">//d_point angles;</span>
<a name="l00051"></a>00051   <a class="code" href="structpixel__tput.html">pixel_tput</a> *p_tput ;
<a name="l00052"></a>00052   gsl_vector **tput_vectors=NULL;
<a name="l00053"></a>00053 
<a name="l00054"></a>00054   <span class="comment">//int ii=0;</span>
<a name="l00055"></a>00055   <span class="comment">//int jj=0;</span>
<a name="l00056"></a>00056   <span class="keywordtype">int</span> index;
<a name="l00057"></a>00057   <span class="keywordtype">int</span> pix_index;
<a name="l00058"></a>00058 
<a name="l00059"></a>00059   <span class="keywordtype">double</span> lambda_mean;
<a name="l00060"></a>00060   <span class="keywordtype">double</span> pixel_ampl;
<a name="l00061"></a>00061   <span class="keywordtype">double</span> fringe_factor;
<a name="l00062"></a>00062   <span class="keywordtype">double</span> fringe_tot;
<a name="l00063"></a>00063 
<a name="l00064"></a>00064   <a class="code" href="structoptical__property.html">optical_property</a> *optprops;
<a name="l00065"></a>00065 
<a name="l00066"></a>00066   <span class="comment">// allocate the pixel throughput structure</span>
<a name="l00067"></a>00067   p_tput = <a class="code" href="fringe__utils_8c.html#a2771bb1bda09da356c808194651cff4c">alloc_pixel_tput</a>();
<a name="l00068"></a>00068 
<a name="l00069"></a>00069   <span class="comment">// allocate memory for the optical property structure  </span>
<a name="l00070"></a>00070   optprops = <a class="code" href="fringe__model_8c.html#ac701ed4f58f047e545bb39105bd38ba4">alloc_optprops_list</a>(fconf);
<a name="l00071"></a>00071 
<a name="l00072"></a>00072   <span class="comment">// compute the mean wavelength</span>
<a name="l00073"></a>00073   lambda_mean = (gsl_vector_get(fconf-&gt;<a class="code" href="structfringe__conf.html#aa96d6742b1e0009ca830907949e8875b">fringe_range</a>, 0) +
<a name="l00074"></a>00074     (gsl_vector_get(fconf-&gt;<a class="code" href="structfringe__conf.html#aa96d6742b1e0009ca830907949e8875b">fringe_range</a>, 1)
<a name="l00075"></a>00075      - gsl_vector_get(fconf-&gt;<a class="code" href="structfringe__conf.html#aa96d6742b1e0009ca830907949e8875b">fringe_range</a>, 0))/2.0)/1.0e+04;
<a name="l00076"></a>00076 
<a name="l00077"></a>00077   <span class="comment">// initialize some values in the optical property list</span>
<a name="l00078"></a>00078   <a class="code" href="fringe__model_8c.html#a30b4bda7a269be14d5225de5aaec952e">init_optprops_list</a>(fconf, lambda_mean, optprops);
<a name="l00079"></a>00079 
<a name="l00080"></a>00080   <span class="comment">// initialize the PET pixel storages</span>
<a name="l00081"></a>00081   obj_pix = obj_pet;
<a name="l00082"></a>00082   bck_pix = bck_pet;
<a name="l00083"></a>00083 
<a name="l00084"></a>00084   fringe_tot = 0.0;
<a name="l00085"></a>00085   pix_index = 0;
<a name="l00086"></a>00086   <span class="comment">// go over the whole PET list</span>
<a name="l00087"></a>00087   <span class="keywordflow">while</span> (obj_pix-&gt;<a class="code" href="structap__pixel.html#abca28f0936fbd5a569ad548fb25e5a38">p_x</a> != -1)
<a name="l00088"></a>00088     {
<a name="l00089"></a>00089       <span class="comment">// check whether the pixel has to be fringe corrected</span>
<a name="l00090"></a>00090       <span class="comment">// at all, based on boundaries given in the configuration</span>
<a name="l00091"></a>00091       <span class="keywordflow">if</span> ( obj_pix-&gt;<a class="code" href="structap__pixel.html#ac36fd281b7d91081490e41ce07a60501">lambda</a> &lt; gsl_vector_get(fconf-&gt;<a class="code" href="structfringe__conf.html#aa96d6742b1e0009ca830907949e8875b">fringe_range</a>, 0)
<a name="l00092"></a>00092            || obj_pix-&gt;<a class="code" href="structap__pixel.html#ac36fd281b7d91081490e41ce07a60501">lambda</a> &gt; gsl_vector_get(fconf-&gt;<a class="code" href="structfringe__conf.html#aa96d6742b1e0009ca830907949e8875b">fringe_range</a>, 1)
<a name="l00093"></a>00093            || obj_pix-&gt;<a class="code" href="structap__pixel.html#a8c1c7b5a35a04145fccfc3f84c420cde">dlambda</a> &gt; fconf-&gt;<a class="code" href="structfringe__conf.html#ab903b587c97228de58c582f8c115cc85">max_dispersion</a>)
<a name="l00094"></a>00094         {
<a name="l00095"></a>00095 
<a name="l00096"></a>00096           <span class="comment">// count up the object PET </span>
<a name="l00097"></a>00097           obj_pix++;
<a name="l00098"></a>00098 
<a name="l00099"></a>00099           <span class="comment">// count up the background PET</span>
<a name="l00100"></a>00100           <span class="keywordflow">if</span> (bck_pet)
<a name="l00101"></a>00101             bck_pix++;
<a name="l00102"></a>00102       
<a name="l00103"></a>00103           <span class="comment">// jump to the next PET pixel</span>
<a name="l00104"></a>00104           <span class="keywordflow">continue</span>;
<a name="l00105"></a>00105         }
<a name="l00106"></a>00106 
<a name="l00107"></a>00107       <span class="comment">// determine the filter throughput values</span>
<a name="l00108"></a>00108       <span class="comment">//      tput_vectors = evaluate_pixel_throughput(fconf, act_beam, obj_pix);</span>
<a name="l00109"></a>00109       <span class="comment">// for the ISR with the WFC value</span>
<a name="l00110"></a>00110       tput_vectors = <a class="code" href="fringe__utils_8c.html#a00c596a71399f5efbfba60c5afd12a14">get_gauss_throughput</a>(fconf, obj_pix, 80.0);
<a name="l00111"></a>00111 
<a name="l00112"></a>00112       <span class="comment">// fill the optical thickness of the layers</span>
<a name="l00113"></a>00113       <span class="comment">// into the structure</span>
<a name="l00114"></a>00114       <a class="code" href="fringe__model_8c.html#a4d241cd2c21f6836aabfc05690fa2361">fill_optprops_thickness</a>(fconf-&gt;<a class="code" href="structfringe__conf.html#a82eebf75b191ca25f824437be6f23c51">opt_layers</a>, obj_pix-&gt;<a class="code" href="structap__pixel.html#abca28f0936fbd5a569ad548fb25e5a38">p_x</a>,
<a name="l00115"></a>00115                               obj_pix-&gt;<a class="code" href="structap__pixel.html#aadf7ee52df3875792fbf13d4d52ed298">p_y</a>, optprops);
<a name="l00116"></a>00116 
<a name="l00117"></a>00117       pixel_ampl = 0.0;
<a name="l00118"></a>00118       <span class="keywordflow">for</span> (index=0; index &lt; tput_vectors[0]-&gt;size; index++)
<a name="l00119"></a>00119         {
<a name="l00120"></a>00120           <span class="comment">// fill all information in the optical</span>
<a name="l00121"></a>00121           <span class="comment">// property list</span>
<a name="l00122"></a>00122           <a class="code" href="fringe__model_8c.html#a7583c38c8f52f4db360e402b0cff8354">fill_optprops_all</a>(fconf-&gt;<a class="code" href="structfringe__conf.html#a82eebf75b191ca25f824437be6f23c51">opt_layers</a>,
<a name="l00123"></a>00123                             gsl_vector_get(tput_vectors[0],index),
<a name="l00124"></a>00124                             optprops);
<a name="l00125"></a>00125           
<a name="l00126"></a>00126           <span class="comment">// compute and add the contribution at a wavelength</span>
<a name="l00127"></a>00127           pixel_ampl += gsl_vector_get(tput_vectors[1],index)*
<a name="l00128"></a>00128             <a class="code" href="fringe__model_8c.html#ab3355b989a07f5f88786c7148a5c76e5">fringe_contrib_single</a>(optprops, fconf);
<a name="l00129"></a>00129         }
<a name="l00130"></a>00130 
<a name="l00131"></a>00131       <span class="comment">//put together the fringe correction factor</span>
<a name="l00132"></a>00132       fringe_factor = fconf-&gt;<a class="code" href="structfringe__conf.html#a82769d872faed1af21769411078d76f5">fringe_amp</a> * pixel_ampl + 1.0;
<a name="l00133"></a>00133 <span class="preprocessor">#ifdef DEBUGFCONF</span>
<a name="l00134"></a>00134 <span class="preprocessor"></span>      fprintf(stderr, <span class="stringliteral">&quot;Wavelength: %f, dispersion: %f, fringe factor: %f, (x,y): (%i, %i)\n&quot;</span>, 
<a name="l00135"></a>00135               obj_pix-&gt;<a class="code" href="structap__pixel.html#ac36fd281b7d91081490e41ce07a60501">lambda</a>, obj_pix-&gt;<a class="code" href="structap__pixel.html#a8c1c7b5a35a04145fccfc3f84c420cde">dlambda</a>, fringe_factor, obj_pix-&gt;<a class="code" href="structap__pixel.html#abca28f0936fbd5a569ad548fb25e5a38">p_x</a>, obj_pix-&gt;<a class="code" href="structap__pixel.html#aadf7ee52df3875792fbf13d4d52ed298">p_y</a>);
<a name="l00136"></a>00136 <span class="preprocessor">#endif</span>
<a name="l00137"></a>00137 <span class="preprocessor"></span>
<a name="l00138"></a>00138       <span class="comment">// correct the object PET</span>
<a name="l00139"></a>00139       obj_pix-&gt;<a class="code" href="structap__pixel.html#a846018a7e3b143259419bd74e2d9073f">count</a> /= fringe_factor;
<a name="l00140"></a>00140       <span class="comment">//obj_pix-&gt;count = fringe_factor;</span>
<a name="l00141"></a>00141       <span class="comment">//fprintf(stdout, &quot;%e &quot;,obj_pix-&gt;count); </span>
<a name="l00142"></a>00142 
<a name="l00143"></a>00143       fringe_tot += fringe_factor;
<a name="l00144"></a>00144       pix_index++;
<a name="l00145"></a>00145 
<a name="l00146"></a>00146 
<a name="l00147"></a>00147       <span class="comment">// treat the background PET pixel</span>
<a name="l00148"></a>00148       <span class="keywordflow">if</span> (bck_pet)
<a name="l00149"></a>00149         {
<a name="l00150"></a>00150           <span class="keywordflow">if</span> (bck_pix-&gt;<a class="code" href="structap__pixel.html#abca28f0936fbd5a569ad548fb25e5a38">p_x</a> != obj_pix-&gt;<a class="code" href="structap__pixel.html#abca28f0936fbd5a569ad548fb25e5a38">p_x</a> || bck_pix-&gt;<a class="code" href="structap__pixel.html#aadf7ee52df3875792fbf13d4d52ed298">p_y</a> != obj_pix-&gt;<a class="code" href="structap__pixel.html#aadf7ee52df3875792fbf13d4d52ed298">p_y</a>)
<a name="l00151"></a>00151             <a class="code" href="aXe__errors_8c.html#a7ef7588e5f91237ba7ce4084e6ed3c11">aXe_message</a> (<a class="code" href="aXe__errors_8h.html#a2556a67874555249b07691c37aa6d6e9">aXe_M_FATAL</a>, __FILE__, __LINE__,
<a name="l00152"></a>00152                          <span class="stringliteral">&quot;aXe_FRINGECORR: The sequence of pixels\n&quot;</span>
<a name="l00153"></a>00153                          <span class="stringliteral">&quot;in the object PET and background PET differs.\n&quot;</span>
<a name="l00154"></a>00154                          <span class="stringliteral">&quot;Something must be wrong!\n&quot;</span>);
<a name="l00155"></a>00155 
<a name="l00156"></a>00156           <span class="comment">// correct also the background PET</span>
<a name="l00157"></a>00157           bck_pix-&gt;<a class="code" href="structap__pixel.html#a846018a7e3b143259419bd74e2d9073f">count</a> /= fringe_factor;
<a name="l00158"></a>00158 
<a name="l00159"></a>00159           <span class="comment">// count up the background PET</span>
<a name="l00160"></a>00160           bck_pix++;
<a name="l00161"></a>00161         }
<a name="l00162"></a>00162 
<a name="l00163"></a>00163       <span class="comment">// count up the object PET</span>
<a name="l00164"></a>00164       obj_pix++;
<a name="l00165"></a>00165       <span class="comment">//      obj_pix-&gt;p_x = -1;</span>
<a name="l00166"></a>00166     }
<a name="l00167"></a>00167 
<a name="l00168"></a>00168   <span class="comment">//  if (pix_index)</span>
<a name="l00169"></a>00169   <span class="comment">//    fprintf(stdout,&quot;Mean fringe factor: %f\n&quot;, fringe_tot/(double)pix_index);</span>
<a name="l00170"></a>00170 
<a name="l00171"></a>00171   <span class="keywordflow">if</span> (tput_vectors)
<a name="l00172"></a>00172     {
<a name="l00173"></a>00173       <span class="comment">// release the memory in the vectors</span>
<a name="l00174"></a>00174       gsl_vector_free(tput_vectors[0]);
<a name="l00175"></a>00175       gsl_vector_free(tput_vectors[1]);
<a name="l00176"></a>00176       free(tput_vectors);
<a name="l00177"></a>00177     }
<a name="l00178"></a>00178 
<a name="l00179"></a>00179   <span class="comment">// free the optical property structure</span>
<a name="l00180"></a>00180   <a class="code" href="fringe__model_8c.html#a1b8ec54dcd7b41e31b24bbc5baacdd28">free_optprops_list</a>(optprops);
<a name="l00181"></a>00181 
<a name="l00182"></a>00182   <span class="comment">// free the memory</span>
<a name="l00183"></a>00183   <a class="code" href="fringe__utils_8c.html#a5e1ffec6cdcba89f4d0ccc7d68a7ba2e">free_pixel_tput</a>(p_tput);
<a name="l00184"></a>00184 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a00c596a71399f5efbfba60c5afd12a14"></a><!-- doxytag: member="fringe_utils.h::get_gauss_throughput" ref="a00c596a71399f5efbfba60c5afd12a14" args="(const fringe_conf *fconf, const ap_pixel *obj_pix, const double fwhm)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gsl_vector** get_gauss_throughput </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structfringe__conf.html">fringe_conf</a> *&nbsp;</td>
          <td class="paramname"> <em>fconf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structap__pixel.html">ap_pixel</a> *&nbsp;</td>
          <td class="paramname"> <em>obj_pix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>fwhm</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Function: get_gauss_throughput</p>
<p>Parameters: </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>fconf</em>&nbsp;</td><td>- the fringe configuration file </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>act_beam</em>&nbsp;</td><td>- the <a class="el" href="structbeam.html">beam</a> aperture </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>obj_pix</em>&nbsp;</td><td>- the PET pixel</td></tr>
  </table>
  </dd>
</dl>
<p>Returns: </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>double_vector - the wavelength and filter throughput steps </dd></dl>

<p><div class="fragment"><pre class="fragment"><a name="l00332"></a>00332 {
<a name="l00333"></a>00333   <a class="code" href="structpixel__tput.html">pixel_tput</a> *p_tput ;
<a name="l00334"></a>00334 
<a name="l00335"></a>00335   gsl_vector **double_vector;
<a name="l00336"></a>00336   gsl_vector *lambda_values;
<a name="l00337"></a>00337   gsl_vector *through_values;
<a name="l00338"></a>00338 
<a name="l00339"></a>00339   <span class="comment">//interpolator *interp;</span>
<a name="l00340"></a>00340 
<a name="l00341"></a>00341   <span class="keywordtype">double</span> stepsize;
<a name="l00342"></a>00342   <span class="keywordtype">double</span> lambda_act;
<a name="l00343"></a>00343   <span class="keywordtype">double</span> through_act;
<a name="l00344"></a>00344   <span class="keywordtype">double</span> through_tot;
<a name="l00345"></a>00345 
<a name="l00346"></a>00346   <span class="keywordtype">double</span> abs_min;
<a name="l00347"></a>00347   <span class="keywordtype">double</span> abs_max;
<a name="l00348"></a>00348 
<a name="l00349"></a>00349   <span class="keywordtype">double</span> sigma;
<a name="l00350"></a>00350   <span class="keywordtype">double</span> arg;
<a name="l00351"></a>00351   
<a name="l00352"></a>00352   <span class="keywordtype">int</span> index;
<a name="l00353"></a>00353 
<a name="l00354"></a>00354   <span class="comment">// convert the FWHM into sigma</span>
<a name="l00355"></a>00355   sigma = fwhm / 2.35482;
<a name="l00356"></a>00356 
<a name="l00357"></a>00357   <span class="comment">// allocate the pixel throughput structure</span>
<a name="l00358"></a>00358   p_tput = <a class="code" href="fringe__utils_8c.html#a2771bb1bda09da356c808194651cff4c">alloc_pixel_tput</a>();
<a name="l00359"></a>00359 
<a name="l00360"></a>00360   <span class="comment">// allocate the space for the vectors</span>
<a name="l00361"></a>00361   lambda_values  = gsl_vector_alloc(fconf-&gt;<a class="code" href="structfringe__conf.html#a0a5158dd39ecd3e68e88853f6b33014c">num_steps</a> + 1);
<a name="l00362"></a>00362   through_values = gsl_vector_alloc(fconf-&gt;<a class="code" href="structfringe__conf.html#a0a5158dd39ecd3e68e88853f6b33014c">num_steps</a> + 1);
<a name="l00363"></a>00363 
<a name="l00364"></a>00364   <span class="comment">// allocate space for the return vector</span>
<a name="l00365"></a>00365   double_vector  = (gsl_vector **)malloc(2*<span class="keyword">sizeof</span> (gsl_vector *));
<a name="l00366"></a>00366 
<a name="l00367"></a>00367   <span class="comment">// compute the minimum and maximum wavelength</span>
<a name="l00368"></a>00368   abs_min = <a class="code" href="aper__conf_8c.html#aacc3ee1a7f283f8ef65cea31f4436a95">MAX</a>(obj_pix-&gt;<a class="code" href="structap__pixel.html#ac36fd281b7d91081490e41ce07a60501">lambda</a> - 2.5 * fwhm,
<a name="l00369"></a>00369                 gsl_vector_get(fconf-&gt;<a class="code" href="structfringe__conf.html#aa96d6742b1e0009ca830907949e8875b">fringe_range</a>, 0));
<a name="l00370"></a>00370   abs_max = <a class="code" href="aXe__utils_8c.html#a74e75242132eaabbc1c512488a135926">MIN</a>(obj_pix-&gt;<a class="code" href="structap__pixel.html#ac36fd281b7d91081490e41ce07a60501">lambda</a> + 2.5 * fwhm,
<a name="l00371"></a>00371                 gsl_vector_get(fconf-&gt;<a class="code" href="structfringe__conf.html#aa96d6742b1e0009ca830907949e8875b">fringe_range</a>, 1));
<a name="l00372"></a>00372 
<a name="l00373"></a>00373   <span class="comment">// compute the steps in wavelength</span>
<a name="l00374"></a>00374   stepsize = (abs_max - abs_min)/(<span class="keywordtype">double</span>)fconf-&gt;<a class="code" href="structfringe__conf.html#a0a5158dd39ecd3e68e88853f6b33014c">num_steps</a>;
<a name="l00375"></a>00375 
<a name="l00376"></a>00376   <span class="comment">// set the lower wavelength end</span>
<a name="l00377"></a>00377   lambda_act = abs_min;
<a name="l00378"></a>00378 
<a name="l00379"></a>00379   <span class="comment">// loop over the wavelength</span>
<a name="l00380"></a>00380   through_tot = 0.0;
<a name="l00381"></a>00381   <span class="keywordflow">for</span> (index=0; index &lt; fconf-&gt;<a class="code" href="structfringe__conf.html#a0a5158dd39ecd3e68e88853f6b33014c">num_steps</a>; index++)
<a name="l00382"></a>00382     {
<a name="l00383"></a>00383       <span class="comment">// set the wavelength value</span>
<a name="l00384"></a>00384       gsl_vector_set(lambda_values, index, lambda_act);
<a name="l00385"></a>00385 
<a name="l00386"></a>00386       <span class="comment">// z=(coord-g(2))/g(3)</span>
<a name="l00387"></a>00387       <span class="comment">// sumgauss=sumgauss+DBLE(g(1)*EXP(-0.5*z**2))</span>
<a name="l00388"></a>00388       arg = (lambda_act - obj_pix-&gt;<a class="code" href="structap__pixel.html#ac36fd281b7d91081490e41ce07a60501">lambda</a>) / sigma;
<a name="l00389"></a>00389 
<a name="l00390"></a>00390       <span class="comment">// compute the throughput</span>
<a name="l00391"></a>00391       through_act = exp(-0.5*arg*arg);
<a name="l00392"></a>00392 
<a name="l00393"></a>00393       <span class="comment">// compute the total throughput</span>
<a name="l00394"></a>00394       through_tot += through_act;
<a name="l00395"></a>00395 
<a name="l00396"></a>00396       <span class="comment">// set the thoughput value</span>
<a name="l00397"></a>00397       gsl_vector_set(through_values, index, through_act);
<a name="l00398"></a>00398 
<a name="l00399"></a>00399       <span class="comment">// increment the wavelength</span>
<a name="l00400"></a>00400       lambda_act += stepsize;
<a name="l00401"></a>00401     }
<a name="l00402"></a>00402 
<a name="l00403"></a>00403   <span class="comment">// treat the last step separately, avoiding</span>
<a name="l00404"></a>00404   <span class="comment">// to leave the allowed interpolation range</span>
<a name="l00405"></a>00405   <span class="comment">// due to rounding errors </span>
<a name="l00406"></a>00406   gsl_vector_set(lambda_values, fconf-&gt;<a class="code" href="structfringe__conf.html#a0a5158dd39ecd3e68e88853f6b33014c">num_steps</a>, abs_max);
<a name="l00407"></a>00407   arg = (abs_max - obj_pix-&gt;<a class="code" href="structap__pixel.html#ac36fd281b7d91081490e41ce07a60501">lambda</a>) / sigma;
<a name="l00408"></a>00408   through_act = exp(-0.5*arg*arg);
<a name="l00409"></a>00409   through_tot += through_act;
<a name="l00410"></a>00410   gsl_vector_set(through_values, fconf-&gt;<a class="code" href="structfringe__conf.html#a0a5158dd39ecd3e68e88853f6b33014c">num_steps</a>, through_act);
<a name="l00411"></a>00411 
<a name="l00412"></a>00412 
<a name="l00413"></a>00413   <span class="keywordflow">for</span> (index=0; index &lt; through_values-&gt;size; index++)
<a name="l00414"></a>00414     {
<a name="l00415"></a>00415       <span class="comment">// normalize the filter throughput values</span>
<a name="l00416"></a>00416       gsl_vector_set(through_values, index,
<a name="l00417"></a>00417                      gsl_vector_get(through_values, index)/through_tot);
<a name="l00418"></a>00418 
<a name="l00419"></a>00419       <span class="comment">// convert the wavelength from AA to micron</span>
<a name="l00420"></a>00420       gsl_vector_set(lambda_values, index,
<a name="l00421"></a>00421                      gsl_vector_get(lambda_values, index)*1.0e-04);
<a name="l00422"></a>00422     }
<a name="l00423"></a>00423 
<a name="l00424"></a>00424 <span class="preprocessor">#ifdef DEBUGFCONF</span>
<a name="l00425"></a>00425 <span class="preprocessor"></span>  through_tot = 0.0;
<a name="l00426"></a>00426   <span class="keywordflow">for</span> (index=0; index &lt; through_values-&gt;size; index++)
<a name="l00427"></a>00427     {
<a name="l00428"></a>00428       fprintf(stderr, <span class="stringliteral">&quot;Wavelength: %f, Throughput: %f\n&quot;</span>,
<a name="l00429"></a>00429               gsl_vector_get(lambda_values, index),
<a name="l00430"></a>00430               gsl_vector_get(through_values, index));
<a name="l00431"></a>00431       through_tot += gsl_vector_get(through_values, index);
<a name="l00432"></a>00432     }
<a name="l00433"></a>00433   fprintf(stderr, <span class="stringliteral">&quot;Total throughput: %f\n&quot;</span>, through_tot);
<a name="l00434"></a>00434 <span class="preprocessor">#endif</span>
<a name="l00435"></a>00435 <span class="preprocessor"></span>
<a name="l00436"></a>00436   <span class="comment">// build up the output array</span>
<a name="l00437"></a>00437   double_vector[0] = lambda_values;
<a name="l00438"></a>00438   double_vector[1] = through_values;
<a name="l00439"></a>00439 
<a name="l00440"></a>00440   <span class="keywordflow">return</span> double_vector;
<a name="l00441"></a>00441 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a99e32a5f7e3cdc9a250e41c83b4b0cc2"></a><!-- doxytag: member="fringe_utils.h::print_pixel_tput" ref="a99e32a5f7e3cdc9a250e41c83b4b0cc2" args="(pixel_tput *p_tput)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void print_pixel_tput </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpixel__tput.html">pixel_tput</a> *&nbsp;</td>
          <td class="paramname"> <em>p_tput</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Function: print_pixel_tput The function prints the content of a pixel throughput structure onto the screen.</p>
<p>Parameters: </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>p_tput</em>&nbsp;</td><td>- the pixel throughput structure </td></tr>
  </table>
  </dd>
</dl>

<p><div class="fragment"><pre class="fragment"><a name="l00644"></a>00644 {
<a name="l00645"></a>00645   fprintf(stdout, <span class="stringliteral">&quot;l_min: %f, l_1: %f, l_2: %f, l_max: %f; tp_max: %f\n\n&quot;</span>,
<a name="l00646"></a>00646           gsl_vector_get(p_tput-&gt;<a class="code" href="structpixel__tput.html#a3355adc4f4a25d3490180424541e466a">lambda_values</a>,0),
<a name="l00647"></a>00647           gsl_vector_get(p_tput-&gt;<a class="code" href="structpixel__tput.html#a3355adc4f4a25d3490180424541e466a">lambda_values</a>,1),
<a name="l00648"></a>00648           gsl_vector_get(p_tput-&gt;<a class="code" href="structpixel__tput.html#a3355adc4f4a25d3490180424541e466a">lambda_values</a>,2),
<a name="l00649"></a>00649           gsl_vector_get(p_tput-&gt;<a class="code" href="structpixel__tput.html#a3355adc4f4a25d3490180424541e466a">lambda_values</a>,3),
<a name="l00650"></a>00650           p_tput-&gt;<a class="code" href="structpixel__tput.html#a7a54412b8ca33d821512bfaef1420fbc">tp_max</a>);
<a name="l00651"></a>00651 }
</pre></div></p>

</div>
</div>
</div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&nbsp;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&nbsp;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&nbsp;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&nbsp;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&nbsp;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&nbsp;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&nbsp;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&nbsp;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&nbsp;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&nbsp;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr size="1"/><address style="text-align: right;"><small>Generated on 12 Oct 2014 for TIPS by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.1 </small></address>
</body>
</html>
