<!-- This comment will put IE 6, 7 and 8 in quirks mode -->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>TIPS: /renoir/fourmano/Desktop/OUSIM/TIPS/branches/tips_build/src/axesim/model_utils.c File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.6.1 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <img id="MSearchSelect" src="search/search.png"
             onmouseover="return searchBox.OnSearchSelectShow()"
             onmouseout="return searchBox.OnSearchSelectHide()"
             alt=""/>
        <input type="text" id="MSearchField" value="Search" accesskey="S"
             onfocus="searchBox.OnSearchFieldFocus(true)" 
             onblur="searchBox.OnSearchFieldFocus(false)" 
             onkeyup="searchBox.OnSearchFieldChange(event)"/>
        <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
        </div>
      </li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>/renoir/fourmano/Desktop/OUSIM/TIPS/branches/tips_build/src/axesim/model_utils.c File Reference</h1><code>#include &lt;math.h&gt;</code><br/>
<code>#include &lt;fitsio.h&gt;</code><br/>
<code>#include &lt;gsl/gsl_matrix.h&gt;</code><br/>
<code>#include &lt;gsl/gsl_vector.h&gt;</code><br/>
<code>#include &lt;gsl/gsl_interp.h&gt;</code><br/>
<code>#include &quot;<a class="el" href="inout__aper_8h_source.html">inout_aper.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="aXe__grism_8h_source.html">aXe_grism.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="spce__PET_8h_source.html">spce_PET.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="spc__wl__calib_8h_source.html">spc_wl_calib.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="aXe__errors_8h_source.html">aXe_errors.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="fringe__conf_8h_source.html">fringe_conf.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="spc__resp_8h_source.html">spc_resp.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="spce__pathlength_8h_source.html">spce_pathlength.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="aper__conf_8h_source.html">aper_conf.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="crossdisp__utils_8h_source.html">crossdisp_utils.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="spc__FITScards_8h_source.html">spc_FITScards.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="specmodel__utils_8h_source.html">specmodel_utils.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="model__utils_8h_source.html">model_utils.h</a>&quot;</code><br/>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Namespaces</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemodel__utils.html">model_utils</a></td></tr>
<tr><td colspan="2"><h2>Defines</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="model__utils_8c.html#aacc3ee1a7f283f8ef65cea31f4436a95">MAX</a>(x, y)&nbsp;&nbsp;&nbsp;(((x)&gt;(y))?(x):(y))</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="model__utils_8c.html#a74e75242132eaabbc1c512488a135926">MIN</a>(x, y)&nbsp;&nbsp;&nbsp;(((x)&lt;(y))?(x):(y))</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="model__utils_8c.html#aa7866fa5e4e0ee9b034e9dab6599a9cc">SQR</a>(x)&nbsp;&nbsp;&nbsp;((x)*(x))</td></tr>
<tr><td colspan="2"><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structdirim__emission.html">dirim_emission</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="model__utils_8c.html#aa166b220ec60f701d55d841950dc269a">model_gauss_dirim</a> (<a class="el" href="structdirobject.html">dirobject</a> *actdir, <a class="el" href="structbeam.html">beam</a> actbeam, <a class="el" href="structaperture__conf.html">aperture_conf</a> *conf, double psf_offset)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structcalib__function.html">calib_function</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="model__utils_8c.html#a89e076f16fb5ab1d68d6fd60a8c56818">get_calib_function</a> (<a class="el" href="structbeamspec.html">beamspec</a> *actspec, <a class="el" href="structdirobject.html">dirobject</a> *actdir, char CONF_file[], const <a class="el" href="structaperture__conf.html">aperture_conf</a> *conf)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structspectrum.html">spectrum</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="model__utils_8c.html#ac1c970f8545c70717925e789935baf15">get_throughput_spec</a> (<a class="el" href="structbeamspec.html">beamspec</a> *actspec, char CONF_file[])</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structtracedata.html">tracedata</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="model__utils_8c.html#a88c32a3ad7593c46dfa166a806205e05">compute_tracedata</a> (const <a class="el" href="structbeam.html">beam</a> actbeam, const <a class="el" href="structdirobject.html">dirobject</a> *actdir, const <a class="el" href="structcalib__function.html">calib_function</a> *wl_calibration, const <a class="el" href="structbeamspec.html">beamspec</a> *actspec)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structtracedata.html">tracedata</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="model__utils_8c.html#a0ad6a3c9e3542d3085e0b4d840e76ad1">compute_short_tracedata</a> (const <a class="el" href="structaperture__conf.html">aperture_conf</a> *conf, const <a class="el" href="structbeam.html">beam</a> actbeam, const <a class="el" href="structdirobject.html">dirobject</a> *actdir, const <a class="el" href="structcalib__function.html">calib_function</a> *wl_calibration, const <a class="el" href="structbeamspec.html">beamspec</a> *actspec)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="model__utils_8c.html#af6b109448b4b2c4087381a89a4946664">get_valid_tracedata</a> (<a class="el" href="structtracedata.html">tracedata</a> *acttrace, const <a class="el" href="structcalib__function.html">calib_function</a> *wl_calibration)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="model__utils_8c.html#a67e212ed30f3f8311e5eaa822dd69705">select_tracedata</a> (<a class="el" href="structtracedata.html">tracedata</a> *acttrace, const <a class="el" href="structcalib__function.html">calib_function</a> *wl_calibration, const int nentries)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="model__utils_8c.html#ab5aca9ee955a502955517d541422cc27">fill_fluxfrom_SED</a> (const <a class="el" href="structdirobject.html">dirobject</a> *actdir, <a class="el" href="structtracedata.html">tracedata</a> *acttrace)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="model__utils_8c.html#a38db08b7fb859351801ecb7c45830a73">print_tracedata</a> (<a class="el" href="structtracedata.html">tracedata</a> *acttrace)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structdirobject.html">dirobject</a> **&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="model__utils_8c.html#ab4a6c2b0e26ff79ca76b2887d670b1df">oblist_to_dirlist</a> (char grism_file[], char CONF_file[], const <a class="el" href="structpx__point.html">px_point</a> npixels, <a class="el" href="structobject.html">object</a> **oblist, <a class="el" href="structspectral__models.html">spectral_models</a> *spec_mod, const double model_scale, const int int_type)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structdirobject.html">dirobject</a> **&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="model__utils_8c.html#a763b05dcf96d0f69417a38f7bf0a61da">oblist_to_dirlist2</a> (char grism_file[], char CONF_file[], const <a class="el" href="structpx__point.html">px_point</a> npixels, <a class="el" href="structobject.html">object</a> **oblist, <a class="el" href="structspectral__models.html">spectral_models</a> *spec_mod, <a class="el" href="structobject__models.html">object_models</a> *obj_mod, const double model_scale, const int int_type)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structdirobject.html">dirobject</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="model__utils_8c.html#ae01b7359b803f5823de49af7ba8de948">fill_dirobject</a> (const <a class="el" href="structobject.html">object</a> *actobject, const <a class="el" href="structpx__point.html">px_point</a> npixels, gsl_matrix *drzcoeffs, const double model_scale, const int max_offset)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structdirobject.html">dirobject</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="model__utils_8c.html#aabe948f13d5487dcabd5499c635ca01e">fill_dirobj_fromdirim</a> (const <a class="el" href="structobject.html">object</a> *actobject, <a class="el" href="structobject__models.html">object_models</a> *objmodels)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structdirobject.html">dirobject</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="model__utils_8c.html#a3c08d3f85de2d04b0f383f9beda7447e">load_dirobj_img</a> (const <a class="el" href="structobject.html">object</a> *actobject, <a class="el" href="structfits__access.html">fits_access</a> *modim_access)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">gsl_vector *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="model__utils_8c.html#a5b20290920148fb8fb75adb149a94f6d">get_refpoint_ranges</a> (const <a class="el" href="structobject.html">object</a> *actobject)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="model__utils_8c.html#a5cd967f1d7c4d8c89f52a7cd3d6b4f81">fill_spectrum</a> (const <a class="el" href="structobject.html">object</a> *actobject, <a class="el" href="structdirobject.html">dirobject</a> *actdir, <a class="el" href="structspectral__models.html">spectral_models</a> *spec_mod, const int int_type)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="model__utils_8c.html#adee63ef5db37c64dcdd2288a4cff5113">load_spectrum</a> (const <a class="el" href="structobject.html">object</a> *actobject, <a class="el" href="structdirobject.html">dirobject</a> *actdir, <a class="el" href="structfits__access.html">fits_access</a> *m_access, const int int_type)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structenergy__distrib.html">energy_distrib</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="model__utils_8c.html#a6b478169411f67ce4c7702fa7815b445">make_sed_from_beam</a> (const <a class="el" href="structbeam.html">beam</a> onebeam, const int int_type, const int objID)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structdirobject.html">dirobject</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="model__utils_8c.html#a39965b9d4410809472bb1a5fd4328026">get_dirobject_from_list</a> (<a class="el" href="structdirobject.html">dirobject</a> **dirlist, const int ID)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structd__point.html">d_point</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="model__utils_8c.html#a6dbc5b3a67592030d394cee3570b44e8">get_dirobject_meanpos</a> (<a class="el" href="structdirobject.html">dirobject</a> *actdir)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structbeam.html">beam</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="model__utils_8c.html#a457e67339a8e12cee377ffebf7410c0d">get_beam_for_beamspec</a> (<a class="el" href="structobject.html">object</a> **oblist, const int nobjects, const <a class="el" href="structbeamspec.html">beamspec</a> *actspec)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structbeamspec.html">beamspec</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="model__utils_8c.html#ab0112661e420045b9ed86e6e8cb71794">get_beamspec_from_list</a> (<a class="el" href="structbeamspec.html">beamspec</a> **speclist, const int aperID, const int beamID)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="model__utils_8c.html#a6ea108739ddb7ea09f86c3c51b1b5848">print_dirobject</a> (const <a class="el" href="structdirobject.html">dirobject</a> *actdir)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="model__utils_8c.html#ade00a122791415b1ec8ba98f979bf914">check_interp_type</a> (const int inter_type, const int n_flux, const int ID)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="model__utils_8c.html#a72c9efb6343e03f3e19b0c81af37a54f">free_dirlist</a> (<a class="el" href="structdirobject.html">dirobject</a> **dirlist)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="model__utils_8c.html#aa711bf6afa5532517ed581be9e59d2d1">free_dirobject</a> (<a class="el" href="structdirobject.html">dirobject</a> *actdir)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="model__utils_8c.html#af4aeb43aa090824fe3dcad3049d38a62">free_enerdist</a> (<a class="el" href="structenergy__distrib.html">energy_distrib</a> *sed)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="model__utils_8c.html#a9869f818df7a666d983da7b3d1956532">free_speclist</a> (<a class="el" href="structbeamspec.html">beamspec</a> **speclist)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="model__utils_8c.html#aa698da13e1ad04e38c6ce9c51e4d2923">free_tracedata</a> (<a class="el" href="structtracedata.html">tracedata</a> *acttrace)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="model__utils_8c.html#ac6e79df79a058ccf4d82853e08a0c2df">get_flux_from_SED</a> (const <a class="el" href="structenergy__distrib.html">energy_distrib</a> *sed, double in_wave)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="model__utils_8c.html#a2eba8404bd9e64513d02fa578502e122">get_aveflux_from_SED</a> (const <a class="el" href="structenergy__distrib.html">energy_distrib</a> *sed, double in_wave, double wave_interv)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="model__utils_8c.html#a8d6681aef9c109bc5c407c286c85d67c">get_flambda_from_magab</a> (double mag, double lambda)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="model__utils_8c.html#ae73d0c2c001f041062d3f9776fd55dc1">fill_gaussvalues</a> (const <a class="el" href="structd__point.html">d_point</a> dpixel, const <a class="el" href="structbeam.html">beam</a> actbeam, const <a class="el" href="structdirobject.html">dirobject</a> *actdir, const double lambda_ref, const <a class="el" href="structaperture__conf.html">aperture_conf</a> *conf, const double psf_offset, <a class="el" href="structtracedata.html">tracedata</a> *acttrace)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structbeam.html">beam</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="model__utils_8c.html#ab02649b7a821651ecce41bd6dc3394f6">get_newbeam</a> (const <a class="el" href="structbeam.html">beam</a> actbeam, const double dpsf)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="model__utils_8c.html#af09a9a57d7ad0ec300ed94e9dd76d595">get_dpsf</a> (const double lambda_ref, const double lambda, const <a class="el" href="structaperture__conf.html">aperture_conf</a> *conf, const <a class="el" href="structbeam.html">beam</a> actbeam)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="model__utils_8c.html#a5d8695af668aaed17d349ca4eb36292c">get_sub_emodel_value</a> (const <a class="el" href="structd__point.html">d_point</a> dpixel, const <a class="el" href="structbeam.html">beam</a> actbeam, const <a class="el" href="structd__point.html">d_point</a> drzscale)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="model__utils_8c.html#ac36a7a4d559d6521def9d8198fa25bbf">get_emodel_value</a> (const <a class="el" href="structd__point.html">d_point</a> dpixel, const <a class="el" href="structbeam.html">beam</a> actbeam, const <a class="el" href="structd__point.html">d_point</a> drzscale)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="model__utils_8c.html#aaf9f8cca863f01beb42cceaf8c74e6ac">get_psf_WFC</a> (const double lambda)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="model__utils_8c.html#a78b257e92ab75a5531ccb6881ecd201e">get_psf_HRC</a> (const double lambda)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="model__utils_8c.html#af417d458a7783d5c0183ad9c69335fd0">get_psf_SBC</a> (const double lambda)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="model__utils_8c.html#a98ec48fe5d4a02d1711285b63fd4ed2a">get_polyN_gsl</a> (const double x, const gsl_vector *params)</td></tr>
</table>
<hr/><h2>Define Documentation</h2>
<a class="anchor" id="aacc3ee1a7f283f8ef65cea31f4436a95"></a><!-- doxytag: member="model_utils.c::MAX" ref="aacc3ee1a7f283f8ef65cea31f4436a95" args="(x, y)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MAX</td>
          <td>(</td>
          <td class="paramtype">x, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">y&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td>&nbsp;&nbsp;&nbsp;(((x)&gt;(y))?(x):(y))</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a74e75242132eaabbc1c512488a135926"></a><!-- doxytag: member="model_utils.c::MIN" ref="a74e75242132eaabbc1c512488a135926" args="(x, y)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MIN</td>
          <td>(</td>
          <td class="paramtype">x, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">y&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td>&nbsp;&nbsp;&nbsp;(((x)&lt;(y))?(x):(y))</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="aa7866fa5e4e0ee9b034e9dab6599a9cc"></a><!-- doxytag: member="model_utils.c::SQR" ref="aa7866fa5e4e0ee9b034e9dab6599a9cc" args="(x)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SQR</td>
          <td>(</td>
          <td class="paramtype">x&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td>&nbsp;&nbsp;&nbsp;((x)*(x))</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="ade00a122791415b1ec8ba98f979bf914"></a><!-- doxytag: member="model_utils.c::check_interp_type" ref="ade00a122791415b1ec8ba98f979bf914" args="(const int inter_type, const int n_flux, const int ID)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int check_interp_type </td>
          <td>(</td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>inter_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>n_flux</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>ID</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Function: check_interp_type The function checks the requested interpolation type against the number of flux values in the models. The interpolation type is adjusted in case that there are not enough flux values for the reuqested type.</p>
<p>Parameters: </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>inter_type</em>&nbsp;</td><td>- the requested interpolation </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>n_flux</em>&nbsp;</td><td>- the number of flux values </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ID</em>&nbsp;</td><td>- the <a class="el" href="structobject.html">object</a> ID</td></tr>
  </table>
  </dd>
</dl>
<p>Returns: </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>type - the feasable interpolation type </dd></dl>

<p><div class="fragment"><pre class="fragment"><a name="l01590"></a>01590 {
<a name="l01591"></a>01591   <span class="keywordtype">int</span> type=0;
<a name="l01592"></a>01592 
<a name="l01593"></a>01593   <span class="comment">// for interpolation types other than linear at leas</span>
<a name="l01594"></a>01594   <span class="comment">// three flux values must be there</span>
<a name="l01595"></a>01595   <span class="keywordflow">if</span> (n_flux &lt; 3 &amp;&amp; inter_type &gt; 1)
<a name="l01596"></a>01596     {
<a name="l01597"></a>01597       <span class="comment">// make a warnign message if there are</span>
<a name="l01598"></a>01598       <span class="comment">// not enough flux value</span>
<a name="l01599"></a>01599       <span class="keywordflow">if</span> (inter_type &gt; 2)
<a name="l01600"></a>01600         <a class="code" href="aXe__errors_8c.html#a7ef7588e5f91237ba7ce4084e6ed3c11">aXe_message</a> (<a class="code" href="aXe__errors_8h.html#a3f3c2d017ceaf0b51cfb71efbcaeff44">aXe_M_WARN4</a>, __FILE__, __LINE__,
<a name="l01601"></a>01601                      <span class="stringliteral">&quot;\naXe_PETCONT: Object: %i: interpolation switched from \&quot;spline\&quot; to \&quot;linear\&quot;!\n&quot;</span>, ID);
<a name="l01602"></a>01602       <span class="keywordflow">else</span>
<a name="l01603"></a>01603         <a class="code" href="aXe__errors_8c.html#a7ef7588e5f91237ba7ce4084e6ed3c11">aXe_message</a> (<a class="code" href="aXe__errors_8h.html#a3f3c2d017ceaf0b51cfb71efbcaeff44">aXe_M_WARN4</a>, __FILE__, __LINE__,
<a name="l01604"></a>01604                      <span class="stringliteral">&quot;\naXe_PETCONT: Object: %i: interpolation switched from \&quot;polynomial\&quot; to \&quot;linear\&quot;!\n&quot;</span>, ID);
<a name="l01605"></a>01605 
<a name="l01606"></a>01606       <span class="comment">// adjust the interpolation type to linear</span>
<a name="l01607"></a>01607       type = 1;
<a name="l01608"></a>01608     }
<a name="l01609"></a>01609   <span class="keywordflow">else</span>
<a name="l01610"></a>01610     {
<a name="l01611"></a>01611       <span class="comment">// copy the requeted interpolation type</span>
<a name="l01612"></a>01612       <span class="comment">// if there are enough flux values</span>
<a name="l01613"></a>01613       type = inter_type;
<a name="l01614"></a>01614     }
<a name="l01615"></a>01615 
<a name="l01616"></a>01616   <span class="comment">// return the adjusted type</span>
<a name="l01617"></a>01617   <span class="keywordflow">return</span> type;
<a name="l01618"></a>01618 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a0ad6a3c9e3542d3085e0b4d840e76ad1"></a><!-- doxytag: member="model_utils.c::compute_short_tracedata" ref="a0ad6a3c9e3542d3085e0b4d840e76ad1" args="(const aperture_conf *conf, const beam actbeam, const dirobject *actdir, const calib_function *wl_calibration, const beamspec *actspec)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structtracedata.html">tracedata</a>* compute_short_tracedata </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structaperture__conf.html">aperture_conf</a> *&nbsp;</td>
          <td class="paramname"> <em>conf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structbeam.html">beam</a>&nbsp;</td>
          <td class="paramname"> <em>actbeam</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdirobject.html">dirobject</a> *&nbsp;</td>
          <td class="paramname"> <em>actdir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcalib__function.html">calib_function</a> *&nbsp;</td>
          <td class="paramname"> <em>wl_calibration</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structbeamspec.html">beamspec</a> *&nbsp;</td>
          <td class="paramname"> <em>actspec</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Function: compute_short_tracedata</p>
<p>Parameters: </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>actbeam</em>&nbsp;</td><td>- the <a class="el" href="structbeam.html">beam</a> of the model <a class="el" href="structspectrum.html">spectrum</a> </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>actdir</em>&nbsp;</td><td>- the direct <a class="el" href="structobject.html">object</a> of the model <a class="el" href="structspectrum.html">spectrum</a> </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>wl_calibration</em>&nbsp;</td><td>- the wavelength calibration of the model <a class="el" href="structspectrum.html">spectrum</a> </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>actspec</em>&nbsp;</td><td>- the model <a class="el" href="structspectrum.html">spectrum</a></td></tr>
  </table>
  </dd>
</dl>
<p>Returns: </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>acttrace - the <a class="el" href="structtracedata.html">tracedata</a> structure </dd></dl>

<p><div class="fragment"><pre class="fragment"><a name="l00338"></a>00338 {
<a name="l00339"></a>00339 
<a name="l00340"></a>00340   <a class="code" href="structtracedata.html">tracedata</a>  *acttrace;
<a name="l00341"></a>00341   <a class="code" href="structtrace__func.html">trace_func</a> *tracefun;
<a name="l00342"></a>00342 
<a name="l00343"></a>00343   gsl_vector *dx;
<a name="l00344"></a>00344   gsl_vector *dy;
<a name="l00345"></a>00345   gsl_vector *xi;
<a name="l00346"></a>00346   gsl_vector *lambda;
<a name="l00347"></a>00347   gsl_vector *dlambda;
<a name="l00348"></a>00348   gsl_vector *flux;
<a name="l00349"></a>00349   gsl_vector *gvalue;
<a name="l00350"></a>00350 
<a name="l00351"></a>00351   <span class="keywordtype">double</span> tmp1, tmp2;
<a name="l00352"></a>00352 
<a name="l00353"></a>00353   <span class="keywordtype">int</span> dx_min, dx_max;
<a name="l00354"></a>00354   <span class="keywordtype">int</span> npoints;
<a name="l00355"></a>00355   <span class="keywordtype">int</span> i;
<a name="l00356"></a>00356   <span class="keywordtype">int</span> nentries;
<a name="l00357"></a>00357   <span class="keywordtype">int</span> dx0, dx1;
<a name="l00358"></a>00358 
<a name="l00359"></a>00359   <span class="comment">// allocate space for the tracedata</span>
<a name="l00360"></a>00360   acttrace = (<a class="code" href="structtracedata.html">tracedata</a> *)malloc(<span class="keyword">sizeof</span>(<a class="code" href="structtracedata.html">tracedata</a>));
<a name="l00361"></a>00361   <span class="keywordflow">if</span> (acttrace == NULL)
<a name="l00362"></a>00362     <a class="code" href="aXe__errors_8c.html#a7ef7588e5f91237ba7ce4084e6ed3c11">aXe_message</a> (<a class="code" href="aXe__errors_8h.html#a2556a67874555249b07691c37aa6d6e9">aXe_M_FATAL</a>, __FILE__, __LINE__,
<a name="l00363"></a>00363                  <span class="stringliteral">&quot;compute_tracedata:&quot;</span> <span class="stringliteral">&quot; Could not allocate&quot;</span>
<a name="l00364"></a>00364                  <span class="stringliteral">&quot; memory for a tracedata object!&quot;</span>);
<a name="l00365"></a>00365 
<a name="l00366"></a>00366   tracefun =  actbeam.<a class="code" href="structbeam.html#a918b8655ff4142f173ca73226ce27922">spec_trace</a>;
<a name="l00367"></a>00367 
<a name="l00368"></a>00368   dx0 = (double)conf-&gt;<a class="code" href="structaperture__conf.html#aa1f52d8496707cab4631dc2369d3dec2">beam</a>[actspec-&gt;<a class="code" href="structbeamspec.html#a8185e83f23ffbab21ec47ec3d2bea13c">beamID</a>].<a class="code" href="structbeam__conf.html#a55f5257b40a3f5f6b43980c779734e84">offset</a>.<a class="code" href="structpx__offset.html#a5d141ef035baf4fefab88956ea1a7060">dx0</a>;
<a name="l00369"></a>00369   dx1 = (<span class="keywordtype">double</span>)conf-&gt;<a class="code" href="structaperture__conf.html#aa1f52d8496707cab4631dc2369d3dec2">beam</a>[actspec-&gt;<a class="code" href="structbeamspec.html#a8185e83f23ffbab21ec47ec3d2bea13c">beamID</a>].<a class="code" href="structbeam__conf.html#a55f5257b40a3f5f6b43980c779734e84">offset</a>.<a class="code" href="structpx__offset.html#a81678dca036abb27f0c829b3aabca784">dx1</a>;
<a name="l00370"></a>00370   dx_min = <a class="code" href="aXe__utils_8c.html#a74e75242132eaabbc1c512488a135926">MIN</a>(dx0, dx1)-1;
<a name="l00371"></a>00371   dx_max = <a class="code" href="aper__conf_8c.html#aacc3ee1a7f283f8ef65cea31f4436a95">MAX</a>(dx0, dx1)+1;
<a name="l00372"></a>00372 
<a name="l00373"></a>00373   <span class="comment">// use the x-range of the direct obect area to</span>
<a name="l00374"></a>00374   <span class="comment">// compute the dx-range for this beam</span>
<a name="l00375"></a>00375   <span class="comment">//dx_min = MIN(actspec-&gt;model_ref.x - actdir-&gt;ix_min, actspec-&gt;model_ref.x - actdir-&gt;ix_max)-5;</span>
<a name="l00376"></a>00376   <span class="comment">//dx_max = MAX(actspec-&gt;model_ref.x - actdir-&gt;ix_min, actspec-&gt;model_ref.x - actdir-&gt;ix_max)</span>
<a name="l00377"></a>00377   <span class="comment">//  + (int)actspec-&gt;model-&gt;size1+5;</span>
<a name="l00378"></a>00378 
<a name="l00379"></a>00379   <span class="comment">// compute the number of points in the dx-range</span>
<a name="l00380"></a>00380   npoints = dx_max - dx_min + 1;
<a name="l00381"></a>00381 
<a name="l00382"></a>00382   <span class="comment">// allocate space for the tracedata</span>
<a name="l00383"></a>00383   dx      = gsl_vector_alloc(npoints);
<a name="l00384"></a>00384   dy      = gsl_vector_alloc(npoints);
<a name="l00385"></a>00385   xi      = gsl_vector_alloc(npoints);
<a name="l00386"></a>00386   lambda  = gsl_vector_alloc(npoints);
<a name="l00387"></a>00387   dlambda = gsl_vector_alloc(npoints);
<a name="l00388"></a>00388   flux    = gsl_vector_alloc(npoints);
<a name="l00389"></a>00389   gvalue  = gsl_vector_alloc(npoints);
<a name="l00390"></a>00390 
<a name="l00391"></a>00391 
<a name="l00392"></a>00392   <span class="comment">// go over each point in the dx-range</span>
<a name="l00393"></a>00393   <span class="keywordflow">for</span> (i=0; i &lt; npoints; i++)
<a name="l00394"></a>00394     {
<a name="l00395"></a>00395 
<a name="l00396"></a>00396       <span class="comment">// compute the dx- and dy-values</span>
<a name="l00397"></a>00397       tmp1 = (double)(dx_min + i);
<a name="l00398"></a>00398       tmp2 = tracefun-&gt;<a class="code" href="structtrace__func.html#a7c1a538b7ae1293d6e0fc1bdd4c2739c">func</a> (tmp1, tracefun-&gt;<a class="code" href="structtrace__func.html#aa610d641940ef4a567aef884dd0b32da">data</a>);
<a name="l00399"></a>00399 
<a name="l00400"></a>00400       <span class="comment">// store dx and dy, and xi (=dx)</span>
<a name="l00401"></a>00401       gsl_vector_set(dx, i, tmp1);
<a name="l00402"></a>00402       gsl_vector_set(dy, i, tmp2);
<a name="l00403"></a>00403       gsl_vector_set(xi, i, tmp1);
<a name="l00404"></a>00404       gsl_vector_set(gvalue, i, 1.0);
<a name="l00405"></a>00405       gsl_vector_set(flux, i, 1.0);
<a name="l00406"></a>00406     }
<a name="l00407"></a>00407 
<a name="l00408"></a>00408   <span class="comment">// compute the true xi values</span>
<a name="l00409"></a>00409   <a class="code" href="spce__pathlength_8c.html#a414f68dbdc28341ce5e57d2af4ab040c">abscissa_to_pathlength</a> (tracefun, xi);
<a name="l00410"></a>00410 
<a name="l00411"></a>00411   <span class="comment">// go over each point in the dx-range</span>
<a name="l00412"></a>00412   <span class="keywordflow">for</span> (i=0; i &lt; npoints; i++)
<a name="l00413"></a>00413     {
<a name="l00414"></a>00414 
<a name="l00415"></a>00415       <span class="comment">// compute  and store lambda</span>
<a name="l00416"></a>00416       gsl_vector_set(lambda, i, wl_calibration-&gt;<a class="code" href="structcalib__function.html#af3b6ef00cf4dfcfc75e8f129c555d99f">func</a>(gsl_vector_get(xi, i), wl_calibration-&gt;<a class="code" href="structcalib__function.html#a0c2f4bb6aac5dbd2ce276ed8bee280da">order</a>, wl_calibration-&gt;<a class="code" href="structcalib__function.html#af6161163d6abff34648d027533dbc89e">coeffs</a>));
<a name="l00417"></a>00417 
<a name="l00418"></a>00418       <span class="comment">// compute  and store dlambda</span>
<a name="l00419"></a>00419       tmp1 = wl_calibration-&gt;<a class="code" href="structcalib__function.html#af3b6ef00cf4dfcfc75e8f129c555d99f">func</a>(gsl_vector_get(xi, i)-0.5, wl_calibration-&gt;<a class="code" href="structcalib__function.html#a0c2f4bb6aac5dbd2ce276ed8bee280da">order</a>, wl_calibration-&gt;<a class="code" href="structcalib__function.html#af6161163d6abff34648d027533dbc89e">coeffs</a>);
<a name="l00420"></a>00420       tmp2 = wl_calibration-&gt;<a class="code" href="structcalib__function.html#af3b6ef00cf4dfcfc75e8f129c555d99f">func</a>(gsl_vector_get(xi, i)+0.5, wl_calibration-&gt;<a class="code" href="structcalib__function.html#a0c2f4bb6aac5dbd2ce276ed8bee280da">order</a>, wl_calibration-&gt;<a class="code" href="structcalib__function.html#af6161163d6abff34648d027533dbc89e">coeffs</a>);
<a name="l00421"></a>00421       gsl_vector_set(dlambda, i, fabs(tmp2-tmp1));
<a name="l00422"></a>00422     }
<a name="l00423"></a>00423 
<a name="l00424"></a>00424   <span class="keywordflow">for</span> (i=0; i &lt; npoints; i++)
<a name="l00425"></a>00425     {
<a name="l00426"></a>00426       <span class="keywordflow">if</span> (i == 0)
<a name="l00427"></a>00427         {
<a name="l00428"></a>00428           tmp1 = fabs(gsl_vector_get(lambda,i+1)-gsl_vector_get(lambda,i));
<a name="l00429"></a>00429         }
<a name="l00430"></a>00430       <span class="keywordflow">else</span> <span class="keywordflow">if</span> (i == npoints-1)
<a name="l00431"></a>00431         {
<a name="l00432"></a>00432           tmp1 = fabs(gsl_vector_get(lambda,i)-gsl_vector_get(lambda,i-1));
<a name="l00433"></a>00433         }
<a name="l00434"></a>00434       <span class="keywordflow">else</span>
<a name="l00435"></a>00435         {
<a name="l00436"></a>00436           tmp1 = fabs(gsl_vector_get(lambda,i+1) - gsl_vector_get(lambda,i-1)) / 2.0;
<a name="l00437"></a>00437         }
<a name="l00438"></a>00438       gsl_vector_set(dlambda, i, tmp1);
<a name="l00439"></a>00439     }
<a name="l00440"></a>00440 
<a name="l00441"></a>00441   <span class="comment">// transfer the quantities to the structure</span>
<a name="l00442"></a>00442   acttrace-&gt;<a class="code" href="structtracedata.html#af5aed7b8f1629b86be33dc7d57056bcc">npoints</a> = npoints;
<a name="l00443"></a>00443   acttrace-&gt;<a class="code" href="structtracedata.html#a30448278ba94615e1ef5d8801deab6e6">dx_start</a>= dx_min;
<a name="l00444"></a>00444 
<a name="l00445"></a>00445   acttrace-&gt;<a class="code" href="structtracedata.html#aebca3378cacc91654b164c7818f120e2">dx</a>      = dx;
<a name="l00446"></a>00446   acttrace-&gt;<a class="code" href="structtracedata.html#a0bdd805ca59eb0b1329694181236c191">dy</a>      = dy;
<a name="l00447"></a>00447   acttrace-&gt;<a class="code" href="structtracedata.html#aee169f9a7859629a3f3b9e8a58c43a39">xi</a>      = xi;
<a name="l00448"></a>00448   acttrace-&gt;<a class="code" href="structtracedata.html#a3c594775ee8672308604497766a66f02">lambda</a>  = lambda;
<a name="l00449"></a>00449   acttrace-&gt;<a class="code" href="structtracedata.html#a63bce5a9b367504eb09b87f41f3373da">dlambda</a> = dlambda;
<a name="l00450"></a>00450   acttrace-&gt;<a class="code" href="structtracedata.html#a536ca0eb0a785814fc211bcf835f666a">flux</a>    = flux;
<a name="l00451"></a>00451   acttrace-&gt;<a class="code" href="structtracedata.html#a263d2f1a51308e73d79c77f5e62c01fb">gvalue</a>  = gvalue;
<a name="l00452"></a>00452 
<a name="l00453"></a>00453   <span class="comment">// for prism data: constrain the tracedata</span>
<a name="l00454"></a>00454   <span class="keywordflow">if</span> (wl_calibration-&gt;<a class="code" href="structcalib__function.html#a585ddafa8bb9e1ac0b7a3da3410b5f80">pr_range</a> != NULL)
<a name="l00455"></a>00455     {
<a name="l00456"></a>00456      nentries = <a class="code" href="model__utils_8c.html#af6b109448b4b2c4087381a89a4946664">get_valid_tracedata</a>(acttrace, wl_calibration);
<a name="l00457"></a>00457      <a class="code" href="model__utils_8c.html#a67e212ed30f3f8311e5eaa822dd69705">select_tracedata</a>(acttrace, wl_calibration,nentries);
<a name="l00458"></a>00458     }
<a name="l00459"></a>00459   <span class="comment">// return the tracestructure</span>
<a name="l00460"></a>00460   <span class="keywordflow">return</span> acttrace;
<a name="l00461"></a>00461 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a88c32a3ad7593c46dfa166a806205e05"></a><!-- doxytag: member="model_utils.c::compute_tracedata" ref="a88c32a3ad7593c46dfa166a806205e05" args="(const beam actbeam, const dirobject *actdir, const calib_function *wl_calibration, const beamspec *actspec)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structtracedata.html">tracedata</a>* compute_tracedata </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structbeam.html">beam</a>&nbsp;</td>
          <td class="paramname"> <em>actbeam</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdirobject.html">dirobject</a> *&nbsp;</td>
          <td class="paramname"> <em>actdir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcalib__function.html">calib_function</a> *&nbsp;</td>
          <td class="paramname"> <em>wl_calibration</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structbeamspec.html">beamspec</a> *&nbsp;</td>
          <td class="paramname"> <em>actspec</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Function: compute_tracedata The function creates a <a class="el" href="structtracedata.html">tracedata</a> structure for a specific <a class="el" href="structbeam.html">beam</a> model. A <a class="el" href="structtracedata.html">tracedata</a> structure consists of all relevant information (position, wavelength, dispersion) for the pixels along the trace of a specific <a class="el" href="structbeam.html">beam</a>. Since the reference point remains constant during the modelling of a <a class="el" href="structbeam.html">beam</a>, it is better to store the relevant data for the use in each pixel.</p>
<p>Parameters: </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>actbeam</em>&nbsp;</td><td>- the <a class="el" href="structbeam.html">beam</a> of the model <a class="el" href="structspectrum.html">spectrum</a> </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>actdir</em>&nbsp;</td><td>- the direct <a class="el" href="structobject.html">object</a> of the model <a class="el" href="structspectrum.html">spectrum</a> </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>wl_calibration</em>&nbsp;</td><td>- the wavelength calibration of the model <a class="el" href="structspectrum.html">spectrum</a> </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>actspec</em>&nbsp;</td><td>- the model <a class="el" href="structspectrum.html">spectrum</a></td></tr>
  </table>
  </dd>
</dl>
<p>Returns: </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>acttrace - the <a class="el" href="structtracedata.html">tracedata</a> structure </dd></dl>

<p><div class="fragment"><pre class="fragment"><a name="l00203"></a>00203 {
<a name="l00204"></a>00204 
<a name="l00205"></a>00205   <a class="code" href="structtracedata.html">tracedata</a>  *acttrace;
<a name="l00206"></a>00206   <a class="code" href="structtrace__func.html">trace_func</a> *tracefun;
<a name="l00207"></a>00207 
<a name="l00208"></a>00208   gsl_vector *dx;
<a name="l00209"></a>00209   gsl_vector *dy;
<a name="l00210"></a>00210   gsl_vector *xi;
<a name="l00211"></a>00211   gsl_vector *lambda;
<a name="l00212"></a>00212   gsl_vector *dlambda;
<a name="l00213"></a>00213   gsl_vector *flux;
<a name="l00214"></a>00214   gsl_vector *gvalue;
<a name="l00215"></a>00215 
<a name="l00216"></a>00216   <span class="keywordtype">double</span> tmp1, tmp2;
<a name="l00217"></a>00217 
<a name="l00218"></a>00218   <span class="keywordtype">int</span> dx_min, dx_max;
<a name="l00219"></a>00219   <span class="keywordtype">int</span> npoints;
<a name="l00220"></a>00220   <span class="keywordtype">int</span> i;
<a name="l00221"></a>00221   <span class="keywordtype">int</span> nentries;
<a name="l00222"></a>00222 
<a name="l00223"></a>00223   <span class="comment">// allocate space for the tracedata</span>
<a name="l00224"></a>00224   acttrace = (<a class="code" href="structtracedata.html">tracedata</a> *)malloc(<span class="keyword">sizeof</span>(<a class="code" href="structtracedata.html">tracedata</a>));
<a name="l00225"></a>00225   <span class="keywordflow">if</span> (acttrace == NULL)
<a name="l00226"></a>00226     <a class="code" href="aXe__errors_8c.html#a7ef7588e5f91237ba7ce4084e6ed3c11">aXe_message</a> (<a class="code" href="aXe__errors_8h.html#a2556a67874555249b07691c37aa6d6e9">aXe_M_FATAL</a>, __FILE__, __LINE__,
<a name="l00227"></a>00227                  <span class="stringliteral">&quot;compute_tracedata:&quot;</span> <span class="stringliteral">&quot; Could not allocate&quot;</span>
<a name="l00228"></a>00228                  <span class="stringliteral">&quot; memory for a tracedata object!&quot;</span>);
<a name="l00229"></a>00229 
<a name="l00230"></a>00230   tracefun =  actbeam.<a class="code" href="structbeam.html#a918b8655ff4142f173ca73226ce27922">spec_trace</a>;
<a name="l00231"></a>00231 
<a name="l00232"></a>00232   <span class="comment">// use the x-range of the direct obect area to</span>
<a name="l00233"></a>00233   <span class="comment">// compute the dx-range for this beam</span>
<a name="l00234"></a>00234   dx_min = <a class="code" href="aXe__utils_8c.html#a74e75242132eaabbc1c512488a135926">MIN</a>(actspec-&gt;<a class="code" href="structbeamspec.html#a4526cf634c09ad9fbd3f566dba8ea0fd">model_ref</a>.<a class="code" href="structd__point.html#a922a3b5d82a119168ba85e5f939d02c3">x</a> - actdir-&gt;<a class="code" href="structdirobject.html#ac068f35c585eec4cd1e5d3392c2dd698">ix_min</a>, actspec-&gt;<a class="code" href="structbeamspec.html#a4526cf634c09ad9fbd3f566dba8ea0fd">model_ref</a>.<a class="code" href="structd__point.html#a922a3b5d82a119168ba85e5f939d02c3">x</a> - actdir-&gt;<a class="code" href="structdirobject.html#ac8c6104f2c2e1384c64bba61ecf40d69">ix_max</a>)-5;
<a name="l00235"></a>00235   dx_max = <a class="code" href="aper__conf_8c.html#aacc3ee1a7f283f8ef65cea31f4436a95">MAX</a>(actspec-&gt;<a class="code" href="structbeamspec.html#a4526cf634c09ad9fbd3f566dba8ea0fd">model_ref</a>.<a class="code" href="structd__point.html#a922a3b5d82a119168ba85e5f939d02c3">x</a> - actdir-&gt;<a class="code" href="structdirobject.html#ac068f35c585eec4cd1e5d3392c2dd698">ix_min</a>, actspec-&gt;<a class="code" href="structbeamspec.html#a4526cf634c09ad9fbd3f566dba8ea0fd">model_ref</a>.<a class="code" href="structd__point.html#a922a3b5d82a119168ba85e5f939d02c3">x</a> - actdir-&gt;<a class="code" href="structdirobject.html#ac8c6104f2c2e1384c64bba61ecf40d69">ix_max</a>)
<a name="l00236"></a>00236     + (int)actspec-&gt;<a class="code" href="structbeamspec.html#a5585f5d3885305e980e09fed9a79a618">model</a>-&gt;size1+5;
<a name="l00237"></a>00237 
<a name="l00238"></a>00238   <span class="comment">// compute the number of points in the dx-range</span>
<a name="l00239"></a>00239   npoints = dx_max - dx_min + 1;
<a name="l00240"></a>00240 
<a name="l00241"></a>00241   <span class="comment">// allocate space for the tracedata</span>
<a name="l00242"></a>00242   dx      = gsl_vector_alloc(npoints);
<a name="l00243"></a>00243   dy      = gsl_vector_alloc(npoints);
<a name="l00244"></a>00244   xi      = gsl_vector_alloc(npoints);
<a name="l00245"></a>00245   lambda  = gsl_vector_alloc(npoints);
<a name="l00246"></a>00246   dlambda = gsl_vector_alloc(npoints);
<a name="l00247"></a>00247   flux    = gsl_vector_alloc(npoints);
<a name="l00248"></a>00248   gvalue  = gsl_vector_alloc(npoints);
<a name="l00249"></a>00249 
<a name="l00250"></a>00250 
<a name="l00251"></a>00251   <span class="comment">// go over each point in the dx-range</span>
<a name="l00252"></a>00252   <span class="keywordflow">for</span> (i=0; i &lt; npoints; i++)
<a name="l00253"></a>00253     {
<a name="l00254"></a>00254 
<a name="l00255"></a>00255       <span class="comment">// compute the dx- and dy-values</span>
<a name="l00256"></a>00256       tmp1 = (double)(dx_min + i);
<a name="l00257"></a>00257       tmp2 = tracefun-&gt;<a class="code" href="structtrace__func.html#a7c1a538b7ae1293d6e0fc1bdd4c2739c">func</a> (tmp1, tracefun-&gt;<a class="code" href="structtrace__func.html#aa610d641940ef4a567aef884dd0b32da">data</a>);
<a name="l00258"></a>00258 
<a name="l00259"></a>00259       <span class="comment">// store dx and dy, and xi (=dx)</span>
<a name="l00260"></a>00260       gsl_vector_set(dx, i, tmp1);
<a name="l00261"></a>00261       gsl_vector_set(dy, i, tmp2);
<a name="l00262"></a>00262       gsl_vector_set(xi, i, tmp1);
<a name="l00263"></a>00263       gsl_vector_set(gvalue, i, 1.0);
<a name="l00264"></a>00264       gsl_vector_set(flux, i, 1.0);
<a name="l00265"></a>00265     }
<a name="l00266"></a>00266 
<a name="l00267"></a>00267   <span class="comment">// compute the true xi values</span>
<a name="l00268"></a>00268   <a class="code" href="spce__pathlength_8c.html#a414f68dbdc28341ce5e57d2af4ab040c">abscissa_to_pathlength</a> (tracefun, xi);
<a name="l00269"></a>00269 
<a name="l00270"></a>00270   <span class="comment">// go over each point in the dx-range</span>
<a name="l00271"></a>00271   <span class="keywordflow">for</span> (i=0; i &lt; npoints; i++)
<a name="l00272"></a>00272     {
<a name="l00273"></a>00273 
<a name="l00274"></a>00274       <span class="comment">// compute  and store lambda</span>
<a name="l00275"></a>00275       gsl_vector_set(lambda, i, wl_calibration-&gt;<a class="code" href="structcalib__function.html#af3b6ef00cf4dfcfc75e8f129c555d99f">func</a>(gsl_vector_get(xi, i), wl_calibration-&gt;<a class="code" href="structcalib__function.html#a0c2f4bb6aac5dbd2ce276ed8bee280da">order</a>, wl_calibration-&gt;<a class="code" href="structcalib__function.html#af6161163d6abff34648d027533dbc89e">coeffs</a>));
<a name="l00276"></a>00276 
<a name="l00277"></a>00277       <span class="comment">// compute  and store dlambda</span>
<a name="l00278"></a>00278       tmp1 = wl_calibration-&gt;<a class="code" href="structcalib__function.html#af3b6ef00cf4dfcfc75e8f129c555d99f">func</a>(gsl_vector_get(xi, i)-0.5, wl_calibration-&gt;<a class="code" href="structcalib__function.html#a0c2f4bb6aac5dbd2ce276ed8bee280da">order</a>, wl_calibration-&gt;<a class="code" href="structcalib__function.html#af6161163d6abff34648d027533dbc89e">coeffs</a>);
<a name="l00279"></a>00279       tmp2 = wl_calibration-&gt;<a class="code" href="structcalib__function.html#af3b6ef00cf4dfcfc75e8f129c555d99f">func</a>(gsl_vector_get(xi, i)+0.5, wl_calibration-&gt;<a class="code" href="structcalib__function.html#a0c2f4bb6aac5dbd2ce276ed8bee280da">order</a>, wl_calibration-&gt;<a class="code" href="structcalib__function.html#af6161163d6abff34648d027533dbc89e">coeffs</a>);
<a name="l00280"></a>00280       gsl_vector_set(dlambda, i, fabs(tmp2-tmp1));
<a name="l00281"></a>00281     }
<a name="l00282"></a>00282 
<a name="l00283"></a>00283   <span class="keywordflow">for</span> (i=0; i &lt; npoints; i++)
<a name="l00284"></a>00284     {
<a name="l00285"></a>00285       <span class="keywordflow">if</span> (i == 0)
<a name="l00286"></a>00286         {
<a name="l00287"></a>00287           tmp1 = fabs(gsl_vector_get(lambda,i+1)-gsl_vector_get(lambda,i));
<a name="l00288"></a>00288         }
<a name="l00289"></a>00289       <span class="keywordflow">else</span> <span class="keywordflow">if</span> (i == npoints-1)
<a name="l00290"></a>00290         {
<a name="l00291"></a>00291           tmp1 = fabs(gsl_vector_get(lambda,i)-gsl_vector_get(lambda,i-1));
<a name="l00292"></a>00292         }
<a name="l00293"></a>00293       <span class="keywordflow">else</span>
<a name="l00294"></a>00294         {
<a name="l00295"></a>00295           tmp1 = fabs(gsl_vector_get(lambda,i+1) - gsl_vector_get(lambda,i-1)) / 2.0;
<a name="l00296"></a>00296         }
<a name="l00297"></a>00297       gsl_vector_set(dlambda, i, tmp1);
<a name="l00298"></a>00298     }
<a name="l00299"></a>00299 
<a name="l00300"></a>00300   <span class="comment">// transfer the quantities to the structure</span>
<a name="l00301"></a>00301   acttrace-&gt;<a class="code" href="structtracedata.html#af5aed7b8f1629b86be33dc7d57056bcc">npoints</a> = npoints;
<a name="l00302"></a>00302   acttrace-&gt;<a class="code" href="structtracedata.html#a30448278ba94615e1ef5d8801deab6e6">dx_start</a>= dx_min;
<a name="l00303"></a>00303 
<a name="l00304"></a>00304   acttrace-&gt;<a class="code" href="structtracedata.html#aebca3378cacc91654b164c7818f120e2">dx</a>      = dx;
<a name="l00305"></a>00305   acttrace-&gt;<a class="code" href="structtracedata.html#a0bdd805ca59eb0b1329694181236c191">dy</a>      = dy;
<a name="l00306"></a>00306   acttrace-&gt;<a class="code" href="structtracedata.html#aee169f9a7859629a3f3b9e8a58c43a39">xi</a>      = xi;
<a name="l00307"></a>00307   acttrace-&gt;<a class="code" href="structtracedata.html#a3c594775ee8672308604497766a66f02">lambda</a>  = lambda;
<a name="l00308"></a>00308   acttrace-&gt;<a class="code" href="structtracedata.html#a63bce5a9b367504eb09b87f41f3373da">dlambda</a> = dlambda;
<a name="l00309"></a>00309   acttrace-&gt;<a class="code" href="structtracedata.html#a536ca0eb0a785814fc211bcf835f666a">flux</a>    = flux;
<a name="l00310"></a>00310   acttrace-&gt;<a class="code" href="structtracedata.html#a263d2f1a51308e73d79c77f5e62c01fb">gvalue</a>  = gvalue;
<a name="l00311"></a>00311 
<a name="l00312"></a>00312   <span class="comment">// for prism data: constrain the tracedata</span>
<a name="l00313"></a>00313   <span class="keywordflow">if</span> (wl_calibration-&gt;<a class="code" href="structcalib__function.html#a585ddafa8bb9e1ac0b7a3da3410b5f80">pr_range</a> != NULL)
<a name="l00314"></a>00314     {
<a name="l00315"></a>00315      nentries = <a class="code" href="model__utils_8c.html#af6b109448b4b2c4087381a89a4946664">get_valid_tracedata</a>(acttrace, wl_calibration);
<a name="l00316"></a>00316      <a class="code" href="model__utils_8c.html#a67e212ed30f3f8311e5eaa822dd69705">select_tracedata</a>(acttrace, wl_calibration,nentries);
<a name="l00317"></a>00317     }
<a name="l00318"></a>00318   <span class="comment">// return the tracestructure</span>
<a name="l00319"></a>00319   <span class="keywordflow">return</span> acttrace;
<a name="l00320"></a>00320 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="aabe948f13d5487dcabd5499c635ca01e"></a><!-- doxytag: member="model_utils.c::fill_dirobj_fromdirim" ref="aabe948f13d5487dcabd5499c635ca01e" args="(const object *actobject, object_models *objmodels)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdirobject.html">dirobject</a>* fill_dirobj_fromdirim </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structobject.html">object</a> *&nbsp;</td>
          <td class="paramname"> <em>actobject</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structobject__models.html">object_models</a> *&nbsp;</td>
          <td class="paramname"> <em>objmodels</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Function: fill_dirobj_fromdirim Transforms an <a class="el" href="structobject.html">object</a> which has a direct emission model associated to into a direct <a class="el" href="structobject.html">object</a>. The direct <a class="el" href="structobject.html">object</a> created is returned</p>
<p>Parameters: </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>actobject</em>&nbsp;</td><td>- the <a class="el" href="structobject.html">object</a> to be transformed </td></tr>
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="structobject__models.html">object_models</a></em>&nbsp;</td><td>- the structure with the direct emission models</td></tr>
  </table>
  </dd>
</dl>
<p>Returns: </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>actdir - the <a class="el" href="structdirobject.html">dirobject</a> created </dd></dl>

<p><div class="fragment"><pre class="fragment"><a name="l00960"></a>00960 {
<a name="l00961"></a>00961 
<a name="l00962"></a>00962   <a class="code" href="structdirobject.html">dirobject</a>      *actdir=NULL;
<a name="l00963"></a>00963   gsl_vector     *extention;
<a name="l00964"></a>00964   <a class="code" href="structdirim__emission.html">dirim_emission</a> *dirim;
<a name="l00965"></a>00965 
<a name="l00966"></a>00966   <span class="comment">// allocate space for the dirobject</span>
<a name="l00967"></a>00967   actdir = (<a class="code" href="structdirobject.html">dirobject</a> *) malloc (<span class="keyword">sizeof</span> (<a class="code" href="structdirobject.html">dirobject</a>));
<a name="l00968"></a>00968   <span class="keywordflow">if</span> (actdir == NULL)
<a name="l00969"></a>00969     <a class="code" href="aXe__errors_8c.html#a7ef7588e5f91237ba7ce4084e6ed3c11">aXe_message</a> (<a class="code" href="aXe__errors_8h.html#a2556a67874555249b07691c37aa6d6e9">aXe_M_FATAL</a>, __FILE__, __LINE__,
<a name="l00970"></a>00970                  <span class="stringliteral">&quot;fill_dirobj_fromdirim:&quot;</span> <span class="stringliteral">&quot; Could not allocate&quot;</span>
<a name="l00971"></a>00971                  <span class="stringliteral">&quot; memory for a dirobject object&quot;</span>);
<a name="l00972"></a>00972 
<a name="l00973"></a>00973   <span class="comment">// assign a direct emission model to a local variable</span>
<a name="l00974"></a>00974   dirim = <a class="code" href="specmodel__utils_8c.html#a152c924fc73a4302519e7407c958ef2e">get_dirim_emission</a>(objmodels, actobject-&gt;<a class="code" href="structobject.html#ad643757142781f8265b430e19700cfe5">beams</a>[0].<a class="code" href="structbeam.html#a343c47194d158bcc217a46923038e1a3">modimage</a>);
<a name="l00975"></a>00975 
<a name="l00976"></a>00976   <span class="comment">// transfer refpoint and ID</span>
<a name="l00977"></a>00977   actdir-&gt;<a class="code" href="structdirobject.html#ac7f75c9d3cdd6d50adc84ec001beee5b">ID</a> = actobject-&gt;<a class="code" href="structobject.html#a8575880bdfc1c0bf44914b4efd2665bf">ID</a>;
<a name="l00978"></a>00978   actdir-&gt;<a class="code" href="structdirobject.html#a66ec2727d2a5269c84804a89626834fa">refpoint</a>.<a class="code" href="structd__point.html#a922a3b5d82a119168ba85e5f939d02c3">x</a> = actobject-&gt;<a class="code" href="structobject.html#ad643757142781f8265b430e19700cfe5">beams</a>[0].<a class="code" href="structbeam.html#a54c64670a8b3e8732c1468d156ddb0ca">refpoint</a>.<a class="code" href="structd__point.html#a922a3b5d82a119168ba85e5f939d02c3">x</a>;
<a name="l00979"></a>00979   actdir-&gt;<a class="code" href="structdirobject.html#a66ec2727d2a5269c84804a89626834fa">refpoint</a>.<a class="code" href="structd__point.html#ad9846a025508bf8873a501ca5fcefbf4">y</a> = actobject-&gt;<a class="code" href="structobject.html#ad643757142781f8265b430e19700cfe5">beams</a>[0].<a class="code" href="structbeam.html#a54c64670a8b3e8732c1468d156ddb0ca">refpoint</a>.<a class="code" href="structd__point.html#ad9846a025508bf8873a501ca5fcefbf4">y</a>;
<a name="l00980"></a>00980 
<a name="l00981"></a>00981   <span class="comment">// get the extentions on the reference points</span>
<a name="l00982"></a>00982   extention = <a class="code" href="model__utils_8c.html#a5b20290920148fb8fb75adb149a94f6d">get_refpoint_ranges</a>(actobject);
<a name="l00983"></a>00983 
<a name="l00984"></a>00984   <span class="comment">// derive and store min/max in x/y for the corners</span>
<a name="l00985"></a>00985   actdir-&gt;<a class="code" href="structdirobject.html#ac068f35c585eec4cd1e5d3392c2dd698">ix_min</a> = (int)floor(actobject-&gt;<a class="code" href="structobject.html#ad643757142781f8265b430e19700cfe5">beams</a>[0].<a class="code" href="structbeam.html#a54c64670a8b3e8732c1468d156ddb0ca">refpoint</a>.<a class="code" href="structd__point.html#a922a3b5d82a119168ba85e5f939d02c3">x</a> - dirim-&gt;<a class="code" href="structdirim__emission.html#a57c2f8cf6dfc3ede582b40f8a63e3eec">xmean</a> + gsl_vector_get(extention, 0) + 0.5);
<a name="l00986"></a>00986   actdir-&gt;<a class="code" href="structdirobject.html#ac8c6104f2c2e1384c64bba61ecf40d69">ix_max</a> = (int)floor(actobject-&gt;<a class="code" href="structobject.html#ad643757142781f8265b430e19700cfe5">beams</a>[0].<a class="code" href="structbeam.html#a54c64670a8b3e8732c1468d156ddb0ca">refpoint</a>.<a class="code" href="structd__point.html#a922a3b5d82a119168ba85e5f939d02c3">x</a> + dirim-&gt;<a class="code" href="structdirim__emission.html#a57c2f8cf6dfc3ede582b40f8a63e3eec">xmean</a> + gsl_vector_get(extention, 1) + 0.5);
<a name="l00987"></a>00987   actdir-&gt;<a class="code" href="structdirobject.html#af24c9a92fa18516591e43d96eec13272">iy_min</a> = (int)floor(actobject-&gt;<a class="code" href="structobject.html#ad643757142781f8265b430e19700cfe5">beams</a>[0].<a class="code" href="structbeam.html#a54c64670a8b3e8732c1468d156ddb0ca">refpoint</a>.<a class="code" href="structd__point.html#ad9846a025508bf8873a501ca5fcefbf4">y</a> - dirim-&gt;<a class="code" href="structdirim__emission.html#a95dcd0f591805409a5667874e771597e">ymean</a> + gsl_vector_get(extention, 2) + 0.5);
<a name="l00988"></a>00988   actdir-&gt;<a class="code" href="structdirobject.html#a3b36973dd52d158c059bfe6587a04244">iy_max</a> = (int)floor(actobject-&gt;<a class="code" href="structobject.html#ad643757142781f8265b430e19700cfe5">beams</a>[0].<a class="code" href="structbeam.html#a54c64670a8b3e8732c1468d156ddb0ca">refpoint</a>.<a class="code" href="structd__point.html#ad9846a025508bf8873a501ca5fcefbf4">y</a> + dirim-&gt;<a class="code" href="structdirim__emission.html#a95dcd0f591805409a5667874e771597e">ymean</a> + gsl_vector_get(extention, 3) + 0.5);
<a name="l00989"></a>00989 
<a name="l00990"></a>00990   <span class="comment">// fix the drizzle scale, since it has no</span>
<a name="l00991"></a>00991   <span class="comment">// business in this context</span>
<a name="l00992"></a>00992   actdir-&gt;<a class="code" href="structdirobject.html#a1e61e87181abdea5dab21eb1dc3564dc">drzscale</a>.<a class="code" href="structd__point.html#a922a3b5d82a119168ba85e5f939d02c3">x</a> = 1.0;
<a name="l00993"></a>00993   actdir-&gt;<a class="code" href="structdirobject.html#a1e61e87181abdea5dab21eb1dc3564dc">drzscale</a>.<a class="code" href="structd__point.html#ad9846a025508bf8873a501ca5fcefbf4">y</a> = 1.0;
<a name="l00994"></a>00994 
<a name="l00995"></a>00995   <span class="comment">// store the direct emission</span>
<a name="l00996"></a>00996   <span class="comment">// object in the direct object</span>
<a name="l00997"></a>00997   actdir-&gt;<a class="code" href="structdirobject.html#a484dadbe6f9bdade97aa303366b4ef6a">dirim</a> = dirim;
<a name="l00998"></a>00998 
<a name="l00999"></a>00999   <span class="comment">// free the memory for the vector</span>
<a name="l01000"></a>01000   gsl_vector_free(extention);
<a name="l01001"></a>01001 
<a name="l01002"></a>01002   <span class="comment">// return the dirobject</span>
<a name="l01003"></a>01003   <span class="keywordflow">return</span> actdir;
<a name="l01004"></a>01004 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ae01b7359b803f5823de49af7ba8de948"></a><!-- doxytag: member="model_utils.c::fill_dirobject" ref="ae01b7359b803f5823de49af7ba8de948" args="(const object *actobject, const px_point npixels, gsl_matrix *drzcoeffs, const double model_scale, const int max_offset)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdirobject.html">dirobject</a>* fill_dirobject </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structobject.html">object</a> *&nbsp;</td>
          <td class="paramname"> <em>actobject</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structpx__point.html">px_point</a>&nbsp;</td>
          <td class="paramname"> <em>npixels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gsl_matrix *&nbsp;</td>
          <td class="paramname"> <em>drzcoeffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>model_scale</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>max_offset</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Function: fill_dirobject Transforms one <a class="el" href="structobject.html">object</a> into one <a class="el" href="structdirobject.html">dirobject</a>. Either transfers or computes the content of the <a class="el" href="structdirobject.html">dirobject</a> from the <a class="el" href="structobject.html">object</a>.</p>
<p>Parameters: </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>actobject</em>&nbsp;</td><td>- the <a class="el" href="structobject.html">object</a> to be transformed </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>npixels</em>&nbsp;</td><td>- the dimension of the grism image </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>drzcoeffs</em>&nbsp;</td><td>- the drizzle coefficients </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>model_scale</em>&nbsp;</td><td>- the scale for the size of the direct <a class="el" href="structobject.html">object</a> area</td></tr>
  </table>
  </dd>
</dl>
<p>Returns: </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>actdir - the <a class="el" href="structdirobject.html">dirobject</a> created </dd></dl>

<p><div class="fragment"><pre class="fragment"><a name="l00880"></a>00880 {
<a name="l00881"></a>00881 
<a name="l00882"></a>00882   <a class="code" href="structdirobject.html">dirobject</a> *actdir;
<a name="l00883"></a>00883   <a class="code" href="structd__point.html">d_point</a> dirmod[4];
<a name="l00884"></a>00884   <span class="keywordtype">double</span> delx_a, dely_a;
<a name="l00885"></a>00885   <span class="keywordtype">double</span> delx_b, dely_b;
<a name="l00886"></a>00886   gsl_vector *extention;
<a name="l00887"></a>00887 
<a name="l00888"></a>00888   <span class="comment">// allocate space for the dirobject</span>
<a name="l00889"></a>00889   actdir = (<a class="code" href="structdirobject.html">dirobject</a> *) malloc (<span class="keyword">sizeof</span> (<a class="code" href="structdirobject.html">dirobject</a>));
<a name="l00890"></a>00890   <span class="keywordflow">if</span> (actdir == NULL)
<a name="l00891"></a>00891     <a class="code" href="aXe__errors_8c.html#a7ef7588e5f91237ba7ce4084e6ed3c11">aXe_message</a> (<a class="code" href="aXe__errors_8h.html#a2556a67874555249b07691c37aa6d6e9">aXe_M_FATAL</a>, __FILE__, __LINE__,
<a name="l00892"></a>00892                  <span class="stringliteral">&quot;fill_dirobject:&quot;</span> <span class="stringliteral">&quot; Could not allocate&quot;</span>
<a name="l00893"></a>00893                  <span class="stringliteral">&quot; memory for a dirobject object&quot;</span>);
<a name="l00894"></a>00894 
<a name="l00895"></a>00895   <span class="comment">// compute the vector of maximum elongation along the large half axis</span>
<a name="l00896"></a>00896   delx_a = model_scale * actobject-&gt;<a class="code" href="structobject.html#ad643757142781f8265b430e19700cfe5">beams</a>[0].<a class="code" href="structbeam.html#a9a40c792769161a2526fb415c6dadad0">awidth</a> * cos(actobject-&gt;<a class="code" href="structobject.html#ad643757142781f8265b430e19700cfe5">beams</a>[0].<a class="code" href="structbeam.html#a5cbf4e447f3c6272f31215965e4d574c">aorient</a>);
<a name="l00897"></a>00897   dely_a = model_scale * actobject-&gt;<a class="code" href="structobject.html#ad643757142781f8265b430e19700cfe5">beams</a>[0].<a class="code" href="structbeam.html#a9a40c792769161a2526fb415c6dadad0">awidth</a> * sin(actobject-&gt;<a class="code" href="structobject.html#ad643757142781f8265b430e19700cfe5">beams</a>[0].<a class="code" href="structbeam.html#a5cbf4e447f3c6272f31215965e4d574c">aorient</a>);
<a name="l00898"></a>00898 
<a name="l00899"></a>00899   <span class="comment">// compute the vector of maximum elongation along the small half axis</span>
<a name="l00900"></a>00900   delx_b = model_scale * actobject-&gt;<a class="code" href="structobject.html#ad643757142781f8265b430e19700cfe5">beams</a>[0].<a class="code" href="structbeam.html#acc52e3393f91f5f11a65d1a6806b681f">bwidth</a> * cos(actobject-&gt;<a class="code" href="structobject.html#ad643757142781f8265b430e19700cfe5">beams</a>[0].<a class="code" href="structbeam.html#a5cbf4e447f3c6272f31215965e4d574c">aorient</a> + M_PI/2.0);
<a name="l00901"></a>00901   dely_b = model_scale * actobject-&gt;<a class="code" href="structobject.html#ad643757142781f8265b430e19700cfe5">beams</a>[0].<a class="code" href="structbeam.html#acc52e3393f91f5f11a65d1a6806b681f">bwidth</a> * sin(actobject-&gt;<a class="code" href="structobject.html#ad643757142781f8265b430e19700cfe5">beams</a>[0].<a class="code" href="structbeam.html#a5cbf4e447f3c6272f31215965e4d574c">aorient</a> + M_PI/2.0);
<a name="l00902"></a>00902 
<a name="l00903"></a>00903   <span class="comment">// corner refpoint + large vector + small vector</span>
<a name="l00904"></a>00904   dirmod[0].<a class="code" href="structd__point.html#a922a3b5d82a119168ba85e5f939d02c3">x</a> = actobject-&gt;<a class="code" href="structobject.html#ad643757142781f8265b430e19700cfe5">beams</a>[0].<a class="code" href="structbeam.html#a54c64670a8b3e8732c1468d156ddb0ca">refpoint</a>.<a class="code" href="structd__point.html#a922a3b5d82a119168ba85e5f939d02c3">x</a> + delx_a + delx_b;
<a name="l00905"></a>00905   dirmod[0].<a class="code" href="structd__point.html#ad9846a025508bf8873a501ca5fcefbf4">y</a> = actobject-&gt;<a class="code" href="structobject.html#ad643757142781f8265b430e19700cfe5">beams</a>[0].<a class="code" href="structbeam.html#a54c64670a8b3e8732c1468d156ddb0ca">refpoint</a>.<a class="code" href="structd__point.html#ad9846a025508bf8873a501ca5fcefbf4">y</a> + dely_a + dely_b;
<a name="l00906"></a>00906 
<a name="l00907"></a>00907   <span class="comment">// corner refpoint + large vector - small vector</span>
<a name="l00908"></a>00908   dirmod[1].<a class="code" href="structd__point.html#a922a3b5d82a119168ba85e5f939d02c3">x</a> = actobject-&gt;<a class="code" href="structobject.html#ad643757142781f8265b430e19700cfe5">beams</a>[0].<a class="code" href="structbeam.html#a54c64670a8b3e8732c1468d156ddb0ca">refpoint</a>.<a class="code" href="structd__point.html#a922a3b5d82a119168ba85e5f939d02c3">x</a> + delx_a - delx_b;
<a name="l00909"></a>00909   dirmod[1].<a class="code" href="structd__point.html#ad9846a025508bf8873a501ca5fcefbf4">y</a> = actobject-&gt;<a class="code" href="structobject.html#ad643757142781f8265b430e19700cfe5">beams</a>[0].<a class="code" href="structbeam.html#a54c64670a8b3e8732c1468d156ddb0ca">refpoint</a>.<a class="code" href="structd__point.html#ad9846a025508bf8873a501ca5fcefbf4">y</a> + dely_a - dely_b;
<a name="l00910"></a>00910 
<a name="l00911"></a>00911   <span class="comment">// corner refpoint - large vector + small vector</span>
<a name="l00912"></a>00912   dirmod[2].<a class="code" href="structd__point.html#a922a3b5d82a119168ba85e5f939d02c3">x</a> = actobject-&gt;<a class="code" href="structobject.html#ad643757142781f8265b430e19700cfe5">beams</a>[0].<a class="code" href="structbeam.html#a54c64670a8b3e8732c1468d156ddb0ca">refpoint</a>.<a class="code" href="structd__point.html#a922a3b5d82a119168ba85e5f939d02c3">x</a> - delx_a + delx_b;
<a name="l00913"></a>00913   dirmod[2].<a class="code" href="structd__point.html#ad9846a025508bf8873a501ca5fcefbf4">y</a> = actobject-&gt;<a class="code" href="structobject.html#ad643757142781f8265b430e19700cfe5">beams</a>[0].<a class="code" href="structbeam.html#a54c64670a8b3e8732c1468d156ddb0ca">refpoint</a>.<a class="code" href="structd__point.html#ad9846a025508bf8873a501ca5fcefbf4">y</a> - dely_a + dely_b;
<a name="l00914"></a>00914 
<a name="l00915"></a>00915   <span class="comment">// corner refpoint - large vector - small vector</span>
<a name="l00916"></a>00916   dirmod[3].<a class="code" href="structd__point.html#a922a3b5d82a119168ba85e5f939d02c3">x</a> = actobject-&gt;<a class="code" href="structobject.html#ad643757142781f8265b430e19700cfe5">beams</a>[0].<a class="code" href="structbeam.html#a54c64670a8b3e8732c1468d156ddb0ca">refpoint</a>.<a class="code" href="structd__point.html#a922a3b5d82a119168ba85e5f939d02c3">x</a> - delx_a - delx_b;
<a name="l00917"></a>00917   dirmod[3].<a class="code" href="structd__point.html#ad9846a025508bf8873a501ca5fcefbf4">y</a> = actobject-&gt;<a class="code" href="structobject.html#ad643757142781f8265b430e19700cfe5">beams</a>[0].<a class="code" href="structbeam.html#a54c64670a8b3e8732c1468d156ddb0ca">refpoint</a>.<a class="code" href="structd__point.html#ad9846a025508bf8873a501ca5fcefbf4">y</a> - dely_a - dely_b;
<a name="l00918"></a>00918 
<a name="l00919"></a>00919   <span class="comment">// transfer refpoint and ID</span>
<a name="l00920"></a>00920   actdir-&gt;<a class="code" href="structdirobject.html#ac7f75c9d3cdd6d50adc84ec001beee5b">ID</a> = actobject-&gt;<a class="code" href="structobject.html#a8575880bdfc1c0bf44914b4efd2665bf">ID</a>;
<a name="l00921"></a>00921   actdir-&gt;<a class="code" href="structdirobject.html#a66ec2727d2a5269c84804a89626834fa">refpoint</a>.<a class="code" href="structd__point.html#a922a3b5d82a119168ba85e5f939d02c3">x</a> = actobject-&gt;<a class="code" href="structobject.html#ad643757142781f8265b430e19700cfe5">beams</a>[0].<a class="code" href="structbeam.html#a54c64670a8b3e8732c1468d156ddb0ca">refpoint</a>.<a class="code" href="structd__point.html#a922a3b5d82a119168ba85e5f939d02c3">x</a>;
<a name="l00922"></a>00922   actdir-&gt;<a class="code" href="structdirobject.html#a66ec2727d2a5269c84804a89626834fa">refpoint</a>.<a class="code" href="structd__point.html#ad9846a025508bf8873a501ca5fcefbf4">y</a> = actobject-&gt;<a class="code" href="structobject.html#ad643757142781f8265b430e19700cfe5">beams</a>[0].<a class="code" href="structbeam.html#a54c64670a8b3e8732c1468d156ddb0ca">refpoint</a>.<a class="code" href="structd__point.html#ad9846a025508bf8873a501ca5fcefbf4">y</a>;
<a name="l00923"></a>00923 
<a name="l00924"></a>00924   <span class="comment">// get the extentions on the reference points</span>
<a name="l00925"></a>00925   extention = <a class="code" href="model__utils_8c.html#a5b20290920148fb8fb75adb149a94f6d">get_refpoint_ranges</a>(actobject);
<a name="l00926"></a>00926 
<a name="l00927"></a>00927   <span class="comment">// derive and store min/max in x/y for the corners</span>
<a name="l00928"></a>00928   actdir-&gt;<a class="code" href="structdirobject.html#ac068f35c585eec4cd1e5d3392c2dd698">ix_min</a> = (int)floor(<a class="code" href="aXe__utils_8c.html#a74e75242132eaabbc1c512488a135926">MIN</a>(<a class="code" href="aXe__utils_8c.html#a74e75242132eaabbc1c512488a135926">MIN</a>(dirmod[0].x,dirmod[1].x),<a class="code" href="aXe__utils_8c.html#a74e75242132eaabbc1c512488a135926">MIN</a>(dirmod[2].x,dirmod[3].x))+ gsl_vector_get(extention, 0) + 0.5) - max_offset;
<a name="l00929"></a>00929   actdir-&gt;<a class="code" href="structdirobject.html#ac8c6104f2c2e1384c64bba61ecf40d69">ix_max</a> = (int)floor(<a class="code" href="aper__conf_8c.html#aacc3ee1a7f283f8ef65cea31f4436a95">MAX</a>(<a class="code" href="aper__conf_8c.html#aacc3ee1a7f283f8ef65cea31f4436a95">MAX</a>(dirmod[0].x,dirmod[1].x),<a class="code" href="aper__conf_8c.html#aacc3ee1a7f283f8ef65cea31f4436a95">MAX</a>(dirmod[2].x,dirmod[3].x))+ gsl_vector_get(extention, 1) + 0.5) + max_offset;
<a name="l00930"></a>00930   actdir-&gt;<a class="code" href="structdirobject.html#af24c9a92fa18516591e43d96eec13272">iy_min</a> = (int)floor(<a class="code" href="aXe__utils_8c.html#a74e75242132eaabbc1c512488a135926">MIN</a>(<a class="code" href="aXe__utils_8c.html#a74e75242132eaabbc1c512488a135926">MIN</a>(dirmod[0].y,dirmod[1].y),<a class="code" href="aXe__utils_8c.html#a74e75242132eaabbc1c512488a135926">MIN</a>(dirmod[2].y,dirmod[3].y))+ gsl_vector_get(extention, 2) + 0.5) - max_offset;
<a name="l00931"></a>00931   actdir-&gt;<a class="code" href="structdirobject.html#a3b36973dd52d158c059bfe6587a04244">iy_max</a> = (int)floor(<a class="code" href="aper__conf_8c.html#aacc3ee1a7f283f8ef65cea31f4436a95">MAX</a>(<a class="code" href="aper__conf_8c.html#aacc3ee1a7f283f8ef65cea31f4436a95">MAX</a>(dirmod[0].y,dirmod[1].y),<a class="code" href="aper__conf_8c.html#aacc3ee1a7f283f8ef65cea31f4436a95">MAX</a>(dirmod[2].y,dirmod[3].y))+ gsl_vector_get(extention, 3) + 0.5) + max_offset;
<a name="l00932"></a>00932 
<a name="l00933"></a>00933   <span class="comment">// derive the distortion scales along the major an minor axis</span>
<a name="l00934"></a>00934   actdir-&gt;<a class="code" href="structdirobject.html#a1e61e87181abdea5dab21eb1dc3564dc">drzscale</a> = <a class="code" href="crossdisp__utils_8c.html#afe2b6e94431b461cfa6e596a90108b1e">get_axis_scales</a>(actobject-&gt;<a class="code" href="structobject.html#ad643757142781f8265b430e19700cfe5">beams</a>[0], drzcoeffs, npixels);
<a name="l00935"></a>00935 
<a name="l00936"></a>00936   actdir-&gt;<a class="code" href="structdirobject.html#a484dadbe6f9bdade97aa303366b4ef6a">dirim</a> = NULL;
<a name="l00937"></a>00937 
<a name="l00938"></a>00938   <span class="comment">// free the memory for the vector</span>
<a name="l00939"></a>00939   gsl_vector_free(extention);
<a name="l00940"></a>00940 
<a name="l00941"></a>00941   <span class="comment">// return the dirobject</span>
<a name="l00942"></a>00942   <span class="keywordflow">return</span> actdir;
<a name="l00943"></a>00943 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ab5aca9ee955a502955517d541422cc27"></a><!-- doxytag: member="model_utils.c::fill_fluxfrom_SED" ref="ab5aca9ee955a502955517d541422cc27" args="(const dirobject *actdir, tracedata *acttrace)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fill_fluxfrom_SED </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdirobject.html">dirobject</a> *&nbsp;</td>
          <td class="paramname"> <em>actdir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structtracedata.html">tracedata</a> *&nbsp;</td>
          <td class="paramname"> <em>acttrace</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><div class="fragment"><pre class="fragment"><a name="l00634"></a>00634 {
<a name="l00635"></a>00635   <span class="keywordtype">int</span> i=0;
<a name="l00636"></a>00636 
<a name="l00637"></a>00637   <span class="comment">// go over all tracedata points</span>
<a name="l00638"></a>00638   <span class="keywordflow">for</span> (i=0; i&lt;acttrace-&gt;<a class="code" href="structtracedata.html#af5aed7b8f1629b86be33dc7d57056bcc">npoints</a>; i++)
<a name="l00639"></a>00639     <span class="comment">// compute and fill in the flux values at each wavelength</span>
<a name="l00640"></a>00640     <span class="comment">//gsl_vector_set(acttrace-&gt;flux, i, get_flux_from_SED(actdir-&gt;SED, gsl_vector_get(acttrace-&gt;lambda, i)/10.0));</span>
<a name="l00641"></a>00641     gsl_vector_set(acttrace-&gt;<a class="code" href="structtracedata.html#a536ca0eb0a785814fc211bcf835f666a">flux</a>, i,
<a name="l00642"></a>00642                    <a class="code" href="model__utils_8c.html#a2eba8404bd9e64513d02fa578502e122">get_aveflux_from_SED</a>(actdir-&gt;<a class="code" href="structdirobject.html#a79645e83aebf3988bd3464b2079d24c1">SED</a>,
<a name="l00643"></a>00643                                         gsl_vector_get(acttrace-&gt;<a class="code" href="structtracedata.html#a3c594775ee8672308604497766a66f02">lambda</a>, i)/10.0, gsl_vector_get(acttrace-&gt;<a class="code" href="structtracedata.html#a63bce5a9b367504eb09b87f41f3373da">dlambda</a>, i)/10.0));
<a name="l00644"></a>00644 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ae73d0c2c001f041062d3f9776fd55dc1"></a><!-- doxytag: member="model_utils.c::fill_gaussvalues" ref="ae73d0c2c001f041062d3f9776fd55dc1" args="(const d_point dpixel, const beam actbeam, const dirobject *actdir, const double lambda_ref, const aperture_conf *conf, const double psf_offset, tracedata *acttrace)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fill_gaussvalues </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structd__point.html">d_point</a>&nbsp;</td>
          <td class="paramname"> <em>dpixel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structbeam.html">beam</a>&nbsp;</td>
          <td class="paramname"> <em>actbeam</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdirobject.html">dirobject</a> *&nbsp;</td>
          <td class="paramname"> <em>actdir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>lambda_ref</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structaperture__conf.html">aperture_conf</a> *&nbsp;</td>
          <td class="paramname"> <em>conf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>psf_offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structtracedata.html">tracedata</a> *&nbsp;</td>
          <td class="paramname"> <em>acttrace</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><div class="fragment"><pre class="fragment"><a name="l01975"></a>01975 {
<a name="l01976"></a>01976   <a class="code" href="structbeam.html">beam</a> new_beam;
<a name="l01977"></a>01977 
<a name="l01978"></a>01978   <span class="keywordtype">double</span> dpsf=0.0;
<a name="l01979"></a>01979   <span class="comment">//double gval=0.0;</span>
<a name="l01980"></a>01980   <span class="keywordtype">double</span> lambda=0.0;
<a name="l01981"></a>01981   <span class="comment">//double factor=0.0;</span>
<a name="l01982"></a>01982   <span class="comment">//double nom=0.0;</span>
<a name="l01983"></a>01983   <span class="comment">//double denom=0.0;</span>
<a name="l01984"></a>01984 
<a name="l01985"></a>01985   <span class="keywordtype">int</span> i=0;
<a name="l01986"></a>01986   <span class="keywordtype">int</span> minpsf_flagg=0;
<a name="l01987"></a>01987 
<a name="l01988"></a>01988   <span class="comment">// get the acurate emission value with subgridding</span>
<a name="l01989"></a>01989   <span class="comment">//gval   = get_sub_emodel_value(dpixel, actbeam, actdir-&gt;drzscale);</span>
<a name="l01990"></a>01990   <span class="comment">//fprintf(stdout, &quot;gvalue: %e %f %f&quot;, gval, actdir-&gt;drzscale.x, actdir-&gt;drzscale.y);</span>
<a name="l01991"></a>01991 
<a name="l01992"></a>01992   <span class="comment">//  0: fastest scenario: fill the vector with</span>
<a name="l01993"></a>01993   <span class="comment">//     identical values: 34s</span>
<a name="l01994"></a>01994   <span class="comment">//  gsl_vector_set_all(acttrace-&gt;gvalue, i, gval);</span>
<a name="l01995"></a>01995 
<a name="l01996"></a>01996 
<a name="l01997"></a>01997   <span class="comment">// 1: iterate over the vector and enter the same</span>
<a name="l01998"></a>01998   <span class="comment">//    value: 35s</span>
<a name="l01999"></a>01999   <span class="keywordflow">if</span> (conf-&gt;<a class="code" href="structaperture__conf.html#a469dc826e363a3b9e340aa99824e2f30">psfrange</a> &amp;&amp; conf-&gt;<a class="code" href="structaperture__conf.html#a904a154040bedf410b669b65791c96e2">psfcoeffs</a>)
<a name="l02000"></a>02000     {
<a name="l02001"></a>02001       <span class="comment">// go over all tracedata (that means wavelength) points</span>
<a name="l02002"></a>02002       <span class="keywordflow">for</span> (i=0; i &lt; acttrace-&gt;<a class="code" href="structtracedata.html#af5aed7b8f1629b86be33dc7d57056bcc">npoints</a>; i++)
<a name="l02003"></a>02003         {
<a name="l02004"></a>02004           <span class="comment">// derive the wavelength</span>
<a name="l02005"></a>02005           lambda = gsl_vector_get(acttrace-&gt;<a class="code" href="structtracedata.html#a3c594775ee8672308604497766a66f02">lambda</a>, i)/10.0;
<a name="l02006"></a>02006 
<a name="l02007"></a>02007           <span class="comment">// derive the correction of the psf at the wavelength</span>
<a name="l02008"></a>02008 
<a name="l02009"></a>02009           <span class="comment">// 3: calculating the psf-offset: 90s</span>
<a name="l02010"></a>02010           dpsf   = psf_offset + <a class="code" href="model__utils_8c.html#af09a9a57d7ad0ec300ed94e9dd76d595">get_dpsf</a>(lambda_ref, lambda, conf, actbeam);
<a name="l02011"></a>02011           <span class="comment">//      dpsf=0.0;</span>
<a name="l02012"></a>02012           <span class="comment">//fprintf(stdout, &quot;dpsf: %f&quot;, dpsf);</span>
<a name="l02013"></a>02013 
<a name="l02014"></a>02014 
<a name="l02015"></a>02015           <span class="comment">// derive a beam with the correct widths at the wavelength</span>
<a name="l02016"></a>02016 
<a name="l02017"></a>02017           <span class="comment">// 2: creating a new beam with a different size: 50s</span>
<a name="l02018"></a>02018           new_beam = <a class="code" href="model__utils_8c.html#ab02649b7a821651ecce41bd6dc3394f6">get_newbeam</a>(actbeam,dpsf);
<a name="l02019"></a>02019 
<a name="l02020"></a>02020           <span class="comment">// transport the</span>
<a name="l02021"></a>02021           <span class="keywordflow">if</span> (new_beam.<a class="code" href="structbeam.html#a5c3f06b67e4cc3c79be539d1b515f3c6">ID</a>)
<a name="l02022"></a>02022             minpsf_flagg=1;
<a name="l02023"></a>02023 
<a name="l02024"></a>02024           <span class="comment">// derive the correction factor for the emission using the correct widths</span>
<a name="l02025"></a>02025           <span class="comment">// 4: computing the correction factor for the wavelength: 255s</span>
<a name="l02026"></a>02026           <span class="comment">//factor = get_emodel_value(dpixel,new_beam,actdir-&gt;drzscale)/get_emodel_value(dpixel,actbeam,actdir-&gt;drzscale);</span>
<a name="l02027"></a>02027           <span class="comment">//nom = get_emodel_value(dpixel,new_beam,actdir-&gt;drzscale);</span>
<a name="l02028"></a>02028           <span class="comment">//denom = get_emodel_value(dpixel,actbeam,actdir-&gt;drzscale);</span>
<a name="l02029"></a>02029           <span class="comment">//if (nom != 0.0 &amp;&amp; denom != 0.0)</span>
<a name="l02030"></a>02030           <span class="comment">//  factor = nom / denom;</span>
<a name="l02031"></a>02031           <span class="comment">//else</span>
<a name="l02032"></a>02032           <span class="comment">//  factor = 1.0;</span>
<a name="l02033"></a>02033           <span class="comment">//fprintf(stdout, &quot;factor: %f &quot;, factor);</span>
<a name="l02034"></a>02034 
<a name="l02035"></a>02035           <span class="comment">// store the emission value, taking into account the correction</span>
<a name="l02036"></a>02036           <span class="comment">//gsl_vector_set(acttrace-&gt;gvalue, i, gval*factor);</span>
<a name="l02037"></a>02037           gsl_vector_set_all(acttrace-&gt;<a class="code" href="structtracedata.html#a263d2f1a51308e73d79c77f5e62c01fb">gvalue</a>, <a class="code" href="model__utils_8c.html#a5d8695af668aaed17d349ca4eb36292c">get_sub_emodel_value</a>(dpixel, new_beam, actdir-&gt;<a class="code" href="structdirobject.html#a1e61e87181abdea5dab21eb1dc3564dc">drzscale</a>));
<a name="l02038"></a>02038           <span class="comment">//fprintf(stdout, &quot;gvalue * factor: %e &quot;, gval*factor);</span>
<a name="l02039"></a>02039           }
<a name="l02040"></a>02040     }
<a name="l02041"></a>02041   <span class="keywordflow">else</span>
<a name="l02042"></a>02042     {
<a name="l02043"></a>02043       <span class="comment">// derive a beam with the correct widths at the wavelength</span>
<a name="l02044"></a>02044       new_beam = <a class="code" href="model__utils_8c.html#ab02649b7a821651ecce41bd6dc3394f6">get_newbeam</a>(actbeam,psf_offset);
<a name="l02045"></a>02045       <span class="keywordflow">if</span> (new_beam.<a class="code" href="structbeam.html#a5c3f06b67e4cc3c79be539d1b515f3c6">ID</a>)
<a name="l02046"></a>02046         minpsf_flagg=1;
<a name="l02047"></a>02047 
<a name="l02048"></a>02048       <span class="comment">// derive the correction factor for the emission using the correct widths</span>
<a name="l02049"></a>02049       <span class="comment">//factor = get_emodel_value(dpixel,new_beam,actdir-&gt;drzscale)/get_emodel_value(dpixel,actbeam,actdir-&gt;drzscale);</span>
<a name="l02050"></a>02050       <span class="comment">//nom = get_emodel_value(dpixel,new_beam,actdir-&gt;drzscale);</span>
<a name="l02051"></a>02051       <span class="comment">//denom = get_emodel_value(dpixel,actbeam,actdir-&gt;drzscale);</span>
<a name="l02052"></a>02052       <span class="comment">//if (nom != 0.0 &amp;&amp; denom != 0.0)</span>
<a name="l02053"></a>02053       <span class="comment">//  factor = nom / denom;</span>
<a name="l02054"></a>02054       <span class="comment">//else</span>
<a name="l02055"></a>02055       <span class="comment">//  factor = 1.0;</span>
<a name="l02056"></a>02056 
<a name="l02057"></a>02057       <span class="comment">// store the emission value, taking into account the correction</span>
<a name="l02058"></a>02058       <span class="comment">//gsl_vector_set_all(acttrace-&gt;gvalue, gval*factor);</span>
<a name="l02059"></a>02059       gsl_vector_set_all(acttrace-&gt;<a class="code" href="structtracedata.html#a263d2f1a51308e73d79c77f5e62c01fb">gvalue</a>, <a class="code" href="model__utils_8c.html#a5d8695af668aaed17d349ca4eb36292c">get_sub_emodel_value</a>(dpixel, new_beam, actdir-&gt;<a class="code" href="structdirobject.html#a1e61e87181abdea5dab21eb1dc3564dc">drzscale</a>));
<a name="l02060"></a>02060 
<a name="l02061"></a>02061     }
<a name="l02062"></a>02062   <span class="keywordflow">if</span> (minpsf_flagg)
<a name="l02063"></a>02063     <a class="code" href="aXe__errors_8c.html#a7ef7588e5f91237ba7ce4084e6ed3c11">aXe_message</a> (<a class="code" href="aXe__errors_8h.html#a3f3c2d017ceaf0b51cfb71efbcaeff44">aXe_M_WARN4</a>, __FILE__, __LINE__,
<a name="l02064"></a>02064                  <span class="stringliteral">&quot;\naXe_PETCONT: points in PSF of object %i beam %c smaller than PSF_MIN=%f! Set to PSF_MIN\n&quot;</span>, actdir-&gt;<a class="code" href="structdirobject.html#ac7f75c9d3cdd6d50adc84ec001beee5b">ID</a>, <a class="code" href="aXe__grism_8h.html#a7d90dabb6016bb0e09b6ab84087b70a7">BEAM</a>(actbeam.<a class="code" href="structbeam.html#a5c3f06b67e4cc3c79be539d1b515f3c6">ID</a>), <a class="code" href="model__utils_8h.html#a7ccf406903b6e63ebb32b3e8dc401f3d">MINPSF</a>);
<a name="l02065"></a>02065 
<a name="l02066"></a>02066 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a5cd967f1d7c4d8c89f52a7cd3d6b4f81"></a><!-- doxytag: member="model_utils.c::fill_spectrum" ref="a5cd967f1d7c4d8c89f52a7cd3d6b4f81" args="(const object *actobject, dirobject *actdir, spectral_models *spec_mod, const int int_type)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fill_spectrum </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structobject.html">object</a> *&nbsp;</td>
          <td class="paramname"> <em>actobject</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdirobject.html">dirobject</a> *&nbsp;</td>
          <td class="paramname"> <em>actdir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structspectral__models.html">spectral_models</a> *&nbsp;</td>
          <td class="paramname"> <em>spec_mod</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>int_type</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Function: fill_spectrum Transfers the wavelength information from an <a class="el" href="structobject.html">object</a> to a <a class="el" href="structdirobject.html">dirobject</a>. Store the minimum and maximum wavelength as well as associated flux values in the structure.</p>
<p>Parameters: </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>actobject</em>&nbsp;</td><td>- the <a class="el" href="structobject.html">object</a> to be transformed </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>actdir</em>&nbsp;</td><td>- the <a class="el" href="structdirobject.html">dirobject</a> to store the flux values in </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>spec_mod</em>&nbsp;</td><td>- the spectral model list </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>int_type</em>&nbsp;</td><td>- the interpolation type to be used </td></tr>
  </table>
  </dd>
</dl>

<p><div class="fragment"><pre class="fragment"><a name="l01151"></a>01151 {
<a name="l01152"></a>01152   <a class="code" href="structenergy__distrib.html">energy_distrib</a> *sed;
<a name="l01153"></a>01153   <span class="comment">//  double *sed_wavs;</span>
<a name="l01154"></a>01154   <span class="comment">//  double *sed_flux;</span>
<a name="l01155"></a>01155 
<a name="l01156"></a>01156   <a class="code" href="structbeam.html">beam</a> onebeam;
<a name="l01157"></a>01157 
<a name="l01158"></a>01158   <span class="comment">//int i_type=0;</span>
<a name="l01159"></a>01159   <span class="comment">//  int nwavs=0;</span>
<a name="l01160"></a>01160   <span class="comment">//int i = 0;</span>
<a name="l01161"></a>01161   <span class="keywordtype">int</span> j = 0;
<a name="l01162"></a>01162 
<a name="l01163"></a>01163   <span class="comment">// the data are derived from the 1st non-zero beam in the object;</span>
<a name="l01164"></a>01164   <span class="comment">// go along the beams util you find a non-zero beam</span>
<a name="l01165"></a>01165   <span class="keywordflow">while</span> (actobject-&gt;<a class="code" href="structobject.html#ad643757142781f8265b430e19700cfe5">beams</a>[j].<a class="code" href="structbeam.html#a199b010e935235ef70f482416d113458">flux</a> == NULL &amp;&amp; j &lt; actobject-&gt;nbeams)
<a name="l01166"></a>01166     j++;
<a name="l01167"></a>01167   <span class="comment">// store this beam</span>
<a name="l01168"></a>01168   onebeam = actobject-&gt;<a class="code" href="structobject.html#ad643757142781f8265b430e19700cfe5">beams</a>[j];
<a name="l01169"></a>01169 
<a name="l01170"></a>01170   <span class="comment">// do something only if the first beam has flux values</span>
<a name="l01171"></a>01171   <span class="keywordflow">if</span> (onebeam.<a class="code" href="structbeam.html#a199b010e935235ef70f482416d113458">flux</a> != NULL &amp;&amp; j &lt; actobject-&gt;nbeams)
<a name="l01172"></a>01172     {
<a name="l01173"></a>01173 
<a name="l01174"></a>01174       <span class="keywordflow">if</span> (onebeam.<a class="code" href="structbeam.html#a60879dd4cb05dff92646b26f0b1ca8d8">modspec</a> &gt; 0 &amp;&amp; spec_mod)
<a name="l01175"></a>01175         {
<a name="l01176"></a>01176           <span class="comment">// get the model spectrum</span>
<a name="l01177"></a>01177           sed = <a class="code" href="specmodel__utils_8c.html#a234518e70caa6622e95b73820fd03aa6">get_model_sed</a>(spec_mod, onebeam.<a class="code" href="structbeam.html#a60879dd4cb05dff92646b26f0b1ca8d8">modspec</a>);
<a name="l01178"></a>01178 
<a name="l01179"></a>01179           <span class="comment">// mark that the SED does NOT come</span>
<a name="l01180"></a>01180           <span class="comment">// from broad band colours</span>
<a name="l01181"></a>01181           actdir-&gt;<a class="code" href="structdirobject.html#a8fe8b9502f2baafd4ea433cb8f6acaa9">bb_sed</a>=0;
<a name="l01182"></a>01182         }
<a name="l01183"></a>01183       <span class="keywordflow">else</span>
<a name="l01184"></a>01184         {
<a name="l01185"></a>01185 
<a name="l01186"></a>01186           sed = <a class="code" href="model__utils_8c.html#a6b478169411f67ce4c7702fa7815b445">make_sed_from_beam</a>(onebeam, int_type, actobject-&gt;<a class="code" href="structobject.html#a8575880bdfc1c0bf44914b4efd2665bf">ID</a>);
<a name="l01187"></a>01187 
<a name="l01188"></a>01188           <span class="comment">/*</span>
<a name="l01189"></a>01189 <span class="comment">          //</span>
<a name="l01190"></a>01190 <span class="comment">          // the code below is a mess!!!!</span>
<a name="l01191"></a>01191 <span class="comment">          // MUST be re-factorized!!</span>
<a name="l01192"></a>01192 <span class="comment">          //</span>
<a name="l01193"></a>01193 <span class="comment"></span>
<a name="l01194"></a>01194 <span class="comment">          // determine the number of flux values, allocate space</span>
<a name="l01195"></a>01195 <span class="comment">          nwavs = (onebeam.flux-&gt;size)/2;</span>
<a name="l01196"></a>01196 <span class="comment"></span>
<a name="l01197"></a>01197 <span class="comment">          // determine the number of flux values, allocate space</span>
<a name="l01198"></a>01198 <span class="comment">          nwavs = (onebeam.flux-&gt;size)/2;</span>
<a name="l01199"></a>01199 <span class="comment">          sed = (energy_distrib*) malloc(sizeof(energy_distrib));</span>
<a name="l01200"></a>01200 <span class="comment">          sed_wavs = (double*) malloc(nwavs*sizeof(double));</span>
<a name="l01201"></a>01201 <span class="comment">          sed_flux = (double*) malloc(nwavs*sizeof(double));</span>
<a name="l01202"></a>01202 <span class="comment"></span>
<a name="l01203"></a>01203 <span class="comment">          // transfer the data into the &apos;local&apos; arrays</span>
<a name="l01204"></a>01204 <span class="comment">          for (i=0; i&lt;nwavs; i++)</span>
<a name="l01205"></a>01205 <span class="comment">            {</span>
<a name="l01206"></a>01206 <span class="comment">              sed_wavs[i] = gsl_vector_get(onebeam.flux, 2*i);</span>
<a name="l01207"></a>01207 <span class="comment">              sed_flux[i] = gsl_vector_get(onebeam.flux, 2*i+1);</span>
<a name="l01208"></a>01208 <span class="comment">            }</span>
<a name="l01209"></a>01209 <span class="comment"></span>
<a name="l01210"></a>01210 <span class="comment">          // transfer the vector and length information</span>
<a name="l01211"></a>01211 <span class="comment">          // to the SED object</span>
<a name="l01212"></a>01212 <span class="comment">          sed-&gt;npoints    = nwavs;</span>
<a name="l01213"></a>01213 <span class="comment">          sed-&gt;wavelength = sed_wavs ;</span>
<a name="l01214"></a>01214 <span class="comment">          sed-&gt;flux       = sed_flux;</span>
<a name="l01215"></a>01215 <span class="comment"></span>
<a name="l01216"></a>01216 <span class="comment">          // check the interpolation type</span>
<a name="l01217"></a>01217 <span class="comment">          i_type = check_interp_type(int_type, nwavs, actobject-&gt;ID);</span>
<a name="l01218"></a>01218 <span class="comment">          if (nwavs &gt; 1)</span>
<a name="l01219"></a>01219 <span class="comment">            {</span>
<a name="l01220"></a>01220 <span class="comment">              // if possible, allocate and</span>
<a name="l01221"></a>01221 <span class="comment">              // initialize an interpolation object</span>
<a name="l01222"></a>01222 <span class="comment">              if (i_type == 2)</span>
<a name="l01223"></a>01223 <span class="comment">                sed-&gt;interp     = gsl_interp_alloc (gsl_interp_polynomial, (size_t)nwavs);</span>
<a name="l01224"></a>01224 <span class="comment">              else if (i_type == 3)</span>
<a name="l01225"></a>01225 <span class="comment">                sed-&gt;interp     = gsl_interp_alloc (gsl_interp_cspline, (size_t)nwavs);</span>
<a name="l01226"></a>01226 <span class="comment">              else</span>
<a name="l01227"></a>01227 <span class="comment">                sed-&gt;interp     = gsl_interp_alloc (gsl_interp_linear, (size_t)nwavs);</span>
<a name="l01228"></a>01228 <span class="comment"></span>
<a name="l01229"></a>01229 <span class="comment">              sed-&gt;accel      = gsl_interp_accel_alloc ();</span>
<a name="l01230"></a>01230 <span class="comment">              gsl_interp_init (sed-&gt;interp, sed-&gt;wavelength, sed-&gt;flux, (size_t)sed-&gt;npoints);</span>
<a name="l01231"></a>01231 <span class="comment">            }</span>
<a name="l01232"></a>01232 <span class="comment">          else</span>
<a name="l01233"></a>01233 <span class="comment">            {</span>
<a name="l01234"></a>01234 <span class="comment">              // if no interpolation, set</span>
<a name="l01235"></a>01235 <span class="comment">              // the memeber to NULL</span>
<a name="l01236"></a>01236 <span class="comment">              sed-&gt;interp = NULL;</span>
<a name="l01237"></a>01237 <span class="comment">              sed-&gt;accel= NULL;</span>
<a name="l01238"></a>01238 <span class="comment">            }</span>
<a name="l01239"></a>01239 <span class="comment">          */</span>
<a name="l01240"></a>01240           <span class="comment">// mark that the SED DOES come</span>
<a name="l01241"></a>01241           <span class="comment">// from broad band colours</span>
<a name="l01242"></a>01242           actdir-&gt;<a class="code" href="structdirobject.html#a8fe8b9502f2baafd4ea433cb8f6acaa9">bb_sed</a>=1;
<a name="l01243"></a>01243         }
<a name="l01244"></a>01244     }
<a name="l01245"></a>01245   <span class="keywordflow">else</span>
<a name="l01246"></a>01246     {
<a name="l01247"></a>01247       <span class="comment">// make an error if there are no flux values</span>
<a name="l01248"></a>01248       <a class="code" href="aXe__errors_8c.html#a7ef7588e5f91237ba7ce4084e6ed3c11">aXe_message</a>(<a class="code" href="aXe__errors_8h.html#a2556a67874555249b07691c37aa6d6e9">aXe_M_FATAL</a>, __FILE__, __LINE__,
<a name="l01249"></a>01249                   <span class="stringliteral">&quot;aXe_PETCONT: &quot;</span> <span class="stringliteral">&quot;the OAF does not have flux values\n&quot;</span>);
<a name="l01250"></a>01250     }
<a name="l01251"></a>01251 
<a name="l01252"></a>01252   <span class="comment">// transfer the SED object to the direct object</span>
<a name="l01253"></a>01253   actdir-&gt;<a class="code" href="structdirobject.html#a79645e83aebf3988bd3464b2079d24c1">SED</a> = sed;
<a name="l01254"></a>01254 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a72c9efb6343e03f3e19b0c81af37a54f"></a><!-- doxytag: member="model_utils.c::free_dirlist" ref="a72c9efb6343e03f3e19b0c81af37a54f" args="(dirobject **dirlist)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void free_dirlist </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdirobject.html">dirobject</a> **&nbsp;</td>
          <td class="paramname"> <em>dirlist</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Function: free_dirlist Releases the memory allocated for a list of dirobjects. After releasing memory, all elements are set to NULL.</p>
<p>Note that here the memory for a model image is NOT released, in this usage scenario only the references were stored. Also for high resolution spectra only references are stored. For broad band spectra memory was allocated and hence is free'd here!</p>
<p>Parameters: </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dirlist</em>&nbsp;</td><td>- the list of dirobjects  spec_mod - describes what all to free </td></tr>
  </table>
  </dd>
</dl>

<p><div class="fragment"><pre class="fragment"><a name="l01637"></a>01637 {
<a name="l01638"></a>01638   <span class="keywordtype">int</span> i, ndirs = 0;
<a name="l01639"></a>01639   <span class="comment">//int j;</span>
<a name="l01640"></a>01640 
<a name="l01641"></a>01641   <span class="comment">// count the number of dirobjects</span>
<a name="l01642"></a>01642   <span class="keywordflow">while</span> (dirlist[ndirs] != NULL)
<a name="l01643"></a>01643     ndirs++;
<a name="l01644"></a>01644 
<a name="l01645"></a>01645   <span class="comment">// go over each item in the list</span>
<a name="l01646"></a>01646   <span class="keywordflow">for</span> (i = 0; i &lt; ndirs; i++)
<a name="l01647"></a>01647     {
<a name="l01648"></a>01648 
<a name="l01649"></a>01649       <span class="comment">// only release memory for</span>
<a name="l01650"></a>01650           <span class="comment">// a broad band SED</span>
<a name="l01651"></a>01651       <span class="keywordflow">if</span> (dirlist[i]-&gt;bb_sed)
<a name="l01652"></a>01652         <span class="comment">// free the energy distribution</span>
<a name="l01653"></a>01653         <a class="code" href="model__utils_8c.html#af4aeb43aa090824fe3dcad3049d38a62">free_enerdist</a> (dirlist[i]-&gt;SED);
<a name="l01654"></a>01654 
<a name="l01655"></a>01655       <span class="comment">// free the dirobject</span>
<a name="l01656"></a>01656       free (dirlist[i]);
<a name="l01657"></a>01657 
<a name="l01658"></a>01658       <span class="comment">// set the dirobject to NULL</span>
<a name="l01659"></a>01659       dirlist[i] = NULL;
<a name="l01660"></a>01660     }
<a name="l01661"></a>01661 
<a name="l01662"></a>01662   <span class="comment">// free the list</span>
<a name="l01663"></a>01663   free (dirlist);
<a name="l01664"></a>01664 
<a name="l01665"></a>01665   <span class="comment">// set the list to NULL</span>
<a name="l01666"></a>01666   dirlist = NULL;
<a name="l01667"></a>01667 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="aa711bf6afa5532517ed581be9e59d2d1"></a><!-- doxytag: member="model_utils.c::free_dirobject" ref="aa711bf6afa5532517ed581be9e59d2d1" args="(dirobject *actdir)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void free_dirobject </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdirobject.html">dirobject</a> *&nbsp;</td>
          <td class="paramname"> <em>actdir</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Function: free_dirobject Releases the memory allocated for a direct <a class="el" href="structobject.html">object</a>.</p>
<p>Parameters: </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>actdir</em>&nbsp;</td><td>- the list of dirobjects </td></tr>
  </table>
  </dd>
</dl>

<p><div class="fragment"><pre class="fragment"><a name="l01678"></a>01678                                   {
<a name="l01679"></a>01679         <span class="keywordflow">if</span> (actdir-&gt;<a class="code" href="structdirobject.html#a79645e83aebf3988bd3464b2079d24c1">SED</a>){
<a name="l01680"></a>01680                 <a class="code" href="model__utils_8c.html#af4aeb43aa090824fe3dcad3049d38a62">free_enerdist</a>(actdir-&gt;<a class="code" href="structdirobject.html#a79645e83aebf3988bd3464b2079d24c1">SED</a>);
<a name="l01681"></a>01681                 actdir-&gt;<a class="code" href="structdirobject.html#a79645e83aebf3988bd3464b2079d24c1">SED</a> = NULL;
<a name="l01682"></a>01682         }
<a name="l01683"></a>01683         <span class="keywordflow">if</span> (actdir-&gt;<a class="code" href="structdirobject.html#a484dadbe6f9bdade97aa303366b4ef6a">dirim</a>){
<a name="l01684"></a>01684                 <a class="code" href="specmodel__utils_8c.html#a78ace28fa324d880ddc10324be32d053">free_dirim_emission</a>(actdir-&gt;<a class="code" href="structdirobject.html#a484dadbe6f9bdade97aa303366b4ef6a">dirim</a>);
<a name="l01685"></a>01685                 actdir-&gt;<a class="code" href="structdirobject.html#a484dadbe6f9bdade97aa303366b4ef6a">dirim</a> = NULL;
<a name="l01686"></a>01686         }
<a name="l01687"></a>01687         free(actdir);
<a name="l01688"></a>01688         actdir=NULL;
<a name="l01689"></a>01689 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="af4aeb43aa090824fe3dcad3049d38a62"></a><!-- doxytag: member="model_utils.c::free_enerdist" ref="af4aeb43aa090824fe3dcad3049d38a62" args="(energy_distrib *sed)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void free_enerdist </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structenergy__distrib.html">energy_distrib</a> *&nbsp;</td>
          <td class="paramname"> <em>sed</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Function: free_enerdist The function releases all the memory of a SED <a class="el" href="structobject.html">object</a></p>
<p>Parameters: </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>sed</em>&nbsp;</td><td>- the SED <a class="el" href="structobject.html">object</a> </td></tr>
  </table>
  </dd>
</dl>

<p><div class="fragment"><pre class="fragment"><a name="l01701"></a>01701 {
<a name="l01702"></a>01702 
<a name="l01703"></a>01703   <span class="comment">// free the two arrays</span>
<a name="l01704"></a>01704   free(sed-&gt;<a class="code" href="structenergy__distrib.html#ac32d12647e9ef7f158b0d4532c09a568">wavelength</a>);
<a name="l01705"></a>01705   free(sed-&gt;<a class="code" href="structenergy__distrib.html#a7da8059a7bb2f8af463b6ee1dd1e6554">flux</a>);
<a name="l01706"></a>01706 
<a name="l01707"></a>01707   <span class="comment">// free the intepolation</span>
<a name="l01708"></a>01708   <span class="comment">// structures if defined</span>
<a name="l01709"></a>01709   <span class="keywordflow">if</span> (sed-&gt;<a class="code" href="structenergy__distrib.html#a3d90efb6bd5ace3c19884613063644af">interp</a> != NULL)
<a name="l01710"></a>01710     gsl_interp_free (sed-&gt;<a class="code" href="structenergy__distrib.html#a3d90efb6bd5ace3c19884613063644af">interp</a>);
<a name="l01711"></a>01711   <span class="keywordflow">if</span> (sed-&gt;<a class="code" href="structenergy__distrib.html#a7d0d556a145bd34158514bdbab57b0ee">accel</a> != NULL)
<a name="l01712"></a>01712     gsl_interp_accel_free (sed-&gt;<a class="code" href="structenergy__distrib.html#a7d0d556a145bd34158514bdbab57b0ee">accel</a>);
<a name="l01713"></a>01713 
<a name="l01714"></a>01714   <span class="comment">// free the object itsel</span>
<a name="l01715"></a>01715   free(sed);
<a name="l01716"></a>01716 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a9869f818df7a666d983da7b3d1956532"></a><!-- doxytag: member="model_utils.c::free_speclist" ref="a9869f818df7a666d983da7b3d1956532" args="(beamspec **speclist)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void free_speclist </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbeamspec.html">beamspec</a> **&nbsp;</td>
          <td class="paramname"> <em>speclist</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Function: free_speclist The function releases all the memory of a list of beamspec's.</p>
<p>Parameters: </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>speclist</em>&nbsp;</td><td>- a list of beamspecs </td></tr>
  </table>
  </dd>
</dl>

<p><div class="fragment"><pre class="fragment"><a name="l01729"></a>01729 {
<a name="l01730"></a>01730 
<a name="l01731"></a>01731   <span class="keywordtype">int</span> i=0;
<a name="l01732"></a>01732 
<a name="l01733"></a>01733   <span class="comment">// go over each item in the list</span>
<a name="l01734"></a>01734   <span class="keywordflow">while</span> (speclist[i] != NULL)
<a name="l01735"></a>01735     {
<a name="l01736"></a>01736 
<a name="l01737"></a>01737       <span class="comment">// free the memory in the matrix</span>
<a name="l01738"></a>01738       <a class="code" href="aXe__grism_8h.html#a61aa1d37853a90711852146f18d0b85f">gsl_matrix_free</a> (speclist[i]-&gt;model);
<a name="l01739"></a>01739 
<a name="l01740"></a>01740       <span class="comment">// free the beamspec object itself</span>
<a name="l01741"></a>01741       free (speclist[i]);
<a name="l01742"></a>01742 
<a name="l01743"></a>01743       <span class="comment">// set the beamspec to NULL,</span>
<a name="l01744"></a>01744       <span class="comment">// increment the counter</span>
<a name="l01745"></a>01745       speclist[i++] = NULL;
<a name="l01746"></a>01746     }
<a name="l01747"></a>01747 
<a name="l01748"></a>01748   <span class="comment">// free the memory of the list</span>
<a name="l01749"></a>01749   free(speclist);
<a name="l01750"></a>01750 
<a name="l01751"></a>01751   <span class="comment">// set the list to NULL</span>
<a name="l01752"></a>01752   speclist = NULL;
<a name="l01753"></a>01753 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="aa698da13e1ad04e38c6ce9c51e4d2923"></a><!-- doxytag: member="model_utils.c::free_tracedata" ref="aa698da13e1ad04e38c6ce9c51e4d2923" args="(tracedata *acttrace)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void free_tracedata </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtracedata.html">tracedata</a> *&nbsp;</td>
          <td class="paramname"> <em>acttrace</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Function: free_tracedata Releases the memory in a <a class="el" href="structtracedata.html">tracedata</a> structure.</p>
<p>Parameters: </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>acttrace</em>&nbsp;</td><td>- the structure to be freed </td></tr>
  </table>
  </dd>
</dl>

<p><div class="fragment"><pre class="fragment"><a name="l01765"></a>01765 {
<a name="l01766"></a>01766   <span class="keywordflow">if</span> (acttrace-&gt;<a class="code" href="structtracedata.html#af5aed7b8f1629b86be33dc7d57056bcc">npoints</a> &gt; 0)
<a name="l01767"></a>01767     {
<a name="l01768"></a>01768       gsl_vector_free(acttrace-&gt;<a class="code" href="structtracedata.html#aebca3378cacc91654b164c7818f120e2">dx</a>);
<a name="l01769"></a>01769       gsl_vector_free(acttrace-&gt;<a class="code" href="structtracedata.html#a0bdd805ca59eb0b1329694181236c191">dy</a>);
<a name="l01770"></a>01770       gsl_vector_free(acttrace-&gt;<a class="code" href="structtracedata.html#aee169f9a7859629a3f3b9e8a58c43a39">xi</a>);
<a name="l01771"></a>01771       gsl_vector_free(acttrace-&gt;<a class="code" href="structtracedata.html#a3c594775ee8672308604497766a66f02">lambda</a>);
<a name="l01772"></a>01772       gsl_vector_free(acttrace-&gt;<a class="code" href="structtracedata.html#a63bce5a9b367504eb09b87f41f3373da">dlambda</a>);
<a name="l01773"></a>01773       gsl_vector_free(acttrace-&gt;<a class="code" href="structtracedata.html#a536ca0eb0a785814fc211bcf835f666a">flux</a>);
<a name="l01774"></a>01774       gsl_vector_free(acttrace-&gt;<a class="code" href="structtracedata.html#a263d2f1a51308e73d79c77f5e62c01fb">gvalue</a>);
<a name="l01775"></a>01775     }
<a name="l01776"></a>01776   free(acttrace);
<a name="l01777"></a>01777 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a2eba8404bd9e64513d02fa578502e122"></a><!-- doxytag: member="model_utils.c::get_aveflux_from_SED" ref="a2eba8404bd9e64513d02fa578502e122" args="(const energy_distrib *sed, double in_wave, double wave_interv)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double get_aveflux_from_SED </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structenergy__distrib.html">energy_distrib</a> *&nbsp;</td>
          <td class="paramname"> <em>sed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>in_wave</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>wave_interv</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Function: get_aveflux_from_SED The function computes and returns the integrated flux of a given SED <a class="el" href="structobject.html">object</a> over a given interval at a given wavelength position. Beyond the wavelength interval the SED is defined on, the flux is taken as constant.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>sed</em>&nbsp;</td><td>- the SED-object to derive a flux value from </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>in_wave</em>&nbsp;</td><td>- the wavelength to average the flux value at </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>wave_interv</em>&nbsp;</td><td>- the wavelength interval to average over</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>flux - the average for the requested wavelength interval </dd></dl>

<p><div class="fragment"><pre class="fragment"><a name="l01833"></a>01833 {
<a name="l01834"></a>01834   <span class="keywordtype">double</span> wav_min=0.0;
<a name="l01835"></a>01835   <span class="keywordtype">double</span> wav_max=0.0;
<a name="l01836"></a>01836 
<a name="l01837"></a>01837   <span class="keywordtype">double</span> range_1=0.0;
<a name="l01838"></a>01838   <span class="keywordtype">double</span> range_2=0.0;
<a name="l01839"></a>01839 
<a name="l01840"></a>01840   <span class="keywordtype">double</span> flux=0.0;
<a name="l01841"></a>01841 
<a name="l01842"></a>01842   <span class="comment">// check whether there is only one</span>
<a name="l01843"></a>01843   <span class="comment">// flux point</span>
<a name="l01844"></a>01844   <span class="keywordflow">if</span> (sed-&gt;<a class="code" href="structenergy__distrib.html#ae5e24fde4a41b46a8b8510118f646e67">npoints</a> &lt; 2)
<a name="l01845"></a>01845     <span class="comment">// return the value at the single</span>
<a name="l01846"></a>01846     <span class="comment">// flux point</span>
<a name="l01847"></a>01847     <span class="keywordflow">return</span> sed-&gt;<a class="code" href="structenergy__distrib.html#a7da8059a7bb2f8af463b6ee1dd1e6554">flux</a>[0];
<a name="l01848"></a>01848 
<a name="l01849"></a>01849   <span class="comment">// compute the interval coundaries</span>
<a name="l01850"></a>01850   wav_min = in_wave - 0.5*wave_interv;
<a name="l01851"></a>01851   wav_max = in_wave + 0.5*wave_interv;
<a name="l01852"></a>01852 
<a name="l01853"></a>01853   <span class="comment">// check whether the upper wavelength</span>
<a name="l01854"></a>01854   <span class="comment">// interval boundary is just shorter than</span>
<a name="l01855"></a>01855   <span class="comment">// the SED range</span>
<a name="l01856"></a>01856   <span class="keywordflow">if</span> (wav_max &lt; sed-&gt;wavelength[0]){
<a name="l01857"></a>01857     <span class="comment">// give the smallest SED flux value</span>
<a name="l01858"></a>01858     flux = sed-&gt;<a class="code" href="structenergy__distrib.html#a7da8059a7bb2f8af463b6ee1dd1e6554">flux</a>[0];}
<a name="l01859"></a>01859 
<a name="l01860"></a>01860   <span class="comment">// check whether the lower wavelength</span>
<a name="l01861"></a>01861   <span class="comment">// interval boundary is just longer than</span>
<a name="l01862"></a>01862   <span class="comment">// the SED range</span>
<a name="l01863"></a>01863   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (wav_min &gt; sed-&gt;<a class="code" href="structenergy__distrib.html#ac32d12647e9ef7f158b0d4532c09a568">wavelength</a>[sed-&gt;<a class="code" href="structenergy__distrib.html#ae5e24fde4a41b46a8b8510118f646e67">npoints</a>-1]){
<a name="l01864"></a>01864     <span class="comment">// give the highest defined value</span>
<a name="l01865"></a>01865     flux = sed-&gt;<a class="code" href="structenergy__distrib.html#a7da8059a7bb2f8af463b6ee1dd1e6554">flux</a>[sed-&gt;<a class="code" href="structenergy__distrib.html#ae5e24fde4a41b46a8b8510118f646e67">npoints</a>-1];}
<a name="l01866"></a>01866 
<a name="l01867"></a>01867   <span class="comment">// check whether the interval covers the lower</span>
<a name="l01868"></a>01868   <span class="comment">// end covered by the SED</span>
<a name="l01869"></a>01869   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (wav_min &lt; sed-&gt;wavelength[0] &amp;&amp; wav_max &gt; sed-&gt;<a class="code" href="structenergy__distrib.html#ac32d12647e9ef7f158b0d4532c09a568">wavelength</a>[0])
<a name="l01870"></a>01870     {
<a name="l01871"></a>01871       <span class="comment">// get the lower interval</span>
<a name="l01872"></a>01872       range_1 = sed-&gt;<a class="code" href="structenergy__distrib.html#ac32d12647e9ef7f158b0d4532c09a568">wavelength</a>[0] - wav_min;
<a name="l01873"></a>01873 
<a name="l01874"></a>01874       <span class="comment">// check whether the upper boundary is</span>
<a name="l01875"></a>01875       <span class="comment">// covered by the SED</span>
<a name="l01876"></a>01876       <span class="keywordflow">if</span> (wav_max &lt;= sed-&gt;wavelength[sed-&gt;<a class="code" href="structenergy__distrib.html#ae5e24fde4a41b46a8b8510118f646e67">npoints</a>-1])
<a name="l01877"></a>01877         {
<a name="l01878"></a>01878           <span class="comment">//fprintf(stderr,&quot;got here!\n&quot;);</span>
<a name="l01879"></a>01879           <span class="comment">// get the integration interval</span>
<a name="l01880"></a>01880           range_2 = wav_max - sed-&gt;<a class="code" href="structenergy__distrib.html#ac32d12647e9ef7f158b0d4532c09a568">wavelength</a>[0];
<a name="l01881"></a>01881 
<a name="l01882"></a>01882           <span class="comment">// average the two integrals</span>
<a name="l01883"></a>01883           flux = (range_1*sed-&gt;<a class="code" href="structenergy__distrib.html#a7da8059a7bb2f8af463b6ee1dd1e6554">flux</a>[0] + gsl_interp_eval_integ(sed-&gt;<a class="code" href="structenergy__distrib.html#a3d90efb6bd5ace3c19884613063644af">interp</a>, sed-&gt;<a class="code" href="structenergy__distrib.html#ac32d12647e9ef7f158b0d4532c09a568">wavelength</a>, sed-&gt;<a class="code" href="structenergy__distrib.html#a7da8059a7bb2f8af463b6ee1dd1e6554">flux</a>, sed-&gt;<a class="code" href="structenergy__distrib.html#ac32d12647e9ef7f158b0d4532c09a568">wavelength</a>[0], wav_max, sed-&gt;<a class="code" href="structenergy__distrib.html#a7d0d556a145bd34158514bdbab57b0ee">accel</a>)) / wave_interv;
<a name="l01884"></a>01884         }
<a name="l01885"></a>01885       <span class="keywordflow">else</span>
<a name="l01886"></a>01886         {
<a name="l01887"></a>01887           <span class="comment">// get the integration interval</span>
<a name="l01888"></a>01888           range_2 = wav_max - sed-&gt;<a class="code" href="structenergy__distrib.html#ac32d12647e9ef7f158b0d4532c09a568">wavelength</a>[sed-&gt;<a class="code" href="structenergy__distrib.html#ae5e24fde4a41b46a8b8510118f646e67">npoints</a>-1];
<a name="l01889"></a>01889 
<a name="l01890"></a>01890           <span class="comment">// average the three integrals</span>
<a name="l01891"></a>01891           flux = (range_1*sed-&gt;<a class="code" href="structenergy__distrib.html#a7da8059a7bb2f8af463b6ee1dd1e6554">flux</a>[0] + range_2*sed-&gt;<a class="code" href="structenergy__distrib.html#a7da8059a7bb2f8af463b6ee1dd1e6554">flux</a>[sed-&gt;<a class="code" href="structenergy__distrib.html#ae5e24fde4a41b46a8b8510118f646e67">npoints</a>-1]
<a name="l01892"></a>01892                   + gsl_interp_eval_integ(sed-&gt;<a class="code" href="structenergy__distrib.html#a3d90efb6bd5ace3c19884613063644af">interp</a>, sed-&gt;<a class="code" href="structenergy__distrib.html#ac32d12647e9ef7f158b0d4532c09a568">wavelength</a>, sed-&gt;<a class="code" href="structenergy__distrib.html#a7da8059a7bb2f8af463b6ee1dd1e6554">flux</a>, sed-&gt;<a class="code" href="structenergy__distrib.html#ac32d12647e9ef7f158b0d4532c09a568">wavelength</a>[0], sed-&gt;<a class="code" href="structenergy__distrib.html#ac32d12647e9ef7f158b0d4532c09a568">wavelength</a>[sed-&gt;<a class="code" href="structenergy__distrib.html#ae5e24fde4a41b46a8b8510118f646e67">npoints</a>-1], sed-&gt;<a class="code" href="structenergy__distrib.html#a7d0d556a145bd34158514bdbab57b0ee">accel</a>)) / wave_interv;
<a name="l01893"></a>01893         }
<a name="l01894"></a>01894     }
<a name="l01895"></a>01895 
<a name="l01896"></a>01896   <span class="comment">// check whether the interval start is beyound</span>
<a name="l01897"></a>01897   <span class="comment">// the lower</span>
<a name="l01898"></a>01898   <span class="comment">// end covered by the SED</span>
<a name="l01899"></a>01899   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (wav_min &gt;= sed-&gt;<a class="code" href="structenergy__distrib.html#ac32d12647e9ef7f158b0d4532c09a568">wavelength</a>[0] &amp;&amp; wav_max &gt;= sed-&gt;<a class="code" href="structenergy__distrib.html#ac32d12647e9ef7f158b0d4532c09a568">wavelength</a>[0])
<a name="l01900"></a>01900     {
<a name="l01901"></a>01901       <span class="comment">// check whether the interval is completely</span>
<a name="l01902"></a>01902       <span class="comment">// covered by the SED</span>
<a name="l01903"></a>01903       <span class="keywordflow">if</span> (wav_max &lt;= sed-&gt;wavelength[sed-&gt;<a class="code" href="structenergy__distrib.html#ae5e24fde4a41b46a8b8510118f646e67">npoints</a>-1])
<a name="l01904"></a>01904         {
<a name="l01905"></a>01905           <span class="comment">// compute the integral over the SED and the interval</span>
<a name="l01906"></a>01906           flux = gsl_interp_eval_integ(sed-&gt;<a class="code" href="structenergy__distrib.html#a3d90efb6bd5ace3c19884613063644af">interp</a>, sed-&gt;<a class="code" href="structenergy__distrib.html#ac32d12647e9ef7f158b0d4532c09a568">wavelength</a>, sed-&gt;<a class="code" href="structenergy__distrib.html#a7da8059a7bb2f8af463b6ee1dd1e6554">flux</a>, wav_min, wav_max, sed-&gt;<a class="code" href="structenergy__distrib.html#a7d0d556a145bd34158514bdbab57b0ee">accel</a>) / wave_interv;
<a name="l01907"></a>01907         }
<a name="l01908"></a>01908       <span class="comment">// if the interval is partly out</span>
<a name="l01909"></a>01909       <span class="comment">// of the SED</span>
<a name="l01910"></a>01910       <span class="keywordflow">else</span>
<a name="l01911"></a>01911         {
<a name="l01912"></a>01912           <span class="comment">// compute the range which is in</span>
<a name="l01913"></a>01913           range_1 = sed-&gt;<a class="code" href="structenergy__distrib.html#ac32d12647e9ef7f158b0d4532c09a568">wavelength</a>[sed-&gt;<a class="code" href="structenergy__distrib.html#ae5e24fde4a41b46a8b8510118f646e67">npoints</a>-1] - wav_min;
<a name="l01914"></a>01914           <span class="comment">// compute the range which is out</span>
<a name="l01915"></a>01915           range_2 = wav_max - sed-&gt;<a class="code" href="structenergy__distrib.html#ac32d12647e9ef7f158b0d4532c09a568">wavelength</a>[sed-&gt;<a class="code" href="structenergy__distrib.html#ae5e24fde4a41b46a8b8510118f646e67">npoints</a>-1];
<a name="l01916"></a>01916 
<a name="l01917"></a>01917           <span class="comment">// compute the integrated flux via weighted summation</span>
<a name="l01918"></a>01918           <span class="comment">// of the in part and the out part</span>
<a name="l01919"></a>01919           flux = (gsl_interp_eval_integ(sed-&gt;<a class="code" href="structenergy__distrib.html#a3d90efb6bd5ace3c19884613063644af">interp</a>, sed-&gt;<a class="code" href="structenergy__distrib.html#ac32d12647e9ef7f158b0d4532c09a568">wavelength</a>, sed-&gt;<a class="code" href="structenergy__distrib.html#a7da8059a7bb2f8af463b6ee1dd1e6554">flux</a>, wav_min, sed-&gt;<a class="code" href="structenergy__distrib.html#ac32d12647e9ef7f158b0d4532c09a568">wavelength</a>[sed-&gt;<a class="code" href="structenergy__distrib.html#ae5e24fde4a41b46a8b8510118f646e67">npoints</a>-1], sed-&gt;<a class="code" href="structenergy__distrib.html#a7d0d556a145bd34158514bdbab57b0ee">accel</a>)
<a name="l01920"></a>01920                   + range_2*sed-&gt;<a class="code" href="structenergy__distrib.html#a7da8059a7bb2f8af463b6ee1dd1e6554">flux</a>[sed-&gt;<a class="code" href="structenergy__distrib.html#ae5e24fde4a41b46a8b8510118f646e67">npoints</a>-1]) / wave_interv;
<a name="l01921"></a>01921         }
<a name="l01922"></a>01922     }
<a name="l01923"></a>01923   <span class="comment">// return the integrated flux value</span>
<a name="l01924"></a>01924   <span class="keywordflow">return</span> flux;
<a name="l01925"></a>01925 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a457e67339a8e12cee377ffebf7410c0d"></a><!-- doxytag: member="model_utils.c::get_beam_for_beamspec" ref="a457e67339a8e12cee377ffebf7410c0d" args="(object **oblist, const int nobjects, const beamspec *actspec)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structbeam.html">beam</a> get_beam_for_beamspec </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structobject.html">object</a> **&nbsp;</td>
          <td class="paramname"> <em>oblist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>nobjects</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structbeamspec.html">beamspec</a> *&nbsp;</td>
          <td class="paramname"> <em>actspec</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Function: get_beam_for_beamspec The function selects for a given <a class="el" href="structbeamspec.html">beamspec</a> the corresponding <a class="el" href="structbeam.html">beam</a> from an <a class="el" href="structobject.html">object</a> list. The identification is done via objectID and beamID. An error is thrown in case that no matching <a class="el" href="structbeam.html">beam</a> could be found.</p>
<p>Parameters: </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>oblist</em>&nbsp;</td><td>- the <a class="el" href="structobject.html">object</a> list to identify a <a class="el" href="structbeam.html">beam</a> from </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nobjects</em>&nbsp;</td><td>- the number of objects in the <a class="el" href="structobject.html">object</a> list </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>actspec</em>&nbsp;</td><td>- the model <a class="el" href="structspectrum.html">spectrum</a> to identify a <a class="el" href="structbeam.html">beam</a> for</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>actbeam - the identified <a class="el" href="structbeam.html">beam</a> </dd></dl>

<p><div class="fragment"><pre class="fragment"><a name="l01469"></a>01469 {
<a name="l01470"></a>01470 
<a name="l01471"></a>01471   <a class="code" href="structbeam.html">beam</a> actbeam;
<a name="l01472"></a>01472 
<a name="l01473"></a>01473   <span class="keywordtype">int</span> i, j;
<a name="l01474"></a>01474 
<a name="l01475"></a>01475   <span class="comment">// set the beam ID to -1 to identify</span>
<a name="l01476"></a>01476   <span class="comment">// failed identification</span>
<a name="l01477"></a>01477   actbeam.<a class="code" href="structbeam.html#a5c3f06b67e4cc3c79be539d1b515f3c6">ID</a> = -1;
<a name="l01478"></a>01478 
<a name="l01479"></a>01479   <span class="comment">// go over all objects in the list</span>
<a name="l01480"></a>01480   <span class="keywordflow">for</span> (i = 0; i &lt; nobjects; i++)
<a name="l01481"></a>01481     {
<a name="l01482"></a>01482 
<a name="l01483"></a>01483       <span class="comment">// search for a matching object ID</span>
<a name="l01484"></a>01484       <span class="keywordflow">if</span> (oblist[i]-&gt;ID == actspec-&gt;<a class="code" href="structbeamspec.html#ac47c161554a61fa65c4f5a744f761252">objectID</a>)
<a name="l01485"></a>01485         {
<a name="l01486"></a>01486 
<a name="l01487"></a>01487           <span class="comment">// go over all beams in the matchin object</span>
<a name="l01488"></a>01488           <span class="keywordflow">for</span> (j=0; j &lt; oblist[i]-&gt;<a class="code" href="structobject.html#a14120e3b048a2118f7acd75ea1571c60">nbeams</a>; j++)
<a name="l01489"></a>01489             {
<a name="l01490"></a>01490 
<a name="l01491"></a>01491               <span class="comment">// search for a matching beam ID</span>
<a name="l01492"></a>01492               <span class="keywordflow">if</span> (oblist[i]-&gt;beams[j].ID == actspec-&gt;<a class="code" href="structbeamspec.html#a8185e83f23ffbab21ec47ec3d2bea13c">beamID</a>)
<a name="l01493"></a>01493                 actbeam = oblist[i]-&gt;<a class="code" href="structobject.html#ad643757142781f8265b430e19700cfe5">beams</a>[j];
<a name="l01494"></a>01494             }
<a name="l01495"></a>01495         }
<a name="l01496"></a>01496     }
<a name="l01497"></a>01497 
<a name="l01498"></a>01498   <span class="comment">// report an error in case that the identification failed</span>
<a name="l01499"></a>01499   <span class="keywordflow">if</span> (actbeam.<a class="code" href="structbeam.html#a5c3f06b67e4cc3c79be539d1b515f3c6">ID</a> == -1)
<a name="l01500"></a>01500     <a class="code" href="aXe__errors_8c.html#a7ef7588e5f91237ba7ce4084e6ed3c11">aXe_message</a>(<a class="code" href="aXe__errors_8h.html#a2556a67874555249b07691c37aa6d6e9">aXe_M_FATAL</a>, __FILE__, __LINE__,
<a name="l01501"></a>01501                 <span class="stringliteral">&quot;aXe_PETCONT: &quot;</span> <span class="stringliteral">&quot;object ID %i, Beam %c not found\n&quot;</span>, actspec-&gt;<a class="code" href="structbeamspec.html#ac47c161554a61fa65c4f5a744f761252">objectID</a>, <a class="code" href="aXe__grism_8h.html#a7d90dabb6016bb0e09b6ab84087b70a7">BEAM</a>(actspec-&gt;<a class="code" href="structbeamspec.html#a8185e83f23ffbab21ec47ec3d2bea13c">beamID</a>));
<a name="l01502"></a>01502 
<a name="l01503"></a>01503   <span class="comment">// return the identified beam</span>
<a name="l01504"></a>01504   <span class="keywordflow">return</span> actbeam;
<a name="l01505"></a>01505 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ab0112661e420045b9ed86e6e8cb71794"></a><!-- doxytag: member="model_utils.c::get_beamspec_from_list" ref="ab0112661e420045b9ed86e6e8cb71794" args="(beamspec **speclist, const int aperID, const int beamID)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structbeamspec.html">beamspec</a>* get_beamspec_from_list </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbeamspec.html">beamspec</a> **&nbsp;</td>
          <td class="paramname"> <em>speclist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>aperID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>beamID</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Function: get_beamspec_from_list The functions extracts and returns a specific model <a class="el" href="structbeam.html">beam</a> out of the list of model beams. The requested model <a class="el" href="structbeam.html">beam</a> is identified on the basis of the aperture ID and the <a class="el" href="structbeam.html">beam</a> ID. Without positive identification the last modelled <a class="el" href="structspectrum.html">spectrum</a> in the ist is returned, which is NULL.</p>
<p>Parameters: </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>speclist</em>&nbsp;</td><td>- </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>aperID</em>&nbsp;</td><td>- the <a class="el" href="structobject.html">object</a> ID of the requested <a class="el" href="structbeam.html">beam</a> </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>beamID</em>&nbsp;</td><td>- the <a class="el" href="structbeam.html">beam</a> ID of the requested <a class="el" href="structbeam.html">beam</a></td></tr>
  </table>
  </dd>
</dl>
<p>Returns: </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>ret - the identified <a class="el" href="structbeam.html">beam</a> (or the NULL <a class="el" href="structbeam.html">beam</a> at the end of the list) </dd></dl>

<p><div class="fragment"><pre class="fragment"><a name="l01525"></a>01525 {
<a name="l01526"></a>01526   <span class="comment">//beamspec *ret;</span>
<a name="l01527"></a>01527   <span class="keywordtype">int</span> i=0;
<a name="l01528"></a>01528 
<a name="l01529"></a>01529   <span class="keywordflow">while</span> (speclist[i] != NULL)
<a name="l01530"></a>01530     {
<a name="l01531"></a>01531       <span class="keywordflow">if</span> (speclist[i]-&gt;objectID == aperID &amp;&amp; speclist[i]-&gt;beamID == beamID)
<a name="l01532"></a>01532         {
<a name="l01533"></a>01533           <span class="keywordflow">break</span>;
<a name="l01534"></a>01534         }
<a name="l01535"></a>01535       i++;
<a name="l01536"></a>01536     }
<a name="l01537"></a>01537 
<a name="l01538"></a>01538 <span class="keywordflow">return</span> speclist[i];
<a name="l01539"></a>01539 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a89e076f16fb5ab1d68d6fd60a8c56818"></a><!-- doxytag: member="model_utils.c::get_calib_function" ref="a89e076f16fb5ab1d68d6fd60a8c56818" args="(beamspec *actspec, dirobject *actdir, char CONF_file[], const aperture_conf *conf)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcalib__function.html">calib_function</a>* get_calib_function </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbeamspec.html">beamspec</a> *&nbsp;</td>
          <td class="paramname"> <em>actspec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdirobject.html">dirobject</a> *&nbsp;</td>
          <td class="paramname"> <em>actdir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&nbsp;</td>
          <td class="paramname"> <em>CONF_file</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structaperture__conf.html">aperture_conf</a> *&nbsp;</td>
          <td class="paramname"> <em>conf</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Function: get_calib_function The function extracts the necessary data for the wavelength calibration from the configuration file. The wavelength calibration is assembled for a particular <a class="el" href="structbeam.html">beam</a> of a particular <a class="el" href="structobject.html">object</a>.</p>
<p>Parameters: </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>actspec</em>&nbsp;</td><td>- the model <a class="el" href="structspectrum.html">spectrum</a> this is done for </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>actdir</em>&nbsp;</td><td>- the <a class="el" href="structdirobject.html">dirobject</a> this is done for </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>CONF_file</em>&nbsp;</td><td>- the full filename of the configuration file </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>conf</em>&nbsp;</td><td>- the configuration structure</td></tr>
  </table>
  </dd>
</dl>
<p>Returns: </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>wl_calibration - the wavelength calibration </dd></dl>

<p><div class="fragment"><pre class="fragment"><a name="l00117"></a>00117 {
<a name="l00118"></a>00118   <a class="code" href="structcalib__function.html">calib_function</a> *wl_calibration;
<a name="l00119"></a>00119   <a class="code" href="structdispstruct.html">dispstruct</a>     *disp;
<a name="l00120"></a>00120   <a class="code" href="structd__point.html">d_point</a> pixel;
<a name="l00121"></a>00121   <span class="keywordtype">int</span> for_grism=0;
<a name="l00122"></a>00122 
<a name="l00123"></a>00123   <span class="comment">// get the reference point right</span>
<a name="l00124"></a>00124   pixel.<a class="code" href="structd__point.html#a922a3b5d82a119168ba85e5f939d02c3">x</a> = actdir-&gt;<a class="code" href="structdirobject.html#a66ec2727d2a5269c84804a89626834fa">refpoint</a>.<a class="code" href="structd__point.html#a922a3b5d82a119168ba85e5f939d02c3">x</a> - conf-&gt;<a class="code" href="structaperture__conf.html#a5cdddf8dafb95b7a77458fbdbf74e5b9">refx</a>;
<a name="l00125"></a>00125   pixel.<a class="code" href="structd__point.html#ad9846a025508bf8873a501ca5fcefbf4">y</a> = actdir-&gt;<a class="code" href="structdirobject.html#a66ec2727d2a5269c84804a89626834fa">refpoint</a>.<a class="code" href="structd__point.html#ad9846a025508bf8873a501ca5fcefbf4">y</a> - conf-&gt;<a class="code" href="structaperture__conf.html#ae48467c471e66355a90db41d8ce77bc6">refy</a>;
<a name="l00126"></a>00126 
<a name="l00127"></a>00127   <span class="comment">// look whether we are for grisms or prisms</span>
<a name="l00128"></a>00128   for_grism = <a class="code" href="disp__conf_8c.html#a18a284f304a89240630f4f61869f468f">check_for_grism</a> (CONF_file,actspec-&gt;<a class="code" href="structbeamspec.html#a8185e83f23ffbab21ec47ec3d2bea13c">beamID</a>);
<a name="l00129"></a>00129 
<a name="l00130"></a>00130   <span class="comment">// get the dispersion structure</span>
<a name="l00131"></a>00131   disp = <a class="code" href="disp__conf_8c.html#a4b76887b807b37abcfc6eae3b15ddf4f">get_dispstruct_at_pos</a>(CONF_file, for_grism,
<a name="l00132"></a>00132                                actspec-&gt;<a class="code" href="structbeamspec.html#a8185e83f23ffbab21ec47ec3d2bea13c">beamID</a>,pixel);
<a name="l00133"></a>00133 
<a name="l00134"></a>00134 
<a name="l00135"></a>00135   <span class="comment">// transform the dispersion structure into the</span>
<a name="l00136"></a>00136   <span class="comment">// wavelength calibration</span>
<a name="l00137"></a>00137   wl_calibration = <a class="code" href="spc__wl__calib_8c.html#a99adb944646e98f75c71fa972290f8a3">create_calib_from_gsl_vector</a>(for_grism, disp-&gt;<a class="code" href="structdispstruct.html#aa3d9b87899d74411311e3a0ab60eeb20">pol</a>);
<a name="l00138"></a>00138   <span class="keywordflow">if</span> (!for_grism)
<a name="l00139"></a>00139     wl_calibration-&gt;<a class="code" href="structcalib__function.html#a585ddafa8bb9e1ac0b7a3da3410b5f80">pr_range</a> = <a class="code" href="disp__conf_8c.html#a689441b9d0c2037f5a6581423f8bfa88">get_prange</a> (CONF_file, actspec-&gt;<a class="code" href="structbeamspec.html#a8185e83f23ffbab21ec47ec3d2bea13c">beamID</a>);
<a name="l00140"></a>00140 
<a name="l00141"></a>00141   <a class="code" href="disp__conf_8c.html#a4f56bf7087ee22ccb4b0a85a7fe7c1bd">free_dispstruct</a>(disp);
<a name="l00142"></a>00142 
<a name="l00143"></a>00143   <span class="comment">// return the wavelength calibration</span>
<a name="l00144"></a>00144   <span class="keywordflow">return</span> wl_calibration;
<a name="l00145"></a>00145 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a39965b9d4410809472bb1a5fd4328026"></a><!-- doxytag: member="model_utils.c::get_dirobject_from_list" ref="a39965b9d4410809472bb1a5fd4328026" args="(dirobject **dirlist, const int ID)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdirobject.html">dirobject</a>* get_dirobject_from_list </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdirobject.html">dirobject</a> **&nbsp;</td>
          <td class="paramname"> <em>dirlist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>ID</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Function: get_dirobject_from_list The function identifies a <a class="el" href="structdirobject.html">dirobject</a> in a list of dirobjects. The identification is made on the attribute ID. The identified <a class="el" href="structdirobject.html">dirobject</a> is returned. If no <a class="el" href="structdirobject.html">dirobject</a> could be identified, the NULL <a class="el" href="structobject.html">object</a>, which is at the end of each <a class="el" href="structdirobject.html">dirobject</a> list, is returned.</p>
<p>Parameters: </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dirlist</em>&nbsp;</td><td>- the <a class="el" href="structdirobject.html">dirobject</a> list </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ID</em>&nbsp;</td><td>- the ID number to be identified</td></tr>
  </table>
  </dd>
</dl>
<p>Returns: </p>
<dl class="return"><dt><b>Returns:</b></dt><dd><a class="el" href="structdirobject.html">dirobject</a> - the identified <a class="el" href="structdirobject.html">dirobject</a> or the 'NULL'-dirobject </dd></dl>

<p><div class="fragment"><pre class="fragment"><a name="l01405"></a>01405 {
<a name="l01406"></a>01406 
<a name="l01407"></a>01407   <span class="comment">//dirobject * actdir;</span>
<a name="l01408"></a>01408   <span class="keywordtype">int</span> i, ndirs = 0;
<a name="l01409"></a>01409 
<a name="l01410"></a>01410   <span class="comment">// count the number of dirobjects in the list</span>
<a name="l01411"></a>01411   <span class="keywordflow">while</span> (dirlist[ndirs] != NULL)
<a name="l01412"></a>01412     ndirs++;
<a name="l01413"></a>01413 
<a name="l01414"></a>01414   <span class="comment">// loop over all dirobject</span>
<a name="l01415"></a>01415   <span class="keywordflow">for</span> (i = 0; i &lt; ndirs; i++)
<a name="l01416"></a>01416     {
<a name="l01417"></a>01417       <span class="comment">// try to identify a dirobject,</span>
<a name="l01418"></a>01418       <span class="comment">// return it in case of a postitive identification</span>
<a name="l01419"></a>01419       <span class="keywordflow">if</span> (dirlist[i]-&gt;ID == ID)
<a name="l01420"></a>01420         <span class="keywordflow">return</span> dirlist[i];
<a name="l01421"></a>01421     }
<a name="l01422"></a>01422 
<a name="l01423"></a>01423   <span class="comment">// return the NULL-dirobject at the end of the list</span>
<a name="l01424"></a>01424   <span class="keywordflow">return</span> dirlist[ndirs];
<a name="l01425"></a>01425 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a6dbc5b3a67592030d394cee3570b44e8"></a><!-- doxytag: member="model_utils.c::get_dirobject_meanpos" ref="a6dbc5b3a67592030d394cee3570b44e8" args="(dirobject *actdir)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structd__point.html">d_point</a> get_dirobject_meanpos </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdirobject.html">dirobject</a> *&nbsp;</td>
          <td class="paramname"> <em>actdir</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Function: get_dirobject_meanpos The function computes the average pixel coos of a direct <a class="el" href="structobject.html">object</a>. This is done in a very simple way, by averaging the maximum and minimum pixel coordinates in both, x and y. Neither the shape nor the the intensity in the individual pixels are taken into account.</p>
<p>Parameters: </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>actdir</em>&nbsp;</td><td>- the direct <a class="el" href="structobject.html">object</a></td></tr>
  </table>
  </dd>
</dl>
<p>Returns: </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>m_point - the means coo's in x and y </dd></dl>

<p><div class="fragment"><pre class="fragment"><a name="l01444"></a>01444 {
<a name="l01445"></a>01445   <a class="code" href="structd__point.html">d_point</a> m_point;
<a name="l01446"></a>01446 
<a name="l01447"></a>01447   m_point.<a class="code" href="structd__point.html#a922a3b5d82a119168ba85e5f939d02c3">x</a> = ((double)actdir-&gt;<a class="code" href="structdirobject.html#ac8c6104f2c2e1384c64bba61ecf40d69">ix_max</a> + (<span class="keywordtype">double</span>)actdir-&gt;<a class="code" href="structdirobject.html#ac068f35c585eec4cd1e5d3392c2dd698">ix_min</a>) / 2.0;
<a name="l01448"></a>01448   m_point.<a class="code" href="structd__point.html#ad9846a025508bf8873a501ca5fcefbf4">y</a> = ((double)actdir-&gt;<a class="code" href="structdirobject.html#a3b36973dd52d158c059bfe6587a04244">iy_max</a> + (<span class="keywordtype">double</span>)actdir-&gt;<a class="code" href="structdirobject.html#af24c9a92fa18516591e43d96eec13272">iy_min</a>) / 2.0;
<a name="l01449"></a>01449 
<a name="l01450"></a>01450   <span class="keywordflow">return</span> m_point;
<a name="l01451"></a>01451 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="af09a9a57d7ad0ec300ed94e9dd76d595"></a><!-- doxytag: member="model_utils.c::get_dpsf" ref="af09a9a57d7ad0ec300ed94e9dd76d595" args="(const double lambda_ref, const double lambda, const aperture_conf *conf, const beam actbeam)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double get_dpsf </td>
          <td>(</td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>lambda_ref</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>lambda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structaperture__conf.html">aperture_conf</a> *&nbsp;</td>
          <td class="paramname"> <em>conf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structbeam.html">beam</a>&nbsp;</td>
          <td class="paramname"> <em>actbeam</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Function: get_dpsf The function computes the difference of the psf width at two different wavelengths. The dependence of the psf as a function of the wavelength is supposed to be a polynomial</p>
<p>Parameters: </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>lambda_ref</em>&nbsp;</td><td>- the reference wavelength </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>lambda</em>&nbsp;</td><td>- the wavelength to evaluate the difference for </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>conf</em>&nbsp;</td><td>- the configuration structure</td></tr>
  </table>
  </dd>
</dl>
<p>Returns: </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>dpsf - the psf difference </dd></dl>

<p><div class="fragment"><pre class="fragment"><a name="l02156"></a>02156 {
<a name="l02157"></a>02157 
<a name="l02158"></a>02158   <span class="keywordtype">double</span> dpsf=0.0;
<a name="l02159"></a>02159   <span class="keywordtype">double</span> lmin=0.0;
<a name="l02160"></a>02160   <span class="keywordtype">double</span> lmax=0.0;
<a name="l02161"></a>02161 
<a name="l02162"></a>02162   <span class="comment">// get the minimum and maximum wavelength</span>
<a name="l02163"></a>02163   <span class="comment">// for the dependency</span>
<a name="l02164"></a>02164   lmin = gsl_vector_get(conf-&gt;<a class="code" href="structaperture__conf.html#a469dc826e363a3b9e340aa99824e2f30">psfrange</a>, 0);
<a name="l02165"></a>02165   lmax = gsl_vector_get(conf-&gt;<a class="code" href="structaperture__conf.html#a469dc826e363a3b9e340aa99824e2f30">psfrange</a>, 1);
<a name="l02166"></a>02166 
<a name="l02167"></a>02167   <span class="comment">// the reference wavelength must be inside of the</span>
<a name="l02168"></a>02168   <span class="comment">// area where the polynomial is valid</span>
<a name="l02169"></a>02169   <span class="keywordflow">if</span> (lambda_ref &lt; lmin){
<a name="l02170"></a>02170     <a class="code" href="aXe__errors_8c.html#a7ef7588e5f91237ba7ce4084e6ed3c11">aXe_message</a> (<a class="code" href="aXe__errors_8h.html#a2556a67874555249b07691c37aa6d6e9">aXe_M_FATAL</a>, __FILE__, __LINE__,
<a name="l02171"></a>02171                  <span class="stringliteral">&quot;aXe_PETCONT:&quot;</span> <span class="stringliteral">&quot;Reference wavelength %f&quot;</span>
<a name="l02172"></a>02172                  <span class="stringliteral">&quot; is smaller than minimum wavelength: %f!\n&quot;</span>, lambda_ref, lmin);
<a name="l02173"></a>02173   }
<a name="l02174"></a>02174   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (lambda_ref &gt; lmax){
<a name="l02175"></a>02175     <a class="code" href="aXe__errors_8c.html#a7ef7588e5f91237ba7ce4084e6ed3c11">aXe_message</a> (<a class="code" href="aXe__errors_8h.html#a2556a67874555249b07691c37aa6d6e9">aXe_M_FATAL</a>, __FILE__, __LINE__,
<a name="l02176"></a>02176                  <span class="stringliteral">&quot;aXe_PETCONT:&quot;</span> <span class="stringliteral">&quot;Reference wavelength %f&quot;</span>
<a name="l02177"></a>02177                  <span class="stringliteral">&quot; is larger than maximum wavelength: %f!\n&quot;</span>, lambda_ref, lmax);
<a name="l02178"></a>02178   }
<a name="l02179"></a>02179   <span class="keywordflow">else</span>{
<a name="l02180"></a>02180     <span class="keywordflow">if</span> (lambda &lt; lmin)
<a name="l02181"></a>02181       <span class="comment">// if the target wavelength is larger,</span>
<a name="l02182"></a>02182       <span class="comment">// evaluate at the upper border</span>
<a name="l02183"></a>02183       dpsf = <a class="code" href="model__utils_8c.html#a98ec48fe5d4a02d1711285b63fd4ed2a">get_polyN_gsl</a>(lmin, conf-&gt;<a class="code" href="structaperture__conf.html#a904a154040bedf410b669b65791c96e2">psfcoeffs</a>) - <a class="code" href="model__utils_8c.html#a98ec48fe5d4a02d1711285b63fd4ed2a">get_polyN_gsl</a>(lambda_ref, conf-&gt;<a class="code" href="structaperture__conf.html#a904a154040bedf410b669b65791c96e2">psfcoeffs</a>);
<a name="l02184"></a>02184     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (lambda &gt; lmax)
<a name="l02185"></a>02185       <span class="comment">// if the target wavelength is smaller,</span>
<a name="l02186"></a>02186       <span class="comment">// evaluate at the lower border</span>
<a name="l02187"></a>02187       dpsf = <a class="code" href="model__utils_8c.html#a98ec48fe5d4a02d1711285b63fd4ed2a">get_polyN_gsl</a>(lmax, conf-&gt;<a class="code" href="structaperture__conf.html#a904a154040bedf410b669b65791c96e2">psfcoeffs</a>) - <a class="code" href="model__utils_8c.html#a98ec48fe5d4a02d1711285b63fd4ed2a">get_polyN_gsl</a>(lambda_ref, conf-&gt;<a class="code" href="structaperture__conf.html#a904a154040bedf410b669b65791c96e2">psfcoeffs</a>);
<a name="l02188"></a>02188     <span class="keywordflow">else</span>
<a name="l02189"></a>02189       <span class="comment">// evaluate the exact position</span>
<a name="l02190"></a>02190       dpsf = <a class="code" href="model__utils_8c.html#a98ec48fe5d4a02d1711285b63fd4ed2a">get_polyN_gsl</a>(lambda, conf-&gt;<a class="code" href="structaperture__conf.html#a904a154040bedf410b669b65791c96e2">psfcoeffs</a>) - <a class="code" href="model__utils_8c.html#a98ec48fe5d4a02d1711285b63fd4ed2a">get_polyN_gsl</a>(lambda_ref, conf-&gt;<a class="code" href="structaperture__conf.html#a904a154040bedf410b669b65791c96e2">psfcoeffs</a>);
<a name="l02191"></a>02191   }
<a name="l02192"></a>02192 
<a name="l02193"></a>02193   <span class="comment">// return the result</span>
<a name="l02194"></a>02194   <span class="keywordflow">return</span> dpsf;
<a name="l02195"></a>02195 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ac36a7a4d559d6521def9d8198fa25bbf"></a><!-- doxytag: member="model_utils.c::get_emodel_value" ref="ac36a7a4d559d6521def9d8198fa25bbf" args="(const d_point dpixel, const beam actbeam, const d_point drzscale)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double get_emodel_value </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structd__point.html">d_point</a>&nbsp;</td>
          <td class="paramname"> <em>dpixel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structbeam.html">beam</a>&nbsp;</td>
          <td class="paramname"> <em>actbeam</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structd__point.html">d_point</a>&nbsp;</td>
          <td class="paramname"> <em>drzscale</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Function: get_emodel_value The function evaluates the emission of a 2D gauss model with the parameters as given in a <a class="el" href="structbeam.html">beam</a> at a particular position. A different pixelscale at the emission point due to geometrical distortion can be taken into account.</p>
<p>Parameters: </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dpixel</em>&nbsp;</td><td>- the point to evaluate the emission model </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>actbeam</em>&nbsp;</td><td>- the <a class="el" href="structbeam.html">beam</a> to set up the model for </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pixscale</em>&nbsp;</td><td>- the relative pixelscale at the model position</td></tr>
  </table>
  </dd>
</dl>
<p>Returns: </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>evalue - the value of the emission model </dd></dl>

<p><div class="fragment"><pre class="fragment"><a name="l02276"></a>02276 {
<a name="l02277"></a>02277   <span class="keywordtype">double</span> evalue=0.0;
<a name="l02278"></a>02278 
<a name="l02279"></a>02279   <span class="keywordtype">double</span> amod, bmod;
<a name="l02280"></a>02280   <span class="keywordtype">double</span> xrel, yrel;
<a name="l02281"></a>02281   <span class="keywordtype">double</span> angle;
<a name="l02282"></a>02282 
<a name="l02283"></a>02283   <span class="keywordtype">double</span> arg;
<a name="l02284"></a>02284 
<a name="l02285"></a>02285   <span class="comment">// apply the correction due to geom. distortion</span>
<a name="l02286"></a>02286   amod =  actbeam.<a class="code" href="structbeam.html#a9a40c792769161a2526fb415c6dadad0">awidth</a> / drzscale.<a class="code" href="structd__point.html#a922a3b5d82a119168ba85e5f939d02c3">x</a>;
<a name="l02287"></a>02287   bmod =  actbeam.<a class="code" href="structbeam.html#acc52e3393f91f5f11a65d1a6806b681f">bwidth</a> / drzscale.<a class="code" href="structd__point.html#ad9846a025508bf8873a501ca5fcefbf4">y</a>;
<a name="l02288"></a>02288 
<a name="l02289"></a>02289   <span class="comment">// make some precalculations</span>
<a name="l02290"></a>02290   xrel = dpixel.<a class="code" href="structd__point.html#a922a3b5d82a119168ba85e5f939d02c3">x</a> - actbeam.<a class="code" href="structbeam.html#a54c64670a8b3e8732c1468d156ddb0ca">refpoint</a>.<a class="code" href="structd__point.html#a922a3b5d82a119168ba85e5f939d02c3">x</a>;
<a name="l02291"></a>02291   yrel = dpixel.<a class="code" href="structd__point.html#ad9846a025508bf8873a501ca5fcefbf4">y</a> - actbeam.<a class="code" href="structbeam.html#a54c64670a8b3e8732c1468d156ddb0ca">refpoint</a>.<a class="code" href="structd__point.html#ad9846a025508bf8873a501ca5fcefbf4">y</a>;
<a name="l02292"></a>02292   angle = actbeam.<a class="code" href="structbeam.html#a5cbf4e447f3c6272f31215965e4d574c">aorient</a>;
<a name="l02293"></a>02293 
<a name="l02294"></a>02294   <span class="comment">// determine the argument of the exponent</span>
<a name="l02295"></a>02295   arg =
<a name="l02296"></a>02296     <a class="code" href="dirimage__model_8c.html#aa7866fa5e4e0ee9b034e9dab6599a9cc">SQR</a>(( xrel*cos(angle) + yrel*sin(angle)) / amod) +
<a name="l02297"></a>02297     <a class="code" href="dirimage__model_8c.html#aa7866fa5e4e0ee9b034e9dab6599a9cc">SQR</a>((-xrel*sin(angle) + yrel*cos(angle)) / bmod);
<a name="l02298"></a>02298 
<a name="l02299"></a>02299   <span class="comment">// determine the emission value</span>
<a name="l02300"></a>02300   evalue = 0.5/(amod*bmod*M_PI)*exp(-0.5*arg);
<a name="l02301"></a>02301 
<a name="l02302"></a>02302   <span class="comment">// return the emission value</span>
<a name="l02303"></a>02303   <span class="keywordflow">return</span> evalue;
<a name="l02304"></a>02304 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a8d6681aef9c109bc5c407c286c85d67c"></a><!-- doxytag: member="model_utils.c::get_flambda_from_magab" ref="a8d6681aef9c109bc5c407c286c85d67c" args="(double mag, double lambda)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double get_flambda_from_magab </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>mag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>lambda</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Function: get_flambda_from_magab The subroutine calculates the flambda value for a mag_AB value given with its wvavelength as input parameters.</p>
<p>Parameters: </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>mag</em>&nbsp;</td><td>- the mag_AB value </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>lambda</em>&nbsp;</td><td>- the wavelength for mag_AB</td></tr>
  </table>
  </dd>
</dl>
<p>Returns: </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>flambda - the calculated flambda value </dd></dl>

<p><div class="fragment"><pre class="fragment"><a name="l01944"></a>01944 {
<a name="l01945"></a>01945   <span class="keywordtype">double</span> flambda=0.0;
<a name="l01946"></a>01946   <span class="keywordtype">double</span> fnu=0.0;
<a name="l01947"></a>01947 
<a name="l01948"></a>01948   fnu     = pow(10.0, -0.4*(mag+48.6));
<a name="l01949"></a>01949   flambda = 1.0e+16*<a class="code" href="model__utils_8h.html#ab697e906e81af4c7b804f99deb510eb7">LIGHTVEL</a>*fnu/(lambda*lambda);
<a name="l01950"></a>01950 
<a name="l01951"></a>01951   <span class="keywordflow">return</span> flambda;
<a name="l01952"></a>01952 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ac6e79df79a058ccf4d82853e08a0c2df"></a><!-- doxytag: member="model_utils.c::get_flux_from_SED" ref="ac6e79df79a058ccf4d82853e08a0c2df" args="(const energy_distrib *sed, double in_wave)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double get_flux_from_SED </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structenergy__distrib.html">energy_distrib</a> *&nbsp;</td>
          <td class="paramname"> <em>sed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>in_wave</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Function: get_flux_from_SED The functions returns the flux value at a given wavelength for a certain SED. In case that the wavelength is beyound the wavelength interval where the SED is defined, the closest model value in wavelength is returned. Otherwise the interpolated value as defined in the SED <a class="el" href="structobject.html">object</a> is returned</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>sed</em>&nbsp;</td><td>- the SED-object to derive a flux value from </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>in_wave</em>&nbsp;</td><td>- the wavelength to compute the flux value for</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>flux - the flux value for the requested wavelength </dd></dl>

<p><div class="fragment"><pre class="fragment"><a name="l01797"></a>01797 {
<a name="l01798"></a>01798         <span class="keywordtype">double</span> flux=0.0;
<a name="l01799"></a>01799 
<a name="l01800"></a>01800         <span class="keywordflow">if</span> (in_wave &lt;= sed-&gt;wavelength[0]){
<a name="l01801"></a>01801                 <span class="comment">// give the lowest defined value if</span>
<a name="l01802"></a>01802                 <span class="comment">// the requested wavelength is lower</span>
<a name="l01803"></a>01803                 flux = sed-&gt;<a class="code" href="structenergy__distrib.html#a7da8059a7bb2f8af463b6ee1dd1e6554">flux</a>[0];
<a name="l01804"></a>01804         }
<a name="l01805"></a>01805         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (in_wave &gt; sed-&gt;<a class="code" href="structenergy__distrib.html#ac32d12647e9ef7f158b0d4532c09a568">wavelength</a>[sed-&gt;<a class="code" href="structenergy__distrib.html#ae5e24fde4a41b46a8b8510118f646e67">npoints</a>-1]){
<a name="l01806"></a>01806                 <span class="comment">// give the highest defined value if</span>
<a name="l01807"></a>01807                 <span class="comment">// the requested wavelength is higher</span>
<a name="l01808"></a>01808                 flux = sed-&gt;<a class="code" href="structenergy__distrib.html#a7da8059a7bb2f8af463b6ee1dd1e6554">flux</a>[sed-&gt;<a class="code" href="structenergy__distrib.html#ae5e24fde4a41b46a8b8510118f646e67">npoints</a>-1];}
<a name="l01809"></a>01809         <span class="keywordflow">else</span> {
<a name="l01810"></a>01810                 <span class="comment">// derive the interpolated value</span>
<a name="l01811"></a>01811                 flux = gsl_interp_eval(sed-&gt;<a class="code" href="structenergy__distrib.html#a3d90efb6bd5ace3c19884613063644af">interp</a>, sed-&gt;<a class="code" href="structenergy__distrib.html#ac32d12647e9ef7f158b0d4532c09a568">wavelength</a>, sed-&gt;<a class="code" href="structenergy__distrib.html#a7da8059a7bb2f8af463b6ee1dd1e6554">flux</a>, in_wave, sed-&gt;<a class="code" href="structenergy__distrib.html#a7d0d556a145bd34158514bdbab57b0ee">accel</a>);}
<a name="l01812"></a>01812 
<a name="l01813"></a>01813         <span class="comment">// return the interpolated flux value</span>
<a name="l01814"></a>01814         <span class="keywordflow">return</span> flux;
<a name="l01815"></a>01815 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ab02649b7a821651ecce41bd6dc3394f6"></a><!-- doxytag: member="model_utils.c::get_newbeam" ref="ab02649b7a821651ecce41bd6dc3394f6" args="(const beam actbeam, const double dpsf)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structbeam.html">beam</a> get_newbeam </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structbeam.html">beam</a>&nbsp;</td>
          <td class="paramname"> <em>actbeam</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>dpsf</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><div class="fragment"><pre class="fragment"><a name="l02084"></a>02084 {
<a name="l02085"></a>02085   <a class="code" href="structbeam.html">beam</a> new_beam;
<a name="l02086"></a>02086 
<a name="l02087"></a>02087   new_beam.<a class="code" href="structbeam.html#a5c3f06b67e4cc3c79be539d1b515f3c6">ID</a>=0;
<a name="l02088"></a>02088 
<a name="l02089"></a>02089   <span class="comment">// check the sign of the modification</span>
<a name="l02090"></a>02090   <span class="keywordflow">if</span> (dpsf &gt;0.0)
<a name="l02091"></a>02091     {
<a name="l02092"></a>02092       <span class="comment">// positive sign:</span>
<a name="l02093"></a>02093       <span class="comment">// add (in quadrature) the psf-modification</span>
<a name="l02094"></a>02094       new_beam.<a class="code" href="structbeam.html#a9a40c792769161a2526fb415c6dadad0">awidth</a>   = sqrt(<a class="code" href="dirimage__model_8c.html#aa7866fa5e4e0ee9b034e9dab6599a9cc">SQR</a>(actbeam.<a class="code" href="structbeam.html#a9a40c792769161a2526fb415c6dadad0">awidth</a>) + <a class="code" href="dirimage__model_8c.html#aa7866fa5e4e0ee9b034e9dab6599a9cc">SQR</a>(dpsf));
<a name="l02095"></a>02095       new_beam.<a class="code" href="structbeam.html#acc52e3393f91f5f11a65d1a6806b681f">bwidth</a>   = sqrt(<a class="code" href="dirimage__model_8c.html#aa7866fa5e4e0ee9b034e9dab6599a9cc">SQR</a>(actbeam.<a class="code" href="structbeam.html#acc52e3393f91f5f11a65d1a6806b681f">bwidth</a>) + <a class="code" href="dirimage__model_8c.html#aa7866fa5e4e0ee9b034e9dab6599a9cc">SQR</a>(dpsf));
<a name="l02096"></a>02096     }
<a name="l02097"></a>02097   <span class="keywordflow">else</span>
<a name="l02098"></a>02098     {
<a name="l02099"></a>02099 
<a name="l02100"></a>02100       <span class="comment">// check whether awidth is big enough</span>
<a name="l02101"></a>02101       <span class="keywordflow">if</span> (actbeam.<a class="code" href="structbeam.html#a9a40c792769161a2526fb415c6dadad0">awidth</a>+dpsf &lt; <a class="code" href="model__utils_8h.html#a7ccf406903b6e63ebb32b3e8dc401f3d">MINPSF</a>)
<a name="l02102"></a>02102         {
<a name="l02103"></a>02103           <span class="comment">// set the minimum sign, and set the psf to MINPSF</span>
<a name="l02104"></a>02104           new_beam.<a class="code" href="structbeam.html#a5c3f06b67e4cc3c79be539d1b515f3c6">ID</a>=1;
<a name="l02105"></a>02105           new_beam.<a class="code" href="structbeam.html#a9a40c792769161a2526fb415c6dadad0">awidth</a> = <a class="code" href="model__utils_8h.html#a7ccf406903b6e63ebb32b3e8dc401f3d">MINPSF</a>;
<a name="l02106"></a>02106         }
<a name="l02107"></a>02107       <span class="keywordflow">else</span>
<a name="l02108"></a>02108         {
<a name="l02109"></a>02109           <span class="comment">// negative sign:</span>
<a name="l02110"></a>02110           <span class="comment">// subtract (in quadrature) the psf-modification</span>
<a name="l02111"></a>02111           new_beam.<a class="code" href="structbeam.html#a9a40c792769161a2526fb415c6dadad0">awidth</a> = sqrt(<a class="code" href="dirimage__model_8c.html#aa7866fa5e4e0ee9b034e9dab6599a9cc">SQR</a>(actbeam.<a class="code" href="structbeam.html#a9a40c792769161a2526fb415c6dadad0">awidth</a>) - <a class="code" href="dirimage__model_8c.html#aa7866fa5e4e0ee9b034e9dab6599a9cc">SQR</a>(dpsf));
<a name="l02112"></a>02112         }
<a name="l02113"></a>02113 
<a name="l02114"></a>02114       <span class="comment">// check whether bwidth is big enough</span>
<a name="l02115"></a>02115       <span class="keywordflow">if</span> (actbeam.<a class="code" href="structbeam.html#acc52e3393f91f5f11a65d1a6806b681f">bwidth</a>+dpsf &lt; <a class="code" href="model__utils_8h.html#a7ccf406903b6e63ebb32b3e8dc401f3d">MINPSF</a>)
<a name="l02116"></a>02116         {
<a name="l02117"></a>02117           <span class="comment">// set the minimum sign, and set the psf to MINPSF</span>
<a name="l02118"></a>02118           new_beam.<a class="code" href="structbeam.html#a5c3f06b67e4cc3c79be539d1b515f3c6">ID</a>=1;
<a name="l02119"></a>02119           new_beam.<a class="code" href="structbeam.html#acc52e3393f91f5f11a65d1a6806b681f">bwidth</a> = <a class="code" href="model__utils_8h.html#a7ccf406903b6e63ebb32b3e8dc401f3d">MINPSF</a>;
<a name="l02120"></a>02120         }
<a name="l02121"></a>02121       <span class="keywordflow">else</span>
<a name="l02122"></a>02122         {
<a name="l02123"></a>02123           <span class="comment">// negative sign:</span>
<a name="l02124"></a>02124           <span class="comment">// subtract (in quadrature) the psf-modification</span>
<a name="l02125"></a>02125           new_beam.<a class="code" href="structbeam.html#acc52e3393f91f5f11a65d1a6806b681f">bwidth</a> = sqrt(<a class="code" href="dirimage__model_8c.html#aa7866fa5e4e0ee9b034e9dab6599a9cc">SQR</a>(actbeam.<a class="code" href="structbeam.html#acc52e3393f91f5f11a65d1a6806b681f">bwidth</a>) - <a class="code" href="dirimage__model_8c.html#aa7866fa5e4e0ee9b034e9dab6599a9cc">SQR</a>(dpsf));
<a name="l02126"></a>02126         }
<a name="l02127"></a>02127     }
<a name="l02128"></a>02128 
<a name="l02129"></a>02129 
<a name="l02130"></a>02130   <span class="comment">// transfer necessary data</span>
<a name="l02131"></a>02131   new_beam.<a class="code" href="structbeam.html#a5cbf4e447f3c6272f31215965e4d574c">aorient</a> = actbeam.<a class="code" href="structbeam.html#a5cbf4e447f3c6272f31215965e4d574c">aorient</a>;
<a name="l02132"></a>02132   new_beam.<a class="code" href="structbeam.html#a54c64670a8b3e8732c1468d156ddb0ca">refpoint</a> = actbeam.<a class="code" href="structbeam.html#a54c64670a8b3e8732c1468d156ddb0ca">refpoint</a>;
<a name="l02133"></a>02133 
<a name="l02134"></a>02134   <span class="comment">// return the new beam</span>
<a name="l02135"></a>02135   <span class="keywordflow">return</span> new_beam;
<a name="l02136"></a>02136 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a98ec48fe5d4a02d1711285b63fd4ed2a"></a><!-- doxytag: member="model_utils.c::get_polyN_gsl" ref="a98ec48fe5d4a02d1711285b63fd4ed2a" args="(const double x, const gsl_vector *params)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double get_polyN_gsl </td>
          <td>(</td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const gsl_vector *&nbsp;</td>
          <td class="paramname"> <em>params</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Function: get_polyN_gsl The function evaluates a polynomial at a given position.</p>
<p>Parameters: </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>x</em>&nbsp;</td><td>- the point to evaluate the polynomial </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>params</em>&nbsp;</td><td>- gsl-vector with the coefficients of the polynomial</td></tr>
  </table>
  </dd>
</dl>
<p>Returns: </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>p - the value of the polynomial </dd></dl>

<p><div class="fragment"><pre class="fragment"><a name="l02356"></a>02356 {
<a name="l02357"></a>02357   <span class="keywordtype">int</span> i;
<a name="l02358"></a>02358 
<a name="l02359"></a>02359   <span class="keywordtype">double</span> p=0.0;
<a name="l02360"></a>02360 
<a name="l02361"></a>02361   <span class="comment">// go over the gsl-vector and</span>
<a name="l02362"></a>02362   <span class="comment">// sum up the individual terms</span>
<a name="l02363"></a>02363   <span class="keywordflow">for</span> (i=0; i&lt;params-&gt;size; i++)
<a name="l02364"></a>02364     {
<a name="l02365"></a>02365       p += gsl_vector_get(params,i)*pow(x,i);
<a name="l02366"></a>02366     }
<a name="l02367"></a>02367 
<a name="l02368"></a>02368   <span class="comment">// return the value</span>
<a name="l02369"></a>02369   <span class="keywordflow">return</span> p;
<a name="l02370"></a>02370 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a78b257e92ab75a5531ccb6881ecd201e"></a><!-- doxytag: member="model_utils.c::get_psf_HRC" ref="a78b257e92ab75a5531ccb6881ecd201e" args="(const double lambda)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double get_psf_HRC </td>
          <td>(</td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>lambda</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><div class="fragment"><pre class="fragment"><a name="l02319"></a>02319 {
<a name="l02320"></a>02320   <span class="keywordtype">double</span> psf = 0.0;
<a name="l02321"></a>02321 
<a name="l02322"></a>02322   psf = 8.1986545952891 - 0.82947763250959e-01*lambda          + 0.40134114766915e-03*pow(lambda,2.0) -
<a name="l02323"></a>02323                           0.94651169604925e-06*pow(lambda,3.0) + 0.11804479784053e-08*pow(lambda,4.0) -
<a name="l02324"></a>02324                           0.74395828991899e-12*pow(lambda,5.0) + 0.18657361078105e-15*pow(lambda,6.0);
<a name="l02325"></a>02325 
<a name="l02326"></a>02326   <span class="keywordflow">return</span> psf;
<a name="l02327"></a>02327 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="af417d458a7783d5c0183ad9c69335fd0"></a><!-- doxytag: member="model_utils.c::get_psf_SBC" ref="af417d458a7783d5c0183ad9c69335fd0" args="(const double lambda)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double get_psf_SBC </td>
          <td>(</td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>lambda</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><div class="fragment"><pre class="fragment"><a name="l02331"></a>02331 {
<a name="l02332"></a>02332   <span class="keywordtype">double</span> psf = 0.0;
<a name="l02333"></a>02333 
<a name="l02334"></a>02334   psf = 7.9833718878881 - 0.11283853224345    *lambda          + 0.64235625522476e-03*pow(lambda,2.0)
<a name="l02335"></a>02335                         - 0.12471899390220e-05*pow(lambda,3.0);
<a name="l02336"></a>02336 
<a name="l02337"></a>02337   <span class="keywordflow">return</span> psf;
<a name="l02338"></a>02338 
<a name="l02339"></a>02339 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="aaf9f8cca863f01beb42cceaf8c74e6ac"></a><!-- doxytag: member="model_utils.c::get_psf_WFC" ref="aaf9f8cca863f01beb42cceaf8c74e6ac" args="(const double lambda)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double get_psf_WFC </td>
          <td>(</td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>lambda</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><div class="fragment"><pre class="fragment"><a name="l02309"></a>02309 {
<a name="l02310"></a>02310   <span class="keywordtype">double</span> psf;
<a name="l02311"></a>02311 
<a name="l02312"></a>02312   psf = 1.2994407614072 + 0.11290883734113e-02*lambda - 0.44245634760175e-06*pow(lambda,2.0);
<a name="l02313"></a>02313 
<a name="l02314"></a>02314   <span class="keywordflow">return</span> psf;
<a name="l02315"></a>02315 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a5b20290920148fb8fb75adb149a94f6d"></a><!-- doxytag: member="model_utils.c::get_refpoint_ranges" ref="a5b20290920148fb8fb75adb149a94f6d" args="(const object *actobject)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gsl_vector* get_refpoint_ranges </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structobject.html">object</a> *&nbsp;</td>
          <td class="paramname"> <em>actobject</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Function: get_refpoint_ranges</p>
<p>Determines the differences of the reference point positions within the beams of an <a class="el" href="structobject.html">object</a>. The min/max values in x/y with respect to the reference point of the first <a class="el" href="structbeam.html">beam</a> are determined and returned in a vector.</p>
<p>Parameters: </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>actobject</em>&nbsp;</td><td>- the <a class="el" href="structobject.html">object</a> to be transformed</td></tr>
  </table>
  </dd>
</dl>
<p>Returns: </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>ret - the <a class="el" href="structdirobject.html">dirobject</a> created </dd></dl>

<p><div class="fragment"><pre class="fragment"><a name="l01101"></a>01101 {
<a name="l01102"></a>01102   gsl_vector *ret;
<a name="l01103"></a>01103   <span class="keywordtype">int</span> j;
<a name="l01104"></a>01104   <span class="comment">//d_point reference;</span>
<a name="l01105"></a>01105 
<a name="l01106"></a>01106   <span class="comment">// allocate memory</span>
<a name="l01107"></a>01107   ret = gsl_vector_alloc(4);
<a name="l01108"></a>01108 
<a name="l01109"></a>01109   <span class="comment">// initialize the vector with the default value</span>
<a name="l01110"></a>01110   gsl_vector_set(ret, 0, actobject-&gt;<a class="code" href="structobject.html#ad643757142781f8265b430e19700cfe5">beams</a>[0].<a class="code" href="structbeam.html#a54c64670a8b3e8732c1468d156ddb0ca">refpoint</a>.<a class="code" href="structd__point.html#a922a3b5d82a119168ba85e5f939d02c3">x</a>);
<a name="l01111"></a>01111   gsl_vector_set(ret, 1, actobject-&gt;<a class="code" href="structobject.html#ad643757142781f8265b430e19700cfe5">beams</a>[0].<a class="code" href="structbeam.html#a54c64670a8b3e8732c1468d156ddb0ca">refpoint</a>.<a class="code" href="structd__point.html#a922a3b5d82a119168ba85e5f939d02c3">x</a>);
<a name="l01112"></a>01112   gsl_vector_set(ret, 2, actobject-&gt;<a class="code" href="structobject.html#ad643757142781f8265b430e19700cfe5">beams</a>[0].<a class="code" href="structbeam.html#a54c64670a8b3e8732c1468d156ddb0ca">refpoint</a>.<a class="code" href="structd__point.html#ad9846a025508bf8873a501ca5fcefbf4">y</a>);
<a name="l01113"></a>01113   gsl_vector_set(ret, 3, actobject-&gt;<a class="code" href="structobject.html#ad643757142781f8265b430e19700cfe5">beams</a>[0].<a class="code" href="structbeam.html#a54c64670a8b3e8732c1468d156ddb0ca">refpoint</a>.<a class="code" href="structd__point.html#ad9846a025508bf8873a501ca5fcefbf4">y</a>);
<a name="l01114"></a>01114 
<a name="l01115"></a>01115 
<a name="l01116"></a>01116   <span class="comment">// go over all beams in the object</span>
<a name="l01117"></a>01117   <span class="keywordflow">for</span> (j=1; j &lt; actobject-&gt;<a class="code" href="structobject.html#a14120e3b048a2118f7acd75ea1571c60">nbeams</a>; j++)
<a name="l01118"></a>01118     {
<a name="l01119"></a>01119       <span class="comment">// get the the new absolute mins and maxs in the reference points</span>
<a name="l01120"></a>01120       gsl_vector_set(ret, 0, <a class="code" href="aXe__utils_8c.html#a74e75242132eaabbc1c512488a135926">MIN</a>(gsl_vector_get(ret, 0) , actobject-&gt;<a class="code" href="structobject.html#ad643757142781f8265b430e19700cfe5">beams</a>[j].<a class="code" href="structbeam.html#a54c64670a8b3e8732c1468d156ddb0ca">refpoint</a>.<a class="code" href="structd__point.html#a922a3b5d82a119168ba85e5f939d02c3">x</a>));
<a name="l01121"></a>01121       gsl_vector_set(ret, 1, <a class="code" href="aper__conf_8c.html#aacc3ee1a7f283f8ef65cea31f4436a95">MAX</a>(gsl_vector_get(ret, 1) , actobject-&gt;<a class="code" href="structobject.html#ad643757142781f8265b430e19700cfe5">beams</a>[j].<a class="code" href="structbeam.html#a54c64670a8b3e8732c1468d156ddb0ca">refpoint</a>.<a class="code" href="structd__point.html#a922a3b5d82a119168ba85e5f939d02c3">x</a>));
<a name="l01122"></a>01122       gsl_vector_set(ret, 2, <a class="code" href="aXe__utils_8c.html#a74e75242132eaabbc1c512488a135926">MIN</a>(gsl_vector_get(ret, 2) , actobject-&gt;<a class="code" href="structobject.html#ad643757142781f8265b430e19700cfe5">beams</a>[j].<a class="code" href="structbeam.html#a54c64670a8b3e8732c1468d156ddb0ca">refpoint</a>.<a class="code" href="structd__point.html#ad9846a025508bf8873a501ca5fcefbf4">y</a>));
<a name="l01123"></a>01123       gsl_vector_set(ret, 3, <a class="code" href="aper__conf_8c.html#aacc3ee1a7f283f8ef65cea31f4436a95">MAX</a>(gsl_vector_get(ret, 3) , actobject-&gt;<a class="code" href="structobject.html#ad643757142781f8265b430e19700cfe5">beams</a>[j].<a class="code" href="structbeam.html#a54c64670a8b3e8732c1468d156ddb0ca">refpoint</a>.<a class="code" href="structd__point.html#ad9846a025508bf8873a501ca5fcefbf4">y</a>));
<a name="l01124"></a>01124     }
<a name="l01125"></a>01125 
<a name="l01126"></a>01126   <span class="comment">// transform the absolute ranges into relative ones</span>
<a name="l01127"></a>01127   gsl_vector_set(ret, 0, gsl_vector_get(ret, 0) - actobject-&gt;<a class="code" href="structobject.html#ad643757142781f8265b430e19700cfe5">beams</a>[0].<a class="code" href="structbeam.html#a54c64670a8b3e8732c1468d156ddb0ca">refpoint</a>.<a class="code" href="structd__point.html#a922a3b5d82a119168ba85e5f939d02c3">x</a>);
<a name="l01128"></a>01128   gsl_vector_set(ret, 1, gsl_vector_get(ret, 1) - actobject-&gt;<a class="code" href="structobject.html#ad643757142781f8265b430e19700cfe5">beams</a>[0].<a class="code" href="structbeam.html#a54c64670a8b3e8732c1468d156ddb0ca">refpoint</a>.<a class="code" href="structd__point.html#a922a3b5d82a119168ba85e5f939d02c3">x</a>);
<a name="l01129"></a>01129   gsl_vector_set(ret, 2, gsl_vector_get(ret, 2) - actobject-&gt;<a class="code" href="structobject.html#ad643757142781f8265b430e19700cfe5">beams</a>[0].<a class="code" href="structbeam.html#a54c64670a8b3e8732c1468d156ddb0ca">refpoint</a>.<a class="code" href="structd__point.html#ad9846a025508bf8873a501ca5fcefbf4">y</a>);
<a name="l01130"></a>01130   gsl_vector_set(ret, 3, gsl_vector_get(ret, 3) - actobject-&gt;<a class="code" href="structobject.html#ad643757142781f8265b430e19700cfe5">beams</a>[0].<a class="code" href="structbeam.html#a54c64670a8b3e8732c1468d156ddb0ca">refpoint</a>.<a class="code" href="structd__point.html#ad9846a025508bf8873a501ca5fcefbf4">y</a>);
<a name="l01131"></a>01131 
<a name="l01132"></a>01132   <span class="comment">// return the result</span>
<a name="l01133"></a>01133   <span class="keywordflow">return</span> ret;
<a name="l01134"></a>01134 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a5d8695af668aaed17d349ca4eb36292c"></a><!-- doxytag: member="model_utils.c::get_sub_emodel_value" ref="a5d8695af668aaed17d349ca4eb36292c" args="(const d_point dpixel, const beam actbeam, const d_point drzscale)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double get_sub_emodel_value </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structd__point.html">d_point</a>&nbsp;</td>
          <td class="paramname"> <em>dpixel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structbeam.html">beam</a>&nbsp;</td>
          <td class="paramname"> <em>actbeam</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structd__point.html">d_point</a>&nbsp;</td>
          <td class="paramname"> <em>drzscale</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Function: get_sub_emodel_value The function evaluates the emission of a 2D gauss model with the parameters as given in a <a class="el" href="structbeam.html">beam</a> at a particular position. This function derives the function values on a series of grid positions +-.5pixels in x/y around the requested positions. This avoids rounding problems. The 1D grisdsize is set by the macro NSUB in the header file</p>
<p>Parameters: </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dpixel</em>&nbsp;</td><td>- the point to evaluate the emission model </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>actbeam</em>&nbsp;</td><td>- the <a class="el" href="structbeam.html">beam</a> to set up the model for </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>drzscale</em>&nbsp;</td><td>- the relative pixelscale at the model position</td></tr>
  </table>
  </dd>
</dl>
<p>Returns: </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>sval - the value of the emission model </dd></dl>

<p><div class="fragment"><pre class="fragment"><a name="l02218"></a>02218 {
<a name="l02219"></a>02219   <a class="code" href="structd__point.html">d_point</a> dtmp;
<a name="l02220"></a>02220 
<a name="l02221"></a>02221   <span class="keywordtype">double</span> sval   = 0.0;
<a name="l02222"></a>02222   <span class="keywordtype">double</span> step   = 0.0;
<a name="l02223"></a>02223   <span class="keywordtype">double</span> offset = 0.0;
<a name="l02224"></a>02224 
<a name="l02225"></a>02225   <span class="keywordtype">int</span> irange = 0;
<a name="l02226"></a>02226   <span class="keywordtype">int</span> kk=0, ll=0;
<a name="l02227"></a>02227 
<a name="l02228"></a>02228   <span class="comment">// convert the number of steps to a local integer</span>
<a name="l02229"></a>02229   irange = (int)<a class="code" href="model__utils_8h.html#a40646ef4581e21d1eac608c36580fff3">NSUB</a>;
<a name="l02230"></a>02230 
<a name="l02231"></a>02231   <span class="comment">// compute the step size</span>
<a name="l02232"></a>02232   step = 1.0/(2.0*(double)<a class="code" href="model__utils_8h.html#a40646ef4581e21d1eac608c36580fff3">NSUB</a>);
<a name="l02233"></a>02233 
<a name="l02234"></a>02234   <span class="comment">// compute the initial offset</span>
<a name="l02235"></a>02235   offset = step/2.0;
<a name="l02236"></a>02236 
<a name="l02237"></a>02237   <span class="keywordflow">for</span> (kk=-irange; kk &lt; irange; kk++)
<a name="l02238"></a>02238     {
<a name="l02239"></a>02239       <span class="keywordflow">for</span> (ll=-irange; ll &lt; irange; ll++)
<a name="l02240"></a>02240         {
<a name="l02241"></a>02241           <span class="comment">// determine the actual grid position</span>
<a name="l02242"></a>02242           dtmp.<a class="code" href="structd__point.html#a922a3b5d82a119168ba85e5f939d02c3">x</a> = dpixel.<a class="code" href="structd__point.html#a922a3b5d82a119168ba85e5f939d02c3">x</a> + (double)kk * step + offset;
<a name="l02243"></a>02243           dtmp.<a class="code" href="structd__point.html#ad9846a025508bf8873a501ca5fcefbf4">y</a> = dpixel.<a class="code" href="structd__point.html#ad9846a025508bf8873a501ca5fcefbf4">y</a> + (double)ll * step + offset;
<a name="l02244"></a>02244 
<a name="l02245"></a>02245           <span class="comment">// get the value at the grid position</span>
<a name="l02246"></a>02246           sval = sval + <a class="code" href="model__utils_8c.html#ac36a7a4d559d6521def9d8198fa25bbf">get_emodel_value</a>(dtmp, actbeam, drzscale);
<a name="l02247"></a>02247         }
<a name="l02248"></a>02248     }
<a name="l02249"></a>02249 
<a name="l02250"></a>02250   <span class="comment">// normalize the result</span>
<a name="l02251"></a>02251   sval = sval *step * step;
<a name="l02252"></a>02252 
<a name="l02253"></a>02253   <span class="comment">// return the result</span>
<a name="l02254"></a>02254   <span class="keywordflow">return</span> sval;
<a name="l02255"></a>02255 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ac1c970f8545c70717925e789935baf15"></a><!-- doxytag: member="model_utils.c::get_throughput_spec" ref="ac1c970f8545c70717925e789935baf15" args="(beamspec *actspec, char CONF_file[])" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structspectrum.html">spectrum</a>* get_throughput_spec </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbeamspec.html">beamspec</a> *&nbsp;</td>
          <td class="paramname"> <em>actspec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&nbsp;</td>
          <td class="paramname"> <em>CONF_file</em>[]</td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Function: get_throughput_spec The function determines the throughput file for a certain model <a class="el" href="structspectrum.html">spectrum</a>. The filename is extracted from the configuration file. Then the throughput file is loaded into a <a class="el" href="structspectrum.html">spectrum</a> structure. The <a class="el" href="structspectrum.html">spectrum</a> structure is returned.</p>
<p>Parameters: </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>actspec</em>&nbsp;</td><td>- the model <a class="el" href="structspectrum.html">spectrum</a> this is done for </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>CONF_file</em>&nbsp;</td><td>- the full filename of the configuration file</td></tr>
  </table>
  </dd>
</dl>
<p>Returns: </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>resp - the response function as a <a class="el" href="structspectrum.html">spectrum</a> structure </dd></dl>

<p><div class="fragment"><pre class="fragment"><a name="l00163"></a>00163 {
<a name="l00164"></a>00164   <a class="code" href="structspectrum.html">spectrum</a> *resp;
<a name="l00165"></a>00165   <span class="keywordtype">char</span> through_file[<a class="code" href="aXe__grism_8h.html#ac1535592e39e7edf0cafbd5e695ea622">MAXCHAR</a>];
<a name="l00166"></a>00166   <span class="keywordtype">char</span> through_file_path[<a class="code" href="aXe__grism_8h.html#ac1535592e39e7edf0cafbd5e695ea622">MAXCHAR</a>];
<a name="l00167"></a>00167 
<a name="l00168"></a>00168   <span class="comment">// determine the filename of the throughput file from the configuration</span>
<a name="l00169"></a>00169   <a class="code" href="spc__resp_8c.html#add20ced757ce2623320cfa20db81e4ac">get_troughput_table_name</a>(CONF_file, actspec-&gt;<a class="code" href="structbeamspec.html#a8185e83f23ffbab21ec47ec3d2bea13c">beamID</a>, through_file);
<a name="l00170"></a>00170 
<a name="l00171"></a>00171   <span class="comment">// build up the full filename</span>
<a name="l00172"></a>00172   <a class="code" href="aXe__utils_8c.html#a4f0ee2e065affb06ef1b8669d2b1029c">build_path</a> (<a class="code" href="aXe__AF2PET_8c.html#a0b0be957330d9c69fa325ee014ce4dad">AXE_CONFIG_PATH</a>, through_file, through_file_path);
<a name="l00173"></a>00173 
<a name="l00174"></a>00174   <span class="comment">// load the throughput into the spectrum struct</span>
<a name="l00175"></a>00175   resp=<a class="code" href="spc__resp_8c.html#a5249f78ca40468a3e4634fe15c87da20">get_response_function_from_FITS</a>(through_file_path,2);
<a name="l00176"></a>00176 
<a name="l00177"></a>00177   <span class="comment">// return the spectrum struct</span>
<a name="l00178"></a>00178   <span class="keywordflow">return</span> resp;
<a name="l00179"></a>00179 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="af6b109448b4b2c4087381a89a4946664"></a><!-- doxytag: member="model_utils.c::get_valid_tracedata" ref="af6b109448b4b2c4087381a89a4946664" args="(tracedata *acttrace, const calib_function *wl_calibration)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double get_valid_tracedata </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtracedata.html">tracedata</a> *&nbsp;</td>
          <td class="paramname"> <em>acttrace</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcalib__function.html">calib_function</a> *&nbsp;</td>
          <td class="paramname"> <em>wl_calibration</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><div class="fragment"><pre class="fragment"><a name="l00478"></a>00478 {
<a name="l00479"></a>00479 
<a name="l00480"></a>00480   <span class="keywordtype">double</span> lower, upper, a_0, d_xi;
<a name="l00481"></a>00481 
<a name="l00482"></a>00482   <span class="keywordtype">int</span> nentries=0;
<a name="l00483"></a>00483         <span class="keywordtype">int</span> i=0;
<a name="l00484"></a>00484         <span class="comment">//int iact;</span>
<a name="l00485"></a>00485 
<a name="l00486"></a>00486   <span class="comment">// get the lower and upper boundaries of the accepted range</span>
<a name="l00487"></a>00487   lower = gsl_vector_get(wl_calibration-&gt;<a class="code" href="structcalib__function.html#a585ddafa8bb9e1ac0b7a3da3410b5f80">pr_range</a>, 0);
<a name="l00488"></a>00488   upper = gsl_vector_get(wl_calibration-&gt;<a class="code" href="structcalib__function.html#a585ddafa8bb9e1ac0b7a3da3410b5f80">pr_range</a>, 1);
<a name="l00489"></a>00489 
<a name="l00490"></a>00490   <span class="comment">// get the a0 coefficient</span>
<a name="l00491"></a>00491   a_0 = wl_calibration-&gt;<a class="code" href="structcalib__function.html#af6161163d6abff34648d027533dbc89e">coeffs</a>[0];
<a name="l00492"></a>00492 
<a name="l00493"></a>00493   <span class="comment">// go over all point int he tracedata</span>
<a name="l00494"></a>00494   <span class="keywordflow">for</span> (i=0; i &lt; acttrace-&gt;<a class="code" href="structtracedata.html#af5aed7b8f1629b86be33dc7d57056bcc">npoints</a>; i++)
<a name="l00495"></a>00495     {
<a name="l00496"></a>00496       <span class="comment">// compute the offset from the singularity</span>
<a name="l00497"></a>00497       d_xi = gsl_vector_get(acttrace-&gt;<a class="code" href="structtracedata.html#aee169f9a7859629a3f3b9e8a58c43a39">xi</a>, i) -  a_0;
<a name="l00498"></a>00498 
<a name="l00499"></a>00499       <span class="comment">// enhance a counter if the offset is within the accepted range</span>
<a name="l00500"></a>00500       <span class="keywordflow">if</span> (d_xi &gt;= lower &amp;&amp; d_xi &lt;= upper)
<a name="l00501"></a>00501         nentries++;
<a name="l00502"></a>00502     }
<a name="l00503"></a>00503 
<a name="l00504"></a>00504   <span class="comment">// return the number of valid data</span>
<a name="l00505"></a>00505   <span class="keywordflow">return</span> nentries;
<a name="l00506"></a>00506 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a3c08d3f85de2d04b0f383f9beda7447e"></a><!-- doxytag: member="model_utils.c::load_dirobj_img" ref="a3c08d3f85de2d04b0f383f9beda7447e" args="(const object *actobject, fits_access *modim_access)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdirobject.html">dirobject</a>* load_dirobj_img </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structobject.html">object</a> *&nbsp;</td>
          <td class="paramname"> <em>actobject</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structfits__access.html">fits_access</a> *&nbsp;</td>
          <td class="paramname"> <em>modim_access</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Function: load_dirobj_img</p>
<p>Returns: </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>diremission - a direct emission model </dd></dl>

<p><div class="fragment"><pre class="fragment"><a name="l01014"></a>01014 {
<a name="l01015"></a>01015         <span class="keywordtype">int</span> modimg;
<a name="l01016"></a>01016 
<a name="l01017"></a>01017         <a class="code" href="structdirobject.html">dirobject</a>      *actdir=NULL;
<a name="l01018"></a>01018         gsl_vector     *extention;
<a name="l01019"></a>01019         <a class="code" href="structdirim__emission.html">dirim_emission</a> *diremission=NULL;
<a name="l01020"></a>01020 
<a name="l01021"></a>01021         <span class="keywordtype">int</span> nrel;
<a name="l01022"></a>01022         <span class="keywordtype">int</span> hdutype;
<a name="l01023"></a>01023         <span class="keywordtype">int</span> f_status=0;
<a name="l01024"></a>01024 
<a name="l01025"></a>01025         <span class="comment">// get the index where to get the model</span>
<a name="l01026"></a>01026         modimg = actobject-&gt;<a class="code" href="structobject.html#ad643757142781f8265b430e19700cfe5">beams</a>[0].<a class="code" href="structbeam.html#a343c47194d158bcc217a46923038e1a3">modimage</a>;
<a name="l01027"></a>01027         <a class="code" href="specmodel__utils_8c.html#a90fff582cc9236b1457b8c9b757420a3">move_in_fits</a>(modim_access, modimg);
<a name="l01028"></a>01028 
<a name="l01029"></a>01029         <span class="comment">// allocate memory for the return structure</span>
<a name="l01030"></a>01030         actdir = (<a class="code" href="structdirobject.html">dirobject</a> *) malloc(<span class="keyword">sizeof</span>(<a class="code" href="structdirobject.html">dirobject</a>));
<a name="l01031"></a>01031         <span class="keywordflow">if</span> (actdir == NULL)
<a name="l01032"></a>01032                 <a class="code" href="aXe__errors_8c.html#a7ef7588e5f91237ba7ce4084e6ed3c11">aXe_message</a> (<a class="code" href="aXe__errors_8h.html#a2556a67874555249b07691c37aa6d6e9">aXe_M_FATAL</a>, __FILE__, __LINE__,
<a name="l01033"></a>01033                                 <span class="stringliteral">&quot;load_dirobj_img:&quot;</span> <span class="stringliteral">&quot; Could not allocate&quot;</span>
<a name="l01034"></a>01034                                 <span class="stringliteral">&quot; memory for a dirobject object!&quot;</span>);
<a name="l01035"></a>01035 
<a name="l01036"></a>01036         <span class="comment">// allocate memory for the dirim structure</span>
<a name="l01037"></a>01037         diremission = (<a class="code" href="structdirim__emission.html">dirim_emission</a> *) malloc(<span class="keyword">sizeof</span>(<a class="code" href="structdirim__emission.html">dirim_emission</a>));
<a name="l01038"></a>01038         <span class="keywordflow">if</span> (diremission == NULL)
<a name="l01039"></a>01039                 <a class="code" href="aXe__errors_8c.html#a7ef7588e5f91237ba7ce4084e6ed3c11">aXe_message</a> (<a class="code" href="aXe__errors_8h.html#a2556a67874555249b07691c37aa6d6e9">aXe_M_FATAL</a>, __FILE__, __LINE__,
<a name="l01040"></a>01040                                 <span class="stringliteral">&quot;load_dirobj_img:&quot;</span> <span class="stringliteral">&quot; Could not allocate&quot;</span>
<a name="l01041"></a>01041                                 <span class="stringliteral">&quot; memory for a dirim_emission object!&quot;</span>);
<a name="l01042"></a>01042 
<a name="l01043"></a>01043         <span class="comment">// load the image from the FITS file</span>
<a name="l01044"></a>01044         diremission-&gt;<a class="code" href="structdirim__emission.html#a8ae8f988a0ad5d4dd23c294c59e81e0e">modimage</a> = <a class="code" href="aXe__utils_8c.html#afdee57669eb437afcad30e96223b48a2">FITSHDU_to_gsl</a>(modim_access-&gt;<a class="code" href="structfits__access.html#af606a81f066e75230aa061386ddede21">fits_file</a>, modim_access-&gt;<a class="code" href="structfits__access.html#afdf355de50df0d99e3186ad2fddcd2b6">fits_ptr</a>, 1);
<a name="l01045"></a>01045 
<a name="l01046"></a>01046         <span class="comment">// transfer the image dimension</span>
<a name="l01047"></a>01047         diremission-&gt;<a class="code" href="structdirim__emission.html#a4184a616a68e4d92efee811168b9ab7e">dim_x</a> = (int)diremission-&gt;<a class="code" href="structdirim__emission.html#a8ae8f988a0ad5d4dd23c294c59e81e0e">modimage</a>-&gt;size1;
<a name="l01048"></a>01048         diremission-&gt;<a class="code" href="structdirim__emission.html#a9b3ba1b1264aaae084c69f290f6343e3">dim_y</a> = (<span class="keywordtype">int</span>)diremission-&gt;<a class="code" href="structdirim__emission.html#a8ae8f988a0ad5d4dd23c294c59e81e0e">modimage</a>-&gt;size2;
<a name="l01049"></a>01049 
<a name="l01050"></a>01050         <span class="comment">// compute and store the mean image coordinates</span>
<a name="l01051"></a>01051         diremission-&gt;<a class="code" href="structdirim__emission.html#a57c2f8cf6dfc3ede582b40f8a63e3eec">xmean</a> = (float)(diremission-&gt;<a class="code" href="structdirim__emission.html#a4184a616a68e4d92efee811168b9ab7e">dim_x</a>-1) / 2.0;
<a name="l01052"></a>01052         diremission-&gt;<a class="code" href="structdirim__emission.html#a95dcd0f591805409a5667874e771597e">ymean</a> = (float)(diremission-&gt;<a class="code" href="structdirim__emission.html#a9b3ba1b1264aaae084c69f290f6343e3">dim_y</a>-1) / 2.0;
<a name="l01053"></a>01053 
<a name="l01054"></a>01054         <span class="comment">// transfer refpoint and ID</span>
<a name="l01055"></a>01055         actdir-&gt;<a class="code" href="structdirobject.html#ac7f75c9d3cdd6d50adc84ec001beee5b">ID</a> = actobject-&gt;<a class="code" href="structobject.html#a8575880bdfc1c0bf44914b4efd2665bf">ID</a>;
<a name="l01056"></a>01056         actdir-&gt;<a class="code" href="structdirobject.html#a66ec2727d2a5269c84804a89626834fa">refpoint</a>.<a class="code" href="structd__point.html#a922a3b5d82a119168ba85e5f939d02c3">x</a> = actobject-&gt;<a class="code" href="structobject.html#ad643757142781f8265b430e19700cfe5">beams</a>[0].<a class="code" href="structbeam.html#a54c64670a8b3e8732c1468d156ddb0ca">refpoint</a>.<a class="code" href="structd__point.html#a922a3b5d82a119168ba85e5f939d02c3">x</a>;
<a name="l01057"></a>01057         actdir-&gt;<a class="code" href="structdirobject.html#a66ec2727d2a5269c84804a89626834fa">refpoint</a>.<a class="code" href="structd__point.html#ad9846a025508bf8873a501ca5fcefbf4">y</a> = actobject-&gt;<a class="code" href="structobject.html#ad643757142781f8265b430e19700cfe5">beams</a>[0].<a class="code" href="structbeam.html#a54c64670a8b3e8732c1468d156ddb0ca">refpoint</a>.<a class="code" href="structd__point.html#ad9846a025508bf8873a501ca5fcefbf4">y</a>;
<a name="l01058"></a>01058 
<a name="l01059"></a>01059         <span class="comment">// get the extentions on the reference points</span>
<a name="l01060"></a>01060         extention = <a class="code" href="model__utils_8c.html#a5b20290920148fb8fb75adb149a94f6d">get_refpoint_ranges</a>(actobject);
<a name="l01061"></a>01061 
<a name="l01062"></a>01062         <span class="comment">// derive and store min/max in x/y for the corners</span>
<a name="l01063"></a>01063         actdir-&gt;<a class="code" href="structdirobject.html#ac068f35c585eec4cd1e5d3392c2dd698">ix_min</a> = (int)floor(actobject-&gt;<a class="code" href="structobject.html#ad643757142781f8265b430e19700cfe5">beams</a>[0].<a class="code" href="structbeam.html#a54c64670a8b3e8732c1468d156ddb0ca">refpoint</a>.<a class="code" href="structd__point.html#a922a3b5d82a119168ba85e5f939d02c3">x</a> - diremission-&gt;<a class="code" href="structdirim__emission.html#a57c2f8cf6dfc3ede582b40f8a63e3eec">xmean</a> + gsl_vector_get(extention, 0) + 0.5);
<a name="l01064"></a>01064         actdir-&gt;<a class="code" href="structdirobject.html#ac8c6104f2c2e1384c64bba61ecf40d69">ix_max</a> = (int)floor(actobject-&gt;<a class="code" href="structobject.html#ad643757142781f8265b430e19700cfe5">beams</a>[0].<a class="code" href="structbeam.html#a54c64670a8b3e8732c1468d156ddb0ca">refpoint</a>.<a class="code" href="structd__point.html#a922a3b5d82a119168ba85e5f939d02c3">x</a> + diremission-&gt;<a class="code" href="structdirim__emission.html#a57c2f8cf6dfc3ede582b40f8a63e3eec">xmean</a> + gsl_vector_get(extention, 1) + 0.5);
<a name="l01065"></a>01065         actdir-&gt;<a class="code" href="structdirobject.html#af24c9a92fa18516591e43d96eec13272">iy_min</a> = (int)floor(actobject-&gt;<a class="code" href="structobject.html#ad643757142781f8265b430e19700cfe5">beams</a>[0].<a class="code" href="structbeam.html#a54c64670a8b3e8732c1468d156ddb0ca">refpoint</a>.<a class="code" href="structd__point.html#ad9846a025508bf8873a501ca5fcefbf4">y</a> - diremission-&gt;<a class="code" href="structdirim__emission.html#a95dcd0f591805409a5667874e771597e">ymean</a> + gsl_vector_get(extention, 2) + 0.5);
<a name="l01066"></a>01066         actdir-&gt;<a class="code" href="structdirobject.html#a3b36973dd52d158c059bfe6587a04244">iy_max</a> = (int)floor(actobject-&gt;<a class="code" href="structobject.html#ad643757142781f8265b430e19700cfe5">beams</a>[0].<a class="code" href="structbeam.html#a54c64670a8b3e8732c1468d156ddb0ca">refpoint</a>.<a class="code" href="structd__point.html#ad9846a025508bf8873a501ca5fcefbf4">y</a> + diremission-&gt;<a class="code" href="structdirim__emission.html#a95dcd0f591805409a5667874e771597e">ymean</a> + gsl_vector_get(extention, 3) + 0.5);
<a name="l01067"></a>01067 
<a name="l01068"></a>01068         <span class="comment">// fix the drizzle scale, since it has no</span>
<a name="l01069"></a>01069         <span class="comment">// business in this context</span>
<a name="l01070"></a>01070         actdir-&gt;<a class="code" href="structdirobject.html#a1e61e87181abdea5dab21eb1dc3564dc">drzscale</a>.<a class="code" href="structd__point.html#a922a3b5d82a119168ba85e5f939d02c3">x</a> = 1.0;
<a name="l01071"></a>01071         actdir-&gt;<a class="code" href="structdirobject.html#a1e61e87181abdea5dab21eb1dc3564dc">drzscale</a>.<a class="code" href="structd__point.html#ad9846a025508bf8873a501ca5fcefbf4">y</a> = 1.0;
<a name="l01072"></a>01072 
<a name="l01073"></a>01073         <span class="comment">// store the direct emission</span>
<a name="l01074"></a>01074         <span class="comment">// object in the direct object</span>
<a name="l01075"></a>01075         actdir-&gt;<a class="code" href="structdirobject.html#a484dadbe6f9bdade97aa303366b4ef6a">dirim</a> = diremission;
<a name="l01076"></a>01076 
<a name="l01077"></a>01077         <span class="comment">// free the memory for the vector</span>
<a name="l01078"></a>01078         gsl_vector_free(extention);
<a name="l01079"></a>01079 
<a name="l01080"></a>01080         <span class="comment">// return the structure</span>
<a name="l01081"></a>01081         <span class="keywordflow">return</span> actdir;
<a name="l01082"></a>01082 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="adee63ef5db37c64dcdd2288a4cff5113"></a><!-- doxytag: member="model_utils.c::load_spectrum" ref="adee63ef5db37c64dcdd2288a4cff5113" args="(const object *actobject, dirobject *actdir, fits_access *m_access, const int int_type)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void load_spectrum </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structobject.html">object</a> *&nbsp;</td>
          <td class="paramname"> <em>actobject</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdirobject.html">dirobject</a> *&nbsp;</td>
          <td class="paramname"> <em>actdir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structfits__access.html">fits_access</a> *&nbsp;</td>
          <td class="paramname"> <em>m_access</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>int_type</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Function: load_spectrum</p>
<p>Parameters: </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>actobject</em>&nbsp;</td><td>- the <a class="el" href="structobject.html">object</a> to be transformed </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>actdir</em>&nbsp;</td><td>- the <a class="el" href="structdirobject.html">dirobject</a> to store the flux values in </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>m_access</em>&nbsp;</td><td>- the model acces structure </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>int_type</em>&nbsp;</td><td>- the interpolation type to be used </td></tr>
  </table>
  </dd>
</dl>

<p><div class="fragment"><pre class="fragment"><a name="l01268"></a>01268 {
<a name="l01269"></a>01269   <a class="code" href="structenergy__distrib.html">energy_distrib</a> *sed=NULL;
<a name="l01270"></a>01270 
<a name="l01271"></a>01271   <a class="code" href="structbeam.html">beam</a> onebeam;
<a name="l01272"></a>01272 
<a name="l01273"></a>01273   <span class="keywordtype">int</span> j = 0;
<a name="l01274"></a>01274 
<a name="l01275"></a>01275   <span class="comment">// the data are derived from the 1st non-zero beam in the object;</span>
<a name="l01276"></a>01276   <span class="comment">// go along the beams util you find a non-zero beam</span>
<a name="l01277"></a>01277   <span class="keywordflow">while</span> (actobject-&gt;<a class="code" href="structobject.html#ad643757142781f8265b430e19700cfe5">beams</a>[j].<a class="code" href="structbeam.html#a199b010e935235ef70f482416d113458">flux</a> == NULL &amp;&amp; j &lt; actobject-&gt;nbeams)
<a name="l01278"></a>01278     j++;
<a name="l01279"></a>01279 
<a name="l01280"></a>01280   <span class="comment">// store this beam</span>
<a name="l01281"></a>01281   onebeam = actobject-&gt;<a class="code" href="structobject.html#ad643757142781f8265b430e19700cfe5">beams</a>[j];
<a name="l01282"></a>01282 
<a name="l01283"></a>01283   <span class="comment">// do something only if the first beam has flux values</span>
<a name="l01284"></a>01284   <span class="keywordflow">if</span> (onebeam.<a class="code" href="structbeam.html#a199b010e935235ef70f482416d113458">flux</a> != NULL &amp;&amp; j &lt; actobject-&gt;nbeams)
<a name="l01285"></a>01285     {
<a name="l01286"></a>01286 
<a name="l01287"></a>01287       <span class="keywordflow">if</span> (onebeam.<a class="code" href="structbeam.html#a60879dd4cb05dff92646b26f0b1ca8d8">modspec</a> &gt; 0 &amp;&amp; m_access)
<a name="l01288"></a>01288         {
<a name="l01289"></a>01289           <span class="comment">// get the model spectrum</span>
<a name="l01290"></a>01290           sed = <a class="code" href="specmodel__utils_8c.html#ab0006ea759b7141dcec257eba61910e2">load_model_sed</a>(m_access, onebeam.<a class="code" href="structbeam.html#a60879dd4cb05dff92646b26f0b1ca8d8">modspec</a>);
<a name="l01291"></a>01291 
<a name="l01292"></a>01292           <span class="comment">// mark that the SED does NOT come</span>
<a name="l01293"></a>01293           <span class="comment">// from broad band colours</span>
<a name="l01294"></a>01294           actdir-&gt;<a class="code" href="structdirobject.html#a8fe8b9502f2baafd4ea433cb8f6acaa9">bb_sed</a>=0;
<a name="l01295"></a>01295         }
<a name="l01296"></a>01296       <span class="keywordflow">else</span>
<a name="l01297"></a>01297         {
<a name="l01298"></a>01298 
<a name="l01299"></a>01299           <span class="comment">// get the model spectrum from broad band colours</span>
<a name="l01300"></a>01300           sed = <a class="code" href="model__utils_8c.html#a6b478169411f67ce4c7702fa7815b445">make_sed_from_beam</a>(onebeam, int_type, actobject-&gt;<a class="code" href="structobject.html#a8575880bdfc1c0bf44914b4efd2665bf">ID</a>);
<a name="l01301"></a>01301 
<a name="l01302"></a>01302           <span class="comment">// mark that the SED DOES come</span>
<a name="l01303"></a>01303           <span class="comment">// from broad band colours</span>
<a name="l01304"></a>01304           actdir-&gt;<a class="code" href="structdirobject.html#a8fe8b9502f2baafd4ea433cb8f6acaa9">bb_sed</a>=1;
<a name="l01305"></a>01305         }
<a name="l01306"></a>01306     }
<a name="l01307"></a>01307   <span class="keywordflow">else</span>
<a name="l01308"></a>01308     {
<a name="l01309"></a>01309       <span class="comment">// make an error if there are no flux values</span>
<a name="l01310"></a>01310       <a class="code" href="aXe__errors_8c.html#a7ef7588e5f91237ba7ce4084e6ed3c11">aXe_message</a>(<a class="code" href="aXe__errors_8h.html#a2556a67874555249b07691c37aa6d6e9">aXe_M_FATAL</a>, __FILE__, __LINE__,
<a name="l01311"></a>01311                   <span class="stringliteral">&quot;aXe_PETCONT: &quot;</span> <span class="stringliteral">&quot;the OAF does not have flux values\n&quot;</span>);
<a name="l01312"></a>01312     }
<a name="l01313"></a>01313 
<a name="l01314"></a>01314   <span class="comment">// transfer the SED object to the direct object</span>
<a name="l01315"></a>01315   actdir-&gt;<a class="code" href="structdirobject.html#a79645e83aebf3988bd3464b2079d24c1">SED</a> = sed;
<a name="l01316"></a>01316 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a6b478169411f67ce4c7702fa7815b445"></a><!-- doxytag: member="model_utils.c::make_sed_from_beam" ref="a6b478169411f67ce4c7702fa7815b445" args="(const beam onebeam, const int int_type, const int objID)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structenergy__distrib.html">energy_distrib</a>* make_sed_from_beam </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structbeam.html">beam</a>&nbsp;</td>
          <td class="paramname"> <em>onebeam</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>int_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>objID</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Function: make_sed_from_beam</p>
<p>Parameters: </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>onebeam</em>&nbsp;</td><td>- the <a class="el" href="structobject.html">object</a> to be transformed </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>int_type</em>&nbsp;</td><td>- the interpolation type to be used </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>objID</em>&nbsp;</td><td>- the interpolation type to be used </td></tr>
  </table>
  </dd>
</dl>

<p><div class="fragment"><pre class="fragment"><a name="l01328"></a>01328 {
<a name="l01329"></a>01329   <a class="code" href="structenergy__distrib.html">energy_distrib</a> *sed;
<a name="l01330"></a>01330   <span class="keywordtype">double</span> *sed_wavs;
<a name="l01331"></a>01331   <span class="keywordtype">double</span> *sed_flux;
<a name="l01332"></a>01332 
<a name="l01333"></a>01333   <span class="keywordtype">int</span> nwavs;
<a name="l01334"></a>01334   <span class="keywordtype">int</span> i_type;
<a name="l01335"></a>01335   <span class="keywordtype">int</span> i;
<a name="l01336"></a>01336 
<a name="l01337"></a>01337   <span class="comment">// determine the number of flux values, allocate space</span>
<a name="l01338"></a>01338   nwavs = (onebeam.<a class="code" href="structbeam.html#a199b010e935235ef70f482416d113458">flux</a>-&gt;size)/2;
<a name="l01339"></a>01339 
<a name="l01340"></a>01340   <span class="comment">// determine the number of flux values, allocate space</span>
<a name="l01341"></a>01341   nwavs = (onebeam.<a class="code" href="structbeam.html#a199b010e935235ef70f482416d113458">flux</a>-&gt;size)/2;
<a name="l01342"></a>01342   sed = (<a class="code" href="structenergy__distrib.html">energy_distrib</a>*) malloc(<span class="keyword">sizeof</span>(<a class="code" href="structenergy__distrib.html">energy_distrib</a>));
<a name="l01343"></a>01343   sed_wavs = (<span class="keywordtype">double</span>*) malloc(nwavs*<span class="keyword">sizeof</span>(<span class="keywordtype">double</span>));
<a name="l01344"></a>01344   sed_flux = (<span class="keywordtype">double</span>*) malloc(nwavs*<span class="keyword">sizeof</span>(<span class="keywordtype">double</span>));
<a name="l01345"></a>01345 
<a name="l01346"></a>01346   <span class="comment">// transfer the data into the &apos;local&apos; arrays</span>
<a name="l01347"></a>01347   <span class="keywordflow">for</span> (i=0; i&lt;nwavs; i++)
<a name="l01348"></a>01348     {
<a name="l01349"></a>01349       sed_wavs[i] = gsl_vector_get(onebeam.<a class="code" href="structbeam.html#a199b010e935235ef70f482416d113458">flux</a>, 2*i);
<a name="l01350"></a>01350       sed_flux[i] = gsl_vector_get(onebeam.<a class="code" href="structbeam.html#a199b010e935235ef70f482416d113458">flux</a>, 2*i+1);
<a name="l01351"></a>01351     }
<a name="l01352"></a>01352 
<a name="l01353"></a>01353   <span class="comment">// transfer the vector and length information</span>
<a name="l01354"></a>01354   <span class="comment">// to the SED object</span>
<a name="l01355"></a>01355   sed-&gt;<a class="code" href="structenergy__distrib.html#ae5e24fde4a41b46a8b8510118f646e67">npoints</a>    = nwavs;
<a name="l01356"></a>01356   sed-&gt;<a class="code" href="structenergy__distrib.html#ac32d12647e9ef7f158b0d4532c09a568">wavelength</a> = sed_wavs ;
<a name="l01357"></a>01357   sed-&gt;<a class="code" href="structenergy__distrib.html#a7da8059a7bb2f8af463b6ee1dd1e6554">flux</a>       = sed_flux;
<a name="l01358"></a>01358 
<a name="l01359"></a>01359   <span class="comment">// check the interpolation type</span>
<a name="l01360"></a>01360   i_type = <a class="code" href="model__utils_8c.html#ade00a122791415b1ec8ba98f979bf914">check_interp_type</a>(int_type, nwavs, objID);
<a name="l01361"></a>01361   <span class="keywordflow">if</span> (nwavs &gt; 1)
<a name="l01362"></a>01362     {
<a name="l01363"></a>01363       <span class="comment">// if possible, allocate and</span>
<a name="l01364"></a>01364       <span class="comment">// initialize an interpolation object</span>
<a name="l01365"></a>01365       <span class="keywordflow">if</span> (i_type == 2)
<a name="l01366"></a>01366         sed-&gt;<a class="code" href="structenergy__distrib.html#a3d90efb6bd5ace3c19884613063644af">interp</a>     = gsl_interp_alloc (gsl_interp_polynomial, (<span class="keywordtype">size_t</span>)nwavs);
<a name="l01367"></a>01367       <span class="keywordflow">else</span> <span class="keywordflow">if</span> (i_type == 3)
<a name="l01368"></a>01368         sed-&gt;<a class="code" href="structenergy__distrib.html#a3d90efb6bd5ace3c19884613063644af">interp</a>     = gsl_interp_alloc (gsl_interp_cspline, (<span class="keywordtype">size_t</span>)nwavs);
<a name="l01369"></a>01369       <span class="keywordflow">else</span>
<a name="l01370"></a>01370         sed-&gt;<a class="code" href="structenergy__distrib.html#a3d90efb6bd5ace3c19884613063644af">interp</a>     = gsl_interp_alloc (gsl_interp_linear, (<span class="keywordtype">size_t</span>)nwavs);
<a name="l01371"></a>01371 
<a name="l01372"></a>01372       sed-&gt;<a class="code" href="structenergy__distrib.html#a7d0d556a145bd34158514bdbab57b0ee">accel</a>      = gsl_interp_accel_alloc ();
<a name="l01373"></a>01373       gsl_interp_init (sed-&gt;<a class="code" href="structenergy__distrib.html#a3d90efb6bd5ace3c19884613063644af">interp</a>, sed-&gt;<a class="code" href="structenergy__distrib.html#ac32d12647e9ef7f158b0d4532c09a568">wavelength</a>, sed-&gt;<a class="code" href="structenergy__distrib.html#a7da8059a7bb2f8af463b6ee1dd1e6554">flux</a>, (<span class="keywordtype">size_t</span>)sed-&gt;<a class="code" href="structenergy__distrib.html#ae5e24fde4a41b46a8b8510118f646e67">npoints</a>);
<a name="l01374"></a>01374     }
<a name="l01375"></a>01375   <span class="keywordflow">else</span>
<a name="l01376"></a>01376     {
<a name="l01377"></a>01377       <span class="comment">// if no interpolation, set</span>
<a name="l01378"></a>01378       <span class="comment">// the memeber to NULL</span>
<a name="l01379"></a>01379       sed-&gt;<a class="code" href="structenergy__distrib.html#a3d90efb6bd5ace3c19884613063644af">interp</a> = NULL;
<a name="l01380"></a>01380       sed-&gt;<a class="code" href="structenergy__distrib.html#a7d0d556a145bd34158514bdbab57b0ee">accel</a>  = NULL;
<a name="l01381"></a>01381     }
<a name="l01382"></a>01382 
<a name="l01383"></a>01383   <span class="comment">// return the sed</span>
<a name="l01384"></a>01384   <span class="keywordflow">return</span> sed;
<a name="l01385"></a>01385 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="aa166b220ec60f701d55d841950dc269a"></a><!-- doxytag: member="model_utils.c::model_gauss_dirim" ref="aa166b220ec60f701d55d841950dc269a" args="(dirobject *actdir, beam actbeam, aperture_conf *conf, double psf_offset)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdirim__emission.html">dirim_emission</a>* model_gauss_dirim </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdirobject.html">dirobject</a> *&nbsp;</td>
          <td class="paramname"> <em>actdir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbeam.html">beam</a>&nbsp;</td>
          <td class="paramname"> <em>actbeam</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structaperture__conf.html">aperture_conf</a> *&nbsp;</td>
          <td class="paramname"> <em>conf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>psf_offset</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><div class="fragment"><pre class="fragment"><a name="l00039"></a>00039 {
<a name="l00040"></a>00040   <span class="keywordtype">int</span> nx, ny;
<a name="l00041"></a>00041   <span class="keywordtype">int</span> ii, jj;
<a name="l00042"></a>00042 
<a name="l00043"></a>00043   <span class="keywordtype">double</span> sval=0.0;
<a name="l00044"></a>00044 
<a name="l00045"></a>00045   <a class="code" href="structd__point.html">d_point</a> dpixel;
<a name="l00046"></a>00046 
<a name="l00047"></a>00047   <a class="code" href="structdirim__emission.html">dirim_emission</a> *gauss_dirim = NULL;
<a name="l00048"></a>00048 
<a name="l00049"></a>00049   <span class="comment">// check whether something can be done</span>
<a name="l00050"></a>00050   <span class="keywordflow">if</span> (actdir-&gt;<a class="code" href="structdirobject.html#a484dadbe6f9bdade97aa303366b4ef6a">dirim</a> || (conf-&gt;<a class="code" href="structaperture__conf.html#a904a154040bedf410b669b65791c96e2">psfcoeffs</a> &amp;&amp; conf-&gt;<a class="code" href="structaperture__conf.html#a469dc826e363a3b9e340aa99824e2f30">psfrange</a>) || psf_offset)
<a name="l00051"></a>00051           <span class="comment">// return NULL if not</span>
<a name="l00052"></a>00052           <span class="keywordflow">return</span> NULL;
<a name="l00053"></a>00053 
<a name="l00054"></a>00054   <span class="comment">// dimension the new matrix;</span>
<a name="l00055"></a>00055   <span class="comment">// leave one border row more</span>
<a name="l00056"></a>00056   nx = actdir-&gt;<a class="code" href="structdirobject.html#ac8c6104f2c2e1384c64bba61ecf40d69">ix_max</a> - actdir-&gt;<a class="code" href="structdirobject.html#ac068f35c585eec4cd1e5d3392c2dd698">ix_min</a> + 3;
<a name="l00057"></a>00057   ny = actdir-&gt;<a class="code" href="structdirobject.html#a3b36973dd52d158c059bfe6587a04244">iy_max</a> - actdir-&gt;<a class="code" href="structdirobject.html#af24c9a92fa18516591e43d96eec13272">iy_min</a> + 3;
<a name="l00058"></a>00058 
<a name="l00059"></a>00059   <span class="comment">// allocate memory for the structure</span>
<a name="l00060"></a>00060   gauss_dirim = (<a class="code" href="structdirim__emission.html">dirim_emission</a> *) malloc(<span class="keyword">sizeof</span>(<a class="code" href="structdirim__emission.html">dirim_emission</a>));
<a name="l00061"></a>00061 
<a name="l00062"></a>00062   <span class="comment">// load the image in the gsl</span>
<a name="l00063"></a>00063   gauss_dirim-&gt;<a class="code" href="structdirim__emission.html#a8ae8f988a0ad5d4dd23c294c59e81e0e">modimage</a> = <a class="code" href="aXe__grism_8h.html#a1214ab1bea5fd80474d7a27db0bfb429">gsl_matrix_alloc</a>(nx, ny);
<a name="l00064"></a>00064 
<a name="l00065"></a>00065   <span class="comment">// transfer the image dimension</span>
<a name="l00066"></a>00066   gauss_dirim-&gt;<a class="code" href="structdirim__emission.html#a4184a616a68e4d92efee811168b9ab7e">dim_x</a> = (int)gauss_dirim-&gt;<a class="code" href="structdirim__emission.html#a8ae8f988a0ad5d4dd23c294c59e81e0e">modimage</a>-&gt;size1;
<a name="l00067"></a>00067   gauss_dirim-&gt;<a class="code" href="structdirim__emission.html#a9b3ba1b1264aaae084c69f290f6343e3">dim_y</a> = (<span class="keywordtype">int</span>)gauss_dirim-&gt;<a class="code" href="structdirim__emission.html#a8ae8f988a0ad5d4dd23c294c59e81e0e">modimage</a>-&gt;size2;
<a name="l00068"></a>00068 
<a name="l00069"></a>00069   <span class="comment">// compute and store the mean image coordinates</span>
<a name="l00070"></a>00070   gauss_dirim-&gt;<a class="code" href="structdirim__emission.html#a57c2f8cf6dfc3ede582b40f8a63e3eec">xmean</a> = (float)(gauss_dirim-&gt;<a class="code" href="structdirim__emission.html#a4184a616a68e4d92efee811168b9ab7e">dim_x</a>-1) / 2.0;
<a name="l00071"></a>00071   gauss_dirim-&gt;<a class="code" href="structdirim__emission.html#a95dcd0f591805409a5667874e771597e">ymean</a> = (float)(gauss_dirim-&gt;<a class="code" href="structdirim__emission.html#a9b3ba1b1264aaae084c69f290f6343e3">dim_y</a>-1) / 2.0;
<a name="l00072"></a>00072 
<a name="l00073"></a>00073   <span class="comment">// go over all pixels in the area</span>
<a name="l00074"></a>00074   <span class="keywordflow">for</span> (ii=0; ii &lt; gauss_dirim-&gt;<a class="code" href="structdirim__emission.html#a4184a616a68e4d92efee811168b9ab7e">dim_x</a>; ii++)
<a name="l00075"></a>00075     {
<a name="l00076"></a>00076           <span class="keywordflow">for</span> (jj=0; jj &lt; gauss_dirim-&gt;<a class="code" href="structdirim__emission.html#a9b3ba1b1264aaae084c69f290f6343e3">dim_y</a>; jj++)
<a name="l00077"></a>00077             {
<a name="l00078"></a>00078                   <span class="comment">// fill the dpixel structure with the position</span>
<a name="l00079"></a>00079                   <span class="comment">// RELATIVE to the reverence position of the beam</span>
<a name="l00080"></a>00080                   dpixel.<a class="code" href="structd__point.html#a922a3b5d82a119168ba85e5f939d02c3">x</a> = (double)ii - gauss_dirim-&gt;<a class="code" href="structdirim__emission.html#a57c2f8cf6dfc3ede582b40f8a63e3eec">xmean</a> + actbeam.<a class="code" href="structbeam.html#a54c64670a8b3e8732c1468d156ddb0ca">refpoint</a>.<a class="code" href="structd__point.html#a922a3b5d82a119168ba85e5f939d02c3">x</a>;
<a name="l00081"></a>00081                   dpixel.<a class="code" href="structd__point.html#ad9846a025508bf8873a501ca5fcefbf4">y</a> = (<span class="keywordtype">double</span>)jj - gauss_dirim-&gt;<a class="code" href="structdirim__emission.html#a95dcd0f591805409a5667874e771597e">ymean</a> + actbeam.<a class="code" href="structbeam.html#a54c64670a8b3e8732c1468d156ddb0ca">refpoint</a>.<a class="code" href="structd__point.html#ad9846a025508bf8873a501ca5fcefbf4">y</a>;
<a name="l00082"></a>00082 
<a name="l00083"></a>00083                   <span class="comment">// do a subsampling over the pixel</span>
<a name="l00084"></a>00084           <span class="comment">// to get a more appropriate value for the</span>
<a name="l00085"></a>00085           <span class="comment">// emission value</span>
<a name="l00086"></a>00086           sval = <a class="code" href="model__utils_8c.html#a5d8695af668aaed17d349ca4eb36292c">get_sub_emodel_value</a>(dpixel, actbeam, actdir-&gt;<a class="code" href="structdirobject.html#a1e61e87181abdea5dab21eb1dc3564dc">drzscale</a>);
<a name="l00087"></a>00087 
<a name="l00088"></a>00088           <span class="comment">// set the emission value in the matrix</span>
<a name="l00089"></a>00089           <a class="code" href="aXe__grism_8h.html#a1f386ef5cd5a3b916246c2bee80f083a">gsl_matrix_set</a>(gauss_dirim-&gt;<a class="code" href="structdirim__emission.html#a8ae8f988a0ad5d4dd23c294c59e81e0e">modimage</a>, ii, jj, sval);
<a name="l00090"></a>00090 
<a name="l00091"></a>00091             }
<a name="l00092"></a>00092     }
<a name="l00093"></a>00093 
<a name="l00094"></a>00094   <span class="comment">// return the matrix</span>
<a name="l00095"></a>00095   <span class="keywordflow">return</span> gauss_dirim;
<a name="l00096"></a>00096 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ab4a6c2b0e26ff79ca76b2887d670b1df"></a><!-- doxytag: member="model_utils.c::oblist_to_dirlist" ref="ab4a6c2b0e26ff79ca76b2887d670b1df" args="(char grism_file[], char CONF_file[], const px_point npixels, object **oblist, spectral_models *spec_mod, const double model_scale, const int int_type)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdirobject.html">dirobject</a>** oblist_to_dirlist </td>
          <td>(</td>
          <td class="paramtype">char&nbsp;</td>
          <td class="paramname"> <em>grism_file</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&nbsp;</td>
          <td class="paramname"> <em>CONF_file</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structpx__point.html">px_point</a>&nbsp;</td>
          <td class="paramname"> <em>npixels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structobject.html">object</a> **&nbsp;</td>
          <td class="paramname"> <em>oblist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structspectral__models.html">spectral_models</a> *&nbsp;</td>
          <td class="paramname"> <em>spec_mod</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>model_scale</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>int_type</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Function: oblist_to_dirlist Transforms a list of "object"'s into a list of "dirobject"'s. The list of "dirobject"'s is terminated with a NULL-object at the end.</p>
<p>Parameters: </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>grism_file</em>&nbsp;</td><td>- the full path to the grism image </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>CONF_file</em>&nbsp;</td><td>- the full path to the config file </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>npixels</em>&nbsp;</td><td>- the dimension of the grism image </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>oblist</em>&nbsp;</td><td>- the <a class="el" href="structobject.html">object</a> list to start from </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>spec_mod</em>&nbsp;</td><td>- the model spectra </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>model_scale</em>&nbsp;</td><td>- the scale for the size of the direct <a class="el" href="structobject.html">object</a> area </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>int_type</em>&nbsp;</td><td>- interpolation type</td></tr>
  </table>
  </dd>
</dl>
<p>Returns: </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>dirlist - the <a class="el" href="structdirobject.html">dirobject</a> list created </dd></dl>

<p><div class="fragment"><pre class="fragment"><a name="l00692"></a>00692 {
<a name="l00693"></a>00693 
<a name="l00694"></a>00694   <a class="code" href="structdirobject.html">dirobject</a> **dirlist;
<a name="l00695"></a>00695   <a class="code" href="structaperture__conf.html">aperture_conf</a> *conf;
<a name="l00696"></a>00696   <a class="code" href="aXe__grism_8h.html#a6117e17bb3108107676f4486e62d40e5">gsl_matrix</a> *drzcoeffs;
<a name="l00697"></a>00697 
<a name="l00698"></a>00698   <span class="keywordtype">int</span> nobjects=0;
<a name="l00699"></a>00699   <span class="keywordtype">int</span> i=0;
<a name="l00700"></a>00700   <span class="keywordtype">int</span> j=0;
<a name="l00701"></a>00701   <span class="keywordtype">int</span> beamID;
<a name="l00702"></a>00702   <span class="keywordtype">int</span> max_offs;
<a name="l00703"></a>00703 
<a name="l00704"></a>00704   <span class="comment">// load the configuration file</span>
<a name="l00705"></a>00705   conf = <a class="code" href="aper__conf_8c.html#a45d84f2fc00f438b5da9054c45b7736c">get_aperture_descriptor</a> (CONF_file);
<a name="l00706"></a>00706 
<a name="l00707"></a>00707   <span class="comment">// load the extension numbers</span>
<a name="l00708"></a>00708   <a class="code" href="aper__conf_8c.html#aa1383c872a0151435880f6ad28f9bd88">get_extension_numbers</a>(grism_file, conf,conf-&gt;<a class="code" href="structaperture__conf.html#a730cc39bb91c34d0dfe92977cb2aaf46">optkey1</a>,conf-&gt;<a class="code" href="structaperture__conf.html#a6b84a9e8edd79d020ea2e189839d86ba">optval1</a>);
<a name="l00709"></a>00709 
<a name="l00710"></a>00710   <span class="comment">// get the  matrix with the drizzle coefficients</span>
<a name="l00711"></a>00711   drzcoeffs = <a class="code" href="crossdisp__utils_8c.html#a24fed0f1bc1490134a2c5c5baaee6ad5">get_crossdisp_matrix</a>(grism_file, conf-&gt;<a class="code" href="structaperture__conf.html#abe36ba97113a8ccb1916acdbe5db113f">science_numext</a>);
<a name="l00712"></a>00712   <span class="keywordflow">if</span> (drzcoeffs-&gt;size1 &lt; 2 || !drzcoeffs-&gt;size2)
<a name="l00713"></a>00713     <a class="code" href="aXe__errors_8c.html#a7ef7588e5f91237ba7ce4084e6ed3c11">aXe_message</a> (<a class="code" href="aXe__errors_8h.html#a2556a67874555249b07691c37aa6d6e9">aXe_M_FATAL</a>, __FILE__, __LINE__,
<a name="l00714"></a>00714                  <span class="stringliteral">&quot;oblist_to_dirlist:&quot;</span> <span class="stringliteral">&quot; Could not get&quot;</span>
<a name="l00715"></a>00715                  <span class="stringliteral">&quot; the drizzle coefficients in file: %s\n&quot;</span>, grism_file);
<a name="l00716"></a>00716 
<a name="l00717"></a>00717   <span class="comment">// determine an offset from the PSF_OFFSET</span>
<a name="l00718"></a>00718   max_offs = (int)ceil(<a class="code" href="aper__conf_8c.html#a63e3b3bf0beebc0fe4677687d96b85df">get_max_offset</a>(conf));
<a name="l00719"></a>00719 
<a name="l00720"></a>00720   <span class="comment">// determine the number of objects in the object list</span>
<a name="l00721"></a>00721   nobjects = <a class="code" href="inout__aper_8c.html#aa4bd812673400180537c7ea98650d3fe">object_list_size</a>(oblist);
<a name="l00722"></a>00722 
<a name="l00723"></a>00723   <span class="comment">// allocate space for the dirobject list</span>
<a name="l00724"></a>00724   dirlist = (<a class="code" href="structdirobject.html">dirobject</a> **) malloc((nobjects+1) * <span class="keyword">sizeof</span>(<a class="code" href="structdirobject.html">dirobject</a> *));
<a name="l00725"></a>00725   <span class="keywordflow">if</span> (dirlist == NULL)
<a name="l00726"></a>00726     <a class="code" href="aXe__errors_8c.html#a7ef7588e5f91237ba7ce4084e6ed3c11">aXe_message</a> (<a class="code" href="aXe__errors_8h.html#a2556a67874555249b07691c37aa6d6e9">aXe_M_FATAL</a>, __FILE__, __LINE__,
<a name="l00727"></a>00727                  <span class="stringliteral">&quot;oblist_to_dirlist:&quot;</span> <span class="stringliteral">&quot; Could not allocate&quot;</span>
<a name="l00728"></a>00728                  <span class="stringliteral">&quot; memory for pointers to %i dirobject objects&quot;</span>, nobjects+1);
<a name="l00729"></a>00729 
<a name="l00730"></a>00730   <span class="comment">// loop over all objectsconfig-&gt;camera</span>
<a name="l00731"></a>00731   <span class="keywordflow">for</span> (i = 0; i &lt; nobjects; i++)
<a name="l00732"></a>00732     {
<a name="l00733"></a>00733       <span class="comment">// make sure that there are beams in the object</span>
<a name="l00734"></a>00734       <span class="keywordflow">if</span> (oblist[i]-&gt;nbeams &gt; 0)
<a name="l00735"></a>00735         {
<a name="l00736"></a>00736           <span class="comment">// create a dirobject for each object</span>
<a name="l00737"></a>00737           dirlist[j] = <a class="code" href="model__utils_8c.html#ae01b7359b803f5823de49af7ba8de948">fill_dirobject</a>(oblist[i], npixels, drzcoeffs, model_scale, max_offs);
<a name="l00738"></a>00738           <a class="code" href="model__utils_8c.html#a5cd967f1d7c4d8c89f52a7cd3d6b4f81">fill_spectrum</a>(oblist[i], dirlist[j], spec_mod, int_type);
<a name="l00739"></a>00739           <span class="comment">//      fill_dpsf_function(conf, dirlist[j]);</span>
<a name="l00740"></a>00740 
<a name="l00741"></a>00741           <span class="comment">// fill the xoffset and yoffset values.</span>
<a name="l00742"></a>00742           <span class="comment">// within the gaussian models they are dummys.</span>
<a name="l00743"></a>00743           <span class="keywordflow">for</span> (beamID=0; beamID &lt; conf-&gt;<a class="code" href="structaperture__conf.html#af53b09fa4f86ff116c002640c3e817d9">nbeams</a>; beamID++)
<a name="l00744"></a>00744             {
<a name="l00745"></a>00745               dirlist[j]-&gt;<a class="code" href="structdirobject.html#a804b505c34bbecd0eb09832e34cbd5ce">xy_off</a>[beamID].<a class="code" href="structd__point.html#a922a3b5d82a119168ba85e5f939d02c3">x</a> = 0.0;
<a name="l00746"></a>00746               dirlist[j]-&gt;<a class="code" href="structdirobject.html#a804b505c34bbecd0eb09832e34cbd5ce">xy_off</a>[beamID].<a class="code" href="structd__point.html#ad9846a025508bf8873a501ca5fcefbf4">y</a> = 0.0;
<a name="l00747"></a>00747             }
<a name="l00748"></a>00748           j++;
<a name="l00749"></a>00749         }
<a name="l00750"></a>00750     }
<a name="l00751"></a>00751 
<a name="l00752"></a>00752   <span class="comment">// terminate the dirobject list with NULL</span>
<a name="l00753"></a>00753   dirlist[j] = NULL;
<a name="l00754"></a>00754 
<a name="l00755"></a>00755   <span class="comment">// release the memory for the drizzle matrix</span>
<a name="l00756"></a>00756   <a class="code" href="aXe__grism_8h.html#a61aa1d37853a90711852146f18d0b85f">gsl_matrix_free</a>(drzcoeffs);
<a name="l00757"></a>00757 
<a name="l00758"></a>00758   <a class="code" href="aper__conf_8c.html#a608428f59a2adb25874101610cd6afe4">free_aperture_conf</a>(conf);
<a name="l00759"></a>00759 
<a name="l00760"></a>00760   <span class="keywordflow">return</span> dirlist;
<a name="l00761"></a>00761 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a763b05dcf96d0f69417a38f7bf0a61da"></a><!-- doxytag: member="model_utils.c::oblist_to_dirlist2" ref="a763b05dcf96d0f69417a38f7bf0a61da" args="(char grism_file[], char CONF_file[], const px_point npixels, object **oblist, spectral_models *spec_mod, object_models *obj_mod, const double model_scale, const int int_type)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdirobject.html">dirobject</a>** oblist_to_dirlist2 </td>
          <td>(</td>
          <td class="paramtype">char&nbsp;</td>
          <td class="paramname"> <em>grism_file</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&nbsp;</td>
          <td class="paramname"> <em>CONF_file</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structpx__point.html">px_point</a>&nbsp;</td>
          <td class="paramname"> <em>npixels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structobject.html">object</a> **&nbsp;</td>
          <td class="paramname"> <em>oblist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structspectral__models.html">spectral_models</a> *&nbsp;</td>
          <td class="paramname"> <em>spec_mod</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structobject__models.html">object_models</a> *&nbsp;</td>
          <td class="paramname"> <em>obj_mod</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>model_scale</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>int_type</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Function: oblist_to_dirlist2 Transforms a list of "object"'s into a list of "dirobject"'s. The list of "dirobject"'s is terminated with a NULL-object at the end.</p>
<p>Parameters: </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>grism_file</em>&nbsp;</td><td>- the full path to the grism image </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>CONF_file</em>&nbsp;</td><td>- the full path to the config file </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>npixels</em>&nbsp;</td><td>- the dimension of the grism image </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>oblist</em>&nbsp;</td><td>- the <a class="el" href="structobject.html">object</a> list to start from </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>spec_mod</em>&nbsp;</td><td>- the model spectra </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>obj_mod</em>&nbsp;</td><td>- te direct emission models </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>model_scale</em>&nbsp;</td><td>- the scale for the size of the direct <a class="el" href="structobject.html">object</a> area </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>int_type</em>&nbsp;</td><td>- interpolation type</td></tr>
  </table>
  </dd>
</dl>
<p>Returns: </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>dirlist - the <a class="el" href="structdirobject.html">dirobject</a> list created </dd></dl>

<p><div class="fragment"><pre class="fragment"><a name="l00786"></a>00786 {
<a name="l00787"></a>00787 
<a name="l00788"></a>00788   <a class="code" href="structdirobject.html">dirobject</a>     **dirlist;
<a name="l00789"></a>00789   <a class="code" href="structaperture__conf.html">aperture_conf</a>  *conf;
<a name="l00790"></a>00790   <a class="code" href="aXe__grism_8h.html#a6117e17bb3108107676f4486e62d40e5">gsl_matrix</a>     *drzcoeffs;
<a name="l00791"></a>00791 
<a name="l00792"></a>00792   <span class="keywordtype">int</span> nobjects=0;
<a name="l00793"></a>00793   <span class="keywordtype">int</span> i=0;
<a name="l00794"></a>00794   <span class="keywordtype">int</span> j=0;
<a name="l00795"></a>00795   <span class="keywordtype">int</span> beamID;
<a name="l00796"></a>00796   <span class="keywordtype">int</span> max_offs;
<a name="l00797"></a>00797 
<a name="l00798"></a>00798   <span class="comment">// load the configuration file</span>
<a name="l00799"></a>00799   conf = <a class="code" href="aper__conf_8c.html#a45d84f2fc00f438b5da9054c45b7736c">get_aperture_descriptor</a> (CONF_file);
<a name="l00800"></a>00800 
<a name="l00801"></a>00801   <span class="comment">// load the extension numbers</span>
<a name="l00802"></a>00802   <a class="code" href="aper__conf_8c.html#aa1383c872a0151435880f6ad28f9bd88">get_extension_numbers</a>(grism_file, conf,conf-&gt;<a class="code" href="structaperture__conf.html#a730cc39bb91c34d0dfe92977cb2aaf46">optkey1</a>,conf-&gt;<a class="code" href="structaperture__conf.html#a6b84a9e8edd79d020ea2e189839d86ba">optval1</a>);
<a name="l00803"></a>00803 
<a name="l00804"></a>00804   <span class="comment">// get the  matrix with the drizzle coefficients</span>
<a name="l00805"></a>00805   drzcoeffs = <a class="code" href="crossdisp__utils_8c.html#a24fed0f1bc1490134a2c5c5baaee6ad5">get_crossdisp_matrix</a>(grism_file, conf-&gt;<a class="code" href="structaperture__conf.html#abe36ba97113a8ccb1916acdbe5db113f">science_numext</a>);
<a name="l00806"></a>00806   <span class="keywordflow">if</span> (drzcoeffs-&gt;size1 &lt; 2 || !drzcoeffs-&gt;size2)
<a name="l00807"></a>00807     <a class="code" href="aXe__errors_8c.html#a7ef7588e5f91237ba7ce4084e6ed3c11">aXe_message</a> (<a class="code" href="aXe__errors_8h.html#a2556a67874555249b07691c37aa6d6e9">aXe_M_FATAL</a>, __FILE__, __LINE__,
<a name="l00808"></a>00808                  <span class="stringliteral">&quot;oblist_to_dirlist:&quot;</span> <span class="stringliteral">&quot; Could not get&quot;</span>
<a name="l00809"></a>00809                  <span class="stringliteral">&quot; the drizzle coefficients in file: %s\n&quot;</span>, grism_file);
<a name="l00810"></a>00810 
<a name="l00811"></a>00811   <span class="comment">// determine an offset from the PSF_OFFSET</span>
<a name="l00812"></a>00812   max_offs = (int)ceil(<a class="code" href="aper__conf_8c.html#a63e3b3bf0beebc0fe4677687d96b85df">get_max_offset</a>(conf));
<a name="l00813"></a>00813 
<a name="l00814"></a>00814   <span class="comment">// determine the number of objects in the object list</span>
<a name="l00815"></a>00815   nobjects = <a class="code" href="inout__aper_8c.html#aa4bd812673400180537c7ea98650d3fe">object_list_size</a>(oblist);
<a name="l00816"></a>00816 
<a name="l00817"></a>00817   <span class="comment">// allocate space for the dirobject list</span>
<a name="l00818"></a>00818   dirlist = (<a class="code" href="structdirobject.html">dirobject</a> **) malloc((nobjects+1) * <span class="keyword">sizeof</span>(<a class="code" href="structdirobject.html">dirobject</a> *));
<a name="l00819"></a>00819   <span class="keywordflow">if</span> (dirlist == NULL)
<a name="l00820"></a>00820     <a class="code" href="aXe__errors_8c.html#a7ef7588e5f91237ba7ce4084e6ed3c11">aXe_message</a> (<a class="code" href="aXe__errors_8h.html#a2556a67874555249b07691c37aa6d6e9">aXe_M_FATAL</a>, __FILE__, __LINE__,
<a name="l00821"></a>00821                  <span class="stringliteral">&quot;oblist_to_dirlist:&quot;</span> <span class="stringliteral">&quot; Could not allocate&quot;</span>
<a name="l00822"></a>00822                  <span class="stringliteral">&quot; memory for pointers to %i dirobject objects&quot;</span>, nobjects+1);
<a name="l00823"></a>00823 
<a name="l00824"></a>00824   <span class="comment">// loop over all objectsconfig-&gt;camera</span>
<a name="l00825"></a>00825   <span class="keywordflow">for</span> (i = 0; i &lt; nobjects; i++)
<a name="l00826"></a>00826     {
<a name="l00827"></a>00827       <span class="comment">// make sure that there are beams in the object</span>
<a name="l00828"></a>00828       <span class="keywordflow">if</span> (oblist[i]-&gt;nbeams &gt; 0)
<a name="l00829"></a>00829         {
<a name="l00830"></a>00830 
<a name="l00831"></a>00831           <span class="keywordflow">if</span> (<a class="code" href="specmodel__utils_8c.html#a2257600178b2705e1c92f6e45bf249a8">has_aperture_dirim</a>(obj_mod, oblist[i]))
<a name="l00832"></a>00832             dirlist[j] = <a class="code" href="model__utils_8c.html#aabe948f13d5487dcabd5499c635ca01e">fill_dirobj_fromdirim</a>(oblist[i], obj_mod);
<a name="l00833"></a>00833           <span class="keywordflow">else</span>
<a name="l00834"></a>00834             <span class="comment">// create a dirobject for each object</span>
<a name="l00835"></a>00835             dirlist[j] = <a class="code" href="model__utils_8c.html#ae01b7359b803f5823de49af7ba8de948">fill_dirobject</a>(oblist[i], npixels, drzcoeffs, model_scale, max_offs);
<a name="l00836"></a>00836 
<a name="l00837"></a>00837           <a class="code" href="model__utils_8c.html#a5cd967f1d7c4d8c89f52a7cd3d6b4f81">fill_spectrum</a>(oblist[i], dirlist[j], spec_mod, int_type);
<a name="l00838"></a>00838           <span class="comment">//      fill_dpsf_function(conf, dirlist[j]);</span>
<a name="l00839"></a>00839 
<a name="l00840"></a>00840           <span class="comment">// fill the xoffset and yoffset values.</span>
<a name="l00841"></a>00841           <span class="comment">// within the gaussian models they are dummys.</span>
<a name="l00842"></a>00842           <span class="keywordflow">for</span> (beamID=0; beamID &lt; conf-&gt;<a class="code" href="structaperture__conf.html#af53b09fa4f86ff116c002640c3e817d9">nbeams</a>; beamID++)
<a name="l00843"></a>00843             {
<a name="l00844"></a>00844               dirlist[j]-&gt;<a class="code" href="structdirobject.html#a804b505c34bbecd0eb09832e34cbd5ce">xy_off</a>[beamID].<a class="code" href="structd__point.html#a922a3b5d82a119168ba85e5f939d02c3">x</a> = 0.0;
<a name="l00845"></a>00845               dirlist[j]-&gt;<a class="code" href="structdirobject.html#a804b505c34bbecd0eb09832e34cbd5ce">xy_off</a>[beamID].<a class="code" href="structd__point.html#ad9846a025508bf8873a501ca5fcefbf4">y</a> = 0.0;
<a name="l00846"></a>00846             }
<a name="l00847"></a>00847           j++;
<a name="l00848"></a>00848         }
<a name="l00849"></a>00849     }
<a name="l00850"></a>00850 
<a name="l00851"></a>00851   <span class="comment">// terminate the dirobject list with NULL</span>
<a name="l00852"></a>00852   dirlist[j] = NULL;
<a name="l00853"></a>00853 
<a name="l00854"></a>00854   <span class="comment">// release the memory for the drizzle matrix</span>
<a name="l00855"></a>00855   <a class="code" href="aXe__grism_8h.html#a61aa1d37853a90711852146f18d0b85f">gsl_matrix_free</a>(drzcoeffs);
<a name="l00856"></a>00856 
<a name="l00857"></a>00857   <a class="code" href="aper__conf_8c.html#a608428f59a2adb25874101610cd6afe4">free_aperture_conf</a>(conf);
<a name="l00858"></a>00858 
<a name="l00859"></a>00859   <span class="keywordflow">return</span> dirlist;
<a name="l00860"></a>00860 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a6ea108739ddb7ea09f86c3c51b1b5848"></a><!-- doxytag: member="model_utils.c::print_dirobject" ref="a6ea108739ddb7ea09f86c3c51b1b5848" args="(const dirobject *actdir)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void print_dirobject </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdirobject.html">dirobject</a> *&nbsp;</td>
          <td class="paramname"> <em>actdir</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Function: print_dirobject Prints the data in a <a class="el" href="structdirobject.html">dirobject</a> onto the screens. "Natural" format is used, which means printed are first the upper corners, then the refpoint, then the lower corners.</p>
<p>Parameters: </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>actdir</em>&nbsp;</td><td>- the <a class="el" href="structdirobject.html">dirobject</a> to be printed </td></tr>
  </table>
  </dd>
</dl>

<p><div class="fragment"><pre class="fragment"><a name="l01552"></a>01552                                          {
<a name="l01553"></a>01553   <span class="keywordtype">int</span> i=0;
<a name="l01554"></a>01554   <span class="keywordtype">int</span> npoints=0;
<a name="l01555"></a>01555 
<a name="l01556"></a>01556   fprintf(stdout, <span class="stringliteral">&quot;Object ID: %i\n&quot;</span>, actdir-&gt;<a class="code" href="structdirobject.html#ac7f75c9d3cdd6d50adc84ec001beee5b">ID</a>);
<a name="l01557"></a>01557   fprintf(stdout,<span class="stringliteral">&quot;%5i,%5i              %5i,%5i\n&quot;</span>, actdir-&gt;<a class="code" href="structdirobject.html#ac068f35c585eec4cd1e5d3392c2dd698">ix_min</a>, actdir-&gt;<a class="code" href="structdirobject.html#a3b36973dd52d158c059bfe6587a04244">iy_max</a>, actdir-&gt;<a class="code" href="structdirobject.html#ac8c6104f2c2e1384c64bba61ecf40d69">ix_max</a>, actdir-&gt;<a class="code" href="structdirobject.html#a3b36973dd52d158c059bfe6587a04244">iy_max</a>);
<a name="l01558"></a>01558   fprintf(stdout,<span class="stringliteral">&quot;        %7.1f,%7.1f         \n&quot;</span>, actdir-&gt;<a class="code" href="structdirobject.html#a66ec2727d2a5269c84804a89626834fa">refpoint</a>.<a class="code" href="structd__point.html#a922a3b5d82a119168ba85e5f939d02c3">x</a>, actdir-&gt;<a class="code" href="structdirobject.html#a66ec2727d2a5269c84804a89626834fa">refpoint</a>.<a class="code" href="structd__point.html#ad9846a025508bf8873a501ca5fcefbf4">y</a>);
<a name="l01559"></a>01559   fprintf(stdout,<span class="stringliteral">&quot;%5i,%5i              %5i,%5i\n\n&quot;</span>, actdir-&gt;<a class="code" href="structdirobject.html#ac068f35c585eec4cd1e5d3392c2dd698">ix_min</a>, actdir-&gt;<a class="code" href="structdirobject.html#af24c9a92fa18516591e43d96eec13272">iy_min</a>, actdir-&gt;<a class="code" href="structdirobject.html#ac8c6104f2c2e1384c64bba61ecf40d69">ix_max</a>, actdir-&gt;<a class="code" href="structdirobject.html#af24c9a92fa18516591e43d96eec13272">iy_min</a>);
<a name="l01560"></a>01560 
<a name="l01561"></a>01561 
<a name="l01562"></a>01562   npoints = actdir-&gt;<a class="code" href="structdirobject.html#a79645e83aebf3988bd3464b2079d24c1">SED</a>-&gt;<a class="code" href="structenergy__distrib.html#ae5e24fde4a41b46a8b8510118f646e67">npoints</a>;
<a name="l01563"></a>01563 
<a name="l01564"></a>01564   fprintf(stdout,<span class="stringliteral">&quot;Wavelengths:\n&quot;</span>);
<a name="l01565"></a>01565   fprintf(stdout,<span class="stringliteral">&quot;Minimum: %.1f,%.3e  Maximum: %.1f, %.3e\n&quot;</span>, actdir-&gt;<a class="code" href="structdirobject.html#a79645e83aebf3988bd3464b2079d24c1">SED</a>-&gt;<a class="code" href="structenergy__distrib.html#ac32d12647e9ef7f158b0d4532c09a568">wavelength</a>[0], actdir-&gt;<a class="code" href="structdirobject.html#a79645e83aebf3988bd3464b2079d24c1">SED</a>-&gt;<a class="code" href="structenergy__distrib.html#a7da8059a7bb2f8af463b6ee1dd1e6554">flux</a>[0],
<a name="l01566"></a>01566           actdir-&gt;<a class="code" href="structdirobject.html#a79645e83aebf3988bd3464b2079d24c1">SED</a>-&gt;<a class="code" href="structenergy__distrib.html#ac32d12647e9ef7f158b0d4532c09a568">wavelength</a>[npoints-1],  actdir-&gt;<a class="code" href="structdirobject.html#a79645e83aebf3988bd3464b2079d24c1">SED</a>-&gt;<a class="code" href="structenergy__distrib.html#a7da8059a7bb2f8af463b6ee1dd1e6554">flux</a>[npoints-1]);
<a name="l01567"></a>01567   <span class="keywordflow">for</span> (i=0; i&lt;npoints;i++)
<a name="l01568"></a>01568     fprintf(stdout,<span class="stringliteral">&quot;Wavelength: %.1f, Flux: %.5e\n&quot;</span>, actdir-&gt;<a class="code" href="structdirobject.html#a79645e83aebf3988bd3464b2079d24c1">SED</a>-&gt;<a class="code" href="structenergy__distrib.html#ac32d12647e9ef7f158b0d4532c09a568">wavelength</a>[i], actdir-&gt;<a class="code" href="structdirobject.html#a79645e83aebf3988bd3464b2079d24c1">SED</a>-&gt;<a class="code" href="structenergy__distrib.html#a7da8059a7bb2f8af463b6ee1dd1e6554">flux</a>[i]);
<a name="l01569"></a>01569   fprintf(stdout,<span class="stringliteral">&quot;\n\n&quot;</span>);
<a name="l01570"></a>01570 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a38db08b7fb859351801ecb7c45830a73"></a><!-- doxytag: member="model_utils.c::print_tracedata" ref="a38db08b7fb859351801ecb7c45830a73" args="(tracedata *acttrace)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void print_tracedata </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtracedata.html">tracedata</a> *&nbsp;</td>
          <td class="paramname"> <em>acttrace</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><div class="fragment"><pre class="fragment"><a name="l00657"></a>00657 {
<a name="l00658"></a>00658   <span class="keywordtype">int</span> i=0;
<a name="l00659"></a>00659 
<a name="l00660"></a>00660   fprintf(stdout, <span class="stringliteral">&quot;Trace starting at: %f\n&quot;</span>, acttrace-&gt;<a class="code" href="structtracedata.html#a30448278ba94615e1ef5d8801deab6e6">dx_start</a>);
<a name="l00661"></a>00661   <span class="keywordflow">for</span> (i=0; i &lt; acttrace-&gt;<a class="code" href="structtracedata.html#af5aed7b8f1629b86be33dc7d57056bcc">npoints</a>; i++)
<a name="l00662"></a>00662     {
<a name="l00663"></a>00663       fprintf(stdout, <span class="stringliteral">&quot;dx: %f, dy: %f, xi: %f, lambda: %f, dlambda: %f, gdata: %f, flux: %g\n&quot;</span>,
<a name="l00664"></a>00664               gsl_vector_get(acttrace-&gt;<a class="code" href="structtracedata.html#aebca3378cacc91654b164c7818f120e2">dx</a>, i), gsl_vector_get(acttrace-&gt;<a class="code" href="structtracedata.html#a0bdd805ca59eb0b1329694181236c191">dy</a>, i),gsl_vector_get(acttrace-&gt;<a class="code" href="structtracedata.html#aee169f9a7859629a3f3b9e8a58c43a39">xi</a>, i),
<a name="l00665"></a>00665               gsl_vector_get(acttrace-&gt;<a class="code" href="structtracedata.html#a3c594775ee8672308604497766a66f02">lambda</a>, i), gsl_vector_get(acttrace-&gt;<a class="code" href="structtracedata.html#a63bce5a9b367504eb09b87f41f3373da">dlambda</a>, i), gsl_vector_get(acttrace-&gt;<a class="code" href="structtracedata.html#a263d2f1a51308e73d79c77f5e62c01fb">gvalue</a>, i),
<a name="l00666"></a>00666               gsl_vector_get(acttrace-&gt;<a class="code" href="structtracedata.html#a536ca0eb0a785814fc211bcf835f666a">flux</a>, i));
<a name="l00667"></a>00667     }
<a name="l00668"></a>00668 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a67e212ed30f3f8311e5eaa822dd69705"></a><!-- doxytag: member="model_utils.c::select_tracedata" ref="a67e212ed30f3f8311e5eaa822dd69705" args="(tracedata *acttrace, const calib_function *wl_calibration, const int nentries)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void select_tracedata </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtracedata.html">tracedata</a> *&nbsp;</td>
          <td class="paramname"> <em>acttrace</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcalib__function.html">calib_function</a> *&nbsp;</td>
          <td class="paramname"> <em>wl_calibration</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>nentries</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><div class="fragment"><pre class="fragment"><a name="l00525"></a>00525 {
<a name="l00526"></a>00526   gsl_vector *dx;
<a name="l00527"></a>00527   gsl_vector *dy;
<a name="l00528"></a>00528   gsl_vector *xi;
<a name="l00529"></a>00529   gsl_vector *lambda;
<a name="l00530"></a>00530   gsl_vector *dlambda;
<a name="l00531"></a>00531   gsl_vector *flux;
<a name="l00532"></a>00532   gsl_vector *gvalue;
<a name="l00533"></a>00533 
<a name="l00534"></a>00534   <span class="keywordtype">double</span> lower, upper, a_0, d_xi;
<a name="l00535"></a>00535 
<a name="l00536"></a>00536   <span class="keywordtype">int</span> i=0, iact;
<a name="l00537"></a>00537 
<a name="l00538"></a>00538   <span class="comment">// get the lower and upper boundaries of the accepted range</span>
<a name="l00539"></a>00539   lower = gsl_vector_get(wl_calibration-&gt;<a class="code" href="structcalib__function.html#a585ddafa8bb9e1ac0b7a3da3410b5f80">pr_range</a>, 0);
<a name="l00540"></a>00540   upper = gsl_vector_get(wl_calibration-&gt;<a class="code" href="structcalib__function.html#a585ddafa8bb9e1ac0b7a3da3410b5f80">pr_range</a>, 1);
<a name="l00541"></a>00541 
<a name="l00542"></a>00542   <span class="comment">// get the a0 coefficient</span>
<a name="l00543"></a>00543   a_0 = wl_calibration-&gt;<a class="code" href="structcalib__function.html#af6161163d6abff34648d027533dbc89e">coeffs</a>[0];
<a name="l00544"></a>00544 
<a name="l00545"></a>00545   <span class="comment">// check wehter thereis valid data at all</span>
<a name="l00546"></a>00546   <span class="keywordflow">if</span> (nentries &lt; 1)
<a name="l00547"></a>00547     {
<a name="l00548"></a>00548       <span class="comment">// if no valid data, set all vectors to NULL</span>
<a name="l00549"></a>00549       dx      = NULL;
<a name="l00550"></a>00550       dy      = NULL;
<a name="l00551"></a>00551       xi      = NULL;
<a name="l00552"></a>00552       lambda  = NULL;
<a name="l00553"></a>00553       dlambda = NULL;
<a name="l00554"></a>00554       flux    = NULL;
<a name="l00555"></a>00555       gvalue    = NULL;
<a name="l00556"></a>00556 
<a name="l00557"></a>00557       acttrace-&gt;<a class="code" href="structtracedata.html#a30448278ba94615e1ef5d8801deab6e6">dx_start</a> = 0.0;
<a name="l00558"></a>00558     }
<a name="l00559"></a>00559   <span class="keywordflow">else</span>
<a name="l00560"></a>00560     {
<a name="l00561"></a>00561       <span class="comment">// if there is valid data:</span>
<a name="l00562"></a>00562       <span class="comment">// allocate space for the new tracedata structure</span>
<a name="l00563"></a>00563       dx      = gsl_vector_alloc(nentries);
<a name="l00564"></a>00564       dy      = gsl_vector_alloc(nentries);
<a name="l00565"></a>00565       xi      = gsl_vector_alloc(nentries);
<a name="l00566"></a>00566       lambda  = gsl_vector_alloc(nentries);
<a name="l00567"></a>00567       dlambda = gsl_vector_alloc(nentries);
<a name="l00568"></a>00568       flux    = gsl_vector_alloc(nentries);
<a name="l00569"></a>00569       gvalue  = gsl_vector_alloc(nentries);
<a name="l00570"></a>00570 
<a name="l00571"></a>00571       <span class="comment">// go over all tracedata points</span>
<a name="l00572"></a>00572       iact=0;
<a name="l00573"></a>00573       <span class="keywordflow">for</span> (i=0; i &lt; acttrace-&gt;<a class="code" href="structtracedata.html#af5aed7b8f1629b86be33dc7d57056bcc">npoints</a>; i++)
<a name="l00574"></a>00574         {
<a name="l00575"></a>00575 
<a name="l00576"></a>00576           <span class="comment">// compute the offset from the singularity</span>
<a name="l00577"></a>00577           d_xi = gsl_vector_get(acttrace-&gt;<a class="code" href="structtracedata.html#aee169f9a7859629a3f3b9e8a58c43a39">xi</a>, i) -  a_0;
<a name="l00578"></a>00578 
<a name="l00579"></a>00579           <span class="comment">// if the offside is in the accepted range</span>
<a name="l00580"></a>00580           <span class="keywordflow">if</span> (d_xi &gt;= lower &amp;&amp; d_xi &lt;= upper)
<a name="l00581"></a>00581             {
<a name="l00582"></a>00582 
<a name="l00583"></a>00583               <span class="comment">// transfer the data from the old to the new structure</span>
<a name="l00584"></a>00584               gsl_vector_set(dx     , iact, gsl_vector_get(acttrace-&gt;<a class="code" href="structtracedata.html#aebca3378cacc91654b164c7818f120e2">dx</a>, i));
<a name="l00585"></a>00585               gsl_vector_set(dy     , iact, gsl_vector_get(acttrace-&gt;<a class="code" href="structtracedata.html#a0bdd805ca59eb0b1329694181236c191">dy</a>, i));
<a name="l00586"></a>00586               gsl_vector_set(xi     , iact, gsl_vector_get(acttrace-&gt;<a class="code" href="structtracedata.html#aee169f9a7859629a3f3b9e8a58c43a39">xi</a>, i));
<a name="l00587"></a>00587               gsl_vector_set(lambda , iact, gsl_vector_get(acttrace-&gt;<a class="code" href="structtracedata.html#a3c594775ee8672308604497766a66f02">lambda</a>, i));
<a name="l00588"></a>00588               gsl_vector_set(dlambda, iact, gsl_vector_get(acttrace-&gt;<a class="code" href="structtracedata.html#a63bce5a9b367504eb09b87f41f3373da">dlambda</a>, i));
<a name="l00589"></a>00589               gsl_vector_set(gvalue , iact, 1.0);
<a name="l00590"></a>00590 
<a name="l00591"></a>00591               <span class="comment">// enhance the counter</span>
<a name="l00592"></a>00592               iact++;
<a name="l00593"></a>00593             }
<a name="l00594"></a>00594         }
<a name="l00595"></a>00595 
<a name="l00596"></a>00596       <span class="comment">// set the intitial value</span>
<a name="l00597"></a>00597       acttrace-&gt;<a class="code" href="structtracedata.html#a30448278ba94615e1ef5d8801deab6e6">dx_start</a> = gsl_vector_get(dx, 0);
<a name="l00598"></a>00598     }
<a name="l00599"></a>00599 
<a name="l00600"></a>00600   <span class="comment">// set the number of points</span>
<a name="l00601"></a>00601   acttrace-&gt;<a class="code" href="structtracedata.html#af5aed7b8f1629b86be33dc7d57056bcc">npoints</a> = nentries;
<a name="l00602"></a>00602 
<a name="l00603"></a>00603   <span class="comment">// release the old vectors in the structure</span>
<a name="l00604"></a>00604   gsl_vector_free(acttrace-&gt;<a class="code" href="structtracedata.html#aebca3378cacc91654b164c7818f120e2">dx</a>);
<a name="l00605"></a>00605   gsl_vector_free(acttrace-&gt;<a class="code" href="structtracedata.html#a0bdd805ca59eb0b1329694181236c191">dy</a>);
<a name="l00606"></a>00606   gsl_vector_free(acttrace-&gt;<a class="code" href="structtracedata.html#aee169f9a7859629a3f3b9e8a58c43a39">xi</a>);
<a name="l00607"></a>00607   gsl_vector_free(acttrace-&gt;<a class="code" href="structtracedata.html#a3c594775ee8672308604497766a66f02">lambda</a>);
<a name="l00608"></a>00608   gsl_vector_free(acttrace-&gt;<a class="code" href="structtracedata.html#a63bce5a9b367504eb09b87f41f3373da">dlambda</a>);
<a name="l00609"></a>00609   gsl_vector_free(acttrace-&gt;<a class="code" href="structtracedata.html#a536ca0eb0a785814fc211bcf835f666a">flux</a>);
<a name="l00610"></a>00610   gsl_vector_free(acttrace-&gt;<a class="code" href="structtracedata.html#a263d2f1a51308e73d79c77f5e62c01fb">gvalue</a>);
<a name="l00611"></a>00611 
<a name="l00612"></a>00612   <span class="comment">// fill the new vectors into the tracedata structure</span>
<a name="l00613"></a>00613   acttrace-&gt;<a class="code" href="structtracedata.html#aebca3378cacc91654b164c7818f120e2">dx</a>      = dx;
<a name="l00614"></a>00614   acttrace-&gt;<a class="code" href="structtracedata.html#a0bdd805ca59eb0b1329694181236c191">dy</a>      = dy;
<a name="l00615"></a>00615   acttrace-&gt;<a class="code" href="structtracedata.html#aee169f9a7859629a3f3b9e8a58c43a39">xi</a>      = xi;
<a name="l00616"></a>00616   acttrace-&gt;<a class="code" href="structtracedata.html#a3c594775ee8672308604497766a66f02">lambda</a>  = lambda;
<a name="l00617"></a>00617   acttrace-&gt;<a class="code" href="structtracedata.html#a63bce5a9b367504eb09b87f41f3373da">dlambda</a> = dlambda;
<a name="l00618"></a>00618   acttrace-&gt;<a class="code" href="structtracedata.html#a536ca0eb0a785814fc211bcf835f666a">flux</a>    = flux;
<a name="l00619"></a>00619   acttrace-&gt;<a class="code" href="structtracedata.html#a263d2f1a51308e73d79c77f5e62c01fb">gvalue</a>  = gvalue;
<a name="l00620"></a>00620 }
</pre></div></p>

</div>
</div>
</div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&nbsp;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&nbsp;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&nbsp;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&nbsp;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&nbsp;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&nbsp;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&nbsp;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&nbsp;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&nbsp;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&nbsp;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr size="1"/><address style="text-align: right;"><small>Generated on 12 Oct 2014 for TIPS by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.1 </small></address>
</body>
</html>
