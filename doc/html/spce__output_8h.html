<!-- This comment will put IE 6, 7 and 8 in quirks mode -->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>TIPS: /renoir/fourmano/Desktop/OUSIM/TIPS/branches/tips_build/include/axesim/spce_output.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.6.1 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <img id="MSearchSelect" src="search/search.png"
             onmouseover="return searchBox.OnSearchSelectShow()"
             onmouseout="return searchBox.OnSearchSelectHide()"
             alt=""/>
        <input type="text" id="MSearchField" value="Search" accesskey="S"
             onfocus="searchBox.OnSearchFieldFocus(true)" 
             onblur="searchBox.OnSearchFieldFocus(false)" 
             onkeyup="searchBox.OnSearchFieldChange(event)"/>
        <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
        </div>
      </li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>/renoir/fourmano/Desktop/OUSIM/TIPS/branches/tips_build/include/axesim/spce_output.h File Reference</h1><code>#include &quot;<a class="el" href="aper__conf_8h_source.html">aper_conf.h</a>&quot;</code><br/>

<p><a href="spce__output_8h_source.html">Go to the source code of this file.</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Data Structures</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdrzstamp__dim.html">drzstamp_dim</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structquadrangle.html">quadrangle</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdrzstamp.html">drzstamp</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdrzprep.html">drzprep</a></td></tr>
<tr><td colspan="2"><h2>Namespaces</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacespce__output.html">spce_output</a></td></tr>
<tr><td colspan="2"><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">gsl_vector_int *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="spce__output_8h.html#a487a01f9e88471517124284a4047bd44">get_trace_inds</a> (const <a class="el" href="structap__pixel.html">ap_pixel</a> *const ap_p)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">gsl_matrix *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="spce__output_8h.html#adecd7e61360bb4de56f06143b2f070ac">stamp_img</a> (const <a class="el" href="structap__pixel.html">ap_pixel</a> *const ap_p, float width, <a class="el" href="structd__point.html">d_point</a> *stp_min)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structdrzprep.html">drzprep</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="spce__output_8h.html#ae73fef882d3f2e909f83b4d9784eaba8">stamp_img_drzprep</a> (const int opt_extr, const <a class="el" href="structap__pixel.html">ap_pixel</a> *const ap_p, const <a class="el" href="structap__pixel.html">ap_pixel</a> *const se_p, float width, float nullval, int usemode, <a class="el" href="structdrzstamp__dim.html">drzstamp_dim</a> dimension, gsl_matrix *drzcoeffs, double exptime, double sky_cps, double rdnoise, const int bckmode)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="spce__output_8h.html#ac02af5218e62e713615c31e68fb3e808">free_drzprep</a> (<a class="el" href="structdrzprep.html">drzprep</a> *drzprep_stamps)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">gsl_matrix *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="spce__output_8h.html#acfb8de045d5147f405aac44a201d51a1">rectified_stamp_img</a> (const <a class="el" href="structap__pixel.html">ap_pixel</a> *const ap_p, float width, <a class="el" href="structd__point.html">d_point</a> *stp_min)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structd__point.html">d_point</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="spce__output_8h.html#a727084323c00d05a5549164d2820c77e">get_minxy_from_PET</a> (const <a class="el" href="structap__pixel.html">ap_pixel</a> *const ap_p)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structd__point.html">d_point</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="spce__output_8h.html#a294f187040188cd530ca348373ae6b9f">get_maxxy_from_PET</a> (const <a class="el" href="structap__pixel.html">ap_pixel</a> *const ap_p)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structdrzstamp.html">drzstamp</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="spce__output_8h.html#ad0a264c9a695797c389c2c4b2e5b0d22">drizzled_stamp_img</a> (const <a class="el" href="structap__pixel.html">ap_pixel</a> *const ap_p, double width, const double orient, const <a class="el" href="structdrzstamp__dim.html">drzstamp_dim</a> dimension)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structdrzstamp__dim.html">drzstamp_dim</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="spce__output_8h.html#a26cf5661457b717143b4bfb97c3a440d">get_drzprep_dim</a> (const <a class="el" href="structap__pixel.html">ap_pixel</a> *const ap_p, float width, int boxwidth, int boxheight)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structdrzstamp__dim.html">drzstamp_dim</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="spce__output_8h.html#aece0dc2dd2738020829c96e9413f5494">get_stamp_dim</a> (const <a class="el" href="structap__pixel.html">ap_pixel</a> *const ap_p, float width, <a class="el" href="structaperture__conf.html">aperture_conf</a> *conf, const int beamID, <a class="el" href="structd__point.html">d_point</a> *stp_min)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structquadrangle.html">quadrangle</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="spce__output_8h.html#a0b04392e15823b7d3e07a84cc698d56d">get_quad_from_pixel</a> (const <a class="el" href="structap__pixel.html">ap_pixel</a> *cur_p, const double orient, const <a class="el" href="structdrzstamp__dim.html">drzstamp_dim</a> dimension)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">gsl_matrix *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="spce__output_8h.html#a7bdb9f552a53b43dd53813e8f3037ac7">drizzled_stamp_img_orig</a> (const <a class="el" href="structap__pixel.html">ap_pixel</a> *const ap_p, float width, <a class="el" href="structaperture__conf.html">aperture_conf</a> *conf)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="spce__output_8h.html#a863b4bf317f0bd06437963cd958db9ba">interpolate_over_NaN</a> (gsl_matrix *data)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="spce__output_8h.html#a307bc04cf548af0968aecb683338713f">free_stamp_img</a> (gsl_matrix *stamp)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="spce__output_8h.html#a699a311158a0c8b9a81792c304e212f4">free_drzstamp</a> (<a class="el" href="structdrzstamp.html">drzstamp</a> *stamp)</td></tr>
</table>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="ad0a264c9a695797c389c2c4b2e5b0d22"></a><!-- doxytag: member="spce_output.h::drizzled_stamp_img" ref="ad0a264c9a695797c389c2c4b2e5b0d22" args="(const ap_pixel *const ap_p, double width, const double orient, const drzstamp_dim dimension)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdrzstamp.html">drzstamp</a>* drizzled_stamp_img </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structap__pixel.html">ap_pixel</a> *const &nbsp;</td>
          <td class="paramname"> <em>ap_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>orient</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdrzstamp__dim.html">drzstamp_dim</a>&nbsp;</td>
          <td class="paramname"> <em>dimension</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Function: drizzled_stamp_img Produce a structure containing a drizzled stamp image plux ther associated weight image. The drizzled stamp image has constant dispersion along the x-axis. No drizzling is applied in cross-dispersion direction. The dimensions of the drizzled stampimage were setr previously, and the information is in an input structure. In case that there are no valid pixels, a dummy structure with 10x10 empty pixels is returned.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ap_p</em>&nbsp;</td><td>- pointer to the list of PET pixels </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>width</em>&nbsp;</td><td>- extraction width used </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dimension</em>&nbsp;</td><td>- dimensional information on the drizzled stamp</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>res - structure with counts and weights of the drizzled stamp </dd></dl>

<p><div class="fragment"><pre class="fragment"><a name="l00492"></a>00492 {
<a name="l00493"></a>00493   <span class="keyword">const</span> <a class="code" href="structap__pixel.html">ap_pixel</a> *cur_p;
<a name="l00494"></a>00494 
<a name="l00495"></a>00495   <a class="code" href="structquadrangle.html">quadrangle</a> quad;
<a name="l00496"></a>00496 
<a name="l00497"></a>00497   <a class="code" href="structdrzstamp.html">drzstamp</a> *res;
<a name="l00498"></a>00498   <a class="code" href="aXe__grism_8h.html#a6117e17bb3108107676f4486e62d40e5">gsl_matrix</a> *counts;
<a name="l00499"></a>00499   <a class="code" href="aXe__grism_8h.html#a6117e17bb3108107676f4486e62d40e5">gsl_matrix</a> *weight;
<a name="l00500"></a>00500 
<a name="l00501"></a>00501   <span class="keywordtype">int</span> icen, ilow, iupp;
<a name="l00502"></a>00502   <span class="keywordtype">int</span> jcen, jlow, jupp;
<a name="l00503"></a>00503 
<a name="l00504"></a>00504   <span class="keywordtype">double</span> xi, jacob=0;
<a name="l00505"></a>00505   <span class="keywordtype">double</span> value, allweig, weig;
<a name="l00506"></a>00506 
<a name="l00507"></a>00507   <span class="keywordtype">double</span> maxarr=0.0;
<a name="l00508"></a>00508   <span class="keywordtype">int</span> iim, jjm;
<a name="l00509"></a>00509 
<a name="l00510"></a>00510   <span class="comment">//double totweigth;</span>
<a name="l00511"></a>00511   <span class="comment">//double cos_phi=0.0;</span>
<a name="l00512"></a>00512 
<a name="l00513"></a>00513   <span class="keywordtype">int</span> ii,jj;
<a name="l00514"></a>00514   <span class="keywordtype">double</span> arr;
<a name="l00515"></a>00515   <span class="keywordtype">int</span> stpi,stpj;
<a name="l00516"></a>00516   <span class="keywordtype">double</span> stpc;
<a name="l00517"></a>00517 
<a name="l00518"></a>00518   <span class="comment">// allocate space for the result</span>
<a name="l00519"></a>00519   res = (<a class="code" href="structdrzstamp.html">drzstamp</a> *) malloc(<span class="keyword">sizeof</span>(<a class="code" href="structdrzstamp.html">drzstamp</a>));
<a name="l00520"></a>00520 
<a name="l00521"></a>00521   <span class="comment">// handle an empty PET</span>
<a name="l00522"></a>00522   <span class="keywordflow">if</span> (ap_p==NULL || !dimension.<a class="code" href="structdrzstamp__dim.html#ab3c0ed305132ecda42a1e8b6dad5ce27">resolution</a>) {
<a name="l00523"></a>00523     <span class="comment">/* Create a dummy stamp image */</span>
<a name="l00524"></a>00524     counts = <a class="code" href="aXe__grism_8h.html#a1214ab1bea5fd80474d7a27db0bfb429">gsl_matrix_alloc</a>(10,10);
<a name="l00525"></a>00525     weight = <a class="code" href="aXe__grism_8h.html#a1214ab1bea5fd80474d7a27db0bfb429">gsl_matrix_alloc</a>(10,10);
<a name="l00526"></a>00526     <span class="comment">/* Fill stamp with 0.0 values */</span>
<a name="l00527"></a>00527     <a class="code" href="aXe__grism_8h.html#af6161aeb008a1ffa7d888df6ccbef7cc">gsl_matrix_set_all</a>(counts, 0.0);
<a name="l00528"></a>00528     <a class="code" href="aXe__grism_8h.html#af6161aeb008a1ffa7d888df6ccbef7cc">gsl_matrix_set_all</a>(weight, 0.0);
<a name="l00529"></a>00529 
<a name="l00530"></a>00530     <span class="comment">// fill the output</span>
<a name="l00531"></a>00531     res-&gt;<a class="code" href="structdrzstamp.html#a1e8778c4fa3383cb553fbfd9d6eb2582">counts</a> = counts;
<a name="l00532"></a>00532     res-&gt;<a class="code" href="structdrzstamp.html#a175c8d689fec7a99909d3df716891907">weight</a> = weight;
<a name="l00533"></a>00533 
<a name="l00534"></a>00534     <span class="comment">// return the output</span>
<a name="l00535"></a>00535     <span class="keywordflow">return</span> res;
<a name="l00536"></a>00536   }
<a name="l00537"></a>00537 
<a name="l00538"></a>00538 
<a name="l00539"></a>00539   <span class="comment">/* Allocate the stamp matrix*/</span>
<a name="l00540"></a>00540   <span class="comment">/* Fill stamp with NaN values */</span>
<a name="l00541"></a>00541   counts = <a class="code" href="aXe__grism_8h.html#a1214ab1bea5fd80474d7a27db0bfb429">gsl_matrix_alloc</a>(dimension.<a class="code" href="structdrzstamp__dim.html#a459626637b5697c339db9e2b31f3ded6">xsize</a>,dimension.<a class="code" href="structdrzstamp__dim.html#a8e268f2124d4cc8783fe4f37708bbe8f">ysize</a>);
<a name="l00542"></a>00542   <a class="code" href="aXe__grism_8h.html#af6161aeb008a1ffa7d888df6ccbef7cc">gsl_matrix_set_all</a>(counts, GSL_NAN);
<a name="l00543"></a>00543 
<a name="l00544"></a>00544   <span class="comment">/* Allocate the weight matrix*/</span>
<a name="l00545"></a>00545   <span class="comment">/* Fill weight with 0.0 values */</span>
<a name="l00546"></a>00546   weight = <a class="code" href="aXe__grism_8h.html#a1214ab1bea5fd80474d7a27db0bfb429">gsl_matrix_alloc</a>(dimension.<a class="code" href="structdrzstamp__dim.html#a459626637b5697c339db9e2b31f3ded6">xsize</a>,dimension.<a class="code" href="structdrzstamp__dim.html#a8e268f2124d4cc8783fe4f37708bbe8f">ysize</a>);
<a name="l00547"></a>00547   <a class="code" href="aXe__grism_8h.html#af6161aeb008a1ffa7d888df6ccbef7cc">gsl_matrix_set_all</a>(weight, 0.0);
<a name="l00548"></a>00548 
<a name="l00549"></a>00549 
<a name="l00550"></a>00550   <span class="comment">// go over each pixel</span>
<a name="l00551"></a>00551   <span class="keywordflow">for</span> (cur_p = ap_p; cur_p-&gt;<a class="code" href="structap__pixel.html#abca28f0936fbd5a569ad548fb25e5a38">p_x</a> != -1; cur_p++)
<a name="l00552"></a>00552     {
<a name="l00553"></a>00553 
<a name="l00554"></a>00554       <span class="comment">// Skip this pixel if it was not actually used</span>
<a name="l00555"></a>00555       <span class="keywordflow">if</span> (fabs(cur_p-&gt;<a class="code" href="structap__pixel.html#abd0f197da151fac01c9e4cbd4146f212">dist</a>)&gt;width+1.5)
<a name="l00556"></a>00556         <span class="keywordflow">continue</span>;
<a name="l00557"></a>00557 
<a name="l00558"></a>00558       <span class="comment">// create the quadrangle for the current pixel</span>
<a name="l00559"></a>00559       <span class="comment">//      quad = get_quad_from_pixel2(cur_p, dimension);</span>
<a name="l00560"></a>00560       quad = <a class="code" href="spce__output_8c.html#a0b04392e15823b7d3e07a84cc698d56d">get_quad_from_pixel</a>(cur_p, orient, dimension);
<a name="l00561"></a>00561 
<a name="l00562"></a>00562       <span class="comment">// get the jacobian (well, easy here)</span>
<a name="l00563"></a>00563       <span class="comment">// the term &quot;cos(cur_p-&gt;dxs)&quot; must be there</span>
<a name="l00564"></a>00564       <span class="comment">// to correct the enlargement necessary</span>
<a name="l00565"></a>00565       <span class="comment">// to cover the whole lambda-crossdispersion area!</span>
<a name="l00566"></a>00566       <span class="comment">// NOT COMPLETELY understood</span>
<a name="l00567"></a>00567       jacob = dimension.<a class="code" href="structdrzstamp__dim.html#ab3c0ed305132ecda42a1e8b6dad5ce27">resolution</a>/cur_p-&gt;<a class="code" href="structap__pixel.html#a8c1c7b5a35a04145fccfc3f84c420cde">dlambda</a>*cos(cur_p-&gt;<a class="code" href="structap__pixel.html#a92d9e84a233d0a1ad482830b23c5e5ba">dxs</a>);
<a name="l00568"></a>00568 
<a name="l00569"></a>00569       <span class="comment">// get the central pixel (icen, jcen) of the current PET-pixel</span>
<a name="l00570"></a>00570       xi = cur_p-&gt;<a class="code" href="structap__pixel.html#ac36fd281b7d91081490e41ce07a60501">lambda</a>/dimension.<a class="code" href="structdrzstamp__dim.html#ab3c0ed305132ecda42a1e8b6dad5ce27">resolution</a>;
<a name="l00571"></a>00571       icen = (int) floor(xi - dimension.<a class="code" href="structdrzstamp__dim.html#af6df14c21230e289ef6abe7134de3cc3">xstart</a>+.5);
<a name="l00572"></a>00572       jcen = (int) floor(cur_p-&gt;<a class="code" href="structap__pixel.html#abd0f197da151fac01c9e4cbd4146f212">dist</a> - dimension.<a class="code" href="structdrzstamp__dim.html#a9ed53e0c679cabe8bd15189b7b9b7a62">ystart</a>+.5);
<a name="l00573"></a>00573 
<a name="l00574"></a>00574       <span class="comment">// get the uper and lower extend of the quadrangle in x</span>
<a name="l00575"></a>00575       iupp = (int)floor(quad.<a class="code" href="structquadrangle.html#a07cdc1aa08d997f3ecf4a4527e1958b1">xmax</a> - (<span class="keywordtype">double</span>)icen + 0.5)+1;
<a name="l00576"></a>00576       ilow = (int)floor(quad.<a class="code" href="structquadrangle.html#a4a693bbae5ab2389a2e89aba2cd1ec6c">xmin</a> - (<span class="keywordtype">double</span>)icen + 0.5);
<a name="l00577"></a>00577 
<a name="l00578"></a>00578       <span class="comment">// get the uper and lower extend of the quadrangle in x</span>
<a name="l00579"></a>00579       jupp = (int)floor(quad.<a class="code" href="structquadrangle.html#a9cd9de4d5ad81c686c3bbea6093d5f2a">ymax</a> - (<span class="keywordtype">double</span>)jcen + 0.5)+1;
<a name="l00580"></a>00580       jlow = (int)floor(quad.<a class="code" href="structquadrangle.html#a28f1d44685c1b1fc1302c23fa53e3c82">ymin</a> - (<span class="keywordtype">double</span>)jcen + 0.5);
<a name="l00581"></a>00581 
<a name="l00582"></a>00582       maxarr=0.0;
<a name="l00583"></a>00583       <span class="comment">//      totweigth = 0.0;</span>
<a name="l00584"></a>00584       <span class="comment">// go over the extend in x</span>
<a name="l00585"></a>00585       <span class="keywordflow">for</span> (ii=ilow;ii&lt;iupp;ii++) {
<a name="l00586"></a>00586         <span class="comment">// go over the extend in x</span>
<a name="l00587"></a>00587         <span class="keywordflow">for</span> (jj=jlow;jj&lt;jupp;jj++) {
<a name="l00588"></a>00588 
<a name="l00589"></a>00589           <span class="comment">// get the coordinates of the current output pixel</span>
<a name="l00590"></a>00590           stpi = icen+ii;
<a name="l00591"></a>00591           stpj = jcen+jj;
<a name="l00592"></a>00592 
<a name="l00593"></a>00593           <span class="comment">// check whether the current output pixel is within</span>
<a name="l00594"></a>00594           <span class="comment">// the stamp image; continue if not</span>
<a name="l00595"></a>00595           <span class="keywordflow">if</span> ( (stpi&gt;=dimension.<a class="code" href="structdrzstamp__dim.html#a459626637b5697c339db9e2b31f3ded6">xsize</a>)||(stpi&lt;0)||(stpj&gt;=dimension.<a class="code" href="structdrzstamp__dim.html#a8e268f2124d4cc8783fe4f37708bbe8f">ysize</a>)||(stpj&lt;0) )
<a name="l00596"></a>00596             <span class="keywordflow">continue</span>;
<a name="l00597"></a>00597 
<a name="l00598"></a>00598           <span class="comment">// get the area which falls onto the current output pixel</span>
<a name="l00599"></a>00599           arr = <a class="code" href="spc__driz_8c.html#a8aae79a1f68a0ac2de5f34e6e9f9f2df">boxer</a>(stpi,stpj,quad.<a class="code" href="structquadrangle.html#a2838cc41fa0d8d867757b05ed1cfdbc2">x</a>,quad.<a class="code" href="structquadrangle.html#a7a086b8fde718d39d81a1d0a5855beff">y</a>);
<a name="l00600"></a>00600           <span class="keywordflow">if</span> (arr &gt; maxarr)
<a name="l00601"></a>00601             {
<a name="l00602"></a>00602               maxarr=arr;
<a name="l00603"></a>00603               iim = ii;
<a name="l00604"></a>00604               jjm = jj;
<a name="l00605"></a>00605             }
<a name="l00606"></a>00606           <span class="comment">// get the already existing counts and weights</span>
<a name="l00607"></a>00607           stpc = <a class="code" href="aXe__grism_8h.html#acf709ee71c580f1cd65d726ed03200ea">gsl_matrix_get</a>(counts,stpi,stpj);
<a name="l00608"></a>00608           weig = <a class="code" href="aXe__grism_8h.html#acf709ee71c580f1cd65d726ed03200ea">gsl_matrix_get</a>(weight,stpi,stpj);
<a name="l00609"></a>00609 
<a name="l00610"></a>00610           <span class="comment">// initialize the counts, if necessary</span>
<a name="l00611"></a>00611           <span class="keywordflow">if</span> (isnan(stpc) &amp;&amp; (arr!=0.0))
<a name="l00612"></a>00612             stpc = 0.0;
<a name="l00613"></a>00613 
<a name="l00614"></a>00614           <span class="comment">// compute the new, total weight of the current output pixel</span>
<a name="l00615"></a>00615           <span class="comment">//      allweig = weig + jacob*arr;</span>
<a name="l00616"></a>00616           allweig = weig + arr;
<a name="l00617"></a>00617 
<a name="l00618"></a>00618           <span class="comment">// do a weighted sum of the count value at the current output pixel</span>
<a name="l00619"></a>00619           value = (stpc*weig + arr*cur_p-&gt;<a class="code" href="structap__pixel.html#a846018a7e3b143259419bd74e2d9073f">count</a>*jacob) / (allweig);
<a name="l00620"></a>00620 
<a name="l00621"></a>00621           <span class="comment">// store the new count value and the new weight</span>
<a name="l00622"></a>00622           <a class="code" href="aXe__grism_8h.html#a1f386ef5cd5a3b916246c2bee80f083a">gsl_matrix_set</a>(counts,stpi,stpj,value);
<a name="l00623"></a>00623           <a class="code" href="aXe__grism_8h.html#a1f386ef5cd5a3b916246c2bee80f083a">gsl_matrix_set</a>(weight,stpi,stpj,allweig);
<a name="l00624"></a>00624           <span class="comment">//      totweigth = totweigth + arr;</span>
<a name="l00625"></a>00625         }
<a name="l00626"></a>00626       }
<a name="l00627"></a>00627     }
<a name="l00628"></a>00628 
<a name="l00629"></a>00629   <span class="comment">// fill the output structure</span>
<a name="l00630"></a>00630   res-&gt;<a class="code" href="structdrzstamp.html#a1e8778c4fa3383cb553fbfd9d6eb2582">counts</a> = counts;
<a name="l00631"></a>00631   res-&gt;<a class="code" href="structdrzstamp.html#a175c8d689fec7a99909d3df716891907">weight</a> = weight;
<a name="l00632"></a>00632 
<a name="l00633"></a>00633   <span class="comment">// return the output</span>
<a name="l00634"></a>00634   <span class="keywordflow">return</span> res;
<a name="l00635"></a>00635 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a7bdb9f552a53b43dd53813e8f3037ac7"></a><!-- doxytag: member="spce_output.h::drizzled_stamp_img_orig" ref="a7bdb9f552a53b43dd53813e8f3037ac7" args="(const ap_pixel *const ap_p, float width, aperture_conf *conf)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gsl_matrix* drizzled_stamp_img_orig </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structap__pixel.html">ap_pixel</a> *const &nbsp;</td>
          <td class="paramname"> <em>ap_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structaperture__conf.html">aperture_conf</a> *&nbsp;</td>
          <td class="paramname"> <em>conf</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Produce a gsl array containing a 'drizzled aperture'. That is, an image of the spectum showing count on an xi,dist grid instead of the traditional image grid x,y. Returns NULL is input <a class="el" href="structobject.html">object</a> is NULL. [modifies ap_p!!] </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ap_p</em>&nbsp;</td><td>a pointer to a -1 terminated <a class="el" href="structap__pixel.html">ap_pixel</a> array </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>width</em>&nbsp;</td><td>extraction width used </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>resampwidth</em>&nbsp;</td><td>A per pixel of output drizzled spectra </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a pointer to a newly allocated gsl_matrix containing the rectified <a class="el" href="structspectrum.html">spectrum</a> </dd></dl>

<p><div class="fragment"><pre class="fragment"><a name="l00951"></a>00951 {
<a name="l00952"></a>00952   <span class="keyword">const</span> <a class="code" href="structap__pixel.html">ap_pixel</a> *cur_p;
<a name="l00953"></a>00953 
<a name="l00954"></a>00954   <span class="keywordtype">double</span> min_xi   = 1e32;
<a name="l00955"></a>00955   <span class="keywordtype">double</span> max_xi   = -1e32;
<a name="l00956"></a>00956   <span class="keywordtype">double</span> min_dist = 1e32;
<a name="l00957"></a>00957   <span class="keywordtype">double</span> max_dist = -1e32;
<a name="l00958"></a>00958   <span class="keywordtype">double</span> min_dlam = 1e32;
<a name="l00959"></a>00959   <span class="keywordtype">double</span> max_dlam = -1e32;
<a name="l00960"></a>00960 
<a name="l00961"></a>00961   <span class="keywordtype">double</span> resampwidth = 0.0;
<a name="l00962"></a>00962 
<a name="l00963"></a>00963   <a class="code" href="aXe__grism_8h.html#a6117e17bb3108107676f4486e62d40e5">gsl_matrix</a> *res;
<a name="l00964"></a>00964 
<a name="l00965"></a>00965   <span class="keywordtype">long</span> xsize,ysize,i,j,n=0;
<a name="l00966"></a>00966 
<a name="l00967"></a>00967   <span class="keywordtype">double</span> xi;
<a name="l00968"></a>00968 
<a name="l00969"></a>00969   <span class="keywordflow">if</span> (ap_p==NULL) {
<a name="l00970"></a>00970     <span class="comment">/* Create a dummy stamp image */</span>
<a name="l00971"></a>00971     res = <a class="code" href="aXe__grism_8h.html#a1214ab1bea5fd80474d7a27db0bfb429">gsl_matrix_alloc</a>(10,10);
<a name="l00972"></a>00972     <span class="comment">/* Fill stamp with 0.0 values */</span>
<a name="l00973"></a>00973     <a class="code" href="aXe__grism_8h.html#af6161aeb008a1ffa7d888df6ccbef7cc">gsl_matrix_set_all</a>(res, 0.0);
<a name="l00974"></a>00974     <span class="keywordflow">return</span> res;
<a name="l00975"></a>00975   }
<a name="l00976"></a>00976 
<a name="l00977"></a>00977   i=0;
<a name="l00978"></a>00978   <span class="keywordflow">for</span> (cur_p = ap_p; cur_p-&gt;<a class="code" href="structap__pixel.html#abca28f0936fbd5a569ad548fb25e5a38">p_x</a> != -1; cur_p++)
<a name="l00979"></a>00979     {
<a name="l00980"></a>00980       <span class="keywordflow">if</span> (fabs(cur_p-&gt;<a class="code" href="structap__pixel.html#abd0f197da151fac01c9e4cbd4146f212">dist</a>)&gt;width+.5) <span class="keywordflow">continue</span>; <span class="comment">/* Skip this pixel if it was not actually used */</span>
<a name="l00981"></a>00981       i++;
<a name="l00982"></a>00982 
<a name="l00983"></a>00983       xi = cur_p-&gt;<a class="code" href="structap__pixel.html#ac36fd281b7d91081490e41ce07a60501">lambda</a>;
<a name="l00984"></a>00984 
<a name="l00985"></a>00985       min_xi = <a class="code" href="aXe__utils_8c.html#a74e75242132eaabbc1c512488a135926">MIN</a> (min_xi, xi);
<a name="l00986"></a>00986       max_xi = <a class="code" href="aper__conf_8c.html#aacc3ee1a7f283f8ef65cea31f4436a95">MAX</a> (max_xi, xi);
<a name="l00987"></a>00987 
<a name="l00988"></a>00988       min_dist = <a class="code" href="aXe__utils_8c.html#a74e75242132eaabbc1c512488a135926">MIN</a> (min_dist, cur_p-&gt;<a class="code" href="structap__pixel.html#abd0f197da151fac01c9e4cbd4146f212">dist</a>);
<a name="l00989"></a>00989       max_dist = <a class="code" href="aper__conf_8c.html#aacc3ee1a7f283f8ef65cea31f4436a95">MAX</a> (max_dist, cur_p-&gt;<a class="code" href="structap__pixel.html#abd0f197da151fac01c9e4cbd4146f212">dist</a>);
<a name="l00990"></a>00990 
<a name="l00991"></a>00991       min_dlam = <a class="code" href="aXe__utils_8c.html#a74e75242132eaabbc1c512488a135926">MIN</a> (min_dlam, cur_p-&gt;<a class="code" href="structap__pixel.html#a8c1c7b5a35a04145fccfc3f84c420cde">dlambda</a>);
<a name="l00992"></a>00992       max_dlam = <a class="code" href="aper__conf_8c.html#aacc3ee1a7f283f8ef65cea31f4436a95">MAX</a> (max_dlam, cur_p-&gt;<a class="code" href="structap__pixel.html#a8c1c7b5a35a04145fccfc3f84c420cde">dlambda</a>);
<a name="l00993"></a>00993 
<a name="l00994"></a>00994       n++;
<a name="l00995"></a>00995     }
<a name="l00996"></a>00996 
<a name="l00997"></a>00997   <span class="keywordflow">if</span> (conf-&gt;<a class="code" href="structaperture__conf.html#a0fb034d1b39c351699420312b2c58d76">drz_resol</a>)
<a name="l00998"></a>00998     {
<a name="l00999"></a>00999       resampwidth = (double)conf-&gt;<a class="code" href="structaperture__conf.html#a0fb034d1b39c351699420312b2c58d76">drz_resol</a>;
<a name="l01000"></a>01000     }
<a name="l01001"></a>01001   <span class="keywordflow">else</span>
<a name="l01002"></a>01002     {
<a name="l01003"></a>01003       resampwidth = (max_dlam+min_dlam)/2.0;
<a name="l01004"></a>01004     }
<a name="l01005"></a>01005 
<a name="l01006"></a>01006   fprintf(stdout, <span class="stringliteral">&quot;resamplewidth: %f\n&quot;</span>, resampwidth);
<a name="l01007"></a>01007 
<a name="l01008"></a>01008   <span class="keywordflow">if</span> (i==0) {
<a name="l01009"></a>01009     <span class="comment">/* Create a dummy stamp image */</span>
<a name="l01010"></a>01010     res = <a class="code" href="aXe__grism_8h.html#a1214ab1bea5fd80474d7a27db0bfb429">gsl_matrix_alloc</a>(10,10);
<a name="l01011"></a>01011     <span class="comment">/* Fill stamp with 0.0 values */</span>
<a name="l01012"></a>01012     <a class="code" href="aXe__grism_8h.html#af6161aeb008a1ffa7d888df6ccbef7cc">gsl_matrix_set_all</a>(res, 0.0);
<a name="l01013"></a>01013     <span class="keywordflow">return</span> res;
<a name="l01014"></a>01014   }
<a name="l01015"></a>01015 
<a name="l01016"></a>01016   min_dist = floor(min_dist);
<a name="l01017"></a>01017   max_dist = floor(max_dist);
<a name="l01018"></a>01018   min_xi = floor(min_xi/resampwidth);
<a name="l01019"></a>01019   max_xi = floor(max_xi/resampwidth);
<a name="l01020"></a>01020 
<a name="l01021"></a>01021   xsize = max_xi-min_xi+2;
<a name="l01022"></a>01022   ysize = max_dist-min_dist+2;
<a name="l01023"></a>01023 
<a name="l01024"></a>01024   <span class="keywordflow">if</span> (n&gt;0)
<a name="l01025"></a>01025     {
<a name="l01026"></a>01026       res = <a class="code" href="aXe__grism_8h.html#a1214ab1bea5fd80474d7a27db0bfb429">gsl_matrix_alloc</a>(xsize,ysize);
<a name="l01027"></a>01027     } <span class="keywordflow">else</span> {
<a name="l01028"></a>01028       <span class="comment">/* Create a dummy stamp image */</span>
<a name="l01029"></a>01029       res = <a class="code" href="aXe__grism_8h.html#a1214ab1bea5fd80474d7a27db0bfb429">gsl_matrix_alloc</a>(10,10);
<a name="l01030"></a>01030       <span class="comment">/* Fill stamp with 0.0 values */</span>
<a name="l01031"></a>01031       <a class="code" href="aXe__grism_8h.html#af6161aeb008a1ffa7d888df6ccbef7cc">gsl_matrix_set_all</a>(res, 0.0);
<a name="l01032"></a>01032       <span class="keywordflow">return</span> res;
<a name="l01033"></a>01033     }
<a name="l01034"></a>01034 
<a name="l01035"></a>01035   res = <a class="code" href="aXe__grism_8h.html#a1214ab1bea5fd80474d7a27db0bfb429">gsl_matrix_alloc</a>(xsize,ysize);
<a name="l01036"></a>01036   <span class="comment">/* Fill stamp with NaN values */</span>
<a name="l01037"></a>01037   <a class="code" href="aXe__grism_8h.html#af6161aeb008a1ffa7d888df6ccbef7cc">gsl_matrix_set_all</a>(res, GSL_NAN);
<a name="l01038"></a>01038 
<a name="l01039"></a>01039 
<a name="l01040"></a>01040   <span class="keywordflow">for</span> (cur_p = ap_p; cur_p-&gt;<a class="code" href="structap__pixel.html#abca28f0936fbd5a569ad548fb25e5a38">p_x</a> != -1; cur_p++)
<a name="l01041"></a>01041     {
<a name="l01042"></a>01042       <span class="keywordtype">int</span> ii,jj;
<a name="l01043"></a>01043       <span class="keywordtype">double</span> x,y,xp,yp,arr;
<a name="l01044"></a>01044       <span class="keywordtype">double</span> xx[4],yy[4];
<a name="l01045"></a>01045       <span class="keywordtype">int</span> stpi,stpj;
<a name="l01046"></a>01046       <span class="keywordtype">double</span> stpc;
<a name="l01047"></a>01047 
<a name="l01048"></a>01048       <span class="comment">/* Skip this pixel if it was not actually used */</span>
<a name="l01049"></a>01049       <span class="keywordflow">if</span> (fabs(cur_p-&gt;<a class="code" href="structap__pixel.html#abd0f197da151fac01c9e4cbd4146f212">dist</a>)&gt;width+.5)
<a name="l01050"></a>01050         <span class="keywordflow">continue</span>;
<a name="l01051"></a>01051 
<a name="l01052"></a>01052 
<a name="l01053"></a>01053       <span class="comment">//cur_p-&gt;dxs=0.;</span>
<a name="l01054"></a>01054       <span class="comment">//cur_p-&gt;xi = 100.5 + min_xi;</span>
<a name="l01055"></a>01055       <span class="comment">//cur_p-&gt;dist = 10. + min_dist;</span>
<a name="l01056"></a>01056       xi = cur_p-&gt;<a class="code" href="structap__pixel.html#ac36fd281b7d91081490e41ce07a60501">lambda</a>/resampwidth;
<a name="l01057"></a>01057 
<a name="l01058"></a>01058       i = (long) floor(xi - min_xi+.5);
<a name="l01059"></a>01059       j = (long) floor(cur_p-&gt;<a class="code" href="structap__pixel.html#abd0f197da151fac01c9e4cbd4146f212">dist</a> - min_dist+.5);
<a name="l01060"></a>01060 
<a name="l01061"></a>01061       <span class="comment">/* The center of this PET entry should fall in pixel (i.j) */</span>
<a name="l01062"></a>01062       <span class="comment">/* Bottom left corner (-.5, -.5) */</span>
<a name="l01063"></a>01063       x = -0.5;
<a name="l01064"></a>01064       y = -0.5;
<a name="l01065"></a>01065       xp =  x*cos(cur_p-&gt;<a class="code" href="structap__pixel.html#a92d9e84a233d0a1ad482830b23c5e5ba">dxs</a>) + y*sin(cur_p-&gt;<a class="code" href="structap__pixel.html#a92d9e84a233d0a1ad482830b23c5e5ba">dxs</a>);
<a name="l01066"></a>01066       yp = -x*sin(cur_p-&gt;<a class="code" href="structap__pixel.html#a92d9e84a233d0a1ad482830b23c5e5ba">dxs</a>) + y*cos(cur_p-&gt;<a class="code" href="structap__pixel.html#a92d9e84a233d0a1ad482830b23c5e5ba">dxs</a>);
<a name="l01067"></a>01067       xx[0] = xp+xi - min_xi;
<a name="l01068"></a>01068       yy[0] = yp+cur_p-&gt;<a class="code" href="structap__pixel.html#abd0f197da151fac01c9e4cbd4146f212">dist</a> - min_dist;
<a name="l01069"></a>01069 
<a name="l01070"></a>01070       <span class="comment">/* Top left corner (-.5, +.5) */</span>
<a name="l01071"></a>01071       x = -0.5;
<a name="l01072"></a>01072       y = +0.5;
<a name="l01073"></a>01073       xp =  x*cos(cur_p-&gt;<a class="code" href="structap__pixel.html#a92d9e84a233d0a1ad482830b23c5e5ba">dxs</a>) + y*sin(cur_p-&gt;<a class="code" href="structap__pixel.html#a92d9e84a233d0a1ad482830b23c5e5ba">dxs</a>);
<a name="l01074"></a>01074       yp = -x*sin(cur_p-&gt;<a class="code" href="structap__pixel.html#a92d9e84a233d0a1ad482830b23c5e5ba">dxs</a>) + y*cos(cur_p-&gt;<a class="code" href="structap__pixel.html#a92d9e84a233d0a1ad482830b23c5e5ba">dxs</a>);
<a name="l01075"></a>01075       xx[1] = xp+ xi - min_xi;
<a name="l01076"></a>01076       yy[1] = yp+cur_p-&gt;<a class="code" href="structap__pixel.html#abd0f197da151fac01c9e4cbd4146f212">dist</a> - min_dist;
<a name="l01077"></a>01077 
<a name="l01078"></a>01078       <span class="comment">/* Top right corner (+.5, +.5) */</span>
<a name="l01079"></a>01079       x = +0.5;
<a name="l01080"></a>01080       y = +0.5;
<a name="l01081"></a>01081       xp =  x*cos(cur_p-&gt;<a class="code" href="structap__pixel.html#a92d9e84a233d0a1ad482830b23c5e5ba">dxs</a>) + y*sin(cur_p-&gt;<a class="code" href="structap__pixel.html#a92d9e84a233d0a1ad482830b23c5e5ba">dxs</a>);
<a name="l01082"></a>01082       yp = -x*sin(cur_p-&gt;<a class="code" href="structap__pixel.html#a92d9e84a233d0a1ad482830b23c5e5ba">dxs</a>) + y*cos(cur_p-&gt;<a class="code" href="structap__pixel.html#a92d9e84a233d0a1ad482830b23c5e5ba">dxs</a>);
<a name="l01083"></a>01083       xx[2] = xp+ xi - min_xi;
<a name="l01084"></a>01084       yy[2] = yp+cur_p-&gt;<a class="code" href="structap__pixel.html#abd0f197da151fac01c9e4cbd4146f212">dist</a> - min_dist;
<a name="l01085"></a>01085 
<a name="l01086"></a>01086       <span class="comment">/* Bottom right corner (+.5, -.5) */</span>
<a name="l01087"></a>01087       x = +0.5;
<a name="l01088"></a>01088       y = -0.5;
<a name="l01089"></a>01089       xp =  x*cos(cur_p-&gt;<a class="code" href="structap__pixel.html#a92d9e84a233d0a1ad482830b23c5e5ba">dxs</a>) + y*sin(cur_p-&gt;<a class="code" href="structap__pixel.html#a92d9e84a233d0a1ad482830b23c5e5ba">dxs</a>);
<a name="l01090"></a>01090       yp = -x*sin(cur_p-&gt;<a class="code" href="structap__pixel.html#a92d9e84a233d0a1ad482830b23c5e5ba">dxs</a>) + y*cos(cur_p-&gt;<a class="code" href="structap__pixel.html#a92d9e84a233d0a1ad482830b23c5e5ba">dxs</a>);
<a name="l01091"></a>01091       <span class="comment">// fprintf(stderr,&quot;1 %f %f\n&quot;,cur_p-&gt;xi - min_xi,cur_p-&gt;dist - min_dist);</span>
<a name="l01092"></a>01092       xx[3] = xp+ xi - min_xi;
<a name="l01093"></a>01093       yy[3] = yp+cur_p-&gt;<a class="code" href="structap__pixel.html#abd0f197da151fac01c9e4cbd4146f212">dist</a> - min_dist;
<a name="l01094"></a>01094 
<a name="l01095"></a>01095       <span class="keywordflow">for</span> (ii=-1;ii&lt;=1;ii++) {
<a name="l01096"></a>01096         <span class="keywordflow">for</span> (jj=-1;jj&lt;=1;jj++) {
<a name="l01097"></a>01097           <span class="comment">//fprintf(stderr,&quot;PET: XI: %f DIST: %f DXS: %f cos:%f\n&quot;,cur_p-&gt;xi,cur_p-&gt;dist,cur_p-&gt;dxs,cos(cur_p-&gt;dxs));</span>
<a name="l01098"></a>01098           arr = <a class="code" href="spc__driz_8c.html#a8aae79a1f68a0ac2de5f34e6e9f9f2df">boxer</a>((<span class="keywordtype">int</span>) floor(xi - min_xi)+ii,(<span class="keywordtype">int</span>) floor(cur_p-&gt;<a class="code" href="structap__pixel.html#abd0f197da151fac01c9e4cbd4146f212">dist</a> - min_dist)+jj,xx,yy);
<a name="l01099"></a>01099 
<a name="l01100"></a>01100           <span class="comment">//fprintf(stderr,&quot;STP: i:%d j:%d arr: %f\n&quot;,(int) floor(cur_p-&gt;xi - min_xi)+ii,(int) floor(cur_p-&gt;dist - min_dist)+jj,arr);</span>
<a name="l01101"></a>01101           stpi = (int) floor(xi - min_xi)+ii;
<a name="l01102"></a>01102           stpj = (int) floor(cur_p-&gt;<a class="code" href="structap__pixel.html#abd0f197da151fac01c9e4cbd4146f212">dist</a> - min_dist)+jj;
<a name="l01103"></a>01103           <span class="keywordflow">if</span> ( (stpi&gt;=xsize)||(stpi&lt;0)||(stpj&gt;=ysize)||(stpj&lt;0) ) <span class="keywordflow">continue</span>;
<a name="l01104"></a>01104           stpc = <a class="code" href="aXe__grism_8h.html#acf709ee71c580f1cd65d726ed03200ea">gsl_matrix_get</a>(res,stpi,stpj);
<a name="l01105"></a>01105           <span class="keywordflow">if</span> (isnan(stpc) &amp;&amp; (arr!=0.0)) stpc = 0.0;
<a name="l01106"></a>01106           <a class="code" href="aXe__grism_8h.html#a1f386ef5cd5a3b916246c2bee80f083a">gsl_matrix_set</a>(res,stpi,stpj,stpc+arr*cur_p-&gt;<a class="code" href="structap__pixel.html#a846018a7e3b143259419bd74e2d9073f">count</a>);
<a name="l01107"></a>01107         }
<a name="l01108"></a>01108       }
<a name="l01109"></a>01109 
<a name="l01110"></a>01110 
<a name="l01111"></a>01111     }
<a name="l01112"></a>01112 
<a name="l01113"></a>01113   <span class="keywordflow">return</span> res;
<a name="l01114"></a>01114 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ac02af5218e62e713615c31e68fb3e808"></a><!-- doxytag: member="spce_output.h::free_drzprep" ref="ac02af5218e62e713615c31e68fb3e808" args="(drzprep *drzprep_stamps)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void free_drzprep </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdrzprep.html">drzprep</a> *&nbsp;</td>
          <td class="paramname"> <em>drzprep_stamps</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><div class="fragment"><pre class="fragment"><a name="l01181"></a>01181 {
<a name="l01182"></a>01182   <span class="comment">// release the individual matrixes</span>
<a name="l01183"></a>01183   <a class="code" href="aXe__grism_8h.html#a61aa1d37853a90711852146f18d0b85f">gsl_matrix_free</a>(drzprep_stamps-&gt;<a class="code" href="structdrzprep.html#a215f7390764932e09f5589bf97c52aec">counts</a>);
<a name="l01184"></a>01184   <a class="code" href="aXe__grism_8h.html#a61aa1d37853a90711852146f18d0b85f">gsl_matrix_free</a>(drzprep_stamps-&gt;<a class="code" href="structdrzprep.html#a105921a3d8442eacc2a7f6f98e8d06f9">error</a>);
<a name="l01185"></a>01185   <a class="code" href="aXe__grism_8h.html#a61aa1d37853a90711852146f18d0b85f">gsl_matrix_free</a>(drzprep_stamps-&gt;<a class="code" href="structdrzprep.html#a65b1b1ebedbc949e2536415ac83b5427">cont</a>);
<a name="l01186"></a>01186   <span class="keywordflow">if</span> (drzprep_stamps-&gt;<a class="code" href="structdrzprep.html#ad0fd183b34cc7ee92112db1a31185fb6">model</a>)
<a name="l01187"></a>01187     <a class="code" href="aXe__grism_8h.html#a61aa1d37853a90711852146f18d0b85f">gsl_matrix_free</a>(drzprep_stamps-&gt;<a class="code" href="structdrzprep.html#ad0fd183b34cc7ee92112db1a31185fb6">model</a>);
<a name="l01188"></a>01188   <span class="keywordflow">if</span> (drzprep_stamps-&gt;<a class="code" href="structdrzprep.html#a0039f4cd84c8b2f6c0ea10cac1bc1b37">vari</a>)
<a name="l01189"></a>01189     <a class="code" href="aXe__grism_8h.html#a61aa1d37853a90711852146f18d0b85f">gsl_matrix_free</a>(drzprep_stamps-&gt;<a class="code" href="structdrzprep.html#a0039f4cd84c8b2f6c0ea10cac1bc1b37">vari</a>);
<a name="l01190"></a>01190 
<a name="l01191"></a>01191   <span class="comment">// release the struct</span>
<a name="l01192"></a>01192   free(drzprep_stamps);
<a name="l01193"></a>01193 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a699a311158a0c8b9a81792c304e212f4"></a><!-- doxytag: member="spce_output.h::free_drzstamp" ref="a699a311158a0c8b9a81792c304e212f4" args="(drzstamp *stamp)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void free_drzstamp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdrzstamp.html">drzstamp</a> *&nbsp;</td>
          <td class="paramname"> <em>rstamp</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Function: free_drzstamp Function to free the memeory allocated by a drizzled stamp image.</p>
<p>Parameters: </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>rstamp</em>&nbsp;</td><td>- the structure for the drizzled stamp image </td></tr>
  </table>
  </dd>
</dl>

<p><div class="fragment"><pre class="fragment"><a name="l01218"></a>01218 {
<a name="l01219"></a>01219   <span class="comment">// release each component</span>
<a name="l01220"></a>01220   <a class="code" href="aXe__grism_8h.html#a61aa1d37853a90711852146f18d0b85f">gsl_matrix_free</a>(rstamp-&gt;<a class="code" href="structdrzstamp.html#a1e8778c4fa3383cb553fbfd9d6eb2582">counts</a>);
<a name="l01221"></a>01221   <a class="code" href="aXe__grism_8h.html#a61aa1d37853a90711852146f18d0b85f">gsl_matrix_free</a>(rstamp-&gt;<a class="code" href="structdrzstamp.html#a175c8d689fec7a99909d3df716891907">weight</a>);
<a name="l01222"></a>01222 
<a name="l01223"></a>01223   <span class="comment">// release the rest</span>
<a name="l01224"></a>01224   free(rstamp);
<a name="l01225"></a>01225 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a307bc04cf548af0968aecb683338713f"></a><!-- doxytag: member="spce_output.h::free_stamp_img" ref="a307bc04cf548af0968aecb683338713f" args="(gsl_matrix *stamp)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void free_stamp_img </td>
          <td>(</td>
          <td class="paramtype">gsl_matrix *&nbsp;</td>
          <td class="paramname"> <em>rstamp</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Function: free_stamp_img Function to free the memeory allocated by a stamp image</p>
<p>Parameters: </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>rstamp</em>&nbsp;</td><td>- the stamp image </td></tr>
  </table>
  </dd>
</dl>

<p><div class="fragment"><pre class="fragment"><a name="l01204"></a>01204 {
<a name="l01205"></a>01205   <span class="comment">// simply free it and &quot;basta&quot;!</span>
<a name="l01206"></a>01206   <a class="code" href="aXe__grism_8h.html#a61aa1d37853a90711852146f18d0b85f">gsl_matrix_free</a>(rstamp);
<a name="l01207"></a>01207 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a26cf5661457b717143b4bfb97c3a440d"></a><!-- doxytag: member="spce_output.h::get_drzprep_dim" ref="a26cf5661457b717143b4bfb97c3a440d" args="(const ap_pixel *const ap_p, float width, int boxwidth, int boxheight)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdrzstamp__dim.html">drzstamp_dim</a> get_drzprep_dim </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structap__pixel.html">ap_pixel</a> *const &nbsp;</td>
          <td class="paramname"> <em>ap_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>boxwidth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>boxheight</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Function: get_drzprep_dim The function computes the dimensional properties of the stamp images created in the drizzle prepare task. Those properties fix the image size and the offsets in both coordinates.</p>
<p>Parameter: </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ap_p</em>&nbsp;</td><td>- the list of <a class="el" href="structbeam.html">beam</a> pixels to find the diemnsions for </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>width</em>&nbsp;</td><td>- the extraction width of the <a class="el" href="structbeam.html">beam</a> </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>boxwidth</em>&nbsp;</td><td>- the boxsize </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>boxheight</em>&nbsp;</td><td>- the boxwidth</td></tr>
  </table>
  </dd>
</dl>
<p>Returns: </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>dimensions - the filled <a class="el" href="structquadrangle.html">quadrangle</a> sturcture </dd></dl>

<p><div class="fragment"><pre class="fragment"><a name="l00656"></a>00656 {
<a name="l00657"></a>00657 
<a name="l00658"></a>00658   <a class="code" href="structdrzstamp__dim.html">drzstamp_dim</a> dimensions;
<a name="l00659"></a>00659 
<a name="l00660"></a>00660   <span class="keyword">const</span> <a class="code" href="structap__pixel.html">ap_pixel</a> *cur_p;
<a name="l00661"></a>00661 
<a name="l00662"></a>00662   <span class="keywordtype">double</span> min_px = 1e32;
<a name="l00663"></a>00663   <span class="keywordtype">double</span> max_px = -1e32;
<a name="l00664"></a>00664   <span class="keywordtype">double</span> min_py = 1e32;
<a name="l00665"></a>00665   <span class="keywordtype">double</span> max_py = -1e32;
<a name="l00666"></a>00666 
<a name="l00667"></a>00667   <span class="comment">// return a dummy if the PET is NULL</span>
<a name="l00668"></a>00668   <span class="keywordflow">if</span> (ap_p==NULL)
<a name="l00669"></a>00669     {
<a name="l00670"></a>00670       dimensions.<a class="code" href="structdrzstamp__dim.html#af6df14c21230e289ef6abe7134de3cc3">xstart</a>=0.0;
<a name="l00671"></a>00671       dimensions.<a class="code" href="structdrzstamp__dim.html#a9ed53e0c679cabe8bd15189b7b9b7a62">ystart</a>=0.0;
<a name="l00672"></a>00672 
<a name="l00673"></a>00673       dimensions.<a class="code" href="structdrzstamp__dim.html#a459626637b5697c339db9e2b31f3ded6">xsize</a>=0;
<a name="l00674"></a>00674       dimensions.<a class="code" href="structdrzstamp__dim.html#a8e268f2124d4cc8783fe4f37708bbe8f">ysize</a>=0;
<a name="l00675"></a>00675 
<a name="l00676"></a>00676       <span class="keywordflow">return</span> dimensions;
<a name="l00677"></a>00677     }
<a name="l00678"></a>00678 
<a name="l00679"></a>00679   <span class="comment">// go over each pixel, find minimum and maximum in x,y</span>
<a name="l00680"></a>00680   <span class="keywordflow">for</span> (cur_p = ap_p; cur_p-&gt;<a class="code" href="structap__pixel.html#abca28f0936fbd5a569ad548fb25e5a38">p_x</a> != -1; cur_p++)
<a name="l00681"></a>00681     {
<a name="l00682"></a>00682       <span class="comment">// if (fabs(cur_p-&gt;dist)&gt;width+.5) continue; /* Skip this pixel if it was not actually used */</span>
<a name="l00683"></a>00683       min_px = <a class="code" href="aXe__utils_8c.html#a74e75242132eaabbc1c512488a135926">MIN</a> (min_px, cur_p-&gt;<a class="code" href="structap__pixel.html#abca28f0936fbd5a569ad548fb25e5a38">p_x</a>);
<a name="l00684"></a>00684       max_px = <a class="code" href="aper__conf_8c.html#aacc3ee1a7f283f8ef65cea31f4436a95">MAX</a> (max_px, cur_p-&gt;<a class="code" href="structap__pixel.html#abca28f0936fbd5a569ad548fb25e5a38">p_x</a>);
<a name="l00685"></a>00685       min_py = <a class="code" href="aXe__utils_8c.html#a74e75242132eaabbc1c512488a135926">MIN</a> (min_py, cur_p-&gt;<a class="code" href="structap__pixel.html#aadf7ee52df3875792fbf13d4d52ed298">p_y</a>);
<a name="l00686"></a>00686       max_py = <a class="code" href="aper__conf_8c.html#aacc3ee1a7f283f8ef65cea31f4436a95">MAX</a> (max_py, cur_p-&gt;<a class="code" href="structap__pixel.html#aadf7ee52df3875792fbf13d4d52ed298">p_y</a>);
<a name="l00687"></a>00687     }
<a name="l00688"></a>00688 
<a name="l00689"></a>00689   <span class="comment">// compute the dimension of the stamps</span>
<a name="l00690"></a>00690   dimensions.<a class="code" href="structdrzstamp__dim.html#a459626637b5697c339db9e2b31f3ded6">xsize</a> = max_px-min_px+1;
<a name="l00691"></a>00691   dimensions.<a class="code" href="structdrzstamp__dim.html#a8e268f2124d4cc8783fe4f37708bbe8f">ysize</a> = max_py-min_py+1;
<a name="l00692"></a>00692 
<a name="l00693"></a>00693   <span class="comment">// correct the dimesions if necessary</span>
<a name="l00694"></a>00694   <span class="keywordflow">if</span> (boxwidth &gt; dimensions.<a class="code" href="structdrzstamp__dim.html#a459626637b5697c339db9e2b31f3ded6">xsize</a>){
<a name="l00695"></a>00695     dimensions.<a class="code" href="structdrzstamp__dim.html#a459626637b5697c339db9e2b31f3ded6">xsize</a> = (long)boxwidth;
<a name="l00696"></a>00696   }
<a name="l00697"></a>00697   <span class="keywordflow">if</span> (boxheight &gt; dimensions.<a class="code" href="structdrzstamp__dim.html#a8e268f2124d4cc8783fe4f37708bbe8f">ysize</a>){
<a name="l00698"></a>00698     dimensions.<a class="code" href="structdrzstamp__dim.html#a8e268f2124d4cc8783fe4f37708bbe8f">ysize</a> = boxheight;
<a name="l00699"></a>00699   }
<a name="l00700"></a>00700 
<a name="l00701"></a>00701   <span class="comment">// fix the start coordinates</span>
<a name="l00702"></a>00702   dimensions.<a class="code" href="structdrzstamp__dim.html#af6df14c21230e289ef6abe7134de3cc3">xstart</a>= min_px;
<a name="l00703"></a>00703   dimensions.<a class="code" href="structdrzstamp__dim.html#a9ed53e0c679cabe8bd15189b7b9b7a62">ystart</a>= min_py;
<a name="l00704"></a>00704 
<a name="l00705"></a>00705   <span class="comment">// return the structure</span>
<a name="l00706"></a>00706   <span class="keywordflow">return</span> dimensions;
<a name="l00707"></a>00707 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a294f187040188cd530ca348373ae6b9f"></a><!-- doxytag: member="spce_output.h::get_maxxy_from_PET" ref="a294f187040188cd530ca348373ae6b9f" args="(const ap_pixel *const ap_p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structd__point.html">d_point</a> get_maxxy_from_PET </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structap__pixel.html">ap_pixel</a> *const &nbsp;</td>
          <td class="paramname"> <em>ap_p</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><div class="fragment"><pre class="fragment"><a name="l00164"></a>00164 {
<a name="l00165"></a>00165   <span class="keyword">const</span> <a class="code" href="structap__pixel.html">ap_pixel</a> *cur_p;
<a name="l00166"></a>00166   <span class="comment">//double min_px = 1e32;</span>
<a name="l00167"></a>00167   <span class="keywordtype">double</span> max_px = -1e32;
<a name="l00168"></a>00168   <span class="comment">//double min_py = 1e32;</span>
<a name="l00169"></a>00169   <span class="keywordtype">double</span> max_py = -1e32;
<a name="l00170"></a>00170   <a class="code" href="structd__point.html">d_point</a> res;
<a name="l00171"></a>00171 
<a name="l00172"></a>00172   <span class="comment">// return -1 in case of an empty PET</span>
<a name="l00173"></a>00173   <span class="keywordflow">if</span> (ap_p==NULL) {
<a name="l00174"></a>00174     res.<a class="code" href="structd__point.html#a922a3b5d82a119168ba85e5f939d02c3">x</a> = -1;
<a name="l00175"></a>00175     res.<a class="code" href="structd__point.html#ad9846a025508bf8873a501ca5fcefbf4">y</a> = -1;
<a name="l00176"></a>00176     <span class="keywordflow">return</span> res;
<a name="l00177"></a>00177   }
<a name="l00178"></a>00178 
<a name="l00179"></a>00179   <span class="comment">// go over each pixel, determine the maximum</span>
<a name="l00180"></a>00180   <span class="keywordflow">for</span> (cur_p = ap_p; cur_p-&gt;<a class="code" href="structap__pixel.html#abca28f0936fbd5a569ad548fb25e5a38">p_x</a> != -1; cur_p++)
<a name="l00181"></a>00181     {
<a name="l00182"></a>00182       max_px = <a class="code" href="aper__conf_8c.html#aacc3ee1a7f283f8ef65cea31f4436a95">MAX</a> (max_px, cur_p-&gt;<a class="code" href="structap__pixel.html#abca28f0936fbd5a569ad548fb25e5a38">p_x</a>);
<a name="l00183"></a>00183       max_py = <a class="code" href="aper__conf_8c.html#aacc3ee1a7f283f8ef65cea31f4436a95">MAX</a> (max_py, cur_p-&gt;<a class="code" href="structap__pixel.html#aadf7ee52df3875792fbf13d4d52ed298">p_y</a>);
<a name="l00184"></a>00184     }
<a name="l00185"></a>00185 
<a name="l00186"></a>00186   <span class="comment">// fill the return</span>
<a name="l00187"></a>00187   res.<a class="code" href="structd__point.html#a922a3b5d82a119168ba85e5f939d02c3">x</a> = max_px;
<a name="l00188"></a>00188   res.<a class="code" href="structd__point.html#ad9846a025508bf8873a501ca5fcefbf4">y</a> = max_py;
<a name="l00189"></a>00189 
<a name="l00190"></a>00190   <span class="comment">// return the result</span>
<a name="l00191"></a>00191   <span class="keywordflow">return</span> res;
<a name="l00192"></a>00192 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a727084323c00d05a5549164d2820c77e"></a><!-- doxytag: member="spce_output.h::get_minxy_from_PET" ref="a727084323c00d05a5549164d2820c77e" args="(const ap_pixel *const ap_p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structd__point.html">d_point</a> get_minxy_from_PET </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structap__pixel.html">ap_pixel</a> *const &nbsp;</td>
          <td class="paramname"> <em>ap_p</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><div class="fragment"><pre class="fragment"><a name="l00120"></a>00120 {
<a name="l00121"></a>00121   <span class="keyword">const</span> <a class="code" href="structap__pixel.html">ap_pixel</a> *cur_p;
<a name="l00122"></a>00122   <span class="keywordtype">double</span> min_px = 1e32;
<a name="l00123"></a>00123   <span class="comment">//double max_px = -1e32;</span>
<a name="l00124"></a>00124   <span class="keywordtype">double</span> min_py = 1e32;
<a name="l00125"></a>00125   <span class="comment">//double max_py = -1e32;</span>
<a name="l00126"></a>00126   <a class="code" href="structd__point.html">d_point</a> res;
<a name="l00127"></a>00127 
<a name="l00128"></a>00128   <span class="comment">// return -1 in case of an empty PET</span>
<a name="l00129"></a>00129   <span class="keywordflow">if</span> (ap_p==NULL) {
<a name="l00130"></a>00130     res.<a class="code" href="structd__point.html#a922a3b5d82a119168ba85e5f939d02c3">x</a> = -1;
<a name="l00131"></a>00131     res.<a class="code" href="structd__point.html#ad9846a025508bf8873a501ca5fcefbf4">y</a> = -1;
<a name="l00132"></a>00132     <span class="keywordflow">return</span> res;
<a name="l00133"></a>00133   }
<a name="l00134"></a>00134 
<a name="l00135"></a>00135   <span class="comment">// go over each pixel, determine the maximum</span>
<a name="l00136"></a>00136   <span class="keywordflow">for</span> (cur_p = ap_p; cur_p-&gt;<a class="code" href="structap__pixel.html#abca28f0936fbd5a569ad548fb25e5a38">p_x</a> != -1; cur_p++)
<a name="l00137"></a>00137     {
<a name="l00138"></a>00138       min_px = <a class="code" href="aXe__utils_8c.html#a74e75242132eaabbc1c512488a135926">MIN</a> (min_px, cur_p-&gt;<a class="code" href="structap__pixel.html#abca28f0936fbd5a569ad548fb25e5a38">p_x</a>);
<a name="l00139"></a>00139       min_py = <a class="code" href="aXe__utils_8c.html#a74e75242132eaabbc1c512488a135926">MIN</a> (min_py, cur_p-&gt;<a class="code" href="structap__pixel.html#aadf7ee52df3875792fbf13d4d52ed298">p_y</a>);
<a name="l00140"></a>00140     }
<a name="l00141"></a>00141 
<a name="l00142"></a>00142   <span class="comment">// fill the return</span>
<a name="l00143"></a>00143   res.<a class="code" href="structd__point.html#a922a3b5d82a119168ba85e5f939d02c3">x</a> = min_px;
<a name="l00144"></a>00144   res.<a class="code" href="structd__point.html#ad9846a025508bf8873a501ca5fcefbf4">y</a> = min_py;
<a name="l00145"></a>00145 
<a name="l00146"></a>00146   <span class="comment">// return the result</span>
<a name="l00147"></a>00147   <span class="keywordflow">return</span> res;
<a name="l00148"></a>00148 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a0b04392e15823b7d3e07a84cc698d56d"></a><!-- doxytag: member="spce_output.h::get_quad_from_pixel" ref="a0b04392e15823b7d3e07a84cc698d56d" args="(const ap_pixel *cur_p, const double orient, const drzstamp_dim dimension)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structquadrangle.html">quadrangle</a> get_quad_from_pixel </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structap__pixel.html">ap_pixel</a> *&nbsp;</td>
          <td class="paramname"> <em>cur_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>orient</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdrzstamp__dim.html">drzstamp_dim</a>&nbsp;</td>
          <td class="paramname"> <em>dimension</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Function: get_quad_from_pixel The subroutine creates a <a class="el" href="structquadrangle.html">quadrangle</a> for a PET pixel in the coordinate system of a drizzled stam image. The <a class="el" href="structquadrangle.html">quadrangle</a> later serves as an input to the boxer routine to resample the PET pixel. Form the math point of view, the generation of the quadrange corresponds to executing an affine transformation of the pixel (x,y) corners into the coordinate system spanned by the wavelength and the crossdispersion direction.</p>
<p>Parameters: </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>cur_p</em>&nbsp;</td><td>- the PET pixel to construct the <a class="el" href="structquadrangle.html">quadrangle</a> for </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dimension</em>&nbsp;</td><td>- the dimensions of the stamp image</td></tr>
  </table>
  </dd>
</dl>
<p>Returns: </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>quad - the filled <a class="el" href="structquadrangle.html">quadrangle</a> sturcture </dd></dl>

<p><div class="fragment"><pre class="fragment"><a name="l00861"></a>00861 {
<a name="l00862"></a>00862   <a class="code" href="structquadrangle.html">quadrangle</a> quad;
<a name="l00863"></a>00863 
<a name="l00864"></a>00864   <span class="keywordtype">double</span> dxi, ddist;
<a name="l00865"></a>00865   <span class="keywordtype">double</span> x, y;
<a name="l00866"></a>00866 
<a name="l00867"></a>00867   <span class="keywordtype">double</span> phi_1, phi_2;
<a name="l00868"></a>00868   <span class="keywordtype">double</span> cos_phi_1, sin_phi_1, tan_phi_2;
<a name="l00869"></a>00869   <span class="keywordtype">double</span> term_1, term_2;
<a name="l00870"></a>00870 
<a name="l00871"></a>00871   <span class="comment">// nomenclature: see contamination.dvi</span>
<a name="l00872"></a>00872   phi_1 = orient - 1.5707963267948966;  <span class="comment">// crossdispersion direction corresponds to beta; numeric=90deg in rad</span>
<a name="l00873"></a>00873   phi_2 = cur_p-&gt;<a class="code" href="structap__pixel.html#a92d9e84a233d0a1ad482830b23c5e5ba">dxs</a> - orient + 1.5707963267948966; <span class="comment">// traceangle corresponds to alpha</span>
<a name="l00874"></a>00874 
<a name="l00875"></a>00875   <span class="comment">// nomenclature: see contamination.dvi</span>
<a name="l00876"></a>00876   cos_phi_1 = cos(phi_1);
<a name="l00877"></a>00877   sin_phi_1 = sin(phi_1);
<a name="l00878"></a>00878   tan_phi_2 = tan(phi_2);
<a name="l00879"></a>00879 
<a name="l00880"></a>00880   <span class="comment">// nomenclature: see contamination.dvi</span>
<a name="l00881"></a>00881   term_1 = cos_phi_1*tan_phi_2 + sin_phi_1;
<a name="l00882"></a>00882   term_2 = cos_phi_1           - sin_phi_1*tan_phi_2;
<a name="l00883"></a>00883 
<a name="l00884"></a>00884   <span class="comment">// Bottom left corner (-.5, -.5):</span>
<a name="l00885"></a>00885   <span class="comment">// get the coos of that corner in the stamp image coo system</span>
<a name="l00886"></a>00886   x = -0.5;
<a name="l00887"></a>00887   y = -0.5;
<a name="l00888"></a>00888   dxi   = +x*cos_phi_1 + y*sin_phi_1;
<a name="l00889"></a>00889   ddist = -x*term_1    + y*term_2;
<a name="l00890"></a>00890   <span class="comment">/*** IMPORTANT:</span>
<a name="l00891"></a>00891 <span class="comment">   * the division by &quot;cos(cur_p-&gt;dxs)&quot; in the equations below is</span>
<a name="l00892"></a>00892 <span class="comment">   * is necessary to cover the whole lambda-crossdisp plane.</span>
<a name="l00893"></a>00893 <span class="comment">   * However then the counts are not anymore preserved.</span>
<a name="l00894"></a>00894 <span class="comment">   * This must be taken into account in the calling routine!!</span>
<a name="l00895"></a>00895 <span class="comment">   **/</span>
<a name="l00896"></a>00896   quad.<a class="code" href="structquadrangle.html#a2838cc41fa0d8d867757b05ed1cfdbc2">x</a>[0] = (cur_p-&gt;<a class="code" href="structap__pixel.html#ac36fd281b7d91081490e41ce07a60501">lambda</a> + cur_p-&gt;<a class="code" href="structap__pixel.html#a8c1c7b5a35a04145fccfc3f84c420cde">dlambda</a>*dxi/cos(cur_p-&gt;<a class="code" href="structap__pixel.html#a92d9e84a233d0a1ad482830b23c5e5ba">dxs</a>))/dimension.<a class="code" href="structdrzstamp__dim.html#ab3c0ed305132ecda42a1e8b6dad5ce27">resolution</a> - dimension.<a class="code" href="structdrzstamp__dim.html#af6df14c21230e289ef6abe7134de3cc3">xstart</a>;
<a name="l00897"></a>00897   quad.<a class="code" href="structquadrangle.html#a7a086b8fde718d39d81a1d0a5855beff">y</a>[0] = cur_p-&gt;<a class="code" href="structap__pixel.html#abd0f197da151fac01c9e4cbd4146f212">dist</a> + ddist - dimension.<a class="code" href="structdrzstamp__dim.html#a9ed53e0c679cabe8bd15189b7b9b7a62">ystart</a>;
<a name="l00898"></a>00898   <span class="comment">//  fprintf(stdout, &quot;%f %f\n&quot;, quad.x[0], quad.y[0]);</span>
<a name="l00899"></a>00899 
<a name="l00900"></a>00900   <span class="comment">// Top left corner (-.5, +.5):</span>
<a name="l00901"></a>00901   <span class="comment">// get the coos of that corner in the stamp image coo system</span>
<a name="l00902"></a>00902   x = -0.5;
<a name="l00903"></a>00903   y = +0.5;
<a name="l00904"></a>00904   dxi   = +x*cos_phi_1 + y*sin_phi_1;
<a name="l00905"></a>00905   ddist = -x*term_1    + y*term_2;
<a name="l00906"></a>00906   <span class="comment">//  quad.x[1] = cur_p-&gt;xi + dxi/cos(cur_p-&gt;dxs);</span>
<a name="l00907"></a>00907   quad.<a class="code" href="structquadrangle.html#a2838cc41fa0d8d867757b05ed1cfdbc2">x</a>[1] = (cur_p-&gt;<a class="code" href="structap__pixel.html#ac36fd281b7d91081490e41ce07a60501">lambda</a> + cur_p-&gt;<a class="code" href="structap__pixel.html#a8c1c7b5a35a04145fccfc3f84c420cde">dlambda</a>*dxi/cos(cur_p-&gt;<a class="code" href="structap__pixel.html#a92d9e84a233d0a1ad482830b23c5e5ba">dxs</a>))/dimension.<a class="code" href="structdrzstamp__dim.html#ab3c0ed305132ecda42a1e8b6dad5ce27">resolution</a> - dimension.<a class="code" href="structdrzstamp__dim.html#af6df14c21230e289ef6abe7134de3cc3">xstart</a>;
<a name="l00908"></a>00908   quad.<a class="code" href="structquadrangle.html#a7a086b8fde718d39d81a1d0a5855beff">y</a>[1] = cur_p-&gt;<a class="code" href="structap__pixel.html#abd0f197da151fac01c9e4cbd4146f212">dist</a> + ddist - dimension.<a class="code" href="structdrzstamp__dim.html#a9ed53e0c679cabe8bd15189b7b9b7a62">ystart</a>;
<a name="l00909"></a>00909 
<a name="l00910"></a>00910   <span class="comment">// Top right corner (+.5, +.5):</span>
<a name="l00911"></a>00911   <span class="comment">// get the coos of that corner in the stamp image coo system</span>
<a name="l00912"></a>00912   x = +0.5;
<a name="l00913"></a>00913   y = +0.5;
<a name="l00914"></a>00914   dxi   = +x*cos_phi_1 + y*sin_phi_1;
<a name="l00915"></a>00915   ddist = -x*term_1    + y*term_2;
<a name="l00916"></a>00916   quad.<a class="code" href="structquadrangle.html#a2838cc41fa0d8d867757b05ed1cfdbc2">x</a>[2] = (cur_p-&gt;<a class="code" href="structap__pixel.html#ac36fd281b7d91081490e41ce07a60501">lambda</a> + cur_p-&gt;<a class="code" href="structap__pixel.html#a8c1c7b5a35a04145fccfc3f84c420cde">dlambda</a>*dxi/cos(cur_p-&gt;<a class="code" href="structap__pixel.html#a92d9e84a233d0a1ad482830b23c5e5ba">dxs</a>))/dimension.<a class="code" href="structdrzstamp__dim.html#ab3c0ed305132ecda42a1e8b6dad5ce27">resolution</a> - dimension.<a class="code" href="structdrzstamp__dim.html#af6df14c21230e289ef6abe7134de3cc3">xstart</a>;
<a name="l00917"></a>00917   quad.<a class="code" href="structquadrangle.html#a7a086b8fde718d39d81a1d0a5855beff">y</a>[2] = cur_p-&gt;<a class="code" href="structap__pixel.html#abd0f197da151fac01c9e4cbd4146f212">dist</a> + ddist - dimension.<a class="code" href="structdrzstamp__dim.html#a9ed53e0c679cabe8bd15189b7b9b7a62">ystart</a>;
<a name="l00918"></a>00918 
<a name="l00919"></a>00919   <span class="comment">// Bottom right corner (+.5, -.5):</span>
<a name="l00920"></a>00920   <span class="comment">// get the coos of that corner in the stamp image coo system</span>
<a name="l00921"></a>00921   x = +0.5;
<a name="l00922"></a>00922   y = -0.5;
<a name="l00923"></a>00923   dxi   = +x*cos_phi_1 + y*sin_phi_1;
<a name="l00924"></a>00924   ddist = -x*term_1    + y*term_2;
<a name="l00925"></a>00925   quad.<a class="code" href="structquadrangle.html#a2838cc41fa0d8d867757b05ed1cfdbc2">x</a>[3] = (cur_p-&gt;<a class="code" href="structap__pixel.html#ac36fd281b7d91081490e41ce07a60501">lambda</a> + cur_p-&gt;<a class="code" href="structap__pixel.html#a8c1c7b5a35a04145fccfc3f84c420cde">dlambda</a>*dxi/cos(cur_p-&gt;<a class="code" href="structap__pixel.html#a92d9e84a233d0a1ad482830b23c5e5ba">dxs</a>))/dimension.<a class="code" href="structdrzstamp__dim.html#ab3c0ed305132ecda42a1e8b6dad5ce27">resolution</a> - dimension.<a class="code" href="structdrzstamp__dim.html#af6df14c21230e289ef6abe7134de3cc3">xstart</a>;
<a name="l00926"></a>00926   quad.<a class="code" href="structquadrangle.html#a7a086b8fde718d39d81a1d0a5855beff">y</a>[3] = cur_p-&gt;<a class="code" href="structap__pixel.html#abd0f197da151fac01c9e4cbd4146f212">dist</a> + ddist - dimension.<a class="code" href="structdrzstamp__dim.html#a9ed53e0c679cabe8bd15189b7b9b7a62">ystart</a>;
<a name="l00927"></a>00927 
<a name="l00928"></a>00928   <span class="comment">// get the maximum and minimum of the quadrangle</span>
<a name="l00929"></a>00929   <span class="comment">// in each dimension</span>
<a name="l00930"></a>00930   quad.<a class="code" href="structquadrangle.html#a07cdc1aa08d997f3ecf4a4527e1958b1">xmax</a> = <a class="code" href="aper__conf_8c.html#aacc3ee1a7f283f8ef65cea31f4436a95">MAX</a>(quad.<a class="code" href="structquadrangle.html#a2838cc41fa0d8d867757b05ed1cfdbc2">x</a>[3],<a class="code" href="aper__conf_8c.html#aacc3ee1a7f283f8ef65cea31f4436a95">MAX</a>(quad.<a class="code" href="structquadrangle.html#a2838cc41fa0d8d867757b05ed1cfdbc2">x</a>[2],<a class="code" href="aper__conf_8c.html#aacc3ee1a7f283f8ef65cea31f4436a95">MAX</a>(quad.<a class="code" href="structquadrangle.html#a2838cc41fa0d8d867757b05ed1cfdbc2">x</a>[1],quad.<a class="code" href="structquadrangle.html#a2838cc41fa0d8d867757b05ed1cfdbc2">x</a>[0])));
<a name="l00931"></a>00931   quad.<a class="code" href="structquadrangle.html#a4a693bbae5ab2389a2e89aba2cd1ec6c">xmin</a> = <a class="code" href="aXe__utils_8c.html#a74e75242132eaabbc1c512488a135926">MIN</a>(quad.<a class="code" href="structquadrangle.html#a2838cc41fa0d8d867757b05ed1cfdbc2">x</a>[3],<a class="code" href="aXe__utils_8c.html#a74e75242132eaabbc1c512488a135926">MIN</a>(quad.<a class="code" href="structquadrangle.html#a2838cc41fa0d8d867757b05ed1cfdbc2">x</a>[2],<a class="code" href="aXe__utils_8c.html#a74e75242132eaabbc1c512488a135926">MIN</a>(quad.<a class="code" href="structquadrangle.html#a2838cc41fa0d8d867757b05ed1cfdbc2">x</a>[1],quad.<a class="code" href="structquadrangle.html#a2838cc41fa0d8d867757b05ed1cfdbc2">x</a>[0])));
<a name="l00932"></a>00932   quad.<a class="code" href="structquadrangle.html#a9cd9de4d5ad81c686c3bbea6093d5f2a">ymax</a> = <a class="code" href="aper__conf_8c.html#aacc3ee1a7f283f8ef65cea31f4436a95">MAX</a>(quad.<a class="code" href="structquadrangle.html#a7a086b8fde718d39d81a1d0a5855beff">y</a>[3],<a class="code" href="aper__conf_8c.html#aacc3ee1a7f283f8ef65cea31f4436a95">MAX</a>(quad.<a class="code" href="structquadrangle.html#a7a086b8fde718d39d81a1d0a5855beff">y</a>[2],<a class="code" href="aper__conf_8c.html#aacc3ee1a7f283f8ef65cea31f4436a95">MAX</a>(quad.<a class="code" href="structquadrangle.html#a7a086b8fde718d39d81a1d0a5855beff">y</a>[1],quad.<a class="code" href="structquadrangle.html#a7a086b8fde718d39d81a1d0a5855beff">y</a>[0])));
<a name="l00933"></a>00933   quad.<a class="code" href="structquadrangle.html#a28f1d44685c1b1fc1302c23fa53e3c82">ymin</a> = <a class="code" href="aXe__utils_8c.html#a74e75242132eaabbc1c512488a135926">MIN</a>(quad.<a class="code" href="structquadrangle.html#a7a086b8fde718d39d81a1d0a5855beff">y</a>[3],<a class="code" href="aXe__utils_8c.html#a74e75242132eaabbc1c512488a135926">MIN</a>(quad.<a class="code" href="structquadrangle.html#a7a086b8fde718d39d81a1d0a5855beff">y</a>[2],<a class="code" href="aXe__utils_8c.html#a74e75242132eaabbc1c512488a135926">MIN</a>(quad.<a class="code" href="structquadrangle.html#a7a086b8fde718d39d81a1d0a5855beff">y</a>[1],quad.<a class="code" href="structquadrangle.html#a7a086b8fde718d39d81a1d0a5855beff">y</a>[0])));
<a name="l00934"></a>00934 
<a name="l00935"></a>00935   <span class="keywordflow">return</span> quad;
<a name="l00936"></a>00936 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="aece0dc2dd2738020829c96e9413f5494"></a><!-- doxytag: member="spce_output.h::get_stamp_dim" ref="aece0dc2dd2738020829c96e9413f5494" args="(const ap_pixel *const ap_p, float width, aperture_conf *conf, const int beamID, d_point *stp_min)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdrzstamp__dim.html">drzstamp_dim</a> get_stamp_dim </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structap__pixel.html">ap_pixel</a> *const &nbsp;</td>
          <td class="paramname"> <em>ap_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structaperture__conf.html">aperture_conf</a> *&nbsp;</td>
          <td class="paramname"> <em>conf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>beamID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structd__point.html">d_point</a> *&nbsp;</td>
          <td class="paramname"> <em>stp_min</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Function: get_stamp_dim The function computes the dimensional properties of the drizzled stamp image associated to a <a class="el" href="structbeam.html">beam</a>. Those properties fix the image size, dispersion and the offsets in both coordinates</p>
<p>Parameters: </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ap_p</em>&nbsp;</td><td>- the list of <a class="el" href="structbeam.html">beam</a> pixels to find the diemnsions for </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>width</em>&nbsp;</td><td>- the extraction width of the <a class="el" href="structbeam.html">beam</a> </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>conf</em>&nbsp;</td><td>- the configuration structure </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>beamID</em>&nbsp;</td><td>- the the <a class="el" href="structbeam.html">beam</a> ID</td></tr>
  </table>
  </dd>
</dl>
<p>Returns: </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>dimensions - the filled <a class="el" href="structquadrangle.html">quadrangle</a> sturcture </dd></dl>

<p><div class="fragment"><pre class="fragment"><a name="l00728"></a>00728 {
<a name="l00729"></a>00729   <a class="code" href="structdrzstamp__dim.html">drzstamp_dim</a> dimensions;
<a name="l00730"></a>00730 
<a name="l00731"></a>00731   <span class="keyword">const</span> <a class="code" href="structap__pixel.html">ap_pixel</a> *cur_p;
<a name="l00732"></a>00732 
<a name="l00733"></a>00733   <span class="keywordtype">double</span> min_lam  = 1e32;
<a name="l00734"></a>00734   <span class="keywordtype">double</span> max_lam  = -1e32;
<a name="l00735"></a>00735   <span class="keywordtype">double</span> min_xi   = 1e32;
<a name="l00736"></a>00736   <span class="keywordtype">double</span> max_xi   = -1e32;
<a name="l00737"></a>00737   <span class="keywordtype">double</span> min_dist = 1e32;
<a name="l00738"></a>00738   <span class="keywordtype">double</span> max_dist = -1e32;
<a name="l00739"></a>00739   <span class="keywordtype">double</span> min_dlam = 1e32;
<a name="l00740"></a>00740   <span class="keywordtype">double</span> max_dlam = -1e32;
<a name="l00741"></a>00741 
<a name="l00742"></a>00742   <span class="comment">//double resampwidth = 0.0;</span>
<a name="l00743"></a>00743 
<a name="l00744"></a>00744   <span class="comment">//long xsize,ysize,j;</span>
<a name="l00745"></a>00745   <span class="keywordtype">long</span> npixel=0;
<a name="l00746"></a>00746 
<a name="l00747"></a>00747   <span class="comment">// check whether there are entries;</span>
<a name="l00748"></a>00748   <span class="comment">// if not, return a dummy structure</span>
<a name="l00749"></a>00749   <span class="keywordflow">if</span> (ap_p==NULL)
<a name="l00750"></a>00750     {
<a name="l00751"></a>00751       dimensions.<a class="code" href="structdrzstamp__dim.html#ab3c0ed305132ecda42a1e8b6dad5ce27">resolution</a>=0.0;
<a name="l00752"></a>00752 
<a name="l00753"></a>00753       dimensions.<a class="code" href="structdrzstamp__dim.html#af6df14c21230e289ef6abe7134de3cc3">xstart</a>=0.0;
<a name="l00754"></a>00754       dimensions.<a class="code" href="structdrzstamp__dim.html#a9ed53e0c679cabe8bd15189b7b9b7a62">ystart</a>=0.0;
<a name="l00755"></a>00755 
<a name="l00756"></a>00756       dimensions.<a class="code" href="structdrzstamp__dim.html#a459626637b5697c339db9e2b31f3ded6">xsize</a>=0;
<a name="l00757"></a>00757       dimensions.<a class="code" href="structdrzstamp__dim.html#a8e268f2124d4cc8783fe4f37708bbe8f">ysize</a>=0;
<a name="l00758"></a>00758 
<a name="l00759"></a>00759       <span class="keywordflow">return</span> dimensions;
<a name="l00760"></a>00760     }
<a name="l00761"></a>00761 
<a name="l00762"></a>00762 
<a name="l00763"></a>00763   <span class="comment">// reset the pixel counter</span>
<a name="l00764"></a>00764   npixel=0;
<a name="l00765"></a>00765 
<a name="l00766"></a>00766   <span class="comment">// go over each pixel</span>
<a name="l00767"></a>00767   <span class="keywordflow">for</span> (cur_p = ap_p; cur_p-&gt;<a class="code" href="structap__pixel.html#abca28f0936fbd5a569ad548fb25e5a38">p_x</a> != -1; cur_p++)
<a name="l00768"></a>00768     {
<a name="l00769"></a>00769 
<a name="l00770"></a>00770       <span class="comment">// Skip the pixel if it was not actually used</span>
<a name="l00771"></a>00771       <span class="keywordflow">if</span> (fabs(cur_p-&gt;<a class="code" href="structap__pixel.html#abd0f197da151fac01c9e4cbd4146f212">dist</a>)&gt;width+.5)
<a name="l00772"></a>00772         <span class="keywordflow">continue</span>;
<a name="l00773"></a>00773 
<a name="l00774"></a>00774       <span class="comment">// search for minimum/maximum in wavelength</span>
<a name="l00775"></a>00775       min_lam = <a class="code" href="aXe__utils_8c.html#a74e75242132eaabbc1c512488a135926">MIN</a> (min_lam, cur_p-&gt;<a class="code" href="structap__pixel.html#ac36fd281b7d91081490e41ce07a60501">lambda</a>);
<a name="l00776"></a>00776       max_lam = <a class="code" href="aper__conf_8c.html#aacc3ee1a7f283f8ef65cea31f4436a95">MAX</a> (max_lam, cur_p-&gt;<a class="code" href="structap__pixel.html#ac36fd281b7d91081490e41ce07a60501">lambda</a>);
<a name="l00777"></a>00777 
<a name="l00778"></a>00778       <span class="comment">// search for minimum/maximum in crossdispersion direction</span>
<a name="l00779"></a>00779       min_dist = <a class="code" href="aXe__utils_8c.html#a74e75242132eaabbc1c512488a135926">MIN</a> (min_dist, cur_p-&gt;<a class="code" href="structap__pixel.html#abd0f197da151fac01c9e4cbd4146f212">dist</a>);
<a name="l00780"></a>00780       max_dist = <a class="code" href="aper__conf_8c.html#aacc3ee1a7f283f8ef65cea31f4436a95">MAX</a> (max_dist, cur_p-&gt;<a class="code" href="structap__pixel.html#abd0f197da151fac01c9e4cbd4146f212">dist</a>);
<a name="l00781"></a>00781 
<a name="l00782"></a>00782       <span class="comment">// search for minimum/maximum in dispersion</span>
<a name="l00783"></a>00783       min_dlam = <a class="code" href="aXe__utils_8c.html#a74e75242132eaabbc1c512488a135926">MIN</a> (min_dlam, cur_p-&gt;<a class="code" href="structap__pixel.html#a8c1c7b5a35a04145fccfc3f84c420cde">dlambda</a>);
<a name="l00784"></a>00784       max_dlam = <a class="code" href="aper__conf_8c.html#aacc3ee1a7f283f8ef65cea31f4436a95">MAX</a> (max_dlam, cur_p-&gt;<a class="code" href="structap__pixel.html#a8c1c7b5a35a04145fccfc3f84c420cde">dlambda</a>);
<a name="l00785"></a>00785 
<a name="l00786"></a>00786       <span class="comment">// enhance the pixel counter</span>
<a name="l00787"></a>00787       npixel++;
<a name="l00788"></a>00788     }
<a name="l00789"></a>00789 
<a name="l00790"></a>00790   <span class="comment">// in case there were no valid pixels,</span>
<a name="l00791"></a>00791   <span class="comment">// return a dummy structure</span>
<a name="l00792"></a>00792   <span class="keywordflow">if</span> (!npixel)
<a name="l00793"></a>00793     {
<a name="l00794"></a>00794       dimensions.<a class="code" href="structdrzstamp__dim.html#ab3c0ed305132ecda42a1e8b6dad5ce27">resolution</a>=0.0;
<a name="l00795"></a>00795 
<a name="l00796"></a>00796       dimensions.<a class="code" href="structdrzstamp__dim.html#af6df14c21230e289ef6abe7134de3cc3">xstart</a>=0.0;
<a name="l00797"></a>00797       dimensions.<a class="code" href="structdrzstamp__dim.html#a9ed53e0c679cabe8bd15189b7b9b7a62">ystart</a>=0.0;
<a name="l00798"></a>00798 
<a name="l00799"></a>00799       dimensions.<a class="code" href="structdrzstamp__dim.html#a459626637b5697c339db9e2b31f3ded6">xsize</a>=0;
<a name="l00800"></a>00800       dimensions.<a class="code" href="structdrzstamp__dim.html#a8e268f2124d4cc8783fe4f37708bbe8f">ysize</a>=0;
<a name="l00801"></a>00801 
<a name="l00802"></a>00802       <span class="keywordflow">return</span> dimensions;
<a name="l00803"></a>00803     }
<a name="l00804"></a>00804 
<a name="l00805"></a>00805   <span class="comment">// fill the resolution value</span>
<a name="l00806"></a>00806   <span class="comment">// if the drizzle resolution is defined in the</span>
<a name="l00807"></a>00807   <span class="comment">// configuration file and it is a first order beam</span>
<a name="l00808"></a>00808   <span class="keywordflow">if</span> (conf-&gt;<a class="code" href="structaperture__conf.html#a0fb034d1b39c351699420312b2c58d76">drz_resol</a> &amp;&amp; !beamID)
<a name="l00809"></a>00809     <span class="comment">// take the drizzle value from the config file</span>
<a name="l00810"></a>00810     dimensions.<a class="code" href="structdrzstamp__dim.html#ab3c0ed305132ecda42a1e8b6dad5ce27">resolution</a> = (double)conf-&gt;<a class="code" href="structaperture__conf.html#a0fb034d1b39c351699420312b2c58d76">drz_resol</a>;
<a name="l00811"></a>00811   <span class="comment">// otherwise</span>
<a name="l00812"></a>00812   <span class="keywordflow">else</span>
<a name="l00813"></a>00813     <span class="comment">// take the average resoution</span>
<a name="l00814"></a>00814     dimensions.<a class="code" href="structdrzstamp__dim.html#ab3c0ed305132ecda42a1e8b6dad5ce27">resolution</a> = (max_dlam+min_dlam)/2.0;
<a name="l00815"></a>00815 
<a name="l00816"></a>00816   <span class="comment">// round up and off in crossdispersion direction</span>
<a name="l00817"></a>00817   min_dist = floor(min_dist);
<a name="l00818"></a>00818   max_dist = ceil(max_dist);
<a name="l00819"></a>00819 
<a name="l00820"></a>00820   <span class="comment">// round up and off in dispersion direction</span>
<a name="l00821"></a>00821   min_xi = floor(min_lam/dimensions.<a class="code" href="structdrzstamp__dim.html#ab3c0ed305132ecda42a1e8b6dad5ce27">resolution</a>);
<a name="l00822"></a>00822   max_xi = ceil(max_lam/dimensions.<a class="code" href="structdrzstamp__dim.html#ab3c0ed305132ecda42a1e8b6dad5ce27">resolution</a>);
<a name="l00823"></a>00823 
<a name="l00824"></a>00824   <span class="comment">// derive and store the stamp image dimensions</span>
<a name="l00825"></a>00825   dimensions.<a class="code" href="structdrzstamp__dim.html#a459626637b5697c339db9e2b31f3ded6">xsize</a> = max_xi-min_xi+2;
<a name="l00826"></a>00826   dimensions.<a class="code" href="structdrzstamp__dim.html#a8e268f2124d4cc8783fe4f37708bbe8f">ysize</a> = max_dist-min_dist+2;
<a name="l00827"></a>00827 
<a name="l00828"></a>00828   <span class="comment">// store the start values</span>
<a name="l00829"></a>00829   dimensions.<a class="code" href="structdrzstamp__dim.html#af6df14c21230e289ef6abe7134de3cc3">xstart</a> = min_xi;
<a name="l00830"></a>00830   dimensions.<a class="code" href="structdrzstamp__dim.html#a9ed53e0c679cabe8bd15189b7b9b7a62">ystart</a> = min_dist;
<a name="l00831"></a>00831 
<a name="l00832"></a>00832   stp_min-&gt;<a class="code" href="structd__point.html#a922a3b5d82a119168ba85e5f939d02c3">x</a> = min_xi * dimensions.<a class="code" href="structdrzstamp__dim.html#ab3c0ed305132ecda42a1e8b6dad5ce27">resolution</a>;
<a name="l00833"></a>00833   stp_min-&gt;<a class="code" href="structd__point.html#ad9846a025508bf8873a501ca5fcefbf4">y</a> = min_dist;
<a name="l00834"></a>00834 
<a name="l00835"></a>00835   <span class="comment">// return the structure</span>
<a name="l00836"></a>00836   <span class="keywordflow">return</span> dimensions;
<a name="l00837"></a>00837 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a487a01f9e88471517124284a4047bd44"></a><!-- doxytag: member="spce_output.h::get_trace_inds" ref="a487a01f9e88471517124284a4047bd44" args="(const ap_pixel *const ap_p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gsl_vector_int* get_trace_inds </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structap__pixel.html">ap_pixel</a> *const &nbsp;</td>
          <td class="paramname"> <em>ap_p</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Find the indices of pixels corresponding to the trace (i.e. the one with the smallest dist in each column). If we get traces with a slope of significantly more than one, a similar function would have to be written operating on rows.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ap_p</em>&nbsp;</td><td>the aperture pixel table </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a gsl_matrix with the indices of the trace pixels in ap_p </dd></dl>

<p><div class="fragment"><pre class="fragment"><a name="l01238"></a>01238 {
<a name="l01239"></a>01239   <span class="keyword">const</span> <a class="code" href="structap__pixel.html">ap_pixel</a> *cur_p;
<a name="l01240"></a>01240   <span class="keywordtype">int</span> trace_resolution = 10000; <span class="comment">/* Number of xi bins in which to follow the</span>
<a name="l01241"></a>01241 <span class="comment">                                   trace */</span>
<a name="l01242"></a>01242   gsl_vector_int *trace_inds = gsl_vector_int_alloc (trace_resolution);
<a name="l01243"></a>01243   gsl_vector_int *trace_inds2;
<a name="l01244"></a>01244   <span class="keywordtype">int</span> n, i;
<a name="l01245"></a>01245   <span class="keywordtype">double</span> distmin;
<a name="l01246"></a>01246 
<a name="l01247"></a>01247   gsl_vector_int_set_all (trace_inds, -1);
<a name="l01248"></a>01248 
<a name="l01249"></a>01249   <span class="comment">/* Find the minimum pixel-to-trace distance in this aperture */</span>
<a name="l01250"></a>01250   distmin = 1e32;
<a name="l01251"></a>01251   <span class="keywordflow">for</span> (cur_p = ap_p; cur_p-&gt;<a class="code" href="structap__pixel.html#abca28f0936fbd5a569ad548fb25e5a38">p_x</a> != -1; cur_p++)
<a name="l01252"></a>01252     {
<a name="l01253"></a>01253       distmin = <a class="code" href="aXe__utils_8c.html#a74e75242132eaabbc1c512488a135926">MIN</a> (distmin, fabs(cur_p-&gt;<a class="code" href="structap__pixel.html#abd0f197da151fac01c9e4cbd4146f212">dist</a>));
<a name="l01254"></a>01254     }
<a name="l01255"></a>01255 
<a name="l01256"></a>01256   n = 0;
<a name="l01257"></a>01257   <span class="keywordflow">for</span> (cur_p = ap_p; cur_p-&gt;<a class="code" href="structap__pixel.html#abca28f0936fbd5a569ad548fb25e5a38">p_x</a> != -1; cur_p++)
<a name="l01258"></a>01258     {
<a name="l01259"></a>01259       <span class="keywordflow">if</span> (fabs(cur_p-&gt;<a class="code" href="structap__pixel.html#abd0f197da151fac01c9e4cbd4146f212">dist</a>) &lt; (distmin + .25))
<a name="l01260"></a>01260         {
<a name="l01261"></a>01261           gsl_vector_int_set (trace_inds, n, cur_p - ap_p);
<a name="l01262"></a>01262           n++;
<a name="l01263"></a>01263         }
<a name="l01264"></a>01264     }
<a name="l01265"></a>01265   trace_inds2 = gsl_vector_int_alloc (n);
<a name="l01266"></a>01266   n = 0;
<a name="l01267"></a>01267   <span class="keywordflow">for</span> (i = 0; i &lt; trace_inds-&gt;size; i++)
<a name="l01268"></a>01268     {
<a name="l01269"></a>01269       <span class="keywordflow">if</span> (gsl_vector_int_get (trace_inds, i) != -1)
<a name="l01270"></a>01270         {
<a name="l01271"></a>01271           gsl_vector_int_set (trace_inds2, n,
<a name="l01272"></a>01272                               gsl_vector_int_get (trace_inds, i));
<a name="l01273"></a>01273           n++;
<a name="l01274"></a>01274         }
<a name="l01275"></a>01275     }
<a name="l01276"></a>01276 
<a name="l01277"></a>01277   <span class="keywordflow">return</span> trace_inds2;
<a name="l01278"></a>01278 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a863b4bf317f0bd06437963cd958db9ba"></a><!-- doxytag: member="spce_output.h::interpolate_over_NaN" ref="a863b4bf317f0bd06437963cd958db9ba" args="(gsl_matrix *data)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void interpolate_over_NaN </td>
          <td>(</td>
          <td class="paramtype">gsl_matrix *&nbsp;</td>
          <td class="paramname"> <em>data</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Function: interpolate_over_NaN Function to interpolate over and replace NaN values in a rectified stamp image. This is done by interpolating in the vertical direction. The original gsl_matrix is free'd and is replaced by a new gsl_matrix pointer. Does nothing if input data is NULL.</p>
<p>Parameters: </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>data</em>&nbsp;</td><td>- the gsl_matrix where NaN values are to be interpolated over </td></tr>
  </table>
  </dd>
</dl>

<p><div class="fragment"><pre class="fragment"><a name="l01128"></a>01128 {
<a name="l01129"></a>01129   <span class="keywordtype">double</span> *x,*y;
<a name="l01130"></a>01130   <span class="keywordtype">int</span> i,j,n;
<a name="l01131"></a>01131   gsl_interp_accel *acc;
<a name="l01132"></a>01132   gsl_spline *spline ;
<a name="l01133"></a>01133 
<a name="l01134"></a>01134   <span class="keywordflow">if</span> (data==NULL) <span class="keywordflow">return</span>;
<a name="l01135"></a>01135 
<a name="l01136"></a>01136   x = malloc(<span class="keyword">sizeof</span>(<span class="keywordtype">double</span>)*data-&gt;size2*data-&gt;size1);
<a name="l01137"></a>01137   y = malloc(<span class="keyword">sizeof</span>(<span class="keywordtype">double</span>)*data-&gt;size2*data-&gt;size1);
<a name="l01138"></a>01138 
<a name="l01139"></a>01139   <span class="keywordflow">for</span> (i=0;i&lt;data-&gt;size1;i++) {
<a name="l01140"></a>01140     n = 0;
<a name="l01141"></a>01141     <span class="keywordflow">for</span> (j=0;j&lt;data-&gt;size2;j++) {
<a name="l01142"></a>01142       <span class="keywordflow">if</span> ( !isnan(<a class="code" href="aXe__grism_8h.html#acf709ee71c580f1cd65d726ed03200ea">gsl_matrix_get</a>(data,i,j)) )  {
<a name="l01143"></a>01143         x[n] = j;
<a name="l01144"></a>01144         y[n] = <a class="code" href="aXe__grism_8h.html#acf709ee71c580f1cd65d726ed03200ea">gsl_matrix_get</a>(data,i,j);
<a name="l01145"></a>01145         n++;
<a name="l01146"></a>01146       }
<a name="l01147"></a>01147     }
<a name="l01148"></a>01148     <span class="comment">//if (n&lt;data-&gt;size2) fprintf(stderr,&quot;%d elements non-NaN found out of %d.\n&quot;,n,data-&gt;size2);</span>
<a name="l01149"></a>01149     <span class="keywordflow">if</span> (n&lt;3) <span class="keywordflow">continue</span>;
<a name="l01150"></a>01150 
<a name="l01151"></a>01151     acc = gsl_interp_accel_alloc ();
<a name="l01152"></a>01152     spline = gsl_spline_alloc (gsl_interp_cspline, n);
<a name="l01153"></a>01153 
<a name="l01154"></a>01154     <span class="comment">/* Interpolating */</span>
<a name="l01155"></a>01155     gsl_spline_init (spline, x, y, n);
<a name="l01156"></a>01156 
<a name="l01157"></a>01157     <span class="keywordflow">for</span> (j=0;j&lt;data-&gt;size2;j++) {
<a name="l01158"></a>01158       <span class="keywordtype">double</span> xi = j;
<a name="l01159"></a>01159       <span class="keywordtype">double</span> yi = gsl_spline_eval(spline,xi,acc);
<a name="l01160"></a>01160       <span class="comment">//if (n&lt;data-&gt;size2)  fprintf(stderr,&quot;%d %g =&gt; %d %g\n&quot;,j,gsl_matrix_get(data,i,j),j,yi);</span>
<a name="l01161"></a>01161       <a class="code" href="aXe__grism_8h.html#a1f386ef5cd5a3b916246c2bee80f083a">gsl_matrix_set</a>(data,i,j,yi);
<a name="l01162"></a>01162     }
<a name="l01163"></a>01163     gsl_spline_free (spline);
<a name="l01164"></a>01164     gsl_interp_accel_free(acc);
<a name="l01165"></a>01165   }
<a name="l01166"></a>01166 
<a name="l01167"></a>01167   free(x);
<a name="l01168"></a>01168   free(y);
<a name="l01169"></a>01169 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="acfb8de045d5147f405aac44a201d51a1"></a><!-- doxytag: member="spce_output.h::rectified_stamp_img" ref="acfb8de045d5147f405aac44a201d51a1" args="(const ap_pixel *const ap_p, float width, d_point *stp_min)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gsl_matrix* rectified_stamp_img </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structap__pixel.html">ap_pixel</a> *const &nbsp;</td>
          <td class="paramname"> <em>ap_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structd__point.html">d_point</a> *&nbsp;</td>
          <td class="paramname"> <em>stp_min</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Function: rectified_stamp_img Produce a gsl array containing a 'rectified aperture'. That is, an image of the spectum showing count on an xi,dist grid instead of the traditional image grid x,y. Returns NULL is input <a class="el" href="structobject.html">object</a> is NULL.</p>
<p>Parameters: </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ap_p</em>&nbsp;</td><td>- a pointer to a -1 terminated <a class="el" href="structap__pixel.html">ap_pixel</a> array </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>width</em>&nbsp;</td><td>- extraction width used</td></tr>
  </table>
  </dd>
</dl>
<p>Returns: </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>res - a pointer to a newly allocated gsl_matrix containing the rectified <a class="el" href="structspectrum.html">spectrum</a> </dd></dl>

<p><div class="fragment"><pre class="fragment"><a name="l00395"></a>00395 {
<a name="l00396"></a>00396   <span class="keyword">const</span> <a class="code" href="structap__pixel.html">ap_pixel</a> *cur_p;
<a name="l00397"></a>00397   <span class="keywordtype">double</span> min_xi = 1e32;
<a name="l00398"></a>00398   <span class="keywordtype">double</span> max_xi = -1e32;
<a name="l00399"></a>00399   <span class="keywordtype">double</span> min_dist = 1e32;
<a name="l00400"></a>00400   <span class="keywordtype">double</span> max_dist = -1e32;
<a name="l00401"></a>00401   <a class="code" href="aXe__grism_8h.html#a6117e17bb3108107676f4486e62d40e5">gsl_matrix</a> *res;
<a name="l00402"></a>00402   <span class="keywordtype">long</span> xsize,ysize,i,j,n=0;
<a name="l00403"></a>00403 
<a name="l00404"></a>00404   <span class="keywordflow">if</span> (ap_p==NULL) {
<a name="l00405"></a>00405     <span class="comment">/* Create a dummy stamp image */</span>
<a name="l00406"></a>00406     res = <a class="code" href="aXe__grism_8h.html#a1214ab1bea5fd80474d7a27db0bfb429">gsl_matrix_alloc</a>(10,10);
<a name="l00407"></a>00407     <span class="comment">/* Fill stamp with 0.0 values */</span>
<a name="l00408"></a>00408     <a class="code" href="aXe__grism_8h.html#af6161aeb008a1ffa7d888df6ccbef7cc">gsl_matrix_set_all</a>(res, 0.0);
<a name="l00409"></a>00409     <span class="keywordflow">return</span> res;
<a name="l00410"></a>00410   }
<a name="l00411"></a>00411 
<a name="l00412"></a>00412   i=0;
<a name="l00413"></a>00413   <span class="keywordflow">for</span> (cur_p = ap_p; cur_p-&gt;<a class="code" href="structap__pixel.html#abca28f0936fbd5a569ad548fb25e5a38">p_x</a> != -1; cur_p++)
<a name="l00414"></a>00414     {
<a name="l00415"></a>00415       <span class="keywordflow">if</span> (fabs(cur_p-&gt;<a class="code" href="structap__pixel.html#abd0f197da151fac01c9e4cbd4146f212">dist</a>)&gt;width+.5) <span class="keywordflow">continue</span>; <span class="comment">/* Skip this pixel if it was not actually used */</span>
<a name="l00416"></a>00416       i++;
<a name="l00417"></a>00417       min_xi = <a class="code" href="aXe__utils_8c.html#a74e75242132eaabbc1c512488a135926">MIN</a> (min_xi, cur_p-&gt;<a class="code" href="structap__pixel.html#aeae2e14e0f53bd1090acb2a8758104a5">xi</a>);
<a name="l00418"></a>00418       max_xi = <a class="code" href="aper__conf_8c.html#aacc3ee1a7f283f8ef65cea31f4436a95">MAX</a> (max_xi, cur_p-&gt;<a class="code" href="structap__pixel.html#aeae2e14e0f53bd1090acb2a8758104a5">xi</a>);
<a name="l00419"></a>00419       min_dist = <a class="code" href="aXe__utils_8c.html#a74e75242132eaabbc1c512488a135926">MIN</a> (min_dist, cur_p-&gt;<a class="code" href="structap__pixel.html#abd0f197da151fac01c9e4cbd4146f212">dist</a>);
<a name="l00420"></a>00420       max_dist = <a class="code" href="aper__conf_8c.html#aacc3ee1a7f283f8ef65cea31f4436a95">MAX</a> (max_dist, cur_p-&gt;<a class="code" href="structap__pixel.html#abd0f197da151fac01c9e4cbd4146f212">dist</a>);
<a name="l00421"></a>00421       n++;
<a name="l00422"></a>00422     }
<a name="l00423"></a>00423 
<a name="l00424"></a>00424   <span class="keywordflow">if</span> (i==0) {
<a name="l00425"></a>00425     <span class="comment">/* Create a dummy stamp image */</span>
<a name="l00426"></a>00426     res = <a class="code" href="aXe__grism_8h.html#a1214ab1bea5fd80474d7a27db0bfb429">gsl_matrix_alloc</a>(10,10);
<a name="l00427"></a>00427     <span class="comment">/* Fill stamp with 0.0 values */</span>
<a name="l00428"></a>00428     <a class="code" href="aXe__grism_8h.html#af6161aeb008a1ffa7d888df6ccbef7cc">gsl_matrix_set_all</a>(res, 0.0);
<a name="l00429"></a>00429     <span class="keywordflow">return</span> res;
<a name="l00430"></a>00430   }
<a name="l00431"></a>00431 
<a name="l00432"></a>00432   min_dist = floor(min_dist);
<a name="l00433"></a>00433   max_dist = floor(max_dist);
<a name="l00434"></a>00434   min_xi = floor(min_xi);
<a name="l00435"></a>00435   max_xi = floor(max_xi);
<a name="l00436"></a>00436 
<a name="l00437"></a>00437   <span class="comment">// compute the array dimensions</span>
<a name="l00438"></a>00438   xsize = max_xi-min_xi+2;
<a name="l00439"></a>00439   ysize = max_dist-min_dist+2;
<a name="l00440"></a>00440 
<a name="l00441"></a>00441   <span class="comment">// store the minima in both coords</span>
<a name="l00442"></a>00442   stp_min-&gt;<a class="code" href="structd__point.html#a922a3b5d82a119168ba85e5f939d02c3">x</a> = min_xi;
<a name="l00443"></a>00443   stp_min-&gt;<a class="code" href="structd__point.html#ad9846a025508bf8873a501ca5fcefbf4">y</a> = min_dist;
<a name="l00444"></a>00444 
<a name="l00445"></a>00445   <span class="keywordflow">if</span> (n&gt;0)
<a name="l00446"></a>00446     {
<a name="l00447"></a>00447       res = <a class="code" href="aXe__grism_8h.html#a1214ab1bea5fd80474d7a27db0bfb429">gsl_matrix_alloc</a>(xsize,ysize);
<a name="l00448"></a>00448     } <span class="keywordflow">else</span> {
<a name="l00449"></a>00449       <span class="comment">/* Create a dummy stamp image */</span>
<a name="l00450"></a>00450       res = <a class="code" href="aXe__grism_8h.html#a1214ab1bea5fd80474d7a27db0bfb429">gsl_matrix_alloc</a>(10,10);
<a name="l00451"></a>00451       <span class="comment">/* Fill stamp with 0.0 values */</span>
<a name="l00452"></a>00452       <a class="code" href="aXe__grism_8h.html#af6161aeb008a1ffa7d888df6ccbef7cc">gsl_matrix_set_all</a>(res, 0.0);
<a name="l00453"></a>00453       <span class="keywordflow">return</span> res;
<a name="l00454"></a>00454     }
<a name="l00455"></a>00455 
<a name="l00456"></a>00456   res = <a class="code" href="aXe__grism_8h.html#a1214ab1bea5fd80474d7a27db0bfb429">gsl_matrix_alloc</a>(xsize,ysize);
<a name="l00457"></a>00457   <span class="comment">/* Fill stamp with NaN values */</span>
<a name="l00458"></a>00458   <a class="code" href="aXe__grism_8h.html#af6161aeb008a1ffa7d888df6ccbef7cc">gsl_matrix_set_all</a>(res, GSL_NAN);
<a name="l00459"></a>00459 
<a name="l00460"></a>00460 
<a name="l00461"></a>00461   <span class="keywordflow">for</span> (cur_p = ap_p; cur_p-&gt;<a class="code" href="structap__pixel.html#abca28f0936fbd5a569ad548fb25e5a38">p_x</a> != -1; cur_p++)
<a name="l00462"></a>00462     {
<a name="l00463"></a>00463       <span class="keywordflow">if</span> (fabs(cur_p-&gt;<a class="code" href="structap__pixel.html#abd0f197da151fac01c9e4cbd4146f212">dist</a>)&gt;width+.5) <span class="keywordflow">continue</span>; <span class="comment">/* Skip this pixel if it was not actually used */</span>
<a name="l00464"></a>00464       i = (long) floor(cur_p-&gt;<a class="code" href="structap__pixel.html#aeae2e14e0f53bd1090acb2a8758104a5">xi</a> - min_xi+.5);
<a name="l00465"></a>00465       j = (long) floor(cur_p-&gt;<a class="code" href="structap__pixel.html#abd0f197da151fac01c9e4cbd4146f212">dist</a> - min_dist+.5);
<a name="l00466"></a>00466       <span class="comment">//fprintf(stderr,&quot;i: %d j: %d\n&quot;,i,j);</span>
<a name="l00467"></a>00467       <a class="code" href="aXe__grism_8h.html#a1f386ef5cd5a3b916246c2bee80f083a">gsl_matrix_set</a>(res,i,j,cur_p-&gt;<a class="code" href="structap__pixel.html#a846018a7e3b143259419bd74e2d9073f">count</a>);
<a name="l00468"></a>00468     }
<a name="l00469"></a>00469 
<a name="l00470"></a>00470   <span class="keywordflow">return</span> res;
<a name="l00471"></a>00471 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="adecd7e61360bb4de56f06143b2f070ac"></a><!-- doxytag: member="spce_output.h::stamp_img" ref="adecd7e61360bb4de56f06143b2f070ac" args="(const ap_pixel *const ap_p, float width, d_point *stp_min)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gsl_matrix* stamp_img </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structap__pixel.html">ap_pixel</a> *const &nbsp;</td>
          <td class="paramname"> <em>ap_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structd__point.html">d_point</a> *&nbsp;</td>
          <td class="paramname"> <em>stp_min</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Function: stamp_img Produce a gsl array containing a stamp image. Returns NULL is input <a class="el" href="structobject.html">object</a> is NULL.</p>
<p>Parameters: </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ap_p</em>&nbsp;</td><td>- a pointer to a -1 terminated <a class="el" href="structap__pixel.html">ap_pixel</a> array </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>width</em>&nbsp;</td><td>- extraction width used </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>stp_min</em>&nbsp;</td><td>- xy-coords of the lower left corner on image</td></tr>
  </table>
  </dd>
</dl>
<p>Returns: </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>res - a pointer to a newly allocated gsl_matrix containing the <a class="el" href="structspectrum.html">spectrum</a> </dd></dl>

<p><div class="fragment"><pre class="fragment"><a name="l00045"></a>00045 {
<a name="l00046"></a>00046   <span class="keyword">const</span> <a class="code" href="structap__pixel.html">ap_pixel</a> *cur_p;
<a name="l00047"></a>00047   <span class="keywordtype">double</span> min_px = 1e32;
<a name="l00048"></a>00048   <span class="keywordtype">double</span> max_px = -1e32;
<a name="l00049"></a>00049   <span class="keywordtype">double</span> min_py = 1e32;
<a name="l00050"></a>00050   <span class="keywordtype">double</span> max_py = -1e32;
<a name="l00051"></a>00051   <a class="code" href="aXe__grism_8h.html#a6117e17bb3108107676f4486e62d40e5">gsl_matrix</a> *res;
<a name="l00052"></a>00052   <span class="keywordtype">long</span> xsize,ysize,i,j,n=0;
<a name="l00053"></a>00053 
<a name="l00054"></a>00054   <span class="keywordflow">if</span> (ap_p==NULL) {
<a name="l00055"></a>00055     <span class="comment">/* Create a dummy stamp image */</span>
<a name="l00056"></a>00056     res = <a class="code" href="aXe__grism_8h.html#a1214ab1bea5fd80474d7a27db0bfb429">gsl_matrix_alloc</a>(10,10);
<a name="l00057"></a>00057     <span class="comment">/* Fill stamp with 0.0 values */</span>
<a name="l00058"></a>00058     <a class="code" href="aXe__grism_8h.html#af6161aeb008a1ffa7d888df6ccbef7cc">gsl_matrix_set_all</a>(res, 0.0);
<a name="l00059"></a>00059 
<a name="l00060"></a>00060     <span class="keywordflow">return</span> res;
<a name="l00061"></a>00061   }
<a name="l00062"></a>00062 
<a name="l00063"></a>00063   <span class="keywordflow">for</span> (cur_p = ap_p; cur_p-&gt;<a class="code" href="structap__pixel.html#abca28f0936fbd5a569ad548fb25e5a38">p_x</a> != -1; cur_p++)
<a name="l00064"></a>00064     {
<a name="l00065"></a>00065       <span class="keywordflow">if</span> (fabs(cur_p-&gt;<a class="code" href="structap__pixel.html#abd0f197da151fac01c9e4cbd4146f212">dist</a>)&gt;width+.5) <span class="keywordflow">continue</span>; <span class="comment">/* Skip this pixel if it was not actually used */</span>
<a name="l00066"></a>00066       min_px = <a class="code" href="aXe__utils_8c.html#a74e75242132eaabbc1c512488a135926">MIN</a> (min_px, cur_p-&gt;<a class="code" href="structap__pixel.html#abca28f0936fbd5a569ad548fb25e5a38">p_x</a>);
<a name="l00067"></a>00067       max_px = <a class="code" href="aper__conf_8c.html#aacc3ee1a7f283f8ef65cea31f4436a95">MAX</a> (max_px, cur_p-&gt;<a class="code" href="structap__pixel.html#abca28f0936fbd5a569ad548fb25e5a38">p_x</a>);
<a name="l00068"></a>00068       min_py = <a class="code" href="aXe__utils_8c.html#a74e75242132eaabbc1c512488a135926">MIN</a> (min_py, cur_p-&gt;<a class="code" href="structap__pixel.html#aadf7ee52df3875792fbf13d4d52ed298">p_y</a>);
<a name="l00069"></a>00069       max_py = <a class="code" href="aper__conf_8c.html#aacc3ee1a7f283f8ef65cea31f4436a95">MAX</a> (max_py, cur_p-&gt;<a class="code" href="structap__pixel.html#aadf7ee52df3875792fbf13d4d52ed298">p_y</a>);
<a name="l00070"></a>00070       n++;
<a name="l00071"></a>00071     }
<a name="l00072"></a>00072 
<a name="l00073"></a>00073   xsize = max_px-min_px+2;
<a name="l00074"></a>00074   ysize = max_py-min_py+2;
<a name="l00075"></a>00075 
<a name="l00076"></a>00076   stp_min-&gt;<a class="code" href="structd__point.html#a922a3b5d82a119168ba85e5f939d02c3">x</a> = min_px;
<a name="l00077"></a>00077   stp_min-&gt;<a class="code" href="structd__point.html#ad9846a025508bf8873a501ca5fcefbf4">y</a> = min_py;
<a name="l00078"></a>00078 
<a name="l00079"></a>00079   <span class="keywordflow">if</span> (n&gt;0)
<a name="l00080"></a>00080     {
<a name="l00081"></a>00081       res = <a class="code" href="aXe__grism_8h.html#a1214ab1bea5fd80474d7a27db0bfb429">gsl_matrix_alloc</a>(xsize,ysize);
<a name="l00082"></a>00082     } <span class="keywordflow">else</span> {
<a name="l00083"></a>00083       <span class="comment">/* Create a dummy stamp image */</span>
<a name="l00084"></a>00084       res = <a class="code" href="aXe__grism_8h.html#a1214ab1bea5fd80474d7a27db0bfb429">gsl_matrix_alloc</a>(10,10);
<a name="l00085"></a>00085       <span class="comment">/* Fill stamp with 0.0 values */</span>
<a name="l00086"></a>00086       <a class="code" href="aXe__grism_8h.html#af6161aeb008a1ffa7d888df6ccbef7cc">gsl_matrix_set_all</a>(res, 0.0);
<a name="l00087"></a>00087       <span class="keywordflow">return</span> res;
<a name="l00088"></a>00088     }
<a name="l00089"></a>00089 
<a name="l00090"></a>00090   <span class="comment">/* Fill stamp with NaN values */</span>
<a name="l00091"></a>00091   <a class="code" href="aXe__grism_8h.html#af6161aeb008a1ffa7d888df6ccbef7cc">gsl_matrix_set_all</a>(res, 0.0);
<a name="l00092"></a>00092   <span class="keywordflow">for</span> (cur_p = ap_p; cur_p-&gt;<a class="code" href="structap__pixel.html#abca28f0936fbd5a569ad548fb25e5a38">p_x</a> != -1; cur_p++)
<a name="l00093"></a>00093     {
<a name="l00094"></a>00094       <span class="keywordflow">if</span> (fabs(cur_p-&gt;<a class="code" href="structap__pixel.html#abd0f197da151fac01c9e4cbd4146f212">dist</a>)&gt;width+.5) <span class="keywordflow">continue</span>; <span class="comment">/* Skip this pixel if it was not actually used */</span>
<a name="l00095"></a>00095       i = (long) floor(cur_p-&gt;<a class="code" href="structap__pixel.html#abca28f0936fbd5a569ad548fb25e5a38">p_x</a> - min_px+.5);
<a name="l00096"></a>00096       j = (long) floor(cur_p-&gt;<a class="code" href="structap__pixel.html#aadf7ee52df3875792fbf13d4d52ed298">p_y</a> - min_py+.5);
<a name="l00097"></a>00097       <span class="keywordflow">if</span> ((i&lt;0) || (i&gt;=xsize)) <span class="keywordflow">continue</span>;
<a name="l00098"></a>00098       <span class="keywordflow">if</span> ((j&lt;0) || (j&gt;=ysize)) <span class="keywordflow">continue</span>;
<a name="l00099"></a>00099 
<a name="l00100"></a>00100       <span class="comment">//fprintf(stderr,&quot;i: %d j: %d\n&quot;,i,j);</span>
<a name="l00101"></a>00101       <a class="code" href="aXe__grism_8h.html#a1f386ef5cd5a3b916246c2bee80f083a">gsl_matrix_set</a>(res,i,j,cur_p-&gt;<a class="code" href="structap__pixel.html#a846018a7e3b143259419bd74e2d9073f">count</a>);
<a name="l00102"></a>00102     }
<a name="l00103"></a>00103 
<a name="l00104"></a>00104   <span class="keywordflow">return</span> res;
<a name="l00105"></a>00105 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ae73fef882d3f2e909f83b4d9784eaba8"></a><!-- doxytag: member="spce_output.h::stamp_img_drzprep" ref="ae73fef882d3f2e909f83b4d9784eaba8" args="(const int opt_extr, const ap_pixel *const ap_p, const ap_pixel *const se_p, float width, float nullval, int usemode, drzstamp_dim dimension, gsl_matrix *drzcoeffs, double exptime, double sky_cps, double rdnoise, const int bckmode)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdrzprep.html">drzprep</a>* stamp_img_drzprep </td>
          <td>(</td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>opt_extr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structap__pixel.html">ap_pixel</a> *const &nbsp;</td>
          <td class="paramname"> <em>ap_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structap__pixel.html">ap_pixel</a> *const &nbsp;</td>
          <td class="paramname"> <em>se_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>nullval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>quant_cont</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdrzstamp__dim.html">drzstamp_dim</a>&nbsp;</td>
          <td class="paramname"> <em>dimension</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gsl_matrix *&nbsp;</td>
          <td class="paramname"> <em>drzcoeffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>exptime</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>sky_cps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>rdnoise</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>bckmode</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Function: stamp_img_drzprep Creates all drizzle prepare stamp images from a PET vector. In case of an empty PET, dummy stamps are returned.</p>
<p>Parameters: </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>opt_extr</em>&nbsp;</td><td>- flagg to indicate optimal extraction </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ap_p</em>&nbsp;</td><td>- a pointer to a -1 terminated <a class="el" href="structap__pixel.html">ap_pixel</a> array </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>width</em>&nbsp;</td><td>- extraction width used </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nullval</em>&nbsp;</td><td>- the default pixel value </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>quant_cont</em>&nbsp;</td><td>- flag to indicate quantitative cont. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dimension</em>&nbsp;</td><td>- size information </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>drzcoeffs</em>&nbsp;</td><td>- the drizzle coefficients </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>exptime</em>&nbsp;</td><td>- the exposure time </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>sky_cps</em>&nbsp;</td><td>- the sky background</td></tr>
  </table>
  </dd>
</dl>
<p>Returns: </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>drzprep_stamps - a pointer to the new struct with the <a class="el" href="structdrzprep.html">drzprep</a> stamp images </dd></dl>

<p><div class="fragment"><pre class="fragment"><a name="l00219"></a>00219 {
<a name="l00220"></a>00220   <a class="code" href="structdrzprep.html">drzprep</a> *drzprep_stamps;
<a name="l00221"></a>00221   <span class="keyword">const</span> <a class="code" href="structap__pixel.html">ap_pixel</a> *cur_p;
<a name="l00222"></a>00222   <span class="keyword">const</span> <a class="code" href="structap__pixel.html">ap_pixel</a> *xxx_p;
<a name="l00223"></a>00223 
<a name="l00224"></a>00224   <span class="keywordtype">int</span> i, j;
<a name="l00225"></a>00225 
<a name="l00226"></a>00226   <span class="keywordtype">double</span> var;
<a name="l00227"></a>00227   <span class="keywordtype">double</span> corr;
<a name="l00228"></a>00228   <span class="keywordtype">double</span> sqr_expt;
<a name="l00229"></a>00229   <span class="keywordtype">double</span> sqr_rdns;
<a name="l00230"></a>00230 
<a name="l00231"></a>00231   <span class="comment">// allocate space for the output structure</span>
<a name="l00232"></a>00232   drzprep_stamps = (<a class="code" href="structdrzprep.html">drzprep</a> *)malloc(<span class="keyword">sizeof</span>(<a class="code" href="structdrzprep.html">drzprep</a>));
<a name="l00233"></a>00233 
<a name="l00234"></a>00234   <span class="keywordflow">if</span> (ap_p==NULL) {
<a name="l00235"></a>00235 
<a name="l00236"></a>00236     <span class="comment">// create a dummy count image and set it to default</span>
<a name="l00237"></a>00237     drzprep_stamps-&gt;<a class="code" href="structdrzprep.html#a215f7390764932e09f5589bf97c52aec">counts</a> = <a class="code" href="aXe__grism_8h.html#a1214ab1bea5fd80474d7a27db0bfb429">gsl_matrix_alloc</a>(10,10);
<a name="l00238"></a>00238     <a class="code" href="aXe__grism_8h.html#af6161aeb008a1ffa7d888df6ccbef7cc">gsl_matrix_set_all</a>(drzprep_stamps-&gt;<a class="code" href="structdrzprep.html#a215f7390764932e09f5589bf97c52aec">counts</a>, nullval);
<a name="l00239"></a>00239 
<a name="l00240"></a>00240     <span class="comment">// create a dummy error image and set it to default</span>
<a name="l00241"></a>00241     drzprep_stamps-&gt;<a class="code" href="structdrzprep.html#a105921a3d8442eacc2a7f6f98e8d06f9">error</a> = <a class="code" href="aXe__grism_8h.html#a1214ab1bea5fd80474d7a27db0bfb429">gsl_matrix_alloc</a>(10,10);
<a name="l00242"></a>00242     <a class="code" href="aXe__grism_8h.html#af6161aeb008a1ffa7d888df6ccbef7cc">gsl_matrix_set_all</a>(drzprep_stamps-&gt;<a class="code" href="structdrzprep.html#a105921a3d8442eacc2a7f6f98e8d06f9">error</a>, nullval);
<a name="l00243"></a>00243 
<a name="l00244"></a>00244     <span class="comment">// create a dummy contamination image and set it to default</span>
<a name="l00245"></a>00245     drzprep_stamps-&gt;<a class="code" href="structdrzprep.html#a65b1b1ebedbc949e2536415ac83b5427">cont</a> = <a class="code" href="aXe__grism_8h.html#a1214ab1bea5fd80474d7a27db0bfb429">gsl_matrix_alloc</a>(10,10);
<a name="l00246"></a>00246     <a class="code" href="aXe__grism_8h.html#af6161aeb008a1ffa7d888df6ccbef7cc">gsl_matrix_set_all</a>(drzprep_stamps-&gt;<a class="code" href="structdrzprep.html#a65b1b1ebedbc949e2536415ac83b5427">cont</a>, nullval);
<a name="l00247"></a>00247 
<a name="l00248"></a>00248     <span class="comment">// create a dummy model image and set it to default</span>
<a name="l00249"></a>00249     drzprep_stamps-&gt;<a class="code" href="structdrzprep.html#ad0fd183b34cc7ee92112db1a31185fb6">model</a> = <a class="code" href="aXe__grism_8h.html#a1214ab1bea5fd80474d7a27db0bfb429">gsl_matrix_alloc</a>(10,10);
<a name="l00250"></a>00250     <a class="code" href="aXe__grism_8h.html#af6161aeb008a1ffa7d888df6ccbef7cc">gsl_matrix_set_all</a>(drzprep_stamps-&gt;<a class="code" href="structdrzprep.html#ad0fd183b34cc7ee92112db1a31185fb6">model</a>, nullval);
<a name="l00251"></a>00251 
<a name="l00252"></a>00252     <span class="comment">// create a dummy model image and set it to default</span>
<a name="l00253"></a>00253     drzprep_stamps-&gt;<a class="code" href="structdrzprep.html#a0039f4cd84c8b2f6c0ea10cac1bc1b37">vari</a> = <a class="code" href="aXe__grism_8h.html#a1214ab1bea5fd80474d7a27db0bfb429">gsl_matrix_alloc</a>(10,10);
<a name="l00254"></a>00254     <a class="code" href="aXe__grism_8h.html#af6161aeb008a1ffa7d888df6ccbef7cc">gsl_matrix_set_all</a>(drzprep_stamps-&gt;<a class="code" href="structdrzprep.html#a0039f4cd84c8b2f6c0ea10cac1bc1b37">vari</a>, nullval);
<a name="l00255"></a>00255 
<a name="l00256"></a>00256     <span class="keywordflow">return</span> drzprep_stamps;
<a name="l00257"></a>00257   }
<a name="l00258"></a>00258 
<a name="l00259"></a>00259   <span class="comment">// allocate the count matrix and fill it with default value</span>
<a name="l00260"></a>00260   drzprep_stamps-&gt;<a class="code" href="structdrzprep.html#a215f7390764932e09f5589bf97c52aec">counts</a>  = <a class="code" href="aXe__grism_8h.html#a1214ab1bea5fd80474d7a27db0bfb429">gsl_matrix_alloc</a>(dimension.<a class="code" href="structdrzstamp__dim.html#a459626637b5697c339db9e2b31f3ded6">xsize</a>, dimension.<a class="code" href="structdrzstamp__dim.html#a8e268f2124d4cc8783fe4f37708bbe8f">ysize</a>);
<a name="l00261"></a>00261   <a class="code" href="aXe__grism_8h.html#af6161aeb008a1ffa7d888df6ccbef7cc">gsl_matrix_set_all</a>(drzprep_stamps-&gt;<a class="code" href="structdrzprep.html#a215f7390764932e09f5589bf97c52aec">counts</a>, nullval);
<a name="l00262"></a>00262 
<a name="l00263"></a>00263   <span class="comment">// allocate the error matrix and fill it with default value</span>
<a name="l00264"></a>00264   drzprep_stamps-&gt;<a class="code" href="structdrzprep.html#a105921a3d8442eacc2a7f6f98e8d06f9">error</a>  = <a class="code" href="aXe__grism_8h.html#a1214ab1bea5fd80474d7a27db0bfb429">gsl_matrix_alloc</a>(dimension.<a class="code" href="structdrzstamp__dim.html#a459626637b5697c339db9e2b31f3ded6">xsize</a>, dimension.<a class="code" href="structdrzstamp__dim.html#a8e268f2124d4cc8783fe4f37708bbe8f">ysize</a>);
<a name="l00265"></a>00265   <a class="code" href="aXe__grism_8h.html#af6161aeb008a1ffa7d888df6ccbef7cc">gsl_matrix_set_all</a>(drzprep_stamps-&gt;<a class="code" href="structdrzprep.html#a105921a3d8442eacc2a7f6f98e8d06f9">error</a>, 0.0);
<a name="l00266"></a>00266 
<a name="l00267"></a>00267   <span class="comment">// allocate the contamination matrix and fill it with default value</span>
<a name="l00268"></a>00268   drzprep_stamps-&gt;<a class="code" href="structdrzprep.html#a65b1b1ebedbc949e2536415ac83b5427">cont</a>  = <a class="code" href="aXe__grism_8h.html#a1214ab1bea5fd80474d7a27db0bfb429">gsl_matrix_alloc</a>(dimension.<a class="code" href="structdrzstamp__dim.html#a459626637b5697c339db9e2b31f3ded6">xsize</a>, dimension.<a class="code" href="structdrzstamp__dim.html#a8e268f2124d4cc8783fe4f37708bbe8f">ysize</a>);
<a name="l00269"></a>00269   <a class="code" href="aXe__grism_8h.html#af6161aeb008a1ffa7d888df6ccbef7cc">gsl_matrix_set_all</a>(drzprep_stamps-&gt;<a class="code" href="structdrzprep.html#a65b1b1ebedbc949e2536415ac83b5427">cont</a>, 0.0);
<a name="l00270"></a>00270 
<a name="l00271"></a>00271   <span class="comment">// set the two extentions</span>
<a name="l00272"></a>00272   <span class="comment">// which are only somethimes</span>
<a name="l00273"></a>00273   <span class="comment">// used to NULL</span>
<a name="l00274"></a>00274   drzprep_stamps-&gt;<a class="code" href="structdrzprep.html#ad0fd183b34cc7ee92112db1a31185fb6">model</a>  = NULL;
<a name="l00275"></a>00275   drzprep_stamps-&gt;<a class="code" href="structdrzprep.html#a0039f4cd84c8b2f6c0ea10cac1bc1b37">vari</a>  = NULL;
<a name="l00276"></a>00276 
<a name="l00277"></a>00277   <span class="keywordflow">if</span> (opt_extr)
<a name="l00278"></a>00278     {
<a name="l00279"></a>00279       <span class="comment">// allocate the mode; matrix and fill it with default value</span>
<a name="l00280"></a>00280       drzprep_stamps-&gt;<a class="code" href="structdrzprep.html#ad0fd183b34cc7ee92112db1a31185fb6">model</a>  = <a class="code" href="aXe__grism_8h.html#a1214ab1bea5fd80474d7a27db0bfb429">gsl_matrix_alloc</a>(dimension.<a class="code" href="structdrzstamp__dim.html#a459626637b5697c339db9e2b31f3ded6">xsize</a>, dimension.<a class="code" href="structdrzstamp__dim.html#a8e268f2124d4cc8783fe4f37708bbe8f">ysize</a>);
<a name="l00281"></a>00281       <a class="code" href="aXe__grism_8h.html#af6161aeb008a1ffa7d888df6ccbef7cc">gsl_matrix_set_all</a>(drzprep_stamps-&gt;<a class="code" href="structdrzprep.html#ad0fd183b34cc7ee92112db1a31185fb6">model</a>, 0.0);
<a name="l00282"></a>00282 
<a name="l00283"></a>00283       <span class="comment">// allocate the mode; matrix and fill it with default value</span>
<a name="l00284"></a>00284       drzprep_stamps-&gt;<a class="code" href="structdrzprep.html#a0039f4cd84c8b2f6c0ea10cac1bc1b37">vari</a>  = <a class="code" href="aXe__grism_8h.html#a1214ab1bea5fd80474d7a27db0bfb429">gsl_matrix_alloc</a>(dimension.<a class="code" href="structdrzstamp__dim.html#a459626637b5697c339db9e2b31f3ded6">xsize</a>, dimension.<a class="code" href="structdrzstamp__dim.html#a8e268f2124d4cc8783fe4f37708bbe8f">ysize</a>);
<a name="l00285"></a>00285       <a class="code" href="aXe__grism_8h.html#af6161aeb008a1ffa7d888df6ccbef7cc">gsl_matrix_set_all</a>(drzprep_stamps-&gt;<a class="code" href="structdrzprep.html#a0039f4cd84c8b2f6c0ea10cac1bc1b37">vari</a>, 0.0);
<a name="l00286"></a>00286     }
<a name="l00287"></a>00287 
<a name="l00288"></a>00288   <span class="comment">// square the exposure time for speed</span>
<a name="l00289"></a>00289   sqr_expt = exptime*exptime;
<a name="l00290"></a>00290   sqr_rdns = rdnoise*rdnoise;
<a name="l00291"></a>00291 
<a name="l00292"></a>00292   <span class="comment">// go over each PET pixel</span>
<a name="l00293"></a>00293   <span class="keywordflow">if</span> (opt_extr &amp;&amp; bckmode)
<a name="l00294"></a>00294     xxx_p = se_p;
<a name="l00295"></a>00295   <span class="keywordflow">for</span> (cur_p = ap_p; cur_p-&gt;<a class="code" href="structap__pixel.html#abca28f0936fbd5a569ad548fb25e5a38">p_x</a> != -1; cur_p++)
<a name="l00296"></a>00296     {
<a name="l00297"></a>00297 
<a name="l00298"></a>00298       <span class="comment">// compute the coordinates in the stamp images</span>
<a name="l00299"></a>00299       <span class="comment">// if (fabs(cur_p-&gt;dist)&gt;width+.5) continue; /* Skip this pixel if it was not actually used */</span>
<a name="l00300"></a>00300       i = (int)(cur_p-&gt;<a class="code" href="structap__pixel.html#abca28f0936fbd5a569ad548fb25e5a38">p_x</a> - dimension.<a class="code" href="structdrzstamp__dim.html#af6df14c21230e289ef6abe7134de3cc3">xstart</a>);
<a name="l00301"></a>00301       j = (int)(cur_p-&gt;<a class="code" href="structap__pixel.html#aadf7ee52df3875792fbf13d4d52ed298">p_y</a> - dimension.<a class="code" href="structdrzstamp__dim.html#a9ed53e0c679cabe8bd15189b7b9b7a62">ystart</a>);
<a name="l00302"></a>00302 
<a name="l00303"></a>00303 
<a name="l00304"></a>00304       <span class="comment">// check whether the coordinates are inside</span>
<a name="l00305"></a>00305       <span class="keywordflow">if</span> ((i&lt;0) || (i&gt;=dimension.<a class="code" href="structdrzstamp__dim.html#a459626637b5697c339db9e2b31f3ded6">xsize</a>) || (j&lt;0) || (j&gt;=dimension.<a class="code" href="structdrzstamp__dim.html#a8e268f2124d4cc8783fe4f37708bbe8f">ysize</a>))
<a name="l00306"></a>00306         {
<a name="l00307"></a>00307           <span class="keywordflow">if</span> (opt_extr &amp;&amp; bckmode)
<a name="l00308"></a>00308             xxx_p++;
<a name="l00309"></a>00309         <span class="keywordflow">continue</span>;
<a name="l00310"></a>00310         }
<a name="l00311"></a>00311 
<a name="l00312"></a>00312       <span class="comment">// comute the jacobian of the drizzle coefficients</span>
<a name="l00313"></a>00313       corr = fabs(<a class="code" href="crossdisp__utils_8c.html#af2009fe7bc8f5da56261aab4baf9146a">get_det_jacobian</a>(i+1, j+1, drzcoeffs, (<span class="keywordtype">int</span>)dimension.<a class="code" href="structdrzstamp__dim.html#a459626637b5697c339db9e2b31f3ded6">xsize</a>,(<span class="keywordtype">int</span>)dimension.<a class="code" href="structdrzstamp__dim.html#a8e268f2124d4cc8783fe4f37708bbe8f">ysize</a>));
<a name="l00314"></a>00314 
<a name="l00315"></a>00315       <span class="comment">//      fprintf(stdout, &quot;corr: %f\n&quot;, corr);</span>
<a name="l00316"></a>00316       <span class="comment">// compute the count value</span>
<a name="l00317"></a>00317       <a class="code" href="aXe__grism_8h.html#a1f386ef5cd5a3b916246c2bee80f083a">gsl_matrix_set</a>(drzprep_stamps-&gt;<a class="code" href="structdrzprep.html#a215f7390764932e09f5589bf97c52aec">counts</a>,i,j,(cur_p-&gt;<a class="code" href="structap__pixel.html#a846018a7e3b143259419bd74e2d9073f">count</a>)/corr);
<a name="l00318"></a>00318 
<a name="l00319"></a>00319       <span class="comment">// aXe-1.4</span>
<a name="l00320"></a>00320       <span class="comment">// compute the true error value in electrons</span>
<a name="l00321"></a>00321       <a class="code" href="aXe__grism_8h.html#a1f386ef5cd5a3b916246c2bee80f083a">gsl_matrix_set</a>(drzprep_stamps-&gt;<a class="code" href="structdrzprep.html#a105921a3d8442eacc2a7f6f98e8d06f9">error</a>,i,j,(cur_p-&gt;<a class="code" href="structap__pixel.html#a70b0f2e20878570616d81ffac4c15c68">error</a>*cur_p-&gt;<a class="code" href="structap__pixel.html#a70b0f2e20878570616d81ffac4c15c68">error</a>*sqr_expt)/corr);
<a name="l00322"></a>00322 
<a name="l00323"></a>00323 
<a name="l00324"></a>00324       <span class="comment">// inverse variance weighting:</span>
<a name="l00325"></a>00325       <span class="comment">// compute the error value</span>
<a name="l00326"></a>00326       <span class="comment">//gsl_matrix_set(drzprep_stamps-&gt;error,i,j,(1.0/(cur_p-&gt;error*cur_p-&gt;error)));</span>
<a name="l00327"></a>00327 
<a name="l00328"></a>00328       <span class="comment">// compute the contamination value</span>
<a name="l00329"></a>00329       <span class="keywordflow">if</span> (quant_cont)
<a name="l00330"></a>00330         <a class="code" href="aXe__grism_8h.html#a1f386ef5cd5a3b916246c2bee80f083a">gsl_matrix_set</a>(drzprep_stamps-&gt;<a class="code" href="structdrzprep.html#a65b1b1ebedbc949e2536415ac83b5427">cont</a>,i,j,(cur_p-&gt;<a class="code" href="structap__pixel.html#a2191ef670b1b5c515fda841dda181f62">contam</a>)/corr);
<a name="l00331"></a>00331       <span class="keywordflow">else</span>
<a name="l00332"></a>00332         <a class="code" href="aXe__grism_8h.html#a1f386ef5cd5a3b916246c2bee80f083a">gsl_matrix_set</a>(drzprep_stamps-&gt;<a class="code" href="structdrzprep.html#a65b1b1ebedbc949e2536415ac83b5427">cont</a>,i,j,(cur_p-&gt;<a class="code" href="structap__pixel.html#a2191ef670b1b5c515fda841dda181f62">contam</a>));
<a name="l00333"></a>00333 
<a name="l00334"></a>00334       <span class="keywordflow">if</span> (opt_extr)
<a name="l00335"></a>00335         {
<a name="l00336"></a>00336 
<a name="l00337"></a>00337           <span class="keywordflow">if</span> (bckmode)
<a name="l00338"></a>00338             {
<a name="l00339"></a>00339               <span class="comment">// check that the foreground and background</span>
<a name="l00340"></a>00340               <span class="comment">// PET element describe the same pixel</span>
<a name="l00341"></a>00341               <span class="keywordflow">if</span> (xxx_p-&gt;<a class="code" href="structap__pixel.html#a0ce028c33a28f543bd9255324800e9ea">x</a> != cur_p-&gt;<a class="code" href="structap__pixel.html#a0ce028c33a28f543bd9255324800e9ea">x</a> || xxx_p-&gt;<a class="code" href="structap__pixel.html#a1df90884734bfaea8ec545b69d802281">y</a> != cur_p-&gt;<a class="code" href="structap__pixel.html#a1df90884734bfaea8ec545b69d802281">y</a>)
<a name="l00342"></a>00342                 <a class="code" href="aXe__errors_8c.html#a7ef7588e5f91237ba7ce4084e6ed3c11">aXe_message</a> (<a class="code" href="aXe__errors_8h.html#a2556a67874555249b07691c37aa6d6e9">aXe_M_FATAL</a>, __FILE__, __LINE__,
<a name="l00343"></a>00343                              <span class="stringliteral">&quot;aXe_DRZPREP: Background PET and Object PET &quot;</span>
<a name="l00344"></a>00344                              <span class="stringliteral">&quot;have different pixel orders in PET&apos;s.\n&quot;</span>);
<a name="l00345"></a>00345 
<a name="l00346"></a>00346               <span class="comment">// compute the inverse variance value for the object PET</span>
<a name="l00347"></a>00347               <span class="comment">// derived from the noise characteristics</span>
<a name="l00348"></a>00348               var = ((xxx_p-&gt;<a class="code" href="structap__pixel.html#ada106f5981b17786de87cfeb2a7db0d1">model</a>+xxx_p-&gt;<a class="code" href="structap__pixel.html#a2191ef670b1b5c515fda841dda181f62">contam</a>+sky_cps+cur_p-&gt;<a class="code" href="structap__pixel.html#a846018a7e3b143259419bd74e2d9073f">count</a>)*exptime + sqr_rdns)/sqr_expt;
<a name="l00349"></a>00349               <span class="comment">//              var = cur_p-&gt;count*exptime / sqr_expt;</span>
<a name="l00350"></a>00350 
<a name="l00351"></a>00351               <span class="comment">// compute the model value</span>
<a name="l00352"></a>00352               <a class="code" href="aXe__grism_8h.html#a1f386ef5cd5a3b916246c2bee80f083a">gsl_matrix_set</a>(drzprep_stamps-&gt;<a class="code" href="structdrzprep.html#ad0fd183b34cc7ee92112db1a31185fb6">model</a>,i,j,(xxx_p-&gt;<a class="code" href="structap__pixel.html#ada106f5981b17786de87cfeb2a7db0d1">model</a>/corr));
<a name="l00353"></a>00353             }
<a name="l00354"></a>00354           <span class="keywordflow">else</span>
<a name="l00355"></a>00355             {
<a name="l00356"></a>00356               <span class="comment">// compute the inverse variance value for the object PET</span>
<a name="l00357"></a>00357               <span class="comment">// derived from the noise characteristics</span>
<a name="l00358"></a>00358               var = ((cur_p-&gt;<a class="code" href="structap__pixel.html#ada106f5981b17786de87cfeb2a7db0d1">model</a>+cur_p-&gt;<a class="code" href="structap__pixel.html#a2191ef670b1b5c515fda841dda181f62">contam</a>+sky_cps)*exptime + sqr_rdns)/sqr_expt;
<a name="l00359"></a>00359 
<a name="l00360"></a>00360               <span class="comment">// compute the model value</span>
<a name="l00361"></a>00361               <a class="code" href="aXe__grism_8h.html#a1f386ef5cd5a3b916246c2bee80f083a">gsl_matrix_set</a>(drzprep_stamps-&gt;<a class="code" href="structdrzprep.html#ad0fd183b34cc7ee92112db1a31185fb6">model</a>,i,j,(cur_p-&gt;<a class="code" href="structap__pixel.html#ada106f5981b17786de87cfeb2a7db0d1">model</a>/corr));
<a name="l00362"></a>00362             }
<a name="l00363"></a>00363 
<a name="l00364"></a>00364           <span class="keywordflow">if</span> (var != 0.0)
<a name="l00365"></a>00365             <a class="code" href="aXe__grism_8h.html#a1f386ef5cd5a3b916246c2bee80f083a">gsl_matrix_set</a>(drzprep_stamps-&gt;<a class="code" href="structdrzprep.html#a0039f4cd84c8b2f6c0ea10cac1bc1b37">vari</a>,i,j,1.0/var);
<a name="l00366"></a>00366 
<a name="l00367"></a>00367 
<a name="l00368"></a>00368         }
<a name="l00369"></a>00369 
<a name="l00370"></a>00370       <span class="keywordflow">if</span> (opt_extr &amp;&amp; bckmode)
<a name="l00371"></a>00371         xxx_p++;
<a name="l00372"></a>00372     }
<a name="l00373"></a>00373 
<a name="l00374"></a>00374   <span class="comment">// return the result structure</span>
<a name="l00375"></a>00375   <span class="keywordflow">return</span> drzprep_stamps;
<a name="l00376"></a>00376 }
</pre></div></p>

</div>
</div>
</div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&nbsp;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&nbsp;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&nbsp;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&nbsp;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&nbsp;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&nbsp;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&nbsp;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&nbsp;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&nbsp;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&nbsp;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr size="1"/><address style="text-align: right;"><small>Generated on 12 Oct 2014 for TIPS by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.1 </small></address>
</body>
</html>
