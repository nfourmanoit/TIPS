\hypertarget{lmmin_8h}{
\section{/renoir/fourmano/Desktop/OUSIM/TIPS/branches/tips\_\-build/include/axesim/lmmin.h File Reference}
\label{lmmin_8h}\index{/renoir/fourmano/Desktop/OUSIM/TIPS/branches/tips\_\-build/include/axesim/lmmin.h@{/renoir/fourmano/Desktop/OUSIM/TIPS/branches/tips\_\-build/include/axesim/lmmin.h}}
}
\subsection*{Data Structures}
\begin{DoxyCompactItemize}
\item 
struct \hyperlink{structlm__control__type}{lm\_\-control\_\-type}
\end{DoxyCompactItemize}
\subsection*{Typedefs}
\begin{DoxyCompactItemize}
\item 
typedef void( \hyperlink{lmmin_8h_afdeb6de6c69fbcb763f18605fe248cd4}{lm\_\-evaluate\_\-ftype} )(double $\ast$par, int m\_\-dat, double $\ast$fvec, void $\ast$data, int $\ast$info)
\item 
typedef void( \hyperlink{lmmin_8h_ae6bdc55b42e1ebd56053992d041b288b}{lm\_\-print\_\-ftype} )(int n\_\-par, double $\ast$par, int m\_\-dat, double $\ast$fvec, void $\ast$data, int iflag, int iter, int nfev)
\end{DoxyCompactItemize}
\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
void \hyperlink{lmmin_8h_ad35cf99e2b3c0532b5eef07b77ca40a0}{lm\_\-evaluate\_\-default} (double $\ast$par, int m\_\-dat, double $\ast$fvec, void $\ast$data, int $\ast$info)
\item 
void \hyperlink{lmmin_8h_a6d71f7e8440a6262d8db38aaea4e7e7e}{lm\_\-print\_\-default} (int n\_\-par, double $\ast$par, int m\_\-dat, double $\ast$fvec, void $\ast$data, int iflag, int iter, int nfev)
\item 
void \hyperlink{lmmin_8h_acca4ad218695fb19545602619924c1d4}{lm\_\-initialize\_\-control} (\hyperlink{structlm__control__type}{lm\_\-control\_\-type} $\ast$control)
\item 
void \hyperlink{lmmin_8h_acccb5d208acdc6abd1cd784fc16f37f3}{lm\_\-minimize} (int m\_\-dat, int n\_\-par, double $\ast$par, \hyperlink{lmmin_8h_afdeb6de6c69fbcb763f18605fe248cd4}{lm\_\-evaluate\_\-ftype} $\ast$evaluate, \hyperlink{lmmin_8h_ae6bdc55b42e1ebd56053992d041b288b}{lm\_\-print\_\-ftype} $\ast$printout, void $\ast$data, \hyperlink{structlm__control__type}{lm\_\-control\_\-type} $\ast$control)
\item 
double \hyperlink{lmmin_8h_a564ef5317c2e0526627bd39b16acaf53}{lm\_\-enorm} (int, double $\ast$)
\item 
void \hyperlink{lmmin_8h_ad9d7115eaad1df34edf2efd92c794dbf}{lm\_\-lmdif} (int m, int n, double $\ast$x, double $\ast$fvec, double ftol, double xtol, double gtol, int maxfev, double epsfcn, double $\ast$diag, int mode, double factor, int $\ast$info, int $\ast$nfev, double $\ast$fjac, int $\ast$ipvt, double $\ast$qtf, double $\ast$wa1, double $\ast$wa2, double $\ast$wa3, double $\ast$wa4, \hyperlink{lmmin_8h_afdeb6de6c69fbcb763f18605fe248cd4}{lm\_\-evaluate\_\-ftype} $\ast$evaluate, \hyperlink{lmmin_8h_ae6bdc55b42e1ebd56053992d041b288b}{lm\_\-print\_\-ftype} $\ast$printout, void $\ast$data)
\end{DoxyCompactItemize}


\subsection{Typedef Documentation}
\hypertarget{lmmin_8h_afdeb6de6c69fbcb763f18605fe248cd4}{
\index{lmmin.h@{lmmin.h}!lm\_\-evaluate\_\-ftype@{lm\_\-evaluate\_\-ftype}}
\index{lm\_\-evaluate\_\-ftype@{lm\_\-evaluate\_\-ftype}!lmmin.h@{lmmin.h}}
\subsubsection[{lm\_\-evaluate\_\-ftype}]{\setlength{\rightskip}{0pt plus 5cm}typedef void( {\bf lm\_\-evaluate\_\-ftype})(double $\ast$par, int m\_\-dat, double $\ast$fvec, void $\ast$data, int $\ast$info)}}
\label{lmmin_8h_afdeb6de6c69fbcb763f18605fe248cd4}
\hypertarget{lmmin_8h_ae6bdc55b42e1ebd56053992d041b288b}{
\index{lmmin.h@{lmmin.h}!lm\_\-print\_\-ftype@{lm\_\-print\_\-ftype}}
\index{lm\_\-print\_\-ftype@{lm\_\-print\_\-ftype}!lmmin.h@{lmmin.h}}
\subsubsection[{lm\_\-print\_\-ftype}]{\setlength{\rightskip}{0pt plus 5cm}typedef void( {\bf lm\_\-print\_\-ftype})(int n\_\-par, double $\ast$par, int m\_\-dat, double $\ast$fvec, void $\ast$data, int iflag, int iter, int nfev)}}
\label{lmmin_8h_ae6bdc55b42e1ebd56053992d041b288b}


\subsection{Function Documentation}
\hypertarget{lmmin_8h_a564ef5317c2e0526627bd39b16acaf53}{
\index{lmmin.h@{lmmin.h}!lm\_\-enorm@{lm\_\-enorm}}
\index{lm\_\-enorm@{lm\_\-enorm}!lmmin.h@{lmmin.h}}
\subsubsection[{lm\_\-enorm}]{\setlength{\rightskip}{0pt plus 5cm}double lm\_\-enorm (int, \/  double $\ast$)}}
\label{lmmin_8h_a564ef5317c2e0526627bd39b16acaf53}



\begin{DoxyCode}
1233 {
1234 /*     given an n-vector x, this function calculates the
1235  *     euclidean norm of x.
1236  *
1237  *     the euclidean norm is computed by accumulating the sum of
1238  *     squares in three different sums. the sums of squares for the
1239  *     small and large components are scaled so that no overflows
1240  *     occur. non-destructive underflows are permitted. underflows
1241  *     and overflows do not occur in the computation of the unscaled
1242  *     sum of squares for the intermediate components.
1243  *     the definitions of small, intermediate and large components
1244  *     depend on two constants, LM_SQRT_DWARF and LM_SQRT_GIANT. the main
1245  *     restrictions on these constants are that LM_SQRT_DWARF**2 not
1246  *     underflow and LM_SQRT_GIANT**2 not overflow.
1247  *
1248  *     parameters
1249  *
1250  *      n is a positive integer input variable.
1251  *
1252  *      x is an input array of length n.
1253  */
1254     int i;
1255     double agiant, s1, s2, s3, xabs, x1max, x3max, temp;
1256 
1257     s1 = 0;
1258     s2 = 0;
1259     s3 = 0;
1260     x1max = 0;
1261     x3max = 0;
1262     agiant = LM_SQRT_GIANT/( (double) n);
1263 
1264     for ( i=0; i<n; i++ )
1265     {
1266         xabs = fabs(x[i]);
1267         if ( xabs > LM_SQRT_DWARF && xabs < agiant )
1268         {
1269 // **  sum for intermediate components.
1270             s2 += xabs*xabs;
1271             continue;
1272         }
1273 
1274         if ( xabs >  LM_SQRT_DWARF )
1275         {
1276 // **  sum for large components.
1277             if (xabs > x1max)
1278             {
1279                 temp = x1max/xabs;
1280                 s1 = 1 + s1*SQR(temp);
1281                 x1max = xabs;
1282             }
1283             else
1284             {
1285                 temp = xabs/x1max;
1286                 s1 += SQR(temp);
1287             }
1288             continue;
1289         }
1290 // **  sum for small components.
1291         if (xabs > x3max)
1292         {
1293             temp = x3max/xabs;
1294             s3 = 1 + s3*SQR(temp);
1295             x3max = xabs;
1296         }
1297         else    
1298         {
1299             if (xabs != 0.)
1300             {
1301                 temp = xabs/x3max;
1302                 s3 += SQR(temp);
1303             }
1304         }
1305     }
1306 
1307 // *** calculation of norm.
1308 
1309     if (s1 != 0)
1310         return x1max*sqrt(s1 + (s2/x1max)/x1max);
1311     if (s2 != 0)
1312     {
1313         if (s2 >= x3max)
1314             return sqrt( s2*(1+(x3max/s2)*(x3max*s3)) );
1315         else
1316             return sqrt( x3max*((s2/x3max)+(x3max*s3)) );
1317     }
1318 
1319     return x3max*sqrt(s3);
1320 }
\end{DoxyCode}
\hypertarget{lmmin_8h_ad35cf99e2b3c0532b5eef07b77ca40a0}{
\index{lmmin.h@{lmmin.h}!lm\_\-evaluate\_\-default@{lm\_\-evaluate\_\-default}}
\index{lm\_\-evaluate\_\-default@{lm\_\-evaluate\_\-default}!lmmin.h@{lmmin.h}}
\subsubsection[{lm\_\-evaluate\_\-default}]{\setlength{\rightskip}{0pt plus 5cm}void lm\_\-evaluate\_\-default (double $\ast$ {\em par}, \/  int {\em m\_\-dat}, \/  double $\ast$ {\em fvec}, \/  void $\ast$ {\em data}, \/  int $\ast$ {\em info})}}
\label{lmmin_8h_ad35cf99e2b3c0532b5eef07b77ca40a0}



\begin{DoxyCode}
28 {
29     int i;
30     lm_data_type *mydata;
31     mydata = (lm_data_type*)data;
32 
33     for (i=0; i<m_dat; i++)
34             fvec[i] = mydata->user_y[i] 
35                 - mydata->user_func( mydata->user_t[i], par);
36 
37     *info = *info; /* to prevent a 'unused variable' warning */
38     /* if <parameters drifted away> { *info = -1; } */
39 }
\end{DoxyCode}
\hypertarget{lmmin_8h_acca4ad218695fb19545602619924c1d4}{
\index{lmmin.h@{lmmin.h}!lm\_\-initialize\_\-control@{lm\_\-initialize\_\-control}}
\index{lm\_\-initialize\_\-control@{lm\_\-initialize\_\-control}!lmmin.h@{lmmin.h}}
\subsubsection[{lm\_\-initialize\_\-control}]{\setlength{\rightskip}{0pt plus 5cm}void lm\_\-initialize\_\-control ({\bf lm\_\-control\_\-type} $\ast$ {\em control})}}
\label{lmmin_8h_acca4ad218695fb19545602619924c1d4}



\begin{DoxyCode}
26 {
27     control->maxcall = 100;
28     control->epsilon = 1.e-14;
29     control->stepbound = 100.;
30     control->ftol = 1.e-14;
31     control->xtol = 1.e-14;
32     control->gtol = 1.e-14;
33 }
\end{DoxyCode}
\hypertarget{lmmin_8h_ad9d7115eaad1df34edf2efd92c794dbf}{
\index{lmmin.h@{lmmin.h}!lm\_\-lmdif@{lm\_\-lmdif}}
\index{lm\_\-lmdif@{lm\_\-lmdif}!lmmin.h@{lmmin.h}}
\subsubsection[{lm\_\-lmdif}]{\setlength{\rightskip}{0pt plus 5cm}void lm\_\-lmdif (int {\em m}, \/  int {\em n}, \/  double $\ast$ {\em x}, \/  double $\ast$ {\em fvec}, \/  double {\em ftol}, \/  double {\em xtol}, \/  double {\em gtol}, \/  int {\em maxfev}, \/  double {\em epsfcn}, \/  double $\ast$ {\em diag}, \/  int {\em mode}, \/  double {\em factor}, \/  int $\ast$ {\em info}, \/  int $\ast$ {\em nfev}, \/  double $\ast$ {\em fjac}, \/  int $\ast$ {\em ipvt}, \/  double $\ast$ {\em qtf}, \/  double $\ast$ {\em wa1}, \/  double $\ast$ {\em wa2}, \/  double $\ast$ {\em wa3}, \/  double $\ast$ {\em wa4}, \/  {\bf lm\_\-evaluate\_\-ftype} $\ast$ {\em evaluate}, \/  {\bf lm\_\-print\_\-ftype} $\ast$ {\em printout}, \/  void $\ast$ {\em data})}}
\label{lmmin_8h_ad9d7115eaad1df34edf2efd92c794dbf}



\begin{DoxyCode}
168 {
169 /*
170  *   the purpose of lmdif is to minimize the sum of the squares of
171  *   m nonlinear functions in n variables by a modification of
172  *   the levenberg-marquardt algorithm. the user must provide a
173  *   subroutine evaluate which calculates the functions. the jacobian
174  *   is then calculated by a forward-difference approximation.
175  *
176  *   the multi-parameter interface lm_lmdif is for users who want
177  *   full control and flexibility. most users will be better off using
178  *   the simpler interface lmfit provided above.
179  *
180  *   the parameters are the same as in the legacy FORTRAN implementation,
181  *   with the following exceptions:
182  *      the old parameter ldfjac which gave leading dimension of fjac has
183  *        been deleted because this C translation makes no use of two-
184  *        dimensional arrays;
185  *      the old parameter nprint has been deleted; printout is now controlled
186  *        by the user-supplied routine *printout;
187  *      the parameter field *data and the function parameters *evaluate and
188  *        *printout have been added; they help avoiding global variables.
189  *
190  *   parameters:
191  *
192  *      m is a positive integer input variable set to the number
193  *        of functions.
194  *
195  *      n is a positive integer input variable set to the number
196  *        of variables. n must not exceed m.
197  *
198  *      x is an array of length n. on input x must contain
199  *        an initial estimate of the solution vector. on output x
200  *        contains the final estimate of the solution vector.
201  *
202  *      fvec is an output array of length m which contains
203  *        the functions evaluated at the output x.
204  *
205  *      ftol is a nonnegative input variable. termination
206  *        occurs when both the actual and predicted relative
207  *        reductions in the sum of squares are at most ftol.
208  *        therefore, ftol measures the relative error desired
209  *        in the sum of squares.
210  *
211  *      xtol is a nonnegative input variable. termination
212  *        occurs when the relative error between two consecutive
213  *        iterates is at most xtol. therefore, xtol measures the
214  *        relative error desired in the approximate solution.
215  *
216  *      gtol is a nonnegative input variable. termination
217  *        occurs when the cosine of the angle between fvec and
218  *        any column of the jacobian is at most gtol in absolute
219  *        value. therefore, gtol measures the orthogonality
220  *        desired between the function vector and the columns
221  *        of the jacobian.
222  *
223  *      maxfev is a positive integer input variable. termination
224  *        occurs when the number of calls to lm_fcn is at least
225  *        maxfev by the end of an iteration.
226  *
227  *      epsfcn is an input variable used in determining a suitable
228  *        step length for the forward-difference approximation. this
229  *        approximation assumes that the relative errors in the
230  *        functions are of the order of epsfcn. if epsfcn is less
231  *        than the machine precision, it is assumed that the relative
232  *        errors in the functions are of the order of the machine
233  *        precision.
234  *
235  *      diag is an array of length n. if mode = 1 (see below), diag is
236  *        internally set. if mode = 2, diag must contain positive entries
237  *        that serve as multiplicative scale factors for the variables.
238  *
239  *      mode is an integer input variable. if mode = 1, the
240  *        variables will be scaled internally. if mode = 2,
241  *        the scaling is specified by the input diag. other
242  *        values of mode are equivalent to mode = 1.
243  *
244  *      factor is a positive input variable used in determining the
245  *        initial step bound. this bound is set to the product of
246  *        factor and the euclidean norm of diag*x if nonzero, or else
247  *        to factor itself. in most cases factor should lie in the
248  *        interval (.1,100.). 100. is a generally recommended value.
249  *
250  *      info is an integer output variable that indicates the termination
251  *        status of lm_lmdif as follows:
252  *
253  *        info < 0  termination requested by user-supplied routine *evaluate;
254  *
255  *        info = 0  improper input parameters;
256  *
257  *        info = 1  both actual and predicted relative reductions
258  *                  in the sum of squares are at most ftol;
259  *
260  *        info = 2  relative error between two consecutive iterates
261  *                  is at most xtol;
262  *
263  *        info = 3  conditions for info = 1 and info = 2 both hold;
264  *
265  *        info = 4  the cosine of the angle between fvec and any
266  *                  column of the jacobian is at most gtol in
267  *                  absolute value;
268  *
269  *        info = 5  number of calls to lm_fcn has reached or
270  *                  exceeded maxfev;
271  *
272  *        info = 6  ftol is too small. no further reduction in
273  *                  the sum of squares is possible;
274  *
275  *        info = 7  xtol is too small. no further improvement in
276  *                  the approximate solution x is possible;
277  *
278  *        info = 8  gtol is too small. fvec is orthogonal to the
279  *                  columns of the jacobian to machine precision;
280  *
281  *      nfev is an output variable set to the number of calls to the
282  *        user-supplied routine *evaluate.
283  *
284  *      fjac is an output m by n array. the upper n by n submatrix
285  *        of fjac contains an upper triangular matrix r with
286  *        diagonal elements of nonincreasing magnitude such that
287  *
288  *               t     t           t
289  *              p *(jac *jac)*p = r *r,
290  *
291  *        where p is a permutation matrix and jac is the final
292  *        calculated jacobian. column j of p is column ipvt(j)
293  *        (see below) of the identity matrix. the lower trapezoidal
294  *        part of fjac contains information generated during
295  *        the computation of r.
296  *
297  *      ipvt is an integer output array of length n. ipvt
298  *        defines a permutation matrix p such that jac*p = q*r,
299  *        where jac is the final calculated jacobian, q is
300  *        orthogonal (not stored), and r is upper triangular
301  *        with diagonal elements of nonincreasing magnitude.
302  *        column j of p is column ipvt(j) of the identity matrix.
303  *
304  *      qtf is an output array of length n which contains
305  *        the first n elements of the vector (q transpose)*fvec.
306  *
307  *      wa1, wa2, and wa3 are work arrays of length n.
308  *
309  *      wa4 is a work array of length m.
310  *
311  *   the following parameters are newly introduced in this C translation:
312  *
313  *      evaluate is the name of the subroutine which calculates the functions.
314  *        a default implementation lm_evaluate_default is provided in lm_eval.c;
315  *        alternatively, evaluate can be provided by a user calling program.
316  *        it should be written as follows:
317  *
318  *        void evaluate ( double* par, int m_dat, double* fvec, 
319  *                       void *data, int *info )
320  *        {
321  *           // for ( i=0; i<m_dat; ++i )
322  *           //     calculate fvec[i] for given parameters par;
323  *           // to stop the minimization, 
324  *           //     set *info to a negative integer.
325  *        }
326  *
327  *      printout is the name of the subroutine which nforms about fit progress.
328  *        a default implementation lm_print_default is provided in lm_eval.c;
329  *        alternatively, printout can be provided by a user calling program.
330  *        it should be written as follows:
331  *
332  *        void printout ( int n_par, double* par, int m_dat, double* fvec, 
333  *                       void *data, int iflag, int iter, int nfev )
334  *        {
335  *           // iflag : 0 (init) 1 (outer loop) 2(inner loop) -1(terminated)
336  *           // iter  : outer loop counter
337  *           // nfev  : number of calls to *evaluate
338  *        }
339  *
340  *      data is an input pointer to an arbitrary structure that is passed to
341  *        evaluate. typically, it contains experimental data to be fitted.
342  *
343  */
344     int i, iter, j;
345     double actred, delta, dirder, eps, fnorm, fnorm1, gnorm, par, pnorm,
346         prered, ratio, step, sum, temp, temp1, temp2, temp3, xnorm;
347     static double p1 = 0.1;
348     static double p5 = 0.5;
349     static double p25 = 0.25;
350     static double p75 = 0.75;
351     static double p0001 = 1.0e-4;
352 
353     *nfev = 0; // function evaluation counter
354     iter = 1;  // outer loop counter
355     par = 0;   // levenberg-marquardt parameter 
356     delta = 0; // just to prevent a warning (initialization within if-clause)
357     xnorm = 0; // dito
358 
359     temp = MAX(epsfcn,LM_MACHEP);
360     eps = sqrt(temp); // used in calculating the Jacobian by forward differences
361 
362 // *** check the input parameters for errors.
363 
364     if ( (n <= 0) || (m < n) || (ftol < 0.)
365         || (xtol < 0.) || (gtol < 0.) || (maxfev <= 0) || (factor <= 0.) )
366     {
367         *info = 0; // invalid parameter
368         return;
369     }
370     if ( mode == 2 )  /* scaling by diag[] */
371     {
372         for ( j=0; j<n; j++ )  /* check for nonpositive elements */
373         {
374             if ( diag[j] <= 0.0 )
375             {
376                 *info = 0; // invalid parameter
377                 return;
378             }
379         }       
380     }
381 #if BUG
382     printf( "lmdif\n" );
383 #endif
384 
385 // *** evaluate the function at the starting point and calculate its norm.
386 
387     *info = 0;
388     (*evaluate)( x, m, fvec, data, info );
389     (*printout)( n, x, m, fvec, data, 0, 0, ++(*nfev) );
390     if ( *info < 0 ) return;
391     fnorm = lm_enorm(m,fvec);
392 
393 // *** the outer loop.
394 
395     do { 
396 #if BUG 
397         printf( "lmdif/ outer loop iter=%d nfev=%d fnorm=%.10e\n",
398                 iter, *nfev, fnorm );
399 #endif
400 
401 // O** calculate the jacobian matrix.
402 
403         for ( j=0; j<n; j++ )
404         {
405             temp = x[j];
406             step = eps * fabs(temp);
407             if (step == 0.) step = eps;
408             x[j] = temp + step;
409             *info = 0;
410             (*evaluate)( x, m, wa4, data, info );
411             (*printout)( n, x, m, wa4, data, 1, iter, ++(*nfev) );
412             if ( *info < 0 ) return;  // user requested break
413             x[j] = temp;
414             for ( i=0; i<m; i++ )
415                 fjac[j*m+i] = (wa4[i] - fvec[i]) / step;
416         }
417 #if BUG>1
418         // DEBUG: print the entire matrix
419         for ( i=0; i<m; i++ )
420         {
421             for ( j=0; j<n; j++ )
422                 printf( "%.5e ", y[j*m+i] );
423             printf( "\n" );
424         }
425 #endif
426 
427 // O** compute the qr factorization of the jacobian.
428 
429         lm_qrfac( m, n, fjac, 1, ipvt, wa1, wa2, wa3);
430 
431 // O** on the first iteration ... 
432 
433         if (iter == 1)
434         {
435             if (mode != 2)
436 //      ... scale according to the norms of the columns of the initial jacobian.
437             {
438                 for ( j=0; j<n; j++ )
439                 {
440                     diag[j] = wa2[j];
441                     if ( wa2[j] == 0. )
442                         diag[j] = 1.;
443                 }
444             }
445 
446 //      ... calculate the norm of the scaled x and 
447 //          initialize the step bound delta.
448 
449             for ( j=0; j<n; j++ )
450                 wa3[j] = diag[j] * x[j];
451 
452             xnorm = lm_enorm( n, wa3 );
453             delta = factor*xnorm;
454             if (delta == 0.)
455                 delta = factor;
456         }
457 
458 // O** form (q transpose)*fvec and store the first n components in qtf.
459 
460         for ( i=0; i<m; i++ )
461             wa4[i] = fvec[i];
462 
463         for ( j=0; j<n; j++ )
464         {
465             temp3 = fjac[j*m+j];
466             if (temp3 != 0.)
467             {
468                 sum = 0;
469                 for ( i=j; i<m; i++ )
470                     sum += fjac[j*m+i] * wa4[i];
471                 temp = -sum / temp3;
472                 for ( i=j; i<m; i++ )
473                     wa4[i] += fjac[j*m+i] * temp;
474             }
475             fjac[j*m+j] = wa1[j];
476             qtf[j] = wa4[j];
477         }
478 
479 // O** compute the norm of the scaled gradient and test for convergence.
480 
481         gnorm = 0;
482         if ( fnorm != 0 )
483         {
484             for ( j=0; j<n; j++ )
485             {
486                 if ( wa2[ ipvt[j] ] == 0 ) continue;
487                 
488                 sum = 0.;
489                 for ( i=0; i<=j; i++ )
490                     sum += fjac[j*m+i] * qtf[i] / fnorm;
491                 gnorm = MAX( gnorm, fabs(sum/wa2[ ipvt[j] ]) );
492             }
493         }
494 
495         if ( gnorm <= gtol )
496         {
497             *info = 4;
498             return;
499         }
500 
501 // O** rescale if necessary.
502 
503         if ( mode != 2 )
504         {
505             for ( j=0; j<n; j++ )
506                 diag[j] = MAX(diag[j],wa2[j]);
507         }
508 
509 // O** the inner loop.
510 
511         do {
512 #if BUG 
513             printf( "lmdif/ inner loop iter=%d nfev=%d\n", iter, *nfev );
514 #endif
515 
516 // OI* determine the levenberg-marquardt parameter.
517 
518             lm_lmpar( n,fjac,m,ipvt,diag,qtf,delta,&par,wa1,wa2,wa3,wa4 );
519 
520 // OI* store the direction p and x + p. calculate the norm of p.
521 
522             for ( j=0; j<n; j++ )
523             {
524                 wa1[j] = -wa1[j];
525                 wa2[j] = x[j] + wa1[j];
526                 wa3[j] = diag[j]*wa1[j];
527             }
528             pnorm = lm_enorm(n,wa3);
529 
530 // OI* on the first iteration, adjust the initial step bound.
531 
532             if ( *nfev<= 1+n ) // bug corrected by J. Wuttke in 2004
533                 delta = MIN(delta,pnorm);
534 
535 // OI* evaluate the function at x + p and calculate its norm.
536 
537             *info = 0;
538             (*evaluate)( wa2, m, wa4, data, info );
539             (*printout)( n, x, m, wa4, data, 2, iter, ++(*nfev) );
540             if ( *info < 0 ) return;  // user requested break
541 
542             fnorm1 = lm_enorm(m,wa4);
543 #if BUG 
544             printf( "lmdif/ pnorm %.10e  fnorm1 %.10e  fnorm %.10e"
545                     " delta=%.10e par=%.10e\n",
546                     pnorm, fnorm1, fnorm, delta, par );
547 #endif
548 
549 // OI* compute the scaled actual reduction.
550 
551             if ( p1*fnorm1 < fnorm )
552                 actred = 1 - SQR( fnorm1/fnorm );
553             else
554                 actred = -1;
555 
556 // OI* compute the scaled predicted reduction and 
557 //     the scaled directional derivative.
558 
559             for ( j=0; j<n; j++ )
560             {
561                 wa3[j] = 0;
562                 for ( i=0; i<=j; i++ )
563                     wa3[i] += fjac[j*m+i]*wa1[ ipvt[j] ];
564             }
565             temp1 = lm_enorm(n,wa3) / fnorm;
566             temp2 = sqrt(par) * pnorm / fnorm;
567             prered = SQR(temp1) + 2 * SQR(temp2);
568             dirder = - ( SQR(temp1) + SQR(temp2) );
569 
570 // OI* compute the ratio of the actual to the predicted reduction.
571 
572             ratio = prered!=0 ? actred/prered : 0;
573 #if BUG 
574             printf( "lmdif/ actred=%.10e prered=%.10e ratio=%.10e"
575                     " sq(1)=%.10e sq(2)=%.10e dd=%.10e\n",
576                     actred, prered, prered!=0 ? ratio : 0.,
577                     SQR(temp1), SQR(temp2), dirder );
578 #endif
579 
580 // OI* update the step bound.
581 
582             if (ratio <= p25)
583             {
584                 if (actred >= 0.)
585                     temp = p5;
586                 else
587                     temp = p5*dirder/(dirder + p5*actred);
588                 if ( p1*fnorm1 >= fnorm || temp < p1 )
589                     temp = p1;
590                 delta = temp * MIN(delta,pnorm/p1);
591                 par /= temp;
592             }
593             else if ( par == 0. || ratio >= p75 )
594             {
595                 delta = pnorm/p5;
596                 par *= p5;
597             }
598 
599 // OI* test for successful iteration...
600 
601             if (ratio >= p0001)
602             {
603 
604 //     ... successful iteration. update x, fvec, and their norms.
605 
606                 for ( j=0; j<n; j++ )
607                 {
608                     x[j] = wa2[j];
609                     wa2[j] = diag[j]*x[j];
610                 }
611                 for ( i=0; i<m; i++ )
612                     fvec[i] = wa4[i];
613                 xnorm = lm_enorm(n,wa2);
614                 fnorm = fnorm1;
615                 iter++;
616             }
617 #if BUG 
618             else {
619                 printf( "ATTN: iteration considered unsuccessful\n" );
620             } 
621 #endif
622 
623 // OI* tests for convergence ( otherwise *info = 1, 2, or 3 )
624 
625             *info = 0; // do not terminate (unless overwritten by nonzero value)
626             if ( fabs(actred) <= ftol && prered <= ftol && p5*ratio <= 1 )
627                 *info = 1;
628             if (delta <= xtol*xnorm)
629                 *info += 2;
630             if ( *info != 0)
631                 return;
632 
633 // OI* tests for termination and stringent tolerances.
634 
635             if ( *nfev >= maxfev)
636                 *info = 5;
637             if ( fabs(actred) <= LM_MACHEP &&
638                  prered <= LM_MACHEP && p5*ratio <= 1 )
639                 *info = 6;
640             if (delta <= LM_MACHEP*xnorm)
641                 *info = 7;
642             if (gnorm <= LM_MACHEP)
643                 *info = 8;
644             if ( *info != 0)
645                 return;
646 
647 // OI* end of the inner loop. repeat if iteration unsuccessful.
648 
649         } while (ratio < p0001);
650 
651 // O** end of the outer loop.
652 
653     } while (1);
654         
655 }
\end{DoxyCode}
\hypertarget{lmmin_8h_acccb5d208acdc6abd1cd784fc16f37f3}{
\index{lmmin.h@{lmmin.h}!lm\_\-minimize@{lm\_\-minimize}}
\index{lm\_\-minimize@{lm\_\-minimize}!lmmin.h@{lmmin.h}}
\subsubsection[{lm\_\-minimize}]{\setlength{\rightskip}{0pt plus 5cm}void lm\_\-minimize (int {\em m\_\-dat}, \/  int {\em n\_\-par}, \/  double $\ast$ {\em par}, \/  {\bf lm\_\-evaluate\_\-ftype} $\ast$ {\em evaluate}, \/  {\bf lm\_\-print\_\-ftype} $\ast$ {\em printout}, \/  void $\ast$ {\em data}, \/  {\bf lm\_\-control\_\-type} $\ast$ {\em control})}}
\label{lmmin_8h_acccb5d208acdc6abd1cd784fc16f37f3}



\begin{DoxyCode}
38 {
39 
40 // *** allocate work space.
41 
42     double *fvec, *diag, *fjac, *qtf, *wa1, *wa2, *wa3, *wa4;
43     int *ipvt;
44 
45     int n = n_par;
46     int m = m_dat;
47 
48     if (!(fvec = (double*) malloc(  m*sizeof(double))) ||
49         !(diag = (double*) malloc(n*  sizeof(double))) ||
50         !(qtf =  (double*) malloc(n*  sizeof(double))) ||
51         !(fjac = (double*) malloc(n*m*sizeof(double))) ||
52         !(wa1 =  (double*) malloc(n*  sizeof(double))) ||
53         !(wa2 =  (double*) malloc(n*  sizeof(double))) ||
54         !(wa3 =  (double*) malloc(n*  sizeof(double))) ||
55         !(wa4 =  (double*) malloc(  m*sizeof(double))) ||
56         !(ipvt = (int*)    malloc(n*  sizeof(int)))) {
57             control->info = 9;
58             return;
59     }
60 
61 // *** perform fit.
62                         
63     control->info = 0;
64     control->nfev = 0;
65 
66     // this goes through the modified legacy interface:
67     lm_lmdif( m, n, par, fvec, control->ftol, control->xtol, control->gtol,
68               control->maxcall*(n+1), control->epsilon, diag, 1,
69               control->stepbound, &(control->info),
70               &(control->nfev), fjac, ipvt, qtf, wa1, wa2, wa3, wa4,
71               evaluate, printout, data );
72 
73     (*printout)( n, par, m, fvec, data, -1, 0, control->nfev );
74     control->fnorm = lm_enorm(m, fvec);
75     if (control->info < 0 ) control->info = 10;
76 
77 // *** clean up.
78 
79     free(fvec);
80     free(diag);
81     free(qtf); 
82     free(fjac);
83     free(wa1); 
84     free(wa2); 
85     free(wa3 );
86     free(wa4); 
87     free(ipvt);
88 }
\end{DoxyCode}
\hypertarget{lmmin_8h_a6d71f7e8440a6262d8db38aaea4e7e7e}{
\index{lmmin.h@{lmmin.h}!lm\_\-print\_\-default@{lm\_\-print\_\-default}}
\index{lm\_\-print\_\-default@{lm\_\-print\_\-default}!lmmin.h@{lmmin.h}}
\subsubsection[{lm\_\-print\_\-default}]{\setlength{\rightskip}{0pt plus 5cm}void lm\_\-print\_\-default (int {\em n\_\-par}, \/  double $\ast$ {\em par}, \/  int {\em m\_\-dat}, \/  double $\ast$ {\em fvec}, \/  void $\ast$ {\em data}, \/  int {\em iflag}, \/  int {\em iter}, \/  int {\em nfev})}}
\label{lmmin_8h_a6d71f7e8440a6262d8db38aaea4e7e7e}



\begin{DoxyCode}
86                : for soft control of printout behaviour, add control
87  *                 variables to the data struct
88  *       iflag : 0 (init) 1 (outer loop) 2(inner loop) -1(terminated)
89  *       iter  : outer loop counter
90  *       nfev  : number of calls to *evaluate
91  */
92 {
93     double f, y, t;
94     int i;
95     lm_data_type *mydata;
96     mydata = (lm_data_type*)data;
97 
98     if (iflag==2) {
99         printf ("trying step in gradient direction\n");
100     } else if (iflag==1) {
101         printf ("determining gradient (iteration %d)\n", iter);
102     } else if (iflag==0) {
103         printf ("starting minimization\n");
104     } else if (iflag==-1) {
105         printf ("terminated after %d evaluations\n", nfev);
106     }
107 
108     printf( "  par: " );
109     for( i=0; i<n_par; ++i )
110         printf( " %12g", par[i] );
111     printf ( " => norm: %12g\n", lm_enorm( m_dat, fvec ) );
112 
113     if ( iflag == -1 ) {
114         printf( "  fitting data as follows:\n" );
115         for( i=0; i<m_dat; ++i ) {
116             t = (mydata->user_t)[i];
117             y = (mydata->user_y)[i];
118             f = mydata->user_func( t, par );
119             printf( "    t[%2d]=%12g y=%12g fit=%12g residue=%12g\n",
120                     i, t, y, f, y-f );
121         }
122     }
123 }
\end{DoxyCode}
