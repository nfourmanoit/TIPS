\hypertarget{spc__flatfield_8h}{
\section{/renoir/fourmano/Desktop/OUSIM/TIPS/branches/tips\_\-build/include/axesim/spc\_\-flatfield.h File Reference}
\label{spc__flatfield_8h}\index{/renoir/fourmano/Desktop/OUSIM/TIPS/branches/tips\_\-build/include/axesim/spc\_\-flatfield.h@{/renoir/fourmano/Desktop/OUSIM/TIPS/branches/tips\_\-build/include/axesim/spc\_\-flatfield.h}}
}
{\ttfamily \#include $<$stdlib.h$>$}\par
{\ttfamily \#include $<$stdarg.h$>$}\par
{\ttfamily \#include $<$math.h$>$}\par
{\ttfamily \#include $<$gsl/gsl\_\-spline.h$>$}\par
{\ttfamily \#include $<$gsl/gsl\_\-rng.h$>$}\par
{\ttfamily \#include $<$gsl/gsl\_\-randist.h$>$}\par
{\ttfamily \#include \char`\"{}aXe\_\-grism.h\char`\"{}}\par
{\ttfamily \#include \char`\"{}aXe\_\-utils.h\char`\"{}}\par
\subsection*{Data Structures}
\begin{DoxyCompactItemize}
\item 
struct \hyperlink{structpoly__cube__flatfield}{poly\_\-cube\_\-flatfield}
\item 
struct \hyperlink{structpolynom__flatfield}{polynom\_\-flatfield}
\item 
struct \hyperlink{structmulti__flatfield}{multi\_\-flatfield}
\item 
struct \hyperlink{structs__flatfield}{s\_\-flatfield}
\end{DoxyCompactItemize}
\subsection*{Namespaces}
\begin{DoxyCompactItemize}
\item 
namespace \hyperlink{namespacespc__flatfield}{spc\_\-flatfield}
\end{DoxyCompactItemize}
\subsection*{Defines}
\begin{DoxyCompactItemize}
\item 
\#define \hyperlink{spc__flatfield_8h_a28c43bd3fb84d6eb9a3199021e3aebcd}{\_\-SPC\_\-FLATFIELD\_\-H}~1
\end{DoxyCompactItemize}
\subsection*{Typedefs}
\begin{DoxyCompactItemize}
\item 
typedef struct \hyperlink{structs__flatfield}{s\_\-flatfield} \hyperlink{spc__flatfield_8h_a2697a446d526e1695a9c8f5fde07166c}{flatfield\_\-d}
\end{DoxyCompactItemize}
\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
\hyperlink{structpoly__cube__flatfield}{poly\_\-cube\_\-flatfield} $\ast$ \hyperlink{spc__flatfield_8h_a83750e7a1e9eaf61ee280a730786f115}{load\_\-flat\_\-poly\_\-cube} (char $\ast$fname)
\item 
void \hyperlink{spc__flatfield_8h_ace74cc16d90b32b8af96da0408dc3c73}{free\_\-flat\_\-poly\_\-cube} (\hyperlink{structpoly__cube__flatfield}{poly\_\-cube\_\-flatfield} $\ast$poly\_\-cube)
\item 
\hyperlink{structs__flatfield}{flatfield\_\-d} $\ast$ \hyperlink{spc__flatfield_8h_a7bbb89f8979ec898f238c71670ea9a97}{make\_\-poly\_\-flatfield} (const \hyperlink{structbeam}{beam} $\ast$const curbeam, const char $\ast$const flat\_\-name, const int order, const double $\ast$const coeffs)
\item 
void \hyperlink{spc__flatfield_8h_ac58feb28bf1828414955e0010edbde09}{free\_\-poly\_\-flatfield} (\hyperlink{structs__flatfield}{flatfield\_\-d} $\ast$const flat)
\item 
\hyperlink{structs__flatfield}{flatfield\_\-d} $\ast$ \hyperlink{spc__flatfield_8h_a51dc63c9e14b10df5c589cbf97eedd20}{make\_\-multi\_\-flatfield} (const \hyperlink{structbeam}{beam} $\ast$const curbeam, const int num\_\-flats, const double lambda, const char $\ast$const flat\_\-name,...)
\item 
void \hyperlink{spc__flatfield_8h_a5a296123b4a5ee3eacc23dc08b2e253b}{free\_\-multi\_\-flatfield} (\hyperlink{structs__flatfield}{flatfield\_\-d} $\ast$const flat)
\item 
void \hyperlink{spc__flatfield_8h_ab42beec46d951d535ed65eeb14a0c50a}{apply\_\-flatfield} (\hyperlink{structap__pixel}{ap\_\-pixel} $\ast$const ap\_\-p, const \hyperlink{structs__flatfield}{flatfield\_\-d} $\ast$const flat)
\item 
double \hyperlink{spc__flatfield_8h_a453e895ac1865f71f8b5126a0bcfb519}{poly\_\-cube\_\-flatfield\_\-lambda} (const double lambda, const int x, const int y, \hyperlink{structpoly__cube__flatfield}{poly\_\-cube\_\-flatfield} $\ast$poly\_\-cube)
\end{DoxyCompactItemize}


\subsection{Define Documentation}
\hypertarget{spc__flatfield_8h_a28c43bd3fb84d6eb9a3199021e3aebcd}{
\index{spc\_\-flatfield.h@{spc\_\-flatfield.h}!\_\-SPC\_\-FLATFIELD\_\-H@{\_\-SPC\_\-FLATFIELD\_\-H}}
\index{\_\-SPC\_\-FLATFIELD\_\-H@{\_\-SPC\_\-FLATFIELD\_\-H}!spc_flatfield.h@{spc\_\-flatfield.h}}
\subsubsection[{\_\-SPC\_\-FLATFIELD\_\-H}]{\setlength{\rightskip}{0pt plus 5cm}\#define \_\-SPC\_\-FLATFIELD\_\-H~1}}
\label{spc__flatfield_8h_a28c43bd3fb84d6eb9a3199021e3aebcd}


\subsection{Typedef Documentation}
\hypertarget{spc__flatfield_8h_a2697a446d526e1695a9c8f5fde07166c}{
\index{spc\_\-flatfield.h@{spc\_\-flatfield.h}!flatfield\_\-d@{flatfield\_\-d}}
\index{flatfield\_\-d@{flatfield\_\-d}!spc_flatfield.h@{spc\_\-flatfield.h}}
\subsubsection[{flatfield\_\-d}]{\setlength{\rightskip}{0pt plus 5cm}typedef struct {\bf s\_\-flatfield}
 {\bf flatfield\_\-d}}}
\label{spc__flatfield_8h_a2697a446d526e1695a9c8f5fde07166c}
Descriptor of a flatfielding function, including the function to compute the flat field value of a given pixel, the bounding box we handle, and auxillary data (usually a flatfield image) 

\subsection{Function Documentation}
\hypertarget{spc__flatfield_8h_ab42beec46d951d535ed65eeb14a0c50a}{
\index{spc\_\-flatfield.h@{spc\_\-flatfield.h}!apply\_\-flatfield@{apply\_\-flatfield}}
\index{apply\_\-flatfield@{apply\_\-flatfield}!spc_flatfield.h@{spc\_\-flatfield.h}}
\subsubsection[{apply\_\-flatfield}]{\setlength{\rightskip}{0pt plus 5cm}void apply\_\-flatfield ({\bf ap\_\-pixel} $\ast$const  {\em ap\_\-p}, \/  const {\bf flatfield\_\-d} $\ast$const  {\em flat})}}
\label{spc__flatfield_8h_ab42beec46d951d535ed65eeb14a0c50a}
\hypertarget{spc__flatfield_8h_ace74cc16d90b32b8af96da0408dc3c73}{
\index{spc\_\-flatfield.h@{spc\_\-flatfield.h}!free\_\-flat\_\-poly\_\-cube@{free\_\-flat\_\-poly\_\-cube}}
\index{free\_\-flat\_\-poly\_\-cube@{free\_\-flat\_\-poly\_\-cube}!spc_flatfield.h@{spc\_\-flatfield.h}}
\subsubsection[{free\_\-flat\_\-poly\_\-cube}]{\setlength{\rightskip}{0pt plus 5cm}void free\_\-flat\_\-poly\_\-cube ({\bf poly\_\-cube\_\-flatfield} $\ast$ {\em poly\_\-cube})}}
\label{spc__flatfield_8h_ace74cc16d90b32b8af96da0408dc3c73}
Completely frees up the space allocated to a gsl\_\-matrix 
\begin{DoxyParams}{Parameters}
\item[{\em poly\_\-cube}]a pointer to a \hyperlink{structpoly__cube__flatfield}{poly\_\-cube\_\-flatfield} structure \end{DoxyParams}



\begin{DoxyCode}
134 {
135   int i=0;
136   
137   if (poly_cube!=NULL) {
138     for (i=0;i<poly_cube->poly_order;i++)
139       gsl_matrix_free(poly_cube->coeffs[i]);
140     free(poly_cube->coeffs);
141     if (poly_cube) free(poly_cube);
142     poly_cube=NULL;
143   }
144 }
\end{DoxyCode}
\hypertarget{spc__flatfield_8h_a5a296123b4a5ee3eacc23dc08b2e253b}{
\index{spc\_\-flatfield.h@{spc\_\-flatfield.h}!free\_\-multi\_\-flatfield@{free\_\-multi\_\-flatfield}}
\index{free\_\-multi\_\-flatfield@{free\_\-multi\_\-flatfield}!spc_flatfield.h@{spc\_\-flatfield.h}}
\subsubsection[{free\_\-multi\_\-flatfield}]{\setlength{\rightskip}{0pt plus 5cm}void free\_\-multi\_\-flatfield ({\bf flatfield\_\-d} $\ast$ {\em flat})}}
\label{spc__flatfield_8h_a5a296123b4a5ee3eacc23dc08b2e253b}
frees a flatfield consisting of multiple images and its assoicated data structures


\begin{DoxyParams}{Parameters}
\item[{\em flat}]the flatfield to free \end{DoxyParams}



\begin{DoxyCode}
472 {
473   int i;
474 
475   for (i = 0; i < flat->data.multi->num_flats; i++)
476     {
477       gsl_matrix_free (flat->data.multi->flatfields[i]);
478       if (flat->data.multi->errors[i])
479         {
480           gsl_matrix_free (flat->data.multi->errors[i]);
481         }
482     }
483   free (flat->data.multi->flatfields);
484   flat->data.multi->flatfields = NULL;
485   free (flat->data.multi->errors);
486   flat->data.multi->errors = NULL;
487   free (flat->data.multi->lambdas);
488   flat->data.multi->lambdas = NULL;
489   free (flat->data.multi);
490   flat->data.multi = NULL;
491   free (flat);
492   flat = NULL;
493 }
\end{DoxyCode}
\hypertarget{spc__flatfield_8h_ac58feb28bf1828414955e0010edbde09}{
\index{spc\_\-flatfield.h@{spc\_\-flatfield.h}!free\_\-poly\_\-flatfield@{free\_\-poly\_\-flatfield}}
\index{free\_\-poly\_\-flatfield@{free\_\-poly\_\-flatfield}!spc_flatfield.h@{spc\_\-flatfield.h}}
\subsubsection[{free\_\-poly\_\-flatfield}]{\setlength{\rightskip}{0pt plus 5cm}void free\_\-poly\_\-flatfield ({\bf flatfield\_\-d} $\ast$ {\em flat})}}
\label{spc__flatfield_8h_ac58feb28bf1828414955e0010edbde09}
frees a polynom flatfield and its assoicated data structures


\begin{DoxyParams}{Parameters}
\item[{\em flat}]the flatfield to free \end{DoxyParams}



\begin{DoxyCode}
324 {
325   gsl_matrix_free (flat->data.poly->flatfield);
326   if (flat->data.poly->errors)
327     {
328       gsl_matrix_free (flat->data.poly->errors);
329     }
330   free (flat->data.poly->poly_coeffs);
331   flat->data.poly->poly_coeffs = NULL;
332   free (flat->data.poly);
333   flat->data.poly = NULL;
334   free (flat);
335   flat = NULL;
336 }
\end{DoxyCode}
\hypertarget{spc__flatfield_8h_a83750e7a1e9eaf61ee280a730786f115}{
\index{spc\_\-flatfield.h@{spc\_\-flatfield.h}!load\_\-flat\_\-poly\_\-cube@{load\_\-flat\_\-poly\_\-cube}}
\index{load\_\-flat\_\-poly\_\-cube@{load\_\-flat\_\-poly\_\-cube}!spc_flatfield.h@{spc\_\-flatfield.h}}
\subsubsection[{load\_\-flat\_\-poly\_\-cube}]{\setlength{\rightskip}{0pt plus 5cm}{\bf poly\_\-cube\_\-flatfield}$\ast$ load\_\-flat\_\-poly\_\-cube (char $\ast$ {\em fname})}}
\label{spc__flatfield_8h_a83750e7a1e9eaf61ee280a730786f115}
Load and return a gsl cube whose planes (z-\/direction) contain the coefficients of a polynomial of the form ff(i,j,lambda) = a0+a1$\ast$lambda+...


\begin{DoxyParams}{Parameters}
\item[{\em fname}]the name of a flat cube to read and load\end{DoxyParams}
\begin{DoxyReturn}{Returns}
a pointer to a NULL terminated array of gsl\_\-matrix 
\end{DoxyReturn}



\begin{DoxyCode}
51 {
52   int i;
53   int order = 0;
54   poly_cube_flatfield *poly_cube;
55     
56   /* Getting the number of extension sin the file */
57   order = FITSextnum(fname);
58     
59   /* Allocating the memory */
60   poly_cube = (poly_cube_flatfield *) malloc(sizeof(poly_cube_flatfield));
61   poly_cube->poly_order = order;
62   poly_cube->coeffs = (gsl_matrix **) malloc(poly_cube->poly_order * sizeof(
      gsl_matrix *));
63   
64   /* Load the FF coefficients, on eplane at a time */
65   for (i=0;i<poly_cube->poly_order;i++)  
66     {
67       poly_cube->coeffs[i] = FITSimage_to_gsl (fname, i+1, 1);
68     }
69   /* Load the minimum and maximum wavelengths this cube applies to */
70   poly_cube->wmin = get_float_from_keyword(fname, 1, "WMIN");
71   poly_cube->wmax = get_float_from_keyword(fname, 1, "WMAX");
72   
73   return poly_cube;
74 }
\end{DoxyCode}
\hypertarget{spc__flatfield_8h_a51dc63c9e14b10df5c589cbf97eedd20}{
\index{spc\_\-flatfield.h@{spc\_\-flatfield.h}!make\_\-multi\_\-flatfield@{make\_\-multi\_\-flatfield}}
\index{make\_\-multi\_\-flatfield@{make\_\-multi\_\-flatfield}!spc_flatfield.h@{spc\_\-flatfield.h}}
\subsubsection[{make\_\-multi\_\-flatfield}]{\setlength{\rightskip}{0pt plus 5cm}{\bf flatfield\_\-d}$\ast$ make\_\-multi\_\-flatfield (const {\bf beam} $\ast$const  {\em curbeam}, \/  const int {\em num\_\-flats}, \/  const double {\em lambda}, \/  const char $\ast$const  {\em flat\_\-name}, \/   {\em ...})}}
\label{spc__flatfield_8h_a51dc63c9e14b10df5c589cbf97eedd20}
creates a descriptor for a flatfield with multiple flatfields at various wavelengths


\begin{DoxyParams}{Parameters}
\item[{\em curbeam}]the \hyperlink{structbeam}{beam} to create the flatfield for, with the bbox filled out (e.g., after \hyperlink{namespacespc__extract}{spc\_\-extract} has run) \item[{\em num\_\-flats}]the number of (lambda,flatfield) pairs \item[{\em lambda}](and the next num\_\-flats odd parameters) the wave length of the following flat field \item[{\em flat\_\-name}](and the next num\_\-flats even parameters) name of the flat field \end{DoxyParams}
\begin{DoxyReturn}{Returns}
an allocated flatfield descriptor 
\end{DoxyReturn}



\begin{DoxyCode}
405 {
406   flatfield_d *ff = malloc (sizeof (flatfield_d));
407   va_list args;
408   int i;
409   
410   if (num_flats < 3)
411     {
412       aXe_message (aXe_M_FATAL, __FILE__, __LINE__,
413                    "Number of flats must be" " larger than 3.");
414     }
415   if (num_flats > MAX_FLATS)
416     {
417       aXe_message (aXe_M_FATAL, __FILE__, __LINE__,
418                    "Too many flatfields." " Increase MAX_FLATS in "
419                    __FILE__ " and recompile me.");
420     }
421   
422   if (!ff)
423     {
424       aXe_message (aXe_M_FATAL, __FILE__, __LINE__, "Out of memory");
425     }
426   ff->ll_x = curbeam->bbox[0].x;
427   ff->ll_y = curbeam->bbox[0].y;
428   ff->w = curbeam->bbox[1].x - curbeam->bbox[0].x + 1;
429   ff->h = curbeam->bbox[1].y - curbeam->bbox[0].y + 1;
430   ff->func = flat_multi_func;
431   
432   ff->data.multi = malloc (sizeof (multi_flatfield));
433   if (!ff->data.multi)
434     {
435       aXe_message (aXe_M_FATAL, __FILE__, __LINE__, "Out of memory");
436     }
437   ff->data.multi->num_flats = num_flats;
438   ff->data.multi->errors = malloc (sizeof (gsl_matrix *) * num_flats);
439   ff->data.multi->flatfields = malloc (sizeof (gsl_matrix *) * num_flats);
440   ff->data.multi->lambdas = malloc (sizeof (double) * num_flats);
441   if ((!ff->data.multi->errors) || (!ff->data.multi->flatfields)
442       || (!ff->data.multi->lambdas))
443     {
444       aXe_message (aXe_M_FATAL, __FILE__, __LINE__, "Out of memory");
445     }
446   
447   ff->data.multi->lambdas[0] = lambda;
448   ff->data.multi->flatfields[0] = load_flatfield (ff, flat_name);
449   ff->data.multi->errors[0] = NULL;
450   va_start (args, flat_name);
451   for (i = 1; i < num_flats; i++)
452     {
453       ff->data.multi->lambdas[i] = va_arg (args, double);
454       ff->data.multi->flatfields[i] =
455         load_flatfield (ff, va_arg (args, char *));
456       ff->data.multi->errors[i] = NULL;
457     }
458   va_end (args);
459   
460   return ff;
461 }
\end{DoxyCode}
\hypertarget{spc__flatfield_8h_a7bbb89f8979ec898f238c71670ea9a97}{
\index{spc\_\-flatfield.h@{spc\_\-flatfield.h}!make\_\-poly\_\-flatfield@{make\_\-poly\_\-flatfield}}
\index{make\_\-poly\_\-flatfield@{make\_\-poly\_\-flatfield}!spc_flatfield.h@{spc\_\-flatfield.h}}
\subsubsection[{make\_\-poly\_\-flatfield}]{\setlength{\rightskip}{0pt plus 5cm}{\bf flatfield\_\-d}$\ast$ make\_\-poly\_\-flatfield (const {\bf beam} $\ast$const  {\em curbeam}, \/  const char $\ast$const  {\em flat\_\-name}, \/  const int {\em order}, \/  const double $\ast$const  {\em coeffs})}}
\label{spc__flatfield_8h_a7bbb89f8979ec898f238c71670ea9a97}
\hypertarget{spc__flatfield_8h_a453e895ac1865f71f8b5126a0bcfb519}{
\index{spc\_\-flatfield.h@{spc\_\-flatfield.h}!poly\_\-cube\_\-flatfield\_\-lambda@{poly\_\-cube\_\-flatfield\_\-lambda}}
\index{poly\_\-cube\_\-flatfield\_\-lambda@{poly\_\-cube\_\-flatfield\_\-lambda}!spc_flatfield.h@{spc\_\-flatfield.h}}
\subsubsection[{poly\_\-cube\_\-flatfield\_\-lambda}]{\setlength{\rightskip}{0pt plus 5cm}double poly\_\-cube\_\-flatfield\_\-lambda (const double {\em lambda}, \/  const int {\em x}, \/  const int {\em y}, \/  {\bf poly\_\-cube\_\-flatfield} $\ast$ {\em poly\_\-cube})}}
\label{spc__flatfield_8h_a453e895ac1865f71f8b5126a0bcfb519}
Evaluates and return the flatfielding value of pixel coordinates x,y and at wavelength lambda, using the field dependent polynomial description contained in a \hyperlink{structpoly__cube__flatfield}{poly\_\-cube\_\-flatfield} structure. Uses abs(lambda) for cosmetic reasons. If the sampled wavelength falls outside of the wmin$<$w$<$wmax range, then a warning is issued and no flat-\/field coefficient is computed, and 1.0 is returned \mbox{[}new version now returns the FF value at the closest known wavelength\mbox{]} 
\begin{DoxyParams}{Parameters}
\item[{\em lambda}]the wavelength \end{DoxyParams}



\begin{DoxyCode}
92 {
93   int i;
94   double ff=0.0;
95   double w; /* nomalized wavelength */
96 
97     
98   /* if ( (lambda>poly_cube->wmax) || (lambda<poly_cube->wmin) )
99      {
100      aXe_message (aXe_M_WARN4, __FILE__, __LINE__, "Sampled wavelengh (%f)"
101      " is outside of FF cube (%f < ww < %f). Returning 1.0\n",lambda,poly_cube->w
      min,poly_cube->wmax);
102      w = 1.0;
103      for (i=0;i<poly_cube->poly_order;i++) 
104      {
105      ff = ff + gsl_matrix_get(poly_cube->coeffs[i],x,y)*pow(w,i);
106      }
107      return ff;
108      }*/
109     
110   w = (fabs(lambda) - poly_cube->wmin)/(poly_cube->wmax-poly_cube->wmin);
111 
112   if (lambda<poly_cube->wmin)
113     {
114       w = .0;
115     }        
116   if (lambda>poly_cube->wmax)
117     {
118       w = 1.0;
119     }    
120   
121   for (i=0;i<poly_cube->poly_order;i++) 
122     {
123       ff = ff + gsl_matrix_get(poly_cube->coeffs[i],x,y)*pow(w,i);
124     }
125   return ff;
126 }
\end{DoxyCode}
