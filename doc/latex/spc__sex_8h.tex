\hypertarget{spc__sex_8h}{
\section{/renoir/fourmano/Desktop/OUSIM/TIPS/branches/tips\_\-build/include/axesim/spc\_\-sex.h File Reference}
\label{spc__sex_8h}\index{/renoir/fourmano/Desktop/OUSIM/TIPS/branches/tips\_\-build/include/axesim/spc\_\-sex.h@{/renoir/fourmano/Desktop/OUSIM/TIPS/branches/tips\_\-build/include/axesim/spc\_\-sex.h}}
}
{\ttfamily \#include \char`\"{}spc\_\-CD.h\char`\"{}}\par
\subsection*{Data Structures}
\begin{DoxyCompactItemize}
\item 
struct \hyperlink{structellipse}{ellipse}
\item 
struct \hyperlink{structSexObject}{SexObject}
\end{DoxyCompactItemize}
\subsection*{Namespaces}
\begin{DoxyCompactItemize}
\item 
namespace \hyperlink{namespacespc__sex}{spc\_\-sex}
\end{DoxyCompactItemize}
\subsection*{Defines}
\begin{DoxyCompactItemize}
\item 
\#define \hyperlink{spc__sex_8h_a385dd6d87c5af9252e1c0bf82d87e969}{CATBUFFERSIZE}~10240
\item 
\#define \hyperlink{spc__sex_8h_aacc3ee1a7f283f8ef65cea31f4436a95}{MAX}(x, y)~(((x)$>$(y))?(x):(y))
\item 
\#define \hyperlink{spc__sex_8h_a19321d394ebca38412cec1c3f5bbf5bf}{MIN\_\-DIFFANGLE}~3.0
\end{DoxyCompactItemize}
\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
\hyperlink{structSexObject}{SexObject} $\ast$ \hyperlink{spc__sex_8h_a9fa77923a7b018be8b7073863b9e3c96}{create\_\-SexObject} (const \hyperlink{structcolinfo}{colinfo} $\ast$actinfo, char $\ast$line, const gsl\_\-vector $\ast$waves, const gsl\_\-vector $\ast$cnums, const \hyperlink{structpx__point}{px\_\-point} backwin\_\-cols, const \hyperlink{structpx__point}{px\_\-point} modinfo\_\-cols, const int magcol, const int fullinfo)
\item 
void \hyperlink{spc__sex_8h_a50a3720d64c09d63859bb71314e14f8b}{SexObject\_\-fprintf} (FILE $\ast$output, \hyperlink{structSexObject}{SexObject} $\ast$o)
\item 
void \hyperlink{spc__sex_8h_ae9d3731ef7e209c389cde4b659e5cac8}{SexMags\_\-to\_\-beamFlux} (\hyperlink{structSexObject}{SexObject} $\ast$sobj, \hyperlink{structbeam}{beam} $\ast$actbeam)
\item 
void \hyperlink{spc__sex_8h_af26ee7c0414b10010e9a3a2cdfcbcb9d}{SexObject\_\-to\_\-slitgeom} (const \hyperlink{structaperture__conf}{aperture\_\-conf} $\ast$conf, const \hyperlink{structSexObject}{SexObject} $\ast$sobj, const double trace\_\-angle, \hyperlink{structbeam}{beam} $\ast$actbeam)
\item 
void \hyperlink{spc__sex_8h_ab677ce148520e7e408d39157562ed425}{fill\_\-corner\_\-ignore} (\hyperlink{structSexObject}{SexObject} $\ast$sobj, \hyperlink{structobservation}{observation} $\ast$const obs, \hyperlink{structaperture__conf}{aperture\_\-conf} $\ast$conf, int beamID, float dmag, \hyperlink{structbeam}{beam} $\ast$actbeam)
\item 
\hyperlink{structd__point}{d\_\-point} \hyperlink{spc__sex_8h_a594a5c195cf16b237615c2b8ca76ac63}{check\_\-object\_\-size} (const \hyperlink{structaperture__conf}{aperture\_\-conf} $\ast$conf, const \hyperlink{structSexObject}{SexObject} $\ast$sobj, const int beamID)
\item 
void \hyperlink{spc__sex_8h_aaf18fdf0a495428d532fc2acb0cb337b}{SexObject\_\-to\_\-beam} (\hyperlink{structSexObject}{SexObject} $\ast$sobj, \hyperlink{structobservation}{observation} $\ast$const obs, \hyperlink{structaperture__conf}{aperture\_\-conf} $\ast$conf, char conffile\mbox{[}$\,$\mbox{]}, float mfwhm, float dmag, int auto\_\-reorient, int bck\_\-mode, int beamID, \hyperlink{structbeam}{beam} $\ast$actbeam)
\item 
\hyperlink{structobject}{object} $\ast$ \hyperlink{spc__sex_8h_adca42a33ade468757a83d39dd9462137}{SexObject\_\-to\_\-objectII} (\hyperlink{structSexObject}{SexObject} $\ast$sobj, \hyperlink{structobservation}{observation} $\ast$const obs, \hyperlink{structaperture__conf}{aperture\_\-conf} $\ast$conf, char conffile\mbox{[}$\,$\mbox{]}, float mfwhm, float dmag, int auto\_\-reorient, int bck\_\-mode)
\item 
\hyperlink{structobject}{object} $\ast$ \hyperlink{spc__sex_8h_a1cc8887bfa02d842b41141ae74750490}{SexObject\_\-to\_\-object} (\hyperlink{structSexObject}{SexObject} $\ast$sobj, \hyperlink{structobservation}{observation} $\ast$const obs, \hyperlink{structaperture__conf}{aperture\_\-conf} $\ast$conf, char conffile\mbox{[}$\,$\mbox{]}, float mfwhm, float dmag, int auto\_\-reorient, int bck\_\-mode)
\item 
\hyperlink{structobject}{object} $\ast$$\ast$ \hyperlink{spc__sex_8h_a3be1c25232414791b69783398d5c0fc3}{SexObjects\_\-to\_\-oblist} (\hyperlink{structSexObject}{SexObject} $\ast$$\ast$sobjs, \hyperlink{structobservation}{observation} $\ast$const obs, \hyperlink{structaperture__conf}{aperture\_\-conf} $\ast$conf, char conffile\mbox{[}$\,$\mbox{]}, float mfwhm, float dmag, int auto\_\-reorient, int back\_\-mode)
\item 
\hyperlink{structobject}{object} $\ast$$\ast$ \hyperlink{spc__sex_8h_aba315f6055ab2042c62d24e4a6312491}{SexObjects\_\-to\_\-oblistII} (\hyperlink{structSexObject}{SexObject} $\ast$$\ast$sobjs, \hyperlink{structobservation}{observation} $\ast$const obs, \hyperlink{structaperture__conf}{aperture\_\-conf} $\ast$conf, char conffile\mbox{[}$\,$\mbox{]}, float mfwhm, float dmag, int auto\_\-reorient, int bck\_\-mode)
\item 
int \hyperlink{spc__sex_8h_a24c706cb578a86827a1d5b991c34e783}{check\_\-conf\_\-for\_\-slitlessgeom} (const \hyperlink{structaperture__conf}{aperture\_\-conf} $\ast$conf, const int auto\_\-reorient)
\item 
int \hyperlink{spc__sex_8h_a81c5036b461b98a7c6dde47ea87c0220}{fill\_\-object\_\-bbox} (\hyperlink{structobservation}{observation} $\ast$const obs, \hyperlink{structbeam}{beam} $\ast$b, const float m\_\-width, const int dxmin, const int dxmax)
\item 
int \hyperlink{spc__sex_8h_aa358fe9be94faba9d46991eb7fa9e766}{size\_\-of\_\-sextractor\_\-catalog} (char filename\mbox{[}$\,$\mbox{]})
\item 
\hyperlink{structSexObject}{SexObject} $\ast$$\ast$ \hyperlink{spc__sex_8h_af8023b218b4f95008b4a8e4df19005fa}{get\_\-SexObject\_\-from\_\-catalog} (char filename\mbox{[}$\,$\mbox{]}, const double lambda\_\-mark)
\item 
void \hyperlink{spc__sex_8h_a7f30208a96f597d37e88ce2ec2c7c519}{ABC\_\-image\_\-to\_\-el} (\hyperlink{structd__point}{d\_\-point} $\ast$a, \hyperlink{structd__point}{d\_\-point} $\ast$b, \hyperlink{structd__point}{d\_\-point} $\ast$c, \hyperlink{structellipse}{ellipse} $\ast$el)
\item 
void \hyperlink{spc__sex_8h_a3b2003d8f076d528435938f1ed8491ed}{ABC\_\-image\_\-to\_\-el2} (\hyperlink{structd__point}{d\_\-point} $\ast$a, \hyperlink{structd__point}{d\_\-point} $\ast$b, \hyperlink{structd__point}{d\_\-point} $\ast$c, \hyperlink{structellipse}{ellipse} $\ast$el)
\item 
void \hyperlink{spc__sex_8h_a1dfd57669396970a74aa9035c953e86d}{el\_\-to\_\-ABC\_\-world} (\hyperlink{structellipse}{ellipse} $\ast$el, \hyperlink{structsky__coord}{sky\_\-coord} $\ast$a, \hyperlink{structsky__coord}{sky\_\-coord} $\ast$b, \hyperlink{structsky__coord}{sky\_\-coord} $\ast$c)
\item 
void \hyperlink{spc__sex_8h_a7062ae05d05dbc0071064dfe649dfb64}{el\_\-to\_\-ABC\_\-world2} (\hyperlink{structellipse}{ellipse} $\ast$el, \hyperlink{structsky__coord}{sky\_\-coord} $\ast$a, \hyperlink{structsky__coord}{sky\_\-coord} $\ast$b, \hyperlink{structsky__coord}{sky\_\-coord} $\ast$c)
\item 
void \hyperlink{spc__sex_8h_a8dc42564a62fb75a865abd1e97f3cef5}{fill\_\-missing\_\-image\_\-coordinates} (\hyperlink{structSexObject}{SexObject} $\ast$o, struct WorldCoor $\ast$from\_\-wcs, int overwrite)
\item 
void \hyperlink{spc__sex_8h_a9e39e413308fb40567ce4507d4b48d78}{fill\_\-all\_\-missing\_\-image\_\-coordinates} (\hyperlink{structSexObject}{SexObject} $\ast$$\ast$sobjs, struct WorldCoor $\ast$from\_\-wcs, int overwrite)
\item 
void \hyperlink{spc__sex_8h_a0ab3db728560b7a291df4044abbea97e}{fill\_\-missing\_\-WCS\_\-coordinates} (\hyperlink{structSexObject}{SexObject} $\ast$o, struct WorldCoor $\ast$from\_\-wcs, int overwrite)
\item 
void \hyperlink{spc__sex_8h_ab49c25c830b7c93a094562fffced9597}{fill\_\-all\_\-missing\_\-WCS\_\-coordinates} (\hyperlink{structSexObject}{SexObject} $\ast$$\ast$sobjs, struct WorldCoor $\ast$from\_\-wcs, int overwrite)
\item 
void \hyperlink{spc__sex_8h_a7f60c3c87d2ddd2c795ab0ab66effce5}{compute\_\-new\_\-image\_\-coordinates} (\hyperlink{structSexObject}{SexObject} $\ast$o, struct WorldCoor $\ast$to\_\-wcs)
\item 
void \hyperlink{spc__sex_8h_a0f5894072e9db45e3cee9324218a8da3}{compute\_\-new\_\-image\_\-sexobject} (\hyperlink{structSexObject}{SexObject} $\ast$o, struct WorldCoor $\ast$to\_\-wcs, int th\_\-sky)
\item 
void \hyperlink{spc__sex_8h_ada6d87ffba18d3cfd0d14d687aeadecd}{compute\_\-all\_\-new\_\-image\_\-coordinates} (\hyperlink{structSexObject}{SexObject} $\ast$$\ast$sobjs, struct WorldCoor $\ast$to\_\-wcs)
\item 
void \hyperlink{spc__sex_8h_a93f742561264057d72a0c2b74633976c}{catalog\_\-to\_\-wcs} (char grismfile\mbox{[}$\,$\mbox{]}, int hdunum, char infile\mbox{[}$\,$\mbox{]}, char outfile\mbox{[}$\,$\mbox{]}, struct WorldCoor $\ast$from\_\-wcs, struct WorldCoor $\ast$to\_\-wcs, int distortion, int overwrite\_\-wcs, int overwrite\_\-img)
\item 
void \hyperlink{spc__sex_8h_a09d4b7e97c42c84bf4a3cf9ffda6c614}{catalog\_\-to\_\-wcs\_\-nodim} (char infile\mbox{[}$\,$\mbox{]}, char outfile\mbox{[}$\,$\mbox{]}, struct WorldCoor $\ast$to\_\-wcs, int overwrite\_\-wcs, int overwrite\_\-img)
\item 
gsl\_\-vector $\ast$ \hyperlink{spc__sex_8h_a496014d96016e580b632b2b15e0b7f72}{sobs\_\-to\_\-vout} (const \hyperlink{structSexObject}{SexObject} $\ast$sobs)
\item 
void \hyperlink{spc__sex_8h_a1de62f331f136845a887cec91920982e}{free\_\-SexObjects} (\hyperlink{structSexObject}{SexObject} $\ast$$\ast$sobjs)
\end{DoxyCompactItemize}


\subsection{Define Documentation}
\hypertarget{spc__sex_8h_a385dd6d87c5af9252e1c0bf82d87e969}{
\index{spc\_\-sex.h@{spc\_\-sex.h}!CATBUFFERSIZE@{CATBUFFERSIZE}}
\index{CATBUFFERSIZE@{CATBUFFERSIZE}!spc_sex.h@{spc\_\-sex.h}}
\subsubsection[{CATBUFFERSIZE}]{\setlength{\rightskip}{0pt plus 5cm}\#define CATBUFFERSIZE~10240}}
\label{spc__sex_8h_a385dd6d87c5af9252e1c0bf82d87e969}
\hypertarget{spc__sex_8h_aacc3ee1a7f283f8ef65cea31f4436a95}{
\index{spc\_\-sex.h@{spc\_\-sex.h}!MAX@{MAX}}
\index{MAX@{MAX}!spc_sex.h@{spc\_\-sex.h}}
\subsubsection[{MAX}]{\setlength{\rightskip}{0pt plus 5cm}\#define MAX(x, \/  y)~(((x)$>$(y))?(x):(y))}}
\label{spc__sex_8h_aacc3ee1a7f283f8ef65cea31f4436a95}
\hypertarget{spc__sex_8h_a19321d394ebca38412cec1c3f5bbf5bf}{
\index{spc\_\-sex.h@{spc\_\-sex.h}!MIN\_\-DIFFANGLE@{MIN\_\-DIFFANGLE}}
\index{MIN\_\-DIFFANGLE@{MIN\_\-DIFFANGLE}!spc_sex.h@{spc\_\-sex.h}}
\subsubsection[{MIN\_\-DIFFANGLE}]{\setlength{\rightskip}{0pt plus 5cm}\#define MIN\_\-DIFFANGLE~3.0}}
\label{spc__sex_8h_a19321d394ebca38412cec1c3f5bbf5bf}


\subsection{Function Documentation}
\hypertarget{spc__sex_8h_a7f30208a96f597d37e88ce2ec2c7c519}{
\index{spc\_\-sex.h@{spc\_\-sex.h}!ABC\_\-image\_\-to\_\-el@{ABC\_\-image\_\-to\_\-el}}
\index{ABC\_\-image\_\-to\_\-el@{ABC\_\-image\_\-to\_\-el}!spc_sex.h@{spc\_\-sex.h}}
\subsubsection[{ABC\_\-image\_\-to\_\-el}]{\setlength{\rightskip}{0pt plus 5cm}void ABC\_\-image\_\-to\_\-el ({\bf d\_\-point} $\ast$ {\em a}, \/  {\bf d\_\-point} $\ast$ {\em b}, \/  {\bf d\_\-point} $\ast$ {\em c}, \/  {\bf ellipse} $\ast$ {\em el})}}
\label{spc__sex_8h_a7f30208a96f597d37e88ce2ec2c7c519}
Function: ABC\_\-image\_\-to\_\-el Convert a set of three image coordinates into an elipse structure 


\begin{DoxyCode}
1757 {
1758   if (b->x != 0.0)
1759     {
1760       el->theta = atan (b->y / b->x) / M_PI * 180.0;
1761     }
1762   else
1763     {
1764       el->theta = 90.0;
1765     }
1766 
1767   el->a = sqrt ((b->x - a->x) * (b->x - a->x) + (b->y - a->y) * (b->y - a->y));
1768   el->b = sqrt ((c->x - a->x) * (c->x - a->x) + (c->y - a->y) * (c->y - a->y));
1769 }
\end{DoxyCode}
\hypertarget{spc__sex_8h_a3b2003d8f076d528435938f1ed8491ed}{
\index{spc\_\-sex.h@{spc\_\-sex.h}!ABC\_\-image\_\-to\_\-el2@{ABC\_\-image\_\-to\_\-el2}}
\index{ABC\_\-image\_\-to\_\-el2@{ABC\_\-image\_\-to\_\-el2}!spc_sex.h@{spc\_\-sex.h}}
\subsubsection[{ABC\_\-image\_\-to\_\-el2}]{\setlength{\rightskip}{0pt plus 5cm}void ABC\_\-image\_\-to\_\-el2 ({\bf d\_\-point} $\ast$ {\em a}, \/  {\bf d\_\-point} $\ast$ {\em b}, \/  {\bf d\_\-point} $\ast$ {\em c}, \/  {\bf ellipse} $\ast$ {\em el})}}
\label{spc__sex_8h_a3b2003d8f076d528435938f1ed8491ed}
Function: ABC\_\-image\_\-to\_\-el2 Convert a set of three image coordinates into an elipse structure 


\begin{DoxyCode}
1778 {
1779   el->theta = atan ((b->y - a->y )/ (b->x - a->x)) / M_PI * 180.0;
1780 
1781   el->a = sqrt ((b->x - a->x) * (b->x - a->x) + (b->y - a->y) * (b->y - a->y));
1782   el->b = sqrt ((c->x - a->x) * (c->x - a->x) + (c->y - a->y) * (c->y - a->y));
1783 }
\end{DoxyCode}
\hypertarget{spc__sex_8h_a93f742561264057d72a0c2b74633976c}{
\index{spc\_\-sex.h@{spc\_\-sex.h}!catalog\_\-to\_\-wcs@{catalog\_\-to\_\-wcs}}
\index{catalog\_\-to\_\-wcs@{catalog\_\-to\_\-wcs}!spc_sex.h@{spc\_\-sex.h}}
\subsubsection[{catalog\_\-to\_\-wcs}]{\setlength{\rightskip}{0pt plus 5cm}void catalog\_\-to\_\-wcs (char {\em grismfile}\mbox{[}$\,$\mbox{]}, \/  int {\em hdunum}, \/  char {\em infile}\mbox{[}$\,$\mbox{]}, \/  char {\em outfile}\mbox{[}$\,$\mbox{]}, \/  struct WorldCoor $\ast$ {\em from\_\-wcs}, \/  struct WorldCoor $\ast$ {\em to\_\-wcs}, \/  int {\em distortion}, \/  int {\em overwrite\_\-wcs}, \/  int {\em overwrite\_\-img})}}
\label{spc__sex_8h_a93f742561264057d72a0c2b74633976c}
Function: catalog\_\-to\_\-wcs This function reads a sextractor catalog and using an input and an output CD matrix, converts the world ra and dec coordinates to the output CD matrix's image pixel coordinates. Non existing (i.e. NaN) world RA and DEC values are generated using the pixel coordinates and the input CD matrix

Parameters: 
\begin{DoxyParams}{Parameters}
\item[{\em -\/}]infile a pointer to a char array containing the name of the input catalog \item[{\em -\/}]outfile a pointer to a char array containing the name of the output catalog \item[{\em -\/}]from\_\-wcs a pointer to an exisiting WoldCoor structure containing the input catalog CD matrix \item[{\em -\/}]to\_\-wcs a pointer to an exisiting WoldCoor structure containing the output catalog CD matrix \item[{\em -\/}]overwrite\_\-wcs if set to 1 then input wold coordinate are recomputed first using the from\_\-wcs and the x,y image values \item[{\em -\/}]overwrite\_\-img if set to 1 then the x,y coordinates of the input image are first computed using the from\_\-wcs and the world ra and dec info \end{DoxyParams}



\begin{DoxyCode}
305 {
306   FILE *fin, *fout;
307   gsl_vector *v;
308   gsl_vector *v_out;
309   gsl_vector *waves;
310   gsl_vector *cnums;
311   gsl_matrix *coeffs=NULL;
312   char Buffer[CATBUFFERSIZE];
313   char line[CATBUFFERSIZE], str[CATBUFFERSIZE];
314   int i, hasmags=0, magcencol = 0;
315   //int index;
316   SexObject *o;
317   colinfo * actcatinfo;
318   px_point    pixmax;
319   px_point    backwin_cols;
320   px_point    modinfo_cols;
321 
322 
323   actcatinfo = get_sex_col_descr (infile);
324   hasmags = has_magnitudes(actcatinfo);
325   if (!hasmags)
326     {
327       aXe_message (aXe_M_FATAL, __FILE__, __LINE__,
328                    "No magnitudes in file %s", infile);
329     }
330   else{
331     waves = gsl_vector_alloc (hasmags);
332     cnums = gsl_vector_alloc (hasmags);
333     hasmags = get_magcols(actcatinfo, waves, cnums);
334     magcencol = get_magauto_col(waves, cnums, 800.0);
335   }
336 
337   backwin_cols = has_backwindow(actcatinfo);
338   modinfo_cols = has_modelinfo(actcatinfo);
339 
340 
341   if (!(fin = fopen (infile, "r")))
342     {
343       aXe_message (aXe_M_FATAL, __FILE__, __LINE__,
344                    "Cannot open catalog file %s", infile);
345     }
346   if (!(fout = fopen (outfile, "w")))
347     {
348       aXe_message (aXe_M_FATAL, __FILE__, __LINE__,
349                    "Cannot open catalog file %s", outfile);
350     }
351 
352   if (check_worldcoo_input(actcatinfo, 0))
353     aXe_message (aXe_M_FATAL, __FILE__, __LINE__,
354                  "Catalogue %s does not have all WCO columns\n", infile);
355 
356   if (check_imagecoo_input(actcatinfo))
357     aXe_message (aXe_M_FATAL, __FILE__, __LINE__,
358                  "Catalogue %s does not have all image coo columns\n", infile);
359 
360   make_GOL_header(fout, actcatinfo, waves, cnums, backwin_cols, modinfo_cols);
361 
362   if (distortion)
363     coeffs = get_crossdisp_matrix(grismfile, hdunum);
364 
365   pixmax = get_npixels (grismfile, hdunum);
366 
367   while (fgets (line, CATBUFFERSIZE, fin))
368     {
369       if (!(line_is_valid (actcatinfo, line)))
370         continue;
371        if (line[0] == ';')
372          continue;
373 
374       /* Create a vector containing the information */
375       lv1ws (line);
376       v = string_to_gsl_array (line);
377 
378       //      o = create_SexObject (sex_col_desc, line);
379       o = create_SexObject (actcatinfo, line, waves, cnums, backwin_cols, modinfo
      _cols, magcencol,  1);
380 
381       if ( (from_wcs!=NULL)&&(to_wcs!=NULL) )
382         {
383           //      if (distortion){
384           //        fprintf(stdout, "(%f,%f) &&-->&& ", o->xy_image.x, o->xy_imag
      e.y);
385           //        o->xy_image = undistort_point(coeffs, pixmax, o->xy_image);
386           //      }
387           fill_missing_WCS_coordinates (o, from_wcs, overwrite_wcs);
388           fill_missing_image_coordinates (o, from_wcs, overwrite_img);
389           compute_new_image_coordinates (o, to_wcs);
390           if (distortion){
391             o->xy_image = distort_point(coeffs, pixmax, o->xy_image);
392             //      fprintf(stdout, "(%f,%f)\n\n", o->xy_image.x, o->xy_image.y);
      
393           }
394         }
395 
396       v_out = sobs_to_vout(o);
397 
398       sprintf (Buffer, "%8.5g ", gsl_vector_get (v_out, 0));
399       for (i = 1; i < v_out->size; i++)
400         {
401           sprintf (str, " %8.5g ", gsl_vector_get (v_out, i));
402           strcat (Buffer, str);
403         }
404       strcat (Buffer, "\n");
405 
406       fputs (Buffer, fout);
407 
408       gsl_vector_free (v_out);
409       gsl_vector_free (v);
410   }
411 
412   if (coeffs)
413     gsl_matrix_free(coeffs);
414 
415   fclose (fin);
416   fclose (fout);
417 }
\end{DoxyCode}
\hypertarget{spc__sex_8h_a09d4b7e97c42c84bf4a3cf9ffda6c614}{
\index{spc\_\-sex.h@{spc\_\-sex.h}!catalog\_\-to\_\-wcs\_\-nodim@{catalog\_\-to\_\-wcs\_\-nodim}}
\index{catalog\_\-to\_\-wcs\_\-nodim@{catalog\_\-to\_\-wcs\_\-nodim}!spc_sex.h@{spc\_\-sex.h}}
\subsubsection[{catalog\_\-to\_\-wcs\_\-nodim}]{\setlength{\rightskip}{0pt plus 5cm}void catalog\_\-to\_\-wcs\_\-nodim (char {\em infile}\mbox{[}$\,$\mbox{]}, \/  char {\em outfile}\mbox{[}$\,$\mbox{]}, \/  struct WorldCoor $\ast$ {\em grism\_\-wcs}, \/  int {\em overwrite\_\-wcs}, \/  int {\em overwrite\_\-img})}}
\label{spc__sex_8h_a09d4b7e97c42c84bf4a3cf9ffda6c614}
Function:catalog\_\-to\_\-wcs\_\-nodim This function reads a sextractor catalog and using an input and an output CD matrix, converts the world ra and dec coordinates to the output CD matrix's image pixel coordinates. Non existing (i.e. NaN) world RA and DEC values are generated using the pixel coordinates and the input CD matrix

Parameters: 
\begin{DoxyParams}{Parameters}
\item[{\em infile}]-\/ a pointer to a char array containing the name of the input catalog \item[{\em outfile}]-\/ a pointer to a char array containing the name of the output catalog \item[{\em from\_\-wcs}]-\/ a pointer to an exisiting WoldCoor structure containing the input catalog CD matrix \item[{\em to\_\-wcs}]-\/ a pointer to an exisiting WoldCoor structure containing the output catalog CD matrix \item[{\em overwrite\_\-wcs}]-\/ if set to 1 then input wold coordinate are recomputed first using the from\_\-wcs and the x,y image values \item[{\em overwrite\_\-img}]-\/ if set to 1 then the x,y coordinates of the input image are first computed using the from\_\-wcs and the world ra and dec info \end{DoxyParams}



\begin{DoxyCode}
447 {
448   FILE *fin, *fout;
449   gsl_vector *v;
450   gsl_vector *v_out;
451   gsl_vector *waves;
452   gsl_vector *cnums;
453   char Buffer[CATBUFFERSIZE];
454   char line[CATBUFFERSIZE], str[CATBUFFERSIZE];
455   int i;
456   //int index;
457   SexObject *o;
458   int compute_imcoos=0;
459   int th_sky=0;
460   int checksum, hasmags=0, magcencol=0;
461   colinfo * actcatinfo;
462   px_point    backwin_cols;
463   px_point    modinfo_cols;
464 
465   actcatinfo = get_sex_col_descr (infile);
466   hasmags = has_magnitudes(actcatinfo);
467   if (!hasmags)
468     {
469       aXe_message (aXe_M_FATAL, __FILE__, __LINE__,
470                    "No magnitudes in file %s", infile);
471     }
472   else{
473     waves = gsl_vector_alloc (hasmags);
474     cnums = gsl_vector_alloc (hasmags);
475     hasmags = get_magcols(actcatinfo, waves, cnums);
476     magcencol = get_magauto_col(waves, cnums, 800.0);
477   }
478 
479   backwin_cols = has_backwindow(actcatinfo);
480   modinfo_cols = has_modelinfo(actcatinfo);
481 
482   if (!(fin = fopen (infile, "r")))
483     {
484       aXe_message (aXe_M_FATAL, __FILE__, __LINE__,
485                    "Cannot open catalog file %s", infile);
486     }
487   if (!(fout = fopen (outfile, "w")))
488     {
489       aXe_message (aXe_M_FATAL, __FILE__, __LINE__,
490                    "Cannot open catalog file %s", outfile);
491     }
492 
493   //  checksum = check_worldcoo_input(sex_col_desc);
494   th_sky=1;
495   checksum = check_worldcoo_input(actcatinfo, 1);
496   if (checksum)
497     aXe_message (aXe_M_FATAL, __FILE__, __LINE__,
498                  "Catalogue %s does not have all necessary columns\n", infile);
499 
500   //  if (check_imagecoo_input(sex_col_desc))
501   if (check_imagecoo_input(actcatinfo))
502     compute_imcoos=1;
503 
504   make_GOL_header(fout, actcatinfo, waves, cnums, backwin_cols, modinfo_cols);
505 
506   while (fgets (line, CATBUFFERSIZE, fin))
507     {
508 
509       /* If line is not a valid catalog entry, just continue */
510       if (!(line_is_valid (actcatinfo, line)))
511         continue;
512 
513       /* if line starts with ";", just continue */
514       if (line[0] == ';')
515         continue;
516 
517       /* Create a vector containing the information */
518       lv1ws (line);
519       v = string_to_gsl_array (line);
520 
521       o = create_SexObject (actcatinfo, line, waves, cnums, backwin_cols, modinfo
      _cols, magcencol,  0);
522 
523 
524       if (compute_imcoos)
525         compute_new_image_sexobject (o, grism_wcs, th_sky);
526       v_out = sobs_to_vout(o);
527 
528 
529       sprintf (Buffer, "%8.5g ", gsl_vector_get (v_out, 0));
530       for (i = 1; i < v_out->size; i++)
531         {
532           sprintf (str, " %8.5g ", gsl_vector_get (v_out, i));
533           strcat (Buffer, str);
534         }
535       strcat (Buffer, "\n");
536 
537       fputs (Buffer, fout);
538 
539       gsl_vector_free (v_out);
540       gsl_vector_free (v);
541     }
542 
543   fclose (fin);
544   fclose (fout);
545 
546   free (actcatinfo);
547 
548 }
\end{DoxyCode}
\hypertarget{spc__sex_8h_a24c706cb578a86827a1d5b991c34e783}{
\index{spc\_\-sex.h@{spc\_\-sex.h}!check\_\-conf\_\-for\_\-slitlessgeom@{check\_\-conf\_\-for\_\-slitlessgeom}}
\index{check\_\-conf\_\-for\_\-slitlessgeom@{check\_\-conf\_\-for\_\-slitlessgeom}!spc_sex.h@{spc\_\-sex.h}}
\subsubsection[{check\_\-conf\_\-for\_\-slitlessgeom}]{\setlength{\rightskip}{0pt plus 5cm}int check\_\-conf\_\-for\_\-slitlessgeom (const {\bf aperture\_\-conf} $\ast$ {\em conf}, \/  const int {\em auto\_\-reorient})}}
\label{spc__sex_8h_a24c706cb578a86827a1d5b991c34e783}
Function: check\_\-conf\_\-for\_\-slitlessgeom The functions checks whether a smoothed flux conversion is possible or not. In case that keywords in the configuration files are missing, it is NOT possible, and 0 is returned.

Parameters: 
\begin{DoxyParams}{Parameters}
\item[{\em conf}]-\/ the configuarion file structure \item[{\em auto\_\-reorient}]-\/ integer indicating the extraction method\end{DoxyParams}
Returns \begin{DoxyReturn}{Returns}
is\_\-possible -\/ the paramters used in the smoothing 
\end{DoxyReturn}



\begin{DoxyCode}
1441   {
1442     int is_possible=1;
1443 
1444     if (auto_reorient == 1 && conf->pobjsize < 0.0)
1445       // change the switch
1446       is_possible = 0;
1447 
1448     // return the pointer
1449     return is_possible;
1450   }
\end{DoxyCode}
\hypertarget{spc__sex_8h_a594a5c195cf16b237615c2b8ca76ac63}{
\index{spc\_\-sex.h@{spc\_\-sex.h}!check\_\-object\_\-size@{check\_\-object\_\-size}}
\index{check\_\-object\_\-size@{check\_\-object\_\-size}!spc_sex.h@{spc\_\-sex.h}}
\subsubsection[{check\_\-object\_\-size}]{\setlength{\rightskip}{0pt plus 5cm}{\bf d\_\-point} check\_\-object\_\-size (const {\bf aperture\_\-conf} $\ast$ {\em conf}, \/  const {\bf SexObject} $\ast$ {\em sobj}, \/  const int {\em beamID})}}
\label{spc__sex_8h_a594a5c195cf16b237615c2b8ca76ac63}



\begin{DoxyCode}
893   {
894     double obj_size = 0.0;
895 
896     d_point ret;
897 
898     // set the input values
899     // as default
900     ret.x = sobj->el_image.a;
901     ret.y = sobj->el_image.b;
902 
903     // check whether a minimum
904     // size is defined
905     if (conf->pobjsize < 0.0)
906       // return the value
907       return ret;
908 
909     // compute the object size
910     obj_size = sobj->el_image.a * sobj->el_image.b;
911 
912     // check whether the object is point-like
913     if (obj_size < SQR(conf->pobjsize))
914       {
915         // transfer the point-like
916         // sizes to the return
917         ret.x = conf->pobjsize;
918         ret.y = conf->pobjsize;
919         fprintf(stdout, "Object ID %i, %c: size set to: %f\n", sobj->number, 
      BEAM(beamID), conf->pobjsize);
920       }
921 
922     // return the resulting
923     // object size
924     return ret;
925   }
\end{DoxyCode}
\hypertarget{spc__sex_8h_ada6d87ffba18d3cfd0d14d687aeadecd}{
\index{spc\_\-sex.h@{spc\_\-sex.h}!compute\_\-all\_\-new\_\-image\_\-coordinates@{compute\_\-all\_\-new\_\-image\_\-coordinates}}
\index{compute\_\-all\_\-new\_\-image\_\-coordinates@{compute\_\-all\_\-new\_\-image\_\-coordinates}!spc_sex.h@{spc\_\-sex.h}}
\subsubsection[{compute\_\-all\_\-new\_\-image\_\-coordinates}]{\setlength{\rightskip}{0pt plus 5cm}void compute\_\-all\_\-new\_\-image\_\-coordinates ({\bf SexObject} $\ast$$\ast$ {\em sobjs}, \/  struct WorldCoor $\ast$ {\em to\_\-wcs})}}
\label{spc__sex_8h_ada6d87ffba18d3cfd0d14d687aeadecd}
Function: compute\_\-all\_\-new\_\-image\_\-coordinates Replaces all SexObjects image coordinates with new ones computed using the the passed WCS.

Parameters: 
\begin{DoxyParams}{Parameters}
\item[{\em sobjs}]-\/ a NULL terminated array containing pointers to SexObjects \item[{\em to\_\-wcs}]-\/ a pointer to an existing WoldCoord wcs structure \end{DoxyParams}



\begin{DoxyCode}
2060 {
2061      int i, nobjs = 0;
2062 
2063      /* Find the number of SexObjects in sobjs */
2064      while (sobjs[nobjs])
2065           nobjs++;
2066 
2067      for (i = 0; i < nobjs; i++)
2068        {
2069             compute_new_image_coordinates (sobjs[i], to_wcs);
2070        }
2071 
2072 }
\end{DoxyCode}
\hypertarget{spc__sex_8h_a7f60c3c87d2ddd2c795ab0ab66effce5}{
\index{spc\_\-sex.h@{spc\_\-sex.h}!compute\_\-new\_\-image\_\-coordinates@{compute\_\-new\_\-image\_\-coordinates}}
\index{compute\_\-new\_\-image\_\-coordinates@{compute\_\-new\_\-image\_\-coordinates}!spc_sex.h@{spc\_\-sex.h}}
\subsubsection[{compute\_\-new\_\-image\_\-coordinates}]{\setlength{\rightskip}{0pt plus 5cm}void compute\_\-new\_\-image\_\-coordinates ({\bf SexObject} $\ast$ {\em o}, \/  struct WorldCoor $\ast$ {\em to\_\-wcs})}}
\label{spc__sex_8h_a7f60c3c87d2ddd2c795ab0ab66effce5}
Function: compute\_\-new\_\-image\_\-coordinates Function that uses the exisiting world coordinates of a \hyperlink{structSexObject}{SexObject} to compute new pixel coordinates using a (new) WCS.

Parameters: 
\begin{DoxyParams}{Parameters}
\item[{\em o}]-\/ a pointer to an exsting \hyperlink{structSexObject}{SexObject}. Should have been checked for validity already \item[{\em to\_\-wcs}]-\/ a pointer to an existing WoldCoord wcs structure \end{DoxyParams}



\begin{DoxyCode}
1976 {
1977   sky_coord as, bs, cs;
1978   d_point a, b, c;
1979   int offscl;
1980 
1981 
1982   /******************************************************************/
1983   /* uses the existing world coordinates of a SexObject to compute  */
1984   /* new pixel coordinates using a (new) WCS.                       */
1985   /*******************************************************************/
1986 
1987   /* recomputes xy_image  from the world values */
1988   wcs2pix (to_wcs, o->xy_world.ra, o->xy_world.dec, &(o->xy_image.x),
1989            &(o->xy_image.y), &offscl);
1990 
1991 
1992   /* recomputes el_image them from the world values */
1993   el_to_ABC_world (&(o->el_world), &as, &bs, &cs);      /* Convert ellipse into a
       set of 3 coordinates */
1994 
1995   /* Compute the end point of the axes in the image coord system */
1996   wcs2pix (to_wcs, as.ra, as.dec, &(a.x), &(a.y), &offscl);
1997   wcs2pix (to_wcs, bs.ra, bs.dec, &(b.x), &(b.y), &offscl);
1998   wcs2pix (to_wcs, cs.ra, cs.dec, &(c.x), &(c.y), &offscl);
1999 
2000 
2001   /* DISABLED */
2002   //     ABC_image_to_el (&a, &b, &c, &(o->el_image));  /* convert 3 coordinates 
      into ellipse */
2003 }
\end{DoxyCode}
\hypertarget{spc__sex_8h_a0f5894072e9db45e3cee9324218a8da3}{
\index{spc\_\-sex.h@{spc\_\-sex.h}!compute\_\-new\_\-image\_\-sexobject@{compute\_\-new\_\-image\_\-sexobject}}
\index{compute\_\-new\_\-image\_\-sexobject@{compute\_\-new\_\-image\_\-sexobject}!spc_sex.h@{spc\_\-sex.h}}
\subsubsection[{compute\_\-new\_\-image\_\-sexobject}]{\setlength{\rightskip}{0pt plus 5cm}void compute\_\-new\_\-image\_\-sexobject ({\bf SexObject} $\ast$ {\em o}, \/  struct WorldCoor $\ast$ {\em to\_\-wcs}, \/  int {\em th\_\-sky})}}
\label{spc__sex_8h_a0f5894072e9db45e3cee9324218a8da3}
Function: compute\_\-new\_\-image\_\-sexobject Function that uses the exisiting world coordinates of a \hyperlink{structSexObject}{SexObject} to compute new pixel coordinates using a (new) WCS.

Parameters: 
\begin{DoxyParams}{Parameters}
\item[{\em o}]-\/ a pointer to an exsting \hyperlink{structSexObject}{SexObject}. Should have been checked for validity already \item[{\em to\_\-wcs}]-\/ a pointer to an existing WoldCoord wcs structure \end{DoxyParams}



\begin{DoxyCode}
2017 {
2018   //sky_coord as;
2019   sky_coord bs, cs;
2020   d_point a, b, c;
2021   int offscl;
2022 
2023   /******************************************************************/
2024   /* uses the existing world coordinates of a SexObject to compute  */
2025   /* new pixel coordinates using a (new) WCS.                       */
2026   /******************************************************************/
2027 
2028   /* recomputes xy_image  from the world values */
2029   wcs2pix (to_wcs, o->xy_world.ra, o->xy_world.dec, &(o->xy_image.x),
2030            &(o->xy_image.y), &offscl);
2031 
2032   /* Convert ellipse into a set of 3 coordinates */
2033   el_to_ABC_world2 (&(o->el_world), &(o->xy_world), &bs, &cs);
2034 
2035   /* Compute the end point of the axes in the image coord system */
2036 
2037   wcs2pix (to_wcs, o->xy_world.ra, o->xy_world.dec, &(a.x), &(a.y), &offscl);
2038   wcs2pix (to_wcs, bs.ra, bs.dec, &(b.x), &(b.y), &offscl);
2039   wcs2pix (to_wcs, cs.ra, cs.dec, &(c.x), &(c.y), &offscl);
2040 
2041 
2042   /* convert 3 coordinates into ellipse */
2043   ABC_image_to_el2 (&a, &b, &c, &(o->el_image));
2044   if (th_sky)
2045     o->el_image.theta = o->el_image.theta - 90.0;
2046 }
\end{DoxyCode}
\hypertarget{spc__sex_8h_a9fa77923a7b018be8b7073863b9e3c96}{
\index{spc\_\-sex.h@{spc\_\-sex.h}!create\_\-SexObject@{create\_\-SexObject}}
\index{create\_\-SexObject@{create\_\-SexObject}!spc_sex.h@{spc\_\-sex.h}}
\subsubsection[{create\_\-SexObject}]{\setlength{\rightskip}{0pt plus 5cm}{\bf SexObject}$\ast$ create\_\-SexObject (const {\bf colinfo} $\ast$ {\em actinfo}, \/  char $\ast$ {\em line}, \/  const gsl\_\-vector $\ast$ {\em waves}, \/  const gsl\_\-vector $\ast$ {\em cnums}, \/  const {\bf px\_\-point} {\em backwin\_\-cols}, \/  const {\bf px\_\-point} {\em modinfo\_\-cols}, \/  const int {\em magcol}, \/  const int {\em fullinfo})}}
\label{spc__sex_8h_a9fa77923a7b018be8b7073863b9e3c96}
Function: create\_\-SexObject Allocates and create s a SExtractor \hyperlink{structobject}{object} from a line of a SExtractor catalog.

Parameters: 
\begin{DoxyParams}{Parameters}
\item[{\em actinfo}]-\/ the header structure with the column names \item[{\em line}]-\/ the line to be transformed into a \hyperlink{structSexObject}{SexObject} \item[{\em waves}]-\/ vector with the walelengths of the magnitude columns \item[{\em cnums}]-\/ vector with the column numbers of the magnitude columns \item[{\em magcol}]-\/ column number of the magnitude column selected for mag\_\-auto \item[{\em fullinfo}]-\/ deecides whether a column is optional or not\end{DoxyParams}
Returns: \begin{DoxyReturn}{Returns}
o -\/ the new created \hyperlink{structSexObject}{SexObject} 
\end{DoxyReturn}



\begin{DoxyCode}
60 {
61   gsl_vector *v;
62   gsl_vector *mags;
63   gsl_vector *wavs;
64   SexObject  *o;
65   int         i=0;
66 
67   // transform the data in the line to a vector
68   lv1ws (line);
69   v = string_to_gsl_array (line);
70 
71   // allocate space for the SexObject
72   o = (SexObject *) malloc (sizeof (SexObject));
73   if (o == NULL)
74     aXe_message (aXe_M_FATAL, __FILE__, __LINE__,
75                  "create_SexObject: Could not allocate memory.");
76 
77   // succesively fill the data into the SexObject.
78   // for 'fullinfo=1' missing data results in an error.
79   // otherwise NaN is stored into the SexObject
80   o->number = (int) get_col_value (actinfo, "NUMBER", v, 1);
81 
82   o->xy_image.x     = get_col_value (actinfo, "X_IMAGE", v,fullinfo);
83   o->xy_image.y     = get_col_value (actinfo, "Y_IMAGE", v,fullinfo);
84 
85   o->xy_world.ra    = get_col_value (actinfo, "X_WORLD", v,1);
86   o->xy_world.dec   = get_col_value (actinfo, "Y_WORLD", v,1);
87 
88   o->el_image.a     = get_col_value (actinfo, "A_IMAGE", v,fullinfo);
89   o->el_image.b     = get_col_value (actinfo, "B_IMAGE", v,fullinfo);
90   o->el_image.theta = get_col_value (actinfo, "THETA_IMAGE", v,fullinfo);
91 
92   o->el_world.a     = get_col_value (actinfo, "A_WORLD", v,1);
93   o->el_world.b     = get_col_value (actinfo, "B_WORLD", v,1);
94 
95   // Some clarification is needed for the next two lines.
96   // to have get_col_value and get_col_value2 is not
97   // satisfying!! PROBLEM
98   o->el_world.theta = get_col_value2 (actinfo, "THETA_WORLD", v,0);
99   if (o->el_world.theta <-900000){
100     //  o->el_world.theta = get_col_value (actinfo, "THETA_WORLD", v,0);
101     //  if (isnan(o->el_world.theta)){
102     o->el_world.theta = get_col_value (actinfo, "THETA_SKY", v,1);
103   }
104 
105   if (backwin_cols.x !=-1)
106     {
107       o->backwindow.x  = get_col_value (actinfo, "BACKWINDOW", v,1);
108       o->backwindow.y  = -1;
109       // old code for FORS2-MXU
110       // o->backwindow.y     = get_col_value (actinfo, "BACKWIN_LOW", v,1);
111 
112     }
113   else
114     {
115       o->backwindow.x     = -1;
116       o->backwindow.y     = -1;
117     }
118 
119   // transfer the index for the model spectrum
120   if (modinfo_cols.x > -1)
121     o->modspec = (int)get_col_value(actinfo, "MODSPEC", v,1);
122   else
123     o->modspec = -1;
124 
125   // transfer the index value for the object shape
126   if (modinfo_cols.y > -1)
127     o->modimage = (int)get_col_value(actinfo, "MODIMAGE", v,1);
128   else
129     o->modimage = -1;
130 
131   // check whether the MAG_AUTO column exists
132   if ((int)waves->size == 1 && (int)gsl_vector_get (waves, 0) == 0)
133     {
134 
135 
136       // fill the MAG_AUTO value
137       // put the magnitude and wavelength vectors to NULL
138       o->magnitudes = NULL;
139       o->lambdas    = NULL;
140       o->mag_auto   = get_col_value (actinfo, "MAG_AUTO", v, 1);
141     }
142   else
143     {
144       // create the vectors for the magnitude values
145       mags = gsl_vector_alloc ((int)waves->size);
146       wavs = gsl_vector_alloc ((int)waves->size);
147 
148       // fill the magnitude values into the vectors and store them in
149       // the SexObject.
150       for (i=0; i < (int)waves->size; i++){
151         gsl_vector_set(mags, i, gsl_vector_get (v, (int)gsl_vector_get (cnums, i)
      -1));
152         gsl_vector_set(wavs, i, gsl_vector_get (waves, i));
153       }
154 
155       // fill the MAG_AUTO value
156       o->magnitudes = mags;
157       o->lambdas    = wavs;
158       o->mag_auto   = gsl_vector_get (v, magcol-1);
159     }
160 
161   return o;
162 }
\end{DoxyCode}
\hypertarget{spc__sex_8h_a1dfd57669396970a74aa9035c953e86d}{
\index{spc\_\-sex.h@{spc\_\-sex.h}!el\_\-to\_\-ABC\_\-world@{el\_\-to\_\-ABC\_\-world}}
\index{el\_\-to\_\-ABC\_\-world@{el\_\-to\_\-ABC\_\-world}!spc_sex.h@{spc\_\-sex.h}}
\subsubsection[{el\_\-to\_\-ABC\_\-world}]{\setlength{\rightskip}{0pt plus 5cm}void el\_\-to\_\-ABC\_\-world ({\bf ellipse} $\ast$ {\em el}, \/  {\bf sky\_\-coord} $\ast$ {\em a}, \/  {\bf sky\_\-coord} $\ast$ {\em b}, \/  {\bf sky\_\-coord} $\ast$ {\em c})}}
\label{spc__sex_8h_a1dfd57669396970a74aa9035c953e86d}
Function: el\_\-to\_\-ABC\_\-world Convert a wold coordinate \hyperlink{structellipse}{ellipse} into a set of 3 points on the tangent plane point a is at pos of obj, semi major-\/axis end is point b, semi minor axis is point c theta is measured from x-\/axis to semi-\/major axis, counter clock wise. 


\begin{DoxyCode}
1724 {
1725 
1726      a->ra = 0.0;
1727      a->dec = 0.0;
1728 
1729      b->ra = el->a * cos (el->theta / 180. * M_PI);
1730      b->dec = el->a * sin (el->theta / 180. * M_PI);
1731 
1732      c->ra = -1.0 * el->b * sin (el->theta / 180. * M_PI);
1733      c->dec = el->b * cos (el->theta / 180. * M_PI);
1734 }
\end{DoxyCode}
\hypertarget{spc__sex_8h_a7062ae05d05dbc0071064dfe649dfb64}{
\index{spc\_\-sex.h@{spc\_\-sex.h}!el\_\-to\_\-ABC\_\-world2@{el\_\-to\_\-ABC\_\-world2}}
\index{el\_\-to\_\-ABC\_\-world2@{el\_\-to\_\-ABC\_\-world2}!spc_sex.h@{spc\_\-sex.h}}
\subsubsection[{el\_\-to\_\-ABC\_\-world2}]{\setlength{\rightskip}{0pt plus 5cm}void el\_\-to\_\-ABC\_\-world2 ({\bf ellipse} $\ast$ {\em el}, \/  {\bf sky\_\-coord} $\ast$ {\em a}, \/  {\bf sky\_\-coord} $\ast$ {\em b}, \/  {\bf sky\_\-coord} $\ast$ {\em c})}}
\label{spc__sex_8h_a7062ae05d05dbc0071064dfe649dfb64}



\begin{DoxyCode}
1742 {
1743   b->ra  = a->ra  - (el->a * cos (el->theta / 180. * M_PI))/cos(a->dec / 180. * M
      _PI);
1744   b->dec = a->dec + (el->a * sin (el->theta / 180. * M_PI));
1745 
1746   c->ra  = a->ra  - (el->b * cos ((el->theta-90.0)/180.*M_PI))/cos(a->dec / 180. 
      * M_PI);
1747   c->dec = a->dec + (el->b * sin ((el->theta-90.0)/180.*M_PI));
1748 }
\end{DoxyCode}
\hypertarget{spc__sex_8h_a9e39e413308fb40567ce4507d4b48d78}{
\index{spc\_\-sex.h@{spc\_\-sex.h}!fill\_\-all\_\-missing\_\-image\_\-coordinates@{fill\_\-all\_\-missing\_\-image\_\-coordinates}}
\index{fill\_\-all\_\-missing\_\-image\_\-coordinates@{fill\_\-all\_\-missing\_\-image\_\-coordinates}!spc_sex.h@{spc\_\-sex.h}}
\subsubsection[{fill\_\-all\_\-missing\_\-image\_\-coordinates}]{\setlength{\rightskip}{0pt plus 5cm}void fill\_\-all\_\-missing\_\-image\_\-coordinates ({\bf SexObject} $\ast$$\ast$ {\em sobjs}, \/  struct WorldCoor $\ast$ {\em from\_\-wcs}, \/  int {\em overwrite})}}
\label{spc__sex_8h_a9e39e413308fb40567ce4507d4b48d78}
Function: fill\_\-all\_\-missing\_\-image\_\-coordinates Replaces all NaN values in a set of SexObjects with ones computed from the available information and the associated WCS.

Parameters: 
\begin{DoxyParams}{Parameters}
\item[{\em sobjs}]-\/ an NULL terminated array containing pointers to SexObjects \item[{\em from\_\-wcs}]-\/ a pointer to an existing WoldCoord wcs structure \item[{\em overwrite}]-\/ forces the re-\/computation of all image coordinates \end{DoxyParams}



\begin{DoxyCode}
1921 {
1922   int i, nobjs = 0;
1923 
1924   /* Find the number of SexObjects in sobjs */
1925   while (sobjs[nobjs])
1926     nobjs++;
1927 
1928   for (i = 0; i < nobjs; i++)
1929     {
1930       fill_missing_image_coordinates (sobjs[i], from_wcs, overwrite);
1931     }
1932 
1933 }
\end{DoxyCode}
\hypertarget{spc__sex_8h_ab49c25c830b7c93a094562fffced9597}{
\index{spc\_\-sex.h@{spc\_\-sex.h}!fill\_\-all\_\-missing\_\-WCS\_\-coordinates@{fill\_\-all\_\-missing\_\-WCS\_\-coordinates}}
\index{fill\_\-all\_\-missing\_\-WCS\_\-coordinates@{fill\_\-all\_\-missing\_\-WCS\_\-coordinates}!spc_sex.h@{spc\_\-sex.h}}
\subsubsection[{fill\_\-all\_\-missing\_\-WCS\_\-coordinates}]{\setlength{\rightskip}{0pt plus 5cm}void fill\_\-all\_\-missing\_\-WCS\_\-coordinates ({\bf SexObject} $\ast$$\ast$ {\em sobjs}, \/  struct WorldCoor $\ast$ {\em from\_\-wcs}, \/  int {\em overwrite})}}
\label{spc__sex_8h_ab49c25c830b7c93a094562fffced9597}
Function: fill\_\-all\_\-missing\_\-WCS\_\-coordinates Replaces all NaN values in a set of SexObjects with ones computed from the available information and the associated WCS.

Parameters: 
\begin{DoxyParams}{Parameters}
\item[{\em sobjs}]-\/ an NULL terminated array containing pointers to SexObjects \item[{\em from\_\-wcs}]-\/ a pointer to an existing WoldCoord wcs structure \item[{\em overwrite}]-\/ forces the re-\/computation of all image coordinates \end{DoxyParams}



\begin{DoxyCode}
1949 {
1950   int i, nobjs = 0;
1951 
1952   /* Find the number of SexObjects in sobjs */
1953   while (sobjs[nobjs])
1954     nobjs++;
1955 
1956   for (i = 0; i < nobjs; i++)
1957     {
1958       fill_missing_WCS_coordinates (sobjs[i], from_wcs, overwrite);
1959     }
1960 
1961 }
\end{DoxyCode}
\hypertarget{spc__sex_8h_ab677ce148520e7e408d39157562ed425}{
\index{spc\_\-sex.h@{spc\_\-sex.h}!fill\_\-corner\_\-ignore@{fill\_\-corner\_\-ignore}}
\index{fill\_\-corner\_\-ignore@{fill\_\-corner\_\-ignore}!spc_sex.h@{spc\_\-sex.h}}
\subsubsection[{fill\_\-corner\_\-ignore}]{\setlength{\rightskip}{0pt plus 5cm}void fill\_\-corner\_\-ignore ({\bf SexObject} $\ast$ {\em sobj}, \/  {\bf observation} $\ast$const  {\em obs}, \/  {\bf aperture\_\-conf} $\ast$ {\em conf}, \/  int {\em beamID}, \/  float {\em dmag}, \/  {\bf beam} $\ast$ {\em actbeam})}}
\label{spc__sex_8h_ab677ce148520e7e408d39157562ed425}
Function: fill\_\-corner\_\-ignore The method computes and fills the \hyperlink{structbeam}{beam} corner information and the the ignore flag into a \hyperlink{structbeam}{beam} structure.

Parameters: 
\begin{DoxyParams}{Parameters}
\item[{\em sobj}]-\/ pointer to a \hyperlink{structSexObject}{SexObject} \item[{\em obs}]-\/ a pointer to the data array containing the image \item[{\em conf}]-\/ pointer to the configuration structure \item[{\em beamID}]-\/ the \hyperlink{structbeam}{beam} ID \item[{\em dmag}]-\/ number of magnitudes to add to the magnitudes cutoffs \item[{\em actbeam}]-\/ the \hyperlink{structbeam}{beam} structure to be filled\end{DoxyParams}
Returns: \begin{DoxyReturn}{Returns}
-\/ 
\end{DoxyReturn}



\begin{DoxyCode}
738   {
739     double mmag_extract;
740     double mmag_mark;
741 
742     // get the extraction and the mark margnitudes
743     mmag_extract = conf->beam[beamID].mmag_extract + dmag;
744     mmag_mark    = conf->beam[beamID].mmag_mark    + dmag;
745 
746     // make a default for the
747     // ignore flag
748     actbeam->ignore = 0;
749 
750     /* magnitude cut */
751     // PROBLEM: there is a logical flaw inside
752     //          whhat happend when (mag > mag_mark) && (mag <  mmag_extract) ????
      
753     //          of course this has only relevance when mag_mark < mmag_extract
754     //      if ((sobj->mag_auto <= mmag_mark)&&(sobj->mag_auto <= mmag_extract))
755     // That's now an easy fix, but makes sense..
756     if (sobj->mag_auto <= mmag_extract)
757         actbeam->ignore = 0; // this object will be extracted
758 
759     if ((sobj->mag_auto <= mmag_mark)&&(sobj->mag_auto > mmag_extract))
760         actbeam->ignore = 2; // this object will be not be extracted
761 
762     if ((sobj->mag_auto > mmag_mark)&&(sobj->mag_auto > mmag_extract))
763         actbeam->ignore = 1; // this object will be ignored
764 
765     // fill the boundary box values;
766     // returns if the beams is completely out of the image
767     if (!fill_object_bbox (obs, actbeam, 2, conf->beam[beamID].offset.dx0,
768                            conf->beam[beamID].offset.dx1))
769       actbeam->ignore = 1;
770   }
\end{DoxyCode}
\hypertarget{spc__sex_8h_a8dc42564a62fb75a865abd1e97f3cef5}{
\index{spc\_\-sex.h@{spc\_\-sex.h}!fill\_\-missing\_\-image\_\-coordinates@{fill\_\-missing\_\-image\_\-coordinates}}
\index{fill\_\-missing\_\-image\_\-coordinates@{fill\_\-missing\_\-image\_\-coordinates}!spc_sex.h@{spc\_\-sex.h}}
\subsubsection[{fill\_\-missing\_\-image\_\-coordinates}]{\setlength{\rightskip}{0pt plus 5cm}void fill\_\-missing\_\-image\_\-coordinates ({\bf SexObject} $\ast$ {\em o}, \/  struct WorldCoor $\ast$ {\em from\_\-wcs}, \/  int {\em overwrite})}}
\label{spc__sex_8h_a8dc42564a62fb75a865abd1e97f3cef5}
Function: fill\_\-missing\_\-image\_\-coordinates Update a \hyperlink{structSexObject}{SexObject} structure and replace all missing image coordinates by re-\/computing them using the world one and the from\_\-wcs wcs. Re-\/computes: peak\_\-image\_\-x peak\_\-image.y xy\_\-image.x xy\_\-image.y el\_\-image.a el\_\-image.b el\_\-image.theta

Parameters: 
\begin{DoxyParams}{Parameters}
\item[{\em o}]-\/ a pointer to an exsting \hyperlink{structSexObject}{SexObject}. Should have been checked for validity already \item[{\em from\_\-wcs}]-\/ a pointer to an existing WoldCoord wcs structure \end{DoxyParams}



\begin{DoxyCode}
1870 {
1871   sky_coord as, bs, cs;
1872   d_point a, b, c;
1873   int offscl;
1874 
1875 
1876   /************************/
1877   /* If the image coordinates are missing, generate them using from_wcs and sextr
      actor world
1878      coordinates */
1879   /************************/
1880   if ((overwrite) || (isnan (o->xy_image.x)) || (isnan (o->xy_image.y)))
1881     {
1882       /* recomputes xy_image  from the world values */
1883       wcs2pix (from_wcs, o->xy_world.ra, o->xy_world.dec,
1884                &(o->xy_image.x), &(o->xy_image.y), &offscl);
1885 
1886     }
1887 
1888 
1889   if ((isnan (o->el_image.a)) || (isnan (o->el_image.b))
1890       || (isnan (o->el_image.theta)) || (overwrite))
1891     {
1892 
1893       /* recomputes el_image them from the world values */
1894 
1895       el_to_ABC_world (&(o->el_world), &as, &bs, &cs);  /* Convert ellipse into a
       set of 3 coordinates */
1896 
1897       /* Compute the end point of the axes in the image coord system */
1898       wcs2pix (from_wcs, as.ra, as.dec, &(a.x), &(a.y), &offscl);
1899       wcs2pix (from_wcs, bs.ra, bs.dec, &(b.x), &(b.y), &offscl);
1900       wcs2pix (from_wcs, cs.ra, cs.dec, &(c.x), &(c.y), &offscl);
1901 
1902       /* DISABLED !!*/
1903       //            ABC_image_to_el (&a, &b, &c, &(o->el_image));       /* conver
      t 3 coordinates into ellipse */
1904     }
1905 }
\end{DoxyCode}
\hypertarget{spc__sex_8h_a0ab3db728560b7a291df4044abbea97e}{
\index{spc\_\-sex.h@{spc\_\-sex.h}!fill\_\-missing\_\-WCS\_\-coordinates@{fill\_\-missing\_\-WCS\_\-coordinates}}
\index{fill\_\-missing\_\-WCS\_\-coordinates@{fill\_\-missing\_\-WCS\_\-coordinates}!spc_sex.h@{spc\_\-sex.h}}
\subsubsection[{fill\_\-missing\_\-WCS\_\-coordinates}]{\setlength{\rightskip}{0pt plus 5cm}void fill\_\-missing\_\-WCS\_\-coordinates ({\bf SexObject} $\ast$ {\em o}, \/  struct WorldCoor $\ast$ {\em from\_\-wcs}, \/  int {\em overwrite})}}
\label{spc__sex_8h_a0ab3db728560b7a291df4044abbea97e}
Function: fill\_\-missing\_\-WCS\_\-coordinates Update a \hyperlink{structSexObject}{SexObject} structure and replace all missing WCS coordinates by re-\/computing them using the world one and the from\_\-wcs wcs. Re-\/computes: peak\_\-world\_\-x peak\_\-world.y xy\_\-world.x xy\_\-world.y el\_\-world.a el\_\-world.b el\_\-world.theta


\begin{DoxyParams}{Parameters}
\item[{\em o}]-\/ a pointer to an exsting \hyperlink{structSexObject}{SexObject}. Should have been checked for validity already \item[{\em from\_\-wcs}]-\/ a pointer to an existing WoldCoord wcs structure \end{DoxyParams}



\begin{DoxyCode}
1803 {
1804   sky_coord as, bs, cs;
1805   d_point a, b, c;
1806   //int offscl;
1807 
1808   /***************************************************************/
1809   /* If the WCS coordinates are missing, generate them using     */
1810   /* from_wcs and sextractor image coordinates                   */
1811   /***************************************************************/
1812 
1813   if ((overwrite) || (isnan (o->xy_world.ra)) || (isnan (o->xy_world.dec)))
1814     {
1815       /* recomputes xy_image  from the world values */
1816       /*pix2wcs (from_wcs, o->xy_image.x, o->xy_image.y,
1817                &(o->xy_world.ra),&(o->xy_world.dec), &offscl);
1818       */
1819       /* recomputes xy_image  from the world values */
1820       // new version requested since wcstools-3.6
1821       pix2wcs (from_wcs, o->xy_image.x, o->xy_image.y,
1822                &(o->xy_world.ra),&(o->xy_world.dec));
1823     }
1824 
1825   if ((isnan (o->el_world.a)) || (isnan (o->el_world.b))
1826       || (isnan (o->el_world.theta)) || (overwrite))
1827     {
1828 
1829       /* recomputes el_image them from the world values */
1830 
1831       /* Note the following is an unconventional use of the et_to*()
1832          routines since we store image coords in as, bs, and cs */
1833       el_to_ABC_world (&(o->el_image), &as, &bs, &cs);  /* Convert ellipse into a
       set of 3 coordinates */
1834 
1835       /* Compute the end point of the axes in the image coord system */
1836       /*      pix2wcs (from_wcs, as.ra, as.dec, &(a.x), &(a.y), &offscl);
1837       pix2wcs (from_wcs, bs.ra, bs.dec, &(b.x), &(b.y), &offscl);
1838       pix2wcs (from_wcs, cs.ra, cs.dec, &(c.x), &(c.y), &offscl);
1839       */
1840       /* Compute the end point of the axes in the image coord system */
1841       // new version requested since wcstools-3.6
1842       pix2wcs (from_wcs, as.ra, as.dec, &(a.x), &(a.y));
1843       pix2wcs (from_wcs, bs.ra, bs.dec, &(b.x), &(b.y));
1844       pix2wcs (from_wcs, cs.ra, cs.dec, &(c.x), &(c.y));
1845 
1846       ABC_image_to_el (&a, &b, &c, &(o->el_world));     /* convert 3 coordinates 
      into ellipse */
1847     }
1848 }
\end{DoxyCode}
\hypertarget{spc__sex_8h_a81c5036b461b98a7c6dde47ea87c0220}{
\index{spc\_\-sex.h@{spc\_\-sex.h}!fill\_\-object\_\-bbox@{fill\_\-object\_\-bbox}}
\index{fill\_\-object\_\-bbox@{fill\_\-object\_\-bbox}!spc_sex.h@{spc\_\-sex.h}}
\subsubsection[{fill\_\-object\_\-bbox}]{\setlength{\rightskip}{0pt plus 5cm}int fill\_\-object\_\-bbox ({\bf observation} $\ast$const  {\em obs}, \/  {\bf beam} $\ast$ {\em b}, \/  const float {\em m\_\-width}, \/  const int {\em dxmin}, \/  const int {\em dxmax})}}
\label{spc__sex_8h_a81c5036b461b98a7c6dde47ea87c0220}
Function: fill\_\-object\_\-bbox Fill up the aperture part of the \hyperlink{structbeam}{beam} of an \hyperlink{structobject}{object} structure by looking at the trace polynomial description associated with this \hyperlink{structobject}{object}.

Parameters: 
\begin{DoxyParams}{Parameters}
\item[{\em obs}]-\/ a pointer to the data array containing the image (used for bound checking) \item[{\em b}]-\/ A pointer to a \hyperlink{structbeam}{beam} whose aperture must be filled. \item[{\em m\_\-width}]-\/ The width in pixel of the extraction box \item[{\em dxmin}]-\/ How far (in pixel) to follow the trace on the left side of the \hyperlink{structspectrum}{spectrum} \item[{\em dxmax}]-\/ How far (in pixel) to follow the trace on the right hand side of the \hyperlink{structspectrum}{spectrum}\end{DoxyParams}
Returns: \begin{DoxyReturn}{Returns}
1 if bounding box appears to be valied (i.e. non-\/empty) 
\end{DoxyReturn}



\begin{DoxyCode}
1471 {
1472      d_point pmin, pmax;
1473      d_point pminl, pminh, pmaxl, pmaxh;
1474      float w = b->width/2. * m_width + 2.0;
1475      float wcos, wsin;
1476      float area;
1477 
1478          int xmin, xmax, xact;
1479          //int i;
1480      double yact;
1481 
1482      pmin.x = b->refpoint.x + dxmin;
1483      pmin.y =
1484           b->refpoint.y + b->spec_trace->func (dxmin, b->spec_trace->data);
1485 
1486      pmax.x = b->refpoint.x + dxmax;
1487      pmax.y =
1488           b->refpoint.y + b->spec_trace->func (dxmax, b->spec_trace->data);
1489 
1490 
1491      if (b->spec_trace->type > 1)
1492        {
1493          if (dxmin < dxmax)
1494            {
1495              xmin = dxmin;
1496              xmax = dxmax;
1497            }
1498          else
1499            {
1500              xmin = dxmax;
1501              xmax = dxmin;
1502            }
1503 
1504          for (xact = xmin; xact < xmax; xact++)
1505            {
1506              yact = b->refpoint.y + b->spec_trace->func (xact, b->spec_trace->
      data);
1507 
1508              if (yact < pmin.y)
1509                pmin.y = yact;
1510              if (yact > pmax.y)
1511                pmax.y = yact;
1512            }
1513          wcos = w * cos (b->orient);
1514          wsin = w * sin (b->orient);
1515 
1516          if (wcos > 0)
1517            {
1518              pmin.x = pmin.x - wcos;
1519              pmax.x = pmax.x + wcos;
1520            }
1521          else
1522            {
1523              pmin.x = pmin.x + wcos;
1524              pmax.x = pmax.x - wcos;
1525            }
1526          if (wsin > 0)
1527            {
1528              pmin.y = pmin.y - wsin;
1529              pmax.y = pmax.y + wsin;
1530            }
1531          else
1532            {
1533              pmin.y = pmin.y + wsin;
1534              pmax.y = pmax.y - wsin;
1535            }
1536          b->corners[0].x = pmin.x;
1537          b->corners[0].y = pmin.y;
1538 
1539          b->corners[1].x = pmax.x;
1540          b->corners[1].y = pmin.y;
1541 
1542          b->corners[2].x = pmax.x;
1543          b->corners[2].y = pmax.y;
1544 
1545          b->corners[3].x = pmin.x;
1546          b->corners[3].y = pmax.y;
1547        }
1548      else
1549        {
1550 
1551          wcos = w * cos (b->orient);
1552          wsin = w * sin (b->orient);
1553 
1554          pminl.x = pmin.x - wcos;
1555          pminl.y = pmin.y - wsin;
1556 
1557          pminh.x = pmin.x + wcos;
1558          pminh.y = pmin.y + wsin;
1559 
1560          pmaxl.x = pmax.x - wcos;
1561          pmaxl.y = pmax.y - wsin;
1562 
1563          pmaxh.x = pmax.x + wcos;
1564          pmaxh.y = pmax.y + wsin;
1565 
1566          b->corners[0].x = pminl.x;
1567          b->corners[0].y = pminl.y;
1568 
1569          b->corners[1].x = pmaxl.x;
1570          b->corners[1].y = pmaxl.y;
1571 
1572          b->corners[2].x = pmaxh.x;
1573          b->corners[2].y = pmaxh.y;
1574 
1575          b->corners[3].x = pminh.x;
1576          b->corners[3].y = pminh.y;
1577        }
1578 
1579      /* Compute the area of this aperture */
1580      area =
1581           0.5 * (fabs (b->corners[0].y - b->corners[4].y) *
1582                  fabs (b->corners[0].x - b->corners[1].x) +
1583                  fabs (b->corners[2].y -
1584                        b->corners[1].y) * fabs (b->corners[3].x -
1585                                                 b->corners[2].x));
1586      if (area == 0)
1587        {
1588             fprintf (stderr, "aper debug: area is zero!\n");
1589             return 0;
1590        }
1591      return 1;
1592 }
\end{DoxyCode}
\hypertarget{spc__sex_8h_a1de62f331f136845a887cec91920982e}{
\index{spc\_\-sex.h@{spc\_\-sex.h}!free\_\-SexObjects@{free\_\-SexObjects}}
\index{free\_\-SexObjects@{free\_\-SexObjects}!spc_sex.h@{spc\_\-sex.h}}
\subsubsection[{free\_\-SexObjects}]{\setlength{\rightskip}{0pt plus 5cm}void free\_\-SexObjects ({\bf SexObject} $\ast$$\ast$ {\em sobjs})}}
\label{spc__sex_8h_a1de62f331f136845a887cec91920982e}
Function: free\_\-SexObjects Free a NULL terminated array of \hyperlink{structSexObject}{SexObject}

Parameters: 
\begin{DoxyParams}{Parameters}
\item[{\em sobjs}]-\/ a NULL terminated array containing pointers to SexObjects \end{DoxyParams}



\begin{DoxyCode}
2085 {
2086   int i, nobjs = 0;
2087 
2088   /* Find the number of SexObjects in sobjs */
2089   while (sobjs[nobjs])
2090     nobjs++;
2091 
2092   for (i = 0; i < nobjs; i++)
2093     {
2094       if (sobjs[i]->magnitudes){
2095         gsl_vector_free (sobjs[i]->lambdas);
2096         gsl_vector_free (sobjs[i]->magnitudes);
2097       }
2098       free (sobjs[i]);
2099       sobjs[i] = NULL;
2100     }
2101   free (sobjs);
2102   sobjs = NULL;
2103 }
\end{DoxyCode}
\hypertarget{spc__sex_8h_af8023b218b4f95008b4a8e4df19005fa}{
\index{spc\_\-sex.h@{spc\_\-sex.h}!get\_\-SexObject\_\-from\_\-catalog@{get\_\-SexObject\_\-from\_\-catalog}}
\index{get\_\-SexObject\_\-from\_\-catalog@{get\_\-SexObject\_\-from\_\-catalog}!spc_sex.h@{spc\_\-sex.h}}
\subsubsection[{get\_\-SexObject\_\-from\_\-catalog}]{\setlength{\rightskip}{0pt plus 5cm}{\bf SexObject}$\ast$$\ast$ get\_\-SexObject\_\-from\_\-catalog (char {\em filename}\mbox{[}$\,$\mbox{]}, \/  const double {\em lambda\_\-mark})}}
\label{spc__sex_8h_af8023b218b4f95008b4a8e4df19005fa}
Function: get\_\-SexObject\_\-from\_\-catalog Parses a Sextractor 2.0 catalog file, and outputs a NULL terminated array of SexObjects pointers. Ignores rows starting with a ;

Parameters: 
\begin{DoxyParams}{Parameters}
\item[{\em filename}]a pointer pointing to a char array containing the list of a sextractor \hyperlink{structobject}{object} output catalog\end{DoxyParams}
Returns: \begin{DoxyReturn}{Returns}
a pointer to an array of SeXObject pointer. NULL terminated 
\end{DoxyReturn}



\begin{DoxyCode}
1653 {
1654   FILE *input;
1655   char Buffer[CATBUFFERSIZE];
1656   gsl_vector *v;
1657   gsl_vector *waves;
1658   gsl_vector *cnums;
1659   int catsize, nobjs, i, hasmags=0, magcencol=0;
1660   SexObject **sobjs, *sobj;
1661   colinfo * actcatinfo;
1662   px_point  backwin_cols;
1663   px_point  modinfo_cols;
1664 
1665 
1666   actcatinfo = get_sex_col_descr (filename);
1667   hasmags = has_magnitudes(actcatinfo);
1668   waves = gsl_vector_alloc (hasmags);
1669   cnums = gsl_vector_alloc (hasmags);
1670   hasmags = get_magcols(actcatinfo, waves, cnums);
1671   magcencol = get_magauto_col(waves, cnums, lambda_mark);
1672 
1673   backwin_cols = has_backwindow(actcatinfo);
1674   modinfo_cols = has_modelinfo(actcatinfo);
1675 
1676 
1677   //  catsize = count_keys (catalog_header);
1678   catsize = actcatinfo->numcols;
1679   nobjs = size_of_sextractor_catalog (filename);
1680 
1681   if (!(input = fopen (filename, "r")))
1682        {
1683          aXe_message (aXe_M_FATAL, __FILE__, __LINE__,
1684                       "Could not open Sextractor catalog" "file %s,\n",
1685                       filename);
1686        }
1687 
1688   /* Allocate enough room for nobjs+1 SexObject  pointers */
1689   sobjs = (SexObject **) malloc ((nobjs + 1) * sizeof (SexObject *));
1690   if (!sobjs)
1691     {
1692       aXe_message (aXe_M_FATAL, __FILE__, __LINE__, "Out of memory.");
1693     }
1694 
1695   i = 0;
1696   while (fgets (Buffer, CATBUFFERSIZE, input))
1697     {
1698       if (Buffer[0] == ';')
1699         continue;
1700       v = string_to_gsl_array (Buffer);
1701       if (v==NULL) continue;
1702       if (v->size == catsize)
1703         {
1704           // BIG BUG!!!
1705           //               sobj = create_SexObject (catalog_header, Buffer);
1706           sobj = create_SexObject (actcatinfo, Buffer, waves, cnums, backwin_cols
      , modinfo_cols, magcencol, 0);
1707           sobjs[i++] = sobj;
1708         }
1709     }
1710   sobjs[i] = NULL;
1711 
1712   return sobjs;
1713 }
\end{DoxyCode}
\hypertarget{spc__sex_8h_ae9d3731ef7e209c389cde4b659e5cac8}{
\index{spc\_\-sex.h@{spc\_\-sex.h}!SexMags\_\-to\_\-beamFlux@{SexMags\_\-to\_\-beamFlux}}
\index{SexMags\_\-to\_\-beamFlux@{SexMags\_\-to\_\-beamFlux}!spc_sex.h@{spc\_\-sex.h}}
\subsubsection[{SexMags\_\-to\_\-beamFlux}]{\setlength{\rightskip}{0pt plus 5cm}void SexMags\_\-to\_\-beamFlux ({\bf SexObject} $\ast$ {\em sobj}, \/  {\bf beam} $\ast$ {\em actbeam})}}
\label{spc__sex_8h_ae9d3731ef7e209c389cde4b659e5cac8}
Function: SexMags\_\-to\_\-beamFlux Fill an \hyperlink{structbeam}{beam} structure with the flux and shape information information contained in a \hyperlink{structSexObject}{SexObject} structure.

Parameters: 
\begin{DoxyParams}{Parameters}
\item[{\em sobj}]-\/ pointer to a \hyperlink{structSexObject}{SexObject} \item[{\em actbeam}]-\/ the \hyperlink{structbeam}{beam} structure to be filled\end{DoxyParams}
Returns: \begin{DoxyReturn}{Returns}
-\/ 
\end{DoxyReturn}



\begin{DoxyCode}
564   {
565     int nvalid=0;
566     int jj=0;
567     int j=0;
568 
569     double fval=0.0;
570 
571     gsl_vector *flux;
572 
573     // set 'default' shapes
574     actbeam->awidth  = -1.0;
575     actbeam->bwidth  = -1.0;
576     actbeam->aorient = -1.0;
577 
578     // set a 'default' flux
579     actbeam->flux = NULL;
580 
581     /* if flux/wavelength information exists */
582     if (sobj->magnitudes)
583       {
584 
585         // get the number of valid entries in 'sobj->magnitudes'
586         nvalid = get_valid_entries(sobj->magnitudes);
587         if (!nvalid)
588           aXe_message (aXe_M_FATAL, __FILE__, __LINE__,
589                        "No valid magnitude for object %i !\n", sobj->number);
590 
591 
592         // allocate the flux vector
593         flux = gsl_vector_alloc (2*(nvalid));
594 
595         // initialize a counter
596         jj=0;
597 
598         //  go over all magnidute values
599         for (j=0; j < sobj->magnitudes->size; j++)
600           {
601             // check whether the current entry is valuied
602             if (is_valid_entry(gsl_vector_get(sobj->magnitudes, j)))
603               {
604                 // get the current entry, already converted to flux
605                 fval = get_flambda_from_magab(gsl_vector_get(sobj->magnitudes, j)
      , gsl_vector_get(sobj->lambdas, j));
606 
607                 // set the wavelength value and the flux value
608                 gsl_vector_set(flux, 2*jj, gsl_vector_get(sobj->lambdas, j));
609                 gsl_vector_set(flux, 2*jj+1, fval);
610 
611                 // enhance the counter
612                 jj++;
613               }
614           }
615 
616         // transfer the flux values
617         // to the beam
618         actbeam->flux = flux;
619 
620         // transfer the shape values
621         // to the beam
622         actbeam->awidth  = sobj->el_image.a;
623         actbeam->bwidth  = sobj->el_image.b;
624         actbeam->aorient = sobj->el_image.theta;
625       }
626   }
\end{DoxyCode}
\hypertarget{spc__sex_8h_a50a3720d64c09d63859bb71314e14f8b}{
\index{spc\_\-sex.h@{spc\_\-sex.h}!SexObject\_\-fprintf@{SexObject\_\-fprintf}}
\index{SexObject\_\-fprintf@{SexObject\_\-fprintf}!spc_sex.h@{spc\_\-sex.h}}
\subsubsection[{SexObject\_\-fprintf}]{\setlength{\rightskip}{0pt plus 5cm}void SexObject\_\-fprintf (FILE $\ast$ {\em output}, \/  {\bf SexObject} $\ast$ {\em o})}}
\label{spc__sex_8h_a50a3720d64c09d63859bb71314e14f8b}
Function: SexObject\_\-fprintf Function to print the attributes of a SexObbject to an output stream.

Paramters: 
\begin{DoxyParams}{Parameters}
\item[{\em output}]-\/ an ouput file or stream \item[{\em o}]-\/ a pointer to a \hyperlink{structSexObject}{SexObject} \end{DoxyParams}



\begin{DoxyCode}
176 {
177      fprintf (output, "NUMBER: %d\n", o->number);
178 
179      fprintf (output, "X_IMAGE: %e\n", o->xy_image.x);
180      fprintf (output, "Y_IMAGE: %e\n", o->xy_image.y);
181 
182      fprintf (output, "X_WORLD: %e\n", o->xy_world.ra);
183      fprintf (output, "Y_WORLD: %e\n", o->xy_world.dec);
184 
185      fprintf (output, "A_IMAGE: %e\n", o->el_image.a);
186      fprintf (output, "B_IMAGE: %e\n", o->el_image.b);
187      fprintf (output, "THETA_IMAGE: %e\n", o->el_image.theta);
188 
189      fprintf (output, "A_WORLD: %e\n", o->el_world.a);
190      fprintf (output, "B_WORLD: %e\n", o->el_world.b);
191      fprintf (output, "THETA_WORLD: %e\n", o->el_world.theta);
192 
193      fprintf (output, "MAG_AUTO: %e\n", o->mag_auto);
194 
195 }
\end{DoxyCode}
\hypertarget{spc__sex_8h_aaf18fdf0a495428d532fc2acb0cb337b}{
\index{spc\_\-sex.h@{spc\_\-sex.h}!SexObject\_\-to\_\-beam@{SexObject\_\-to\_\-beam}}
\index{SexObject\_\-to\_\-beam@{SexObject\_\-to\_\-beam}!spc_sex.h@{spc\_\-sex.h}}
\subsubsection[{SexObject\_\-to\_\-beam}]{\setlength{\rightskip}{0pt plus 5cm}void SexObject\_\-to\_\-beam ({\bf SexObject} $\ast$ {\em sobj}, \/  {\bf observation} $\ast$const  {\em obs}, \/  {\bf aperture\_\-conf} $\ast$ {\em conf}, \/  char {\em conffile}\mbox{[}$\,$\mbox{]}, \/  float {\em mfwhm}, \/  float {\em dmag}, \/  int {\em auto\_\-reorient}, \/  int {\em bck\_\-mode}, \/  int {\em beamID}, \/  {\bf beam} $\ast$ {\em actbeam})}}
\label{spc__sex_8h_aaf18fdf0a495428d532fc2acb0cb337b}
Function: SexObject\_\-to\_\-beam Fill an \hyperlink{structbeam}{beam} structure with the information contained in a \hyperlink{structSexObject}{SexObject} structure plus further information derived via the confiugration file.

Parameters: 
\begin{DoxyParams}{Parameters}
\item[{\em sobj}]-\/ pointer to a \hyperlink{structSexObject}{SexObject} \item[{\em obs}]-\/ a pointer to the data array containing the image \item[{\em conf}]-\/ pointer to the configuration structure \item[{\em conffile}]-\/ the name of the aperture configuration file \item[{\em mfwhm}]-\/ the fwhm multiplicator constant to apply to determine the width of the aperture box for the \hyperlink{structobject}{object}. \item[{\em dmag}]-\/ number of magnitudes to add to the magnitudes cutoffs \item[{\em auto\_\-reorient}]-\/ if set then this task tries to optimize the orientation of the extraction slit -\/ Should in general be left at 1 so that strange geomety is avoided. If set to 2 the extraction is forced to be vertical (90 deg.) \item[{\em bck\_\-mode}]-\/ pointer for background mode \item[{\em beamID}]-\/ the \hyperlink{structbeam}{beam} ID \item[{\em actbeam}]-\/ the \hyperlink{structbeam}{beam} structure to be filled\end{DoxyParams}
Returns: \begin{DoxyReturn}{Returns}
-\/ 
\end{DoxyReturn}



\begin{DoxyCode}
957   {
958     double trace_angle;
959 
960     d_point pixel;
961 
962     tracestruct *trace;
963 
964     // set the beam ID
965     actbeam->ID = conf->beam[beamID].ID;
966 
967     // set the model template ID's
968     actbeam->modspec  = sobj->modspec;
969     actbeam->modimage = sobj->modimage;
970 
971     // Adjust for posibly non (0,0) ref point of the 2D field dependence
972     // get the geometrical description of the trace at position "pixel"
973     pixel.x = sobj->xy_image.x - 1.0 - conf->refx;
974     pixel.y = sobj->xy_image.y - 1.0 - conf->refy;
975     trace = get_tracestruct_at_pos (conffile, conf->beam[beamID].ID, pixel);
976 
977     // transfer trace information to the beam
978     actbeam->spec_trace = vector_to_trace_polyN(trace->pol);
979 
980     // compute the local trace angle
981     trace_angle = atan2(actbeam->spec_trace->deriv (0, actbeam->spec_trace->data)
      ,1.0);
982 
983     // set the reference point
984     actbeam->refpoint.x = sobj->xy_image.x - 1.0 + trace->offset.x;
985     actbeam->refpoint.y = sobj->xy_image.y - 1.0 + trace->offset.y;
986 
987     // fill the flux and shape information
988     SexMags_to_beamFlux(sobj, actbeam);
989 
990     // fill in the slit geometry
991     SexObject_to_slitgeom(conf, sobj, trace_angle, actbeam);
992 
993     // actually set the extraction parameters
994     set_extraction_parameters(sobj,bck_mode,mfwhm, auto_reorient, trace_angle, ac
      tbeam);
995 
996     // set the beam corners and the ignore flag
997     fill_corner_ignore(sobj, obs, conf, beamID, dmag, actbeam);
998   }
\end{DoxyCode}
\hypertarget{spc__sex_8h_a1cc8887bfa02d842b41141ae74750490}{
\index{spc\_\-sex.h@{spc\_\-sex.h}!SexObject\_\-to\_\-object@{SexObject\_\-to\_\-object}}
\index{SexObject\_\-to\_\-object@{SexObject\_\-to\_\-object}!spc_sex.h@{spc\_\-sex.h}}
\subsubsection[{SexObject\_\-to\_\-object}]{\setlength{\rightskip}{0pt plus 5cm}{\bf object}$\ast$ SexObject\_\-to\_\-object ({\bf SexObject} $\ast$ {\em sobj}, \/  {\bf observation} $\ast$const  {\em obs}, \/  {\bf aperture\_\-conf} $\ast$ {\em conf}, \/  char {\em conffile}\mbox{[}$\,$\mbox{]}, \/  float {\em mfwhm}, \/  float {\em dmag}, \/  int {\em auto\_\-reorient}, \/  int {\em bck\_\-mode})}}
\label{spc__sex_8h_a1cc8887bfa02d842b41141ae74750490}
Function: SexObject\_\-to\_\-object Fill an \hyperlink{structobject}{object} structure with the information contained in a \hyperlink{structSexObject}{SexObject} structure This function uses a configuration file to compute the full list of beams for each \hyperlink{structobject}{object}.

Parameters: 
\begin{DoxyParams}{Parameters}
\item[{\em sobj}]-\/ pointer to a \hyperlink{structSexObject}{SexObject} \item[{\em obs}]-\/ a pointer to the data array containing the image \item[{\em conffile}]-\/ the name of the aperture configuration file \item[{\em maxmag}]-\/ upper magniture bound. If \hyperlink{structobject}{object} has a magnitude greater than this has its ignore flag set to 1, zero otherwise. \item[{\em mfwhm}]-\/ the fwhm multiplicator constant to apply to determine the width of the aperture box for the \hyperlink{structobject}{object}. \item[{\em dmag}]-\/ number of magnitudes to add to the magnitudes cutoffs \item[{\em auto\_\-reorient}]-\/ if set then this task tries to optimize the orientation of the extraction slit -\/ Should in general be left at 1 so that strange geomety is avoided. If set to 2 the extraction is forced to be vertical (90 deg.)\end{DoxyParams}
Returns: \begin{DoxyReturn}{Returns}
a pointer to a newly allocated \hyperlink{structobject}{object} structure 
\end{DoxyReturn}



\begin{DoxyCode}
1083 {
1084   int i, dx0, dx1;
1085   beam *b;
1086   object *ob = malloc (sizeof (object));
1087   d_point pixel;
1088   tracestruct *trace;
1089   //  aperture_conf *conf;
1090   float mmag_extract, mmag_mark;
1091   //  conf = get_aperture_descriptor (conffile);
1092   int j = 0, jj=0, nvalid=0;
1093   double fval=0.0;
1094   gsl_vector *flux;
1095   float aposang, paposang;
1096   float dya, dyb;
1097   int iturn;
1098 
1099   ob->ID = sobj->number;
1100 
1101 
1102   for (i = 0; i < conf->nbeams; i++)
1103     {
1104       dx0 = conf->beam[i].offset.dx0;
1105       dx1 = conf->beam[i].offset.dx1;
1106       mmag_extract = conf->beam[i].mmag_extract+dmag;
1107       mmag_mark = conf->beam[i].mmag_mark+dmag;
1108       b = &(ob->beams[i]);
1109       b->ID = conf->beam[i].ID;
1110 
1111       //---------------------------------------
1112       // some code for FORS2 MXU
1113       // b->backwindow.x = sobj->backwindow.x;
1114       // b->backwindow.y = sobj->backwindow.y;
1115 
1116       b->modspec  = sobj->modspec;
1117       b->modimage = sobj->modimage;
1118 
1119       /* Adjust for posibly non (0,0) ref point of the 2D field dependence */
1120       pixel.x = sobj->xy_image.x-1 - conf->refx;
1121       pixel.y = sobj->xy_image.y-1 - conf->refy;
1122       /* get the geometrical description of the trace at position "pixel" */
1123       trace =
1124         get_tracestruct_at_pos (conffile, conf->beam[i].ID, pixel);
1125 
1126       b->spec_trace = vector_to_trace_polyN ( trace->pol );
1127 
1128       b->width   = sobj->el_image.a * mfwhm;
1129 
1130 
1131       /* if flux/wavelength information exists */
1132       if (sobj->magnitudes)
1133         {
1134 
1135           // get the number of valid entries in 'sobj->magnitudes'
1136           nvalid = get_valid_entries(sobj->magnitudes);
1137           if (!nvalid)
1138             aXe_message (aXe_M_FATAL, __FILE__, __LINE__,
1139                          "No valid magnitude for object %i !\n", sobj->number);
1140 
1141 
1142           // allocate the vector for the flux
1143           flux = gsl_vector_alloc (2*(nvalid));
1144 
1145           // fill the flux vector with values
1146           jj=0;
1147           for (j=0; j < sobj->magnitudes->size; j++)
1148             {
1149               if (is_valid_entry(gsl_vector_get(sobj->magnitudes, j)))
1150                 {
1151 
1152                   fval = get_flambda_from_magab(gsl_vector_get(sobj->magnitudes, 
      j), gsl_vector_get(sobj->lambdas, j));
1153 
1154                   gsl_vector_set(flux, 2*jj, gsl_vector_get(sobj->lambdas, j));
1155                   //              gsl_vector_set(flux, 2*jj+1, gsl_vector_get(sob
      j->magnitudes, j));
1156                   gsl_vector_set(flux, 2*jj+1, fval);
1157                   jj++;
1158                 }
1159             }
1160           b->flux = flux;
1161 
1162           /* fill the structual parameters of the object */
1163           b->awidth  = sobj->el_image.a;
1164           b->bwidth  = sobj->el_image.b;
1165           b->aorient = sobj->el_image.theta;
1166         }
1167       // if flux/wavelength information does not exists
1168       else
1169         {
1170           // set everything to dummy values
1171           b->flux = NULL;
1172 
1173           b->awidth  = -1.0;
1174           b->bwidth  = -1.0;
1175           b->aorient = -1.0;
1176         }
1177 
1178       /* Convert from SeXtractor angle reference point to aXe's */
1179       b->orient = (180 + sobj->el_image.theta) / 180. * M_PI;
1180       while (b->orient > M_PI)
1181         b->orient = b->orient - M_PI;
1182 
1183       // calculate the angle between
1184       // the extraction direction and the trace
1185       aposang =
1186         b->orient - atan2(b->spec_trace->deriv (0, b->spec_trace->data),1.0);
1187 
1188       // transform the angle to degrees
1189       paposang = aposang / M_PI * 180.;
1190 
1191       // give a warning for small angles
1192       // between the orientation direction and
1193       // the trace angle.
1194       if ((fabs(paposang < MIN_DIFFANGLE) || fabs(paposang-180.0) < 
      MIN_DIFFANGLE) && auto_reorient == 0)
1195         aXe_message (aXe_M_WARN4, __FILE__, __LINE__,
1196                      "aXe_GOL2AF: Object ID: %i: The angle between the extraction
       orientation and "
1197                      "the trace is less than %5.2f degrees. You may get severe pr
      oblems"
1198                      " down to core dumps in the 1D extraction later on!\n", ob->
      ID, MIN_DIFFANGLE);
1199 
1200 
1201       /* Case when the extraction angle is modified to that the extraction */
1202       /* proceeds along the semi-axis which projects farther away from the
1203        * trace i.e. we avoid trying to extract spectra in a direction nearly
1204        * parallel the trace */
1205       if (auto_reorient==1)
1206         {
1207 
1208           aposang =
1209             b->orient - atan2(b->spec_trace->deriv (0,
1210                                                     b->spec_trace->data),1.0);
1211 
1212           /* February 2004 introduced to make a hardstop in the range for
1213              allowed angles. */
1214           if (aposang > 0.0){
1215             paposang = aposang / M_PI * 180.;
1216           }
1217           else{
1218             paposang = aposang / M_PI * 180. + 360.0;
1219           }
1220           if (paposang > 180.0)
1221             paposang = paposang-180.0;
1222           /* the hard stop is here */
1223           if (paposang > 30.0 && paposang < 150.0){
1224             iturn = 0;}
1225           else{
1226             iturn = 1;}
1227           /*end introduction */
1228 
1229 
1230           /* Compute how far each axes extends away from the trace */
1231           dya = fabs (sobj->el_image.a * sin (aposang));
1232           dyb = fabs (sobj->el_image.b * sin (M_PI / 2. - aposang));
1233 
1234           /* Select the broader of the two axes */
1235           if (dya > dyb && iturn == 0)
1236             {
1237               b->width = sobj->el_image.a * mfwhm;
1238             }
1239           else
1240             {
1241               b->width = sobj->el_image.b * mfwhm;
1242               b->orient = b->orient + M_PI / 2.;
1243             }
1244         }
1245 
1246         /* Case when we force the extraction to be vertical,
1247            the extraction width is recomputed */
1248       if (auto_reorient==2) {
1249         // new system for fixed extraction:
1250         //    - extraction direction perpendicular
1251         //      to the trace
1252         //    - the mfwhm is used as a fixed extraction widt in pixels
1253         b->orient =
1254           atan2(b->spec_trace->deriv (0,b->spec_trace->data),1.0)+ M_PI / 2.0;
1255 
1256         if (mfwhm < 0.0)
1257           {
1258             b->orient =
1259               atan2(b->spec_trace->deriv (0.0,b->spec_trace->data),1.0)+ M_PI / 2
      .0;
1260             b->width  = -mfwhm;
1261 
1262           }
1263         else
1264           {
1265             aposang = b->orient
1266               - atan2(b->spec_trace->deriv (0,b->spec_trace->data),1.0);
1267 
1268             /* Compute how far each axes extends away from the trace */
1269             dya = fabs (sobj->el_image.a * sin (aposang));
1270             dyb = fabs (sobj->el_image.b * sin (M_PI / 2. - aposang));
1271             b->width = mfwhm*MAX(dya,dyb);
1272             b->orient =
1273               atan2(b->spec_trace->deriv (0,b->spec_trace->data),1.0)+ M_PI / 2.0
      ;
1274           }
1275 
1276       }
1277 
1278       if (sobj->backwindow.x != -1 && bck_mode)
1279         b->width = MAX(b->width, sobj->backwindow.x);
1280 
1281       /* On coordinate systems:
1282          the sexrtractor image positions are given in the iraf system,
1283          which means the value of the lower left pixel is associated
1284          with the coordinate (1.0,1.0).
1285          aXe works in a kind of 'matrix system', where the value of
1286          the lower left pixel is stored in the matrix indices (0,0)
1287          or (0.0,0.0) seen as a coordinate system.
1288          To transform into this system 1.0 is subracted from
1289          both sextractor coordinates.
1290        */
1291       b->refpoint.x = sobj->xy_image.x-1.0 + trace->offset.x;
1292       b->refpoint.y = sobj->xy_image.y-1.0 + trace->offset.y;
1293 
1294       /* magnitude cut */
1295       // PROBLEM: there is a logical flaw inside
1296       //          whhat happend when (mag > mag_mark) && (mag <  mmag_extract) ??
      ??
1297       //          of course this has only relevance when mag_mark < mmag_extract
1298       //      if ((sobj->mag_auto <= mmag_mark)&&(sobj->mag_auto <= mmag_extract)
      )
1299       // That's now an easy fix, but makes sense..
1300       if (sobj->mag_auto <= mmag_extract)
1301         {
1302           b->ignore = 0; /* This object will be extracted */
1303         }
1304       if ((sobj->mag_auto <= mmag_mark)&&(sobj->mag_auto > mmag_extract))
1305         {
1306           b->ignore = 2; /* This object will be not be extracted */
1307         }
1308       if ((sobj->mag_auto > mmag_mark)&&(sobj->mag_auto > mmag_extract))
1309         {
1310           b->ignore = 1; /* This object will be ignored */
1311         }
1312 
1313       if (!fill_object_bbox (obs, b, 2, dx0, dx1))
1314         b->ignore = 1;
1315 
1316     b->slitgeom[0] = -1.0;
1317     b->slitgeom[1] = -1.0;
1318     b->slitgeom[2] = -1.0;
1319     b->slitgeom[3] = -1.0;
1320     }
1321 
1322   ob->nbeams = conf->nbeams;
1323   ob->grism_obs = obs;
1324 
1325   return ob;
1326 }
\end{DoxyCode}
\hypertarget{spc__sex_8h_adca42a33ade468757a83d39dd9462137}{
\index{spc\_\-sex.h@{spc\_\-sex.h}!SexObject\_\-to\_\-objectII@{SexObject\_\-to\_\-objectII}}
\index{SexObject\_\-to\_\-objectII@{SexObject\_\-to\_\-objectII}!spc_sex.h@{spc\_\-sex.h}}
\subsubsection[{SexObject\_\-to\_\-objectII}]{\setlength{\rightskip}{0pt plus 5cm}{\bf object}$\ast$ SexObject\_\-to\_\-objectII ({\bf SexObject} $\ast$ {\em sobj}, \/  {\bf observation} $\ast$const  {\em obs}, \/  {\bf aperture\_\-conf} $\ast$ {\em conf}, \/  char {\em conffile}\mbox{[}$\,$\mbox{]}, \/  float {\em mfwhm}, \/  float {\em dmag}, \/  int {\em auto\_\-reorient}, \/  int {\em bck\_\-mode})}}
\label{spc__sex_8h_adca42a33ade468757a83d39dd9462137}
Function: SexObject\_\-to\_\-objectII Fill an \hyperlink{structobject}{object} structure with the information contained in a \hyperlink{structSexObject}{SexObject} structure This function uses a configuration file to compute the full list of beams for each \hyperlink{structobject}{object}.

Parameters: 
\begin{DoxyParams}{Parameters}
\item[{\em sobj}]-\/ pointer to a \hyperlink{structSexObject}{SexObject} \item[{\em obs}]-\/ a pointer to the data array containing the image \item[{\em conf}]-\/ pointer to the configuration structure \item[{\em conffile}]-\/ the name of the aperture configuration file \item[{\em mfwhm}]-\/ the fwhm multiplicator constant to apply to determine the width of the aperture box for the \hyperlink{structobject}{object}. \item[{\em dmag}]-\/ number of magnitudes to add to the magnitudes cutoffs \item[{\em auto\_\-reorient}]-\/ if set then this task tries to optimize the orientation of the extraction slit -\/ Should in general be left at 1 so that strange geomety is avoided. If set to 2 the extraction is forced to be vertical (90 deg.) \item[{\em bck\_\-mode}]-\/ pointer for background mode\end{DoxyParams}
Returns: \begin{DoxyReturn}{Returns}
a pointer to a newly allocated \hyperlink{structobject}{object} structure 
\end{DoxyReturn}



\begin{DoxyCode}
1027   {
1028     int i=0;
1029 
1030     object *ob;
1031 
1032     // allocate an object
1033     ob = (object *)malloc(sizeof(object));
1034 
1035     // store the object specific
1036     // information
1037     ob->ID = sobj->number;
1038     ob->nbeams = conf->nbeams;
1039     ob->grism_obs = obs;
1040 
1041     // go over all beams
1042     for (i = 0; i < conf->nbeams; i++)
1043         // fill the current beam
1044         SexObject_to_beam(sobj, obs, conf, conffile, mfwhm, dmag, auto_reorient,
1045                           bck_mode, i, &(ob->beams[i]));
1046 
1047     // return the object
1048     return ob;
1049   }
\end{DoxyCode}
\hypertarget{spc__sex_8h_af26ee7c0414b10010e9a3a2cdfcbcb9d}{
\index{spc\_\-sex.h@{spc\_\-sex.h}!SexObject\_\-to\_\-slitgeom@{SexObject\_\-to\_\-slitgeom}}
\index{SexObject\_\-to\_\-slitgeom@{SexObject\_\-to\_\-slitgeom}!spc_sex.h@{spc\_\-sex.h}}
\subsubsection[{SexObject\_\-to\_\-slitgeom}]{\setlength{\rightskip}{0pt plus 5cm}void SexObject\_\-to\_\-slitgeom (const {\bf aperture\_\-conf} $\ast$ {\em conf}, \/  const {\bf SexObject} $\ast$ {\em sobj}, \/  const double {\em trace\_\-angle}, \/  {\bf beam} $\ast$ {\em actbeam})}}
\label{spc__sex_8h_af26ee7c0414b10010e9a3a2cdfcbcb9d}
Function: SexObject\_\-to\_\-slitgeom Fill a \hyperlink{structbeam}{beam} structure with the optimized geometry information. The quantities are computed from the \hyperlink{structobject}{object} shape and the trace angle.

Parameters: 
\begin{DoxyParams}{Parameters}
\item[{\em sobj}]-\/ pointer to a \hyperlink{structSexObject}{SexObject} \item[{\em trace\_\-angle}]-\/ pointer to a \hyperlink{structSexObject}{SexObject} \item[{\em actbeam}]-\/ the \hyperlink{structbeam}{beam} structure to be filled\end{DoxyParams}
Returns: \begin{DoxyReturn}{Returns}
-\/ 
\end{DoxyReturn}



\begin{DoxyCode}
645   {
646     double theta=0.0;
647     double orient=0.0;
648     double tmp_angle, cos_tmp_angle;
649     double A11, A12, A22;
650 
651     d_point obj_size;
652 
653     // convert the SExtractor angle to rad in the right quadrant
654     orient = (180.0 + sobj->el_image.theta) / 180.0 * M_PI;
655     while (orient > M_PI)
656       orient = orient - M_PI;
657 
658     // compute angle between object
659     // orientation and trace
660     theta = orient - trace_angle;
661 
662     // check the object size, possibly setting
663     // it to the size of point-like object
664     obj_size = check_object_size(conf, sobj, actbeam->ID);
665 
666     /*
667     // determine the three matrix elements
668     A11 = SQR(cos(theta) / sobj->el_image.a) + SQR(sin(theta) / sobj->el_image.b)
      ;
669     A12 = cos(theta) * sin(theta) * (1.0/(SQR(sobj->el_image.a)) - 1.0/SQR(sobj->
      el_image.b));
670     A22 = SQR(sin(theta) / sobj->el_image.a) + SQR(cos(theta) / sobj->el_image.b)
      ;
671 
672     // compute a temporary angle
673     // and its cosine
674     tmp_angle     = atan(A12 / A11);
675     cos_tmp_angle = cos(tmp_angle);
676 
677     // compute the slit length
678     if (cos_tmp_angle > 0.01)
679       actbeam->slitgeom[0] = sqrt(A11)*sobj->el_image.a*sobj->el_image.b / cos_tm
      p_angle;
680     else
681       actbeam->slitgeom[0] = sqrt(A11)*sobj->el_image.a*sobj->el_image.b / 0.01;
682 
683     // compute the slit orientation
684     actbeam->slitgeom[1] = tmp_angle + trace_angle + M_PI_2;
685 
686     // compute the slit length
687     actbeam->slitgeom[2] = 1.0 / sqrt(A11);
688 
689     // compute a modified B_IMAGE value, defined to keep the object area constant
      
690     actbeam->slitgeom[3] = sobj->el_image.a*sobj->el_image.b / actbeam->slitgeom[
      0];
691     */
692 
693     // determine the three matrix elements
694     A11 = SQR(cos(theta) / obj_size.x) + SQR(sin(theta) / obj_size.y);
695     A12 = cos(theta) * sin(theta) * (1.0/(SQR(obj_size.x)) - 1.0/SQR(obj_size.y))
      ;
696     A22 = SQR(sin(theta) / obj_size.x) + SQR(cos(theta) / obj_size.y);
697 
698     // compute a temporary angle
699     // and its cosine
700     tmp_angle     = atan(A12 / A11);
701     cos_tmp_angle = cos(tmp_angle);
702 
703     // compute the slit length
704     if (cos_tmp_angle > 0.01)
705       actbeam->slitgeom[0] = sqrt(A11)*obj_size.x*obj_size.y / cos_tmp_angle;
706     else
707       actbeam->slitgeom[0] = sqrt(A11)*obj_size.x*obj_size.y / 0.01;
708 
709     // compute the slit orientation
710     actbeam->slitgeom[1] = tmp_angle + trace_angle + M_PI_2;
711 
712     // compute the slit width
713     actbeam->slitgeom[2] = 1.0 / sqrt(A11);
714 
715     // compute a modified B_IMAGE value, defined to keep the object area constant
      
716     actbeam->slitgeom[3] = obj_size.x*obj_size.y / actbeam->slitgeom[0];
717   }
\end{DoxyCode}
\hypertarget{spc__sex_8h_a3be1c25232414791b69783398d5c0fc3}{
\index{spc\_\-sex.h@{spc\_\-sex.h}!SexObjects\_\-to\_\-oblist@{SexObjects\_\-to\_\-oblist}}
\index{SexObjects\_\-to\_\-oblist@{SexObjects\_\-to\_\-oblist}!spc_sex.h@{spc\_\-sex.h}}
\subsubsection[{SexObjects\_\-to\_\-oblist}]{\setlength{\rightskip}{0pt plus 5cm}{\bf object}$\ast$$\ast$ SexObjects\_\-to\_\-oblist ({\bf SexObject} $\ast$$\ast$ {\em sobjs}, \/  {\bf observation} $\ast$const  {\em obs}, \/  {\bf aperture\_\-conf} $\ast$ {\em conf}, \/  char {\em conffile}\mbox{[}$\,$\mbox{]}, \/  float {\em mfwhm}, \/  float {\em dmag}, \/  int {\em auto\_\-reorient}, \/  int {\em bck\_\-mode})}}
\label{spc__sex_8h_a3be1c25232414791b69783398d5c0fc3}
Function: SexObjects\_\-to\_\-oblist Produces an \hyperlink{structobject}{object} list from the data contained in an array of SexObjects

Parameters: 
\begin{DoxyParams}{Parameters}
\item[{\em sobjs}]-\/ an NULL terminated array containing pointers to SexObjects \item[{\em obs}]-\/ a pointer to the data array containing the image \item[{\em conffile}]-\/ the name of the aperture configuration file \item[{\em mmag\_\-extract}]-\/ upper magniture bound. Any \hyperlink{structobject}{object} with a magnitude greater than this has its ignore flag set to 1. \item[{\em mmag\_\-mark}]-\/ upper magniture bound. Any \hyperlink{structobject}{object} with a magnitude greater than this has its ignore flag set to 2. \item[{\em mfwhm}]-\/ the fwhm multiplicator constant to apply to determine the width of the aperture box for the \hyperlink{structobject}{object}. \item[{\em dmag}]-\/ number of magnitudes to add to the magnitudes cutoffs \item[{\em auto\_\-reorient}]-\/ if set to 1 then this task tries to optimize the orientation of the extraction slit. Should in general be left at 1 so that strange geomety is avoided. If set to 2 the extraction is forced to be vertical (90 deg.)\end{DoxyParams}
Return: \begin{DoxyReturn}{Returns}
a pointer to a NULL terminated \hyperlink{structobject}{object} array. 
\end{DoxyReturn}



\begin{DoxyCode}
1356 {
1357      int i, nobjs = 0;
1358      object **oblist;
1359 
1360      /* Find the number of SexObjects in sobjs */
1361      while (sobjs[nobjs])
1362           nobjs++;
1363      /* Allocate enough room for a new object list */
1364      oblist = (object **) malloc ((nobjs + 1) * sizeof (object *));
1365 
1366      for (i = 0; i < nobjs; i++)
1367        {
1368          //fprintf(stdout, "Using the old routine...\n");
1369          oblist[i] =
1370          SexObject_to_object(sobjs[i], obs, conf, conffile, mfwhm, dmag, auto_reo
      rient, bck_mode);
1371         }
1372      oblist[nobjs] = NULL;
1373 
1374      return oblist;
1375 }
\end{DoxyCode}
\hypertarget{spc__sex_8h_aba315f6055ab2042c62d24e4a6312491}{
\index{spc\_\-sex.h@{spc\_\-sex.h}!SexObjects\_\-to\_\-oblistII@{SexObjects\_\-to\_\-oblistII}}
\index{SexObjects\_\-to\_\-oblistII@{SexObjects\_\-to\_\-oblistII}!spc_sex.h@{spc\_\-sex.h}}
\subsubsection[{SexObjects\_\-to\_\-oblistII}]{\setlength{\rightskip}{0pt plus 5cm}{\bf object}$\ast$$\ast$ SexObjects\_\-to\_\-oblistII ({\bf SexObject} $\ast$$\ast$ {\em sobjs}, \/  {\bf observation} $\ast$const  {\em obs}, \/  {\bf aperture\_\-conf} $\ast$ {\em conf}, \/  char {\em conffile}\mbox{[}$\,$\mbox{]}, \/  float {\em mfwhm}, \/  float {\em dmag}, \/  int {\em auto\_\-reorient}, \/  int {\em bck\_\-mode})}}
\label{spc__sex_8h_aba315f6055ab2042c62d24e4a6312491}
Function: SexObjects\_\-to\_\-oblistII Produces an \hyperlink{structobject}{object} list from the data contained in an array of SexObjects

Parameters: 
\begin{DoxyParams}{Parameters}
\item[{\em sobjs}]-\/ an NULL terminated array containing pointers to SexObjects \item[{\em obs}]-\/ a pointer to the data array containing the image \item[{\em conffile}]-\/ the name of the aperture configuration file \item[{\em mmag\_\-extract}]-\/ upper magniture bound. Any \hyperlink{structobject}{object} with a magnitude greater than this has its ignore flag set to 1. \item[{\em mmag\_\-mark}]-\/ upper magniture bound. Any \hyperlink{structobject}{object} with a magnitude greater than this has its ignore flag set to 2. \item[{\em mfwhm}]-\/ the fwhm multiplicator constant to apply to determine the width of the aperture box for the \hyperlink{structobject}{object}. \item[{\em dmag}]-\/ number of magnitudes to add to the magnitudes cutoffs \item[{\em auto\_\-reorient}]-\/ if set to 1 then this task tries to optimize the orientation of the extraction slit. Should in general be left at 1 so that strange geomety is avoided. If set to 2 the extraction is forced to be vertical (90 deg.)\end{DoxyParams}
Return: \begin{DoxyReturn}{Returns}
a pointer to a NULL terminated \hyperlink{structobject}{object} array. 
\end{DoxyReturn}



\begin{DoxyCode}
1404 {
1405      int i, nobjs = 0;
1406      object **oblist;
1407 
1408      /* Find the number of SexObjects in sobjs */
1409      while (sobjs[nobjs])
1410           nobjs++;
1411      /* Allocate enough room for a new object list */
1412      oblist = (object **) malloc ((nobjs + 1) * sizeof (object *));
1413 
1414      for (i = 0; i < nobjs; i++)
1415        {
1416          //fprintf(stdout, "Using the new routine...\n");
1417          oblist[i] =
1418          SexObject_to_objectII(sobjs[i], obs, conf, conffile, mfwhm, dmag, auto_r
      eorient, bck_mode);
1419         }
1420      oblist[nobjs] = NULL;
1421 
1422      return oblist;
1423 }
\end{DoxyCode}
\hypertarget{spc__sex_8h_aa358fe9be94faba9d46991eb7fa9e766}{
\index{spc\_\-sex.h@{spc\_\-sex.h}!size\_\-of\_\-sextractor\_\-catalog@{size\_\-of\_\-sextractor\_\-catalog}}
\index{size\_\-of\_\-sextractor\_\-catalog@{size\_\-of\_\-sextractor\_\-catalog}!spc_sex.h@{spc\_\-sex.h}}
\subsubsection[{size\_\-of\_\-sextractor\_\-catalog}]{\setlength{\rightskip}{0pt plus 5cm}int size\_\-of\_\-sextractor\_\-catalog (char {\em filename}\mbox{[}$\,$\mbox{]})}}
\label{spc__sex_8h_aa358fe9be94faba9d46991eb7fa9e766}
Function: size\_\-of\_\-sextractor\_\-catalog A utility function which parses a Sextractor catalog file, and returns the number of valid catalog entries found in the file

Parameters: 
\begin{DoxyParams}{Parameters}
\item[{\em filename}]-\/ a pointer pointing to a char array containing the list of a sextractor \hyperlink{structobject}{object} output catalog. Ignores rows starting with a \char`\"{};\char`\"{} \end{DoxyParams}



\begin{DoxyCode}
1606 {
1607   FILE *input;
1608   char Buffer[CATBUFFERSIZE];
1609   gsl_vector *v;
1610   int catsize;
1611   int num = 0;
1612   colinfo * actcatinfo;
1613 
1614   actcatinfo = get_sex_col_descr (filename);
1615   //  catalog_header = get_sex_col_descr (filename);
1616   catsize = actcatinfo->numcols;
1617   if (!(input = fopen (filename, "r")))
1618     {
1619       aXe_message (aXe_M_FATAL, __FILE__, __LINE__,
1620                    "Could not open Sextractor catalog" "file %s,\n",
1621                    filename);
1622     }
1623 
1624 
1625   while (fgets (Buffer, CATBUFFERSIZE, input))
1626     {
1627       if (Buffer[0] == ';')
1628         continue;
1629       lv1ws (Buffer);
1630       v = string_to_gsl_array (Buffer);
1631       if (v==NULL) continue;
1632       if (v->size == catsize)
1633         num++;
1634     }
1635   return num;
1636 }
\end{DoxyCode}
\hypertarget{spc__sex_8h_a496014d96016e580b632b2b15e0b7f72}{
\index{spc\_\-sex.h@{spc\_\-sex.h}!sobs\_\-to\_\-vout@{sobs\_\-to\_\-vout}}
\index{sobs\_\-to\_\-vout@{sobs\_\-to\_\-vout}!spc_sex.h@{spc\_\-sex.h}}
\subsubsection[{sobs\_\-to\_\-vout}]{\setlength{\rightskip}{0pt plus 5cm}gsl\_\-vector$\ast$ sobs\_\-to\_\-vout (const {\bf SexObject} $\ast$ {\em sobs})}}
\label{spc__sex_8h_a496014d96016e580b632b2b15e0b7f72}
Function: sobs\_\-to\_\-vout The function transforms a \hyperlink{structSexObject}{SexObject} into a vector.

Parameters: 
\begin{DoxyParams}{Parameters}
\item[{\em sobs}]-\/ the \hyperlink{structSexObject}{SexObject} to be transformed\end{DoxyParams}
Returns: \begin{DoxyReturn}{Returns}
vout -\/ the vector with the Seobject data 
\end{DoxyReturn}



\begin{DoxyCode}
211 {
212 
213   int nentries, i;
214   int count=0;
215 
216   // determine the size of the vector
217   if (sobs->magnitudes){
218     nentries = 11+sobs->magnitudes->size;
219   }
220   else{
221     nentries = 12;
222   }
223 
224   if(sobs->backwindow.x != -1)
225     nentries = nentries+1;
226     // old FORS2-MXU code:
227     //nentries = nentries+2;
228 
229   if(sobs->modspec != -1)
230     nentries++;
231   if(sobs->modimage != -1)
232     nentries++;
233 
234   // allocate space for the vector
235   gsl_vector *vout = gsl_vector_alloc (nentries);
236 
237   // fill the vector
238   gsl_vector_set (vout, count++, sobs->number);
239   gsl_vector_set (vout, count++, sobs->xy_world.ra);
240   gsl_vector_set (vout, count++, sobs->xy_world.dec);
241   gsl_vector_set (vout, count++, sobs->el_world.a);
242   gsl_vector_set (vout, count++, sobs->el_world.b);
243   gsl_vector_set (vout, count++, sobs->el_world.theta);
244   gsl_vector_set (vout, count++, sobs->xy_image.x);
245   gsl_vector_set (vout, count++, sobs->xy_image.y);
246   gsl_vector_set (vout, count++, sobs->el_image.a);
247   gsl_vector_set (vout, count++, sobs->el_image.b);
248   gsl_vector_set (vout, count++, sobs->el_image.theta);
249 
250   if(sobs->backwindow.x != -1)
251     {
252       gsl_vector_set (vout, count++, sobs->backwindow.x);
253       // old code for FORS2-MXU
254       //gsl_vector_set (vout, count++, sobs->backwindow.y);
255     }
256 
257   if(sobs->modspec != -1)
258       gsl_vector_set (vout, count++, sobs->modspec);
259 
260   if(sobs->modimage != -1)
261       gsl_vector_set (vout, count++, sobs->modimage);
262 
263   // see whether there is MAG_AUTO
264   if (sobs->magnitudes){
265     // fill in the magnitude values
266     for (i=0; i < sobs->magnitudes->size; i++)
267       gsl_vector_set (vout, count++, gsl_vector_get(sobs->magnitudes, i));
268   }
269   else{
270     // fill in the MAG_AUTO value
271     gsl_vector_set (vout, count++, sobs->mag_auto);
272   }
273 
274   // return the vector
275   return vout;
276 }
\end{DoxyCode}
