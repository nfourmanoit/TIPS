\hypertarget{spce__output_8h}{
\section{/renoir/fourmano/Desktop/OUSIM/TIPS/branches/tips\_\-build/include/axesim/spce\_\-output.h File Reference}
\label{spce__output_8h}\index{/renoir/fourmano/Desktop/OUSIM/TIPS/branches/tips\_\-build/include/axesim/spce\_\-output.h@{/renoir/fourmano/Desktop/OUSIM/TIPS/branches/tips\_\-build/include/axesim/spce\_\-output.h}}
}
{\ttfamily \#include \char`\"{}aper\_\-conf.h\char`\"{}}\par
\subsection*{Data Structures}
\begin{DoxyCompactItemize}
\item 
struct \hyperlink{structdrzstamp__dim}{drzstamp\_\-dim}
\item 
struct \hyperlink{structquadrangle}{quadrangle}
\item 
struct \hyperlink{structdrzstamp}{drzstamp}
\item 
struct \hyperlink{structdrzprep}{drzprep}
\end{DoxyCompactItemize}
\subsection*{Namespaces}
\begin{DoxyCompactItemize}
\item 
namespace \hyperlink{namespacespce__output}{spce\_\-output}
\end{DoxyCompactItemize}
\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
gsl\_\-vector\_\-int $\ast$ \hyperlink{spce__output_8h_a487a01f9e88471517124284a4047bd44}{get\_\-trace\_\-inds} (const \hyperlink{structap__pixel}{ap\_\-pixel} $\ast$const ap\_\-p)
\item 
gsl\_\-matrix $\ast$ \hyperlink{spce__output_8h_adecd7e61360bb4de56f06143b2f070ac}{stamp\_\-img} (const \hyperlink{structap__pixel}{ap\_\-pixel} $\ast$const ap\_\-p, float width, \hyperlink{structd__point}{d\_\-point} $\ast$stp\_\-min)
\item 
\hyperlink{structdrzprep}{drzprep} $\ast$ \hyperlink{spce__output_8h_ae73fef882d3f2e909f83b4d9784eaba8}{stamp\_\-img\_\-drzprep} (const int opt\_\-extr, const \hyperlink{structap__pixel}{ap\_\-pixel} $\ast$const ap\_\-p, const \hyperlink{structap__pixel}{ap\_\-pixel} $\ast$const se\_\-p, float width, float nullval, int usemode, \hyperlink{structdrzstamp__dim}{drzstamp\_\-dim} dimension, gsl\_\-matrix $\ast$drzcoeffs, double exptime, double sky\_\-cps, double rdnoise, const int bckmode)
\item 
void \hyperlink{spce__output_8h_ac02af5218e62e713615c31e68fb3e808}{free\_\-drzprep} (\hyperlink{structdrzprep}{drzprep} $\ast$drzprep\_\-stamps)
\item 
gsl\_\-matrix $\ast$ \hyperlink{spce__output_8h_acfb8de045d5147f405aac44a201d51a1}{rectified\_\-stamp\_\-img} (const \hyperlink{structap__pixel}{ap\_\-pixel} $\ast$const ap\_\-p, float width, \hyperlink{structd__point}{d\_\-point} $\ast$stp\_\-min)
\item 
\hyperlink{structd__point}{d\_\-point} \hyperlink{spce__output_8h_a727084323c00d05a5549164d2820c77e}{get\_\-minxy\_\-from\_\-PET} (const \hyperlink{structap__pixel}{ap\_\-pixel} $\ast$const ap\_\-p)
\item 
\hyperlink{structd__point}{d\_\-point} \hyperlink{spce__output_8h_a294f187040188cd530ca348373ae6b9f}{get\_\-maxxy\_\-from\_\-PET} (const \hyperlink{structap__pixel}{ap\_\-pixel} $\ast$const ap\_\-p)
\item 
\hyperlink{structdrzstamp}{drzstamp} $\ast$ \hyperlink{spce__output_8h_ad0a264c9a695797c389c2c4b2e5b0d22}{drizzled\_\-stamp\_\-img} (const \hyperlink{structap__pixel}{ap\_\-pixel} $\ast$const ap\_\-p, double width, const double orient, const \hyperlink{structdrzstamp__dim}{drzstamp\_\-dim} dimension)
\item 
\hyperlink{structdrzstamp__dim}{drzstamp\_\-dim} \hyperlink{spce__output_8h_a26cf5661457b717143b4bfb97c3a440d}{get\_\-drzprep\_\-dim} (const \hyperlink{structap__pixel}{ap\_\-pixel} $\ast$const ap\_\-p, float width, int boxwidth, int boxheight)
\item 
\hyperlink{structdrzstamp__dim}{drzstamp\_\-dim} \hyperlink{spce__output_8h_aece0dc2dd2738020829c96e9413f5494}{get\_\-stamp\_\-dim} (const \hyperlink{structap__pixel}{ap\_\-pixel} $\ast$const ap\_\-p, float width, \hyperlink{structaperture__conf}{aperture\_\-conf} $\ast$conf, const int beamID, \hyperlink{structd__point}{d\_\-point} $\ast$stp\_\-min)
\item 
\hyperlink{structquadrangle}{quadrangle} \hyperlink{spce__output_8h_a0b04392e15823b7d3e07a84cc698d56d}{get\_\-quad\_\-from\_\-pixel} (const \hyperlink{structap__pixel}{ap\_\-pixel} $\ast$cur\_\-p, const double orient, const \hyperlink{structdrzstamp__dim}{drzstamp\_\-dim} dimension)
\item 
gsl\_\-matrix $\ast$ \hyperlink{spce__output_8h_a7bdb9f552a53b43dd53813e8f3037ac7}{drizzled\_\-stamp\_\-img\_\-orig} (const \hyperlink{structap__pixel}{ap\_\-pixel} $\ast$const ap\_\-p, float width, \hyperlink{structaperture__conf}{aperture\_\-conf} $\ast$conf)
\item 
void \hyperlink{spce__output_8h_a863b4bf317f0bd06437963cd958db9ba}{interpolate\_\-over\_\-NaN} (gsl\_\-matrix $\ast$data)
\item 
void \hyperlink{spce__output_8h_a307bc04cf548af0968aecb683338713f}{free\_\-stamp\_\-img} (gsl\_\-matrix $\ast$stamp)
\item 
void \hyperlink{spce__output_8h_a699a311158a0c8b9a81792c304e212f4}{free\_\-drzstamp} (\hyperlink{structdrzstamp}{drzstamp} $\ast$stamp)
\end{DoxyCompactItemize}


\subsection{Function Documentation}
\hypertarget{spce__output_8h_ad0a264c9a695797c389c2c4b2e5b0d22}{
\index{spce\_\-output.h@{spce\_\-output.h}!drizzled\_\-stamp\_\-img@{drizzled\_\-stamp\_\-img}}
\index{drizzled\_\-stamp\_\-img@{drizzled\_\-stamp\_\-img}!spce_output.h@{spce\_\-output.h}}
\subsubsection[{drizzled\_\-stamp\_\-img}]{\setlength{\rightskip}{0pt plus 5cm}{\bf drzstamp}$\ast$ drizzled\_\-stamp\_\-img (const {\bf ap\_\-pixel} $\ast$const  {\em ap\_\-p}, \/  double {\em width}, \/  double {\em orient}, \/  const {\bf drzstamp\_\-dim} {\em dimension})}}
\label{spce__output_8h_ad0a264c9a695797c389c2c4b2e5b0d22}
Function: drizzled\_\-stamp\_\-img Produce a structure containing a drizzled stamp image plux ther associated weight image. The drizzled stamp image has constant dispersion along the x-\/axis. No drizzling is applied in cross-\/dispersion direction. The dimensions of the drizzled stampimage were setr previously, and the information is in an input structure. In case that there are no valid pixels, a dummy structure with 10x10 empty pixels is returned.


\begin{DoxyParams}{Parameters}
\item[{\em ap\_\-p}]-\/ pointer to the list of PET pixels \item[{\em width}]-\/ extraction width used \item[{\em dimension}]-\/ dimensional information on the drizzled stamp\end{DoxyParams}
\begin{DoxyReturn}{Returns}
res -\/ structure with counts and weights of the drizzled stamp 
\end{DoxyReturn}



\begin{DoxyCode}
492 {
493   const ap_pixel *cur_p;
494 
495   quadrangle quad;
496 
497   drzstamp *res;
498   gsl_matrix *counts;
499   gsl_matrix *weight;
500 
501   int icen, ilow, iupp;
502   int jcen, jlow, jupp;
503 
504   double xi, jacob=0;
505   double value, allweig, weig;
506 
507   double maxarr=0.0;
508   int iim, jjm;
509 
510   //double totweigth;
511   //double cos_phi=0.0;
512 
513   int ii,jj;
514   double arr;
515   int stpi,stpj;
516   double stpc;
517 
518   // allocate space for the result
519   res = (drzstamp *) malloc(sizeof(drzstamp));
520 
521   // handle an empty PET
522   if (ap_p==NULL || !dimension.resolution) {
523     /* Create a dummy stamp image */
524     counts = gsl_matrix_alloc(10,10);
525     weight = gsl_matrix_alloc(10,10);
526     /* Fill stamp with 0.0 values */
527     gsl_matrix_set_all(counts, 0.0);
528     gsl_matrix_set_all(weight, 0.0);
529 
530     // fill the output
531     res->counts = counts;
532     res->weight = weight;
533 
534     // return the output
535     return res;
536   }
537 
538 
539   /* Allocate the stamp matrix*/
540   /* Fill stamp with NaN values */
541   counts = gsl_matrix_alloc(dimension.xsize,dimension.ysize);
542   gsl_matrix_set_all(counts, GSL_NAN);
543 
544   /* Allocate the weight matrix*/
545   /* Fill weight with 0.0 values */
546   weight = gsl_matrix_alloc(dimension.xsize,dimension.ysize);
547   gsl_matrix_set_all(weight, 0.0);
548 
549 
550   // go over each pixel
551   for (cur_p = ap_p; cur_p->p_x != -1; cur_p++)
552     {
553 
554       // Skip this pixel if it was not actually used
555       if (fabs(cur_p->dist)>width+1.5)
556         continue;
557 
558       // create the quadrangle for the current pixel
559       //      quad = get_quad_from_pixel2(cur_p, dimension);
560       quad = get_quad_from_pixel(cur_p, orient, dimension);
561 
562       // get the jacobian (well, easy here)
563       // the term "cos(cur_p->dxs)" must be there
564       // to correct the enlargement necessary
565       // to cover the whole lambda-crossdispersion area!
566       // NOT COMPLETELY understood
567       jacob = dimension.resolution/cur_p->dlambda*cos(cur_p->dxs);
568 
569       // get the central pixel (icen, jcen) of the current PET-pixel
570       xi = cur_p->lambda/dimension.resolution;
571       icen = (int) floor(xi - dimension.xstart+.5);
572       jcen = (int) floor(cur_p->dist - dimension.ystart+.5);
573 
574       // get the uper and lower extend of the quadrangle in x
575       iupp = (int)floor(quad.xmax - (double)icen + 0.5)+1;
576       ilow = (int)floor(quad.xmin - (double)icen + 0.5);
577 
578       // get the uper and lower extend of the quadrangle in x
579       jupp = (int)floor(quad.ymax - (double)jcen + 0.5)+1;
580       jlow = (int)floor(quad.ymin - (double)jcen + 0.5);
581 
582       maxarr=0.0;
583       //      totweigth = 0.0;
584       // go over the extend in x
585       for (ii=ilow;ii<iupp;ii++) {
586         // go over the extend in x
587         for (jj=jlow;jj<jupp;jj++) {
588 
589           // get the coordinates of the current output pixel
590           stpi = icen+ii;
591           stpj = jcen+jj;
592 
593           // check whether the current output pixel is within
594           // the stamp image; continue if not
595           if ( (stpi>=dimension.xsize)||(stpi<0)||(stpj>=dimension.ysize)||(stpj<
      0) )
596             continue;
597 
598           // get the area which falls onto the current output pixel
599           arr = boxer(stpi,stpj,quad.x,quad.y);
600           if (arr > maxarr)
601             {
602               maxarr=arr;
603               iim = ii;
604               jjm = jj;
605             }
606           // get the already existing counts and weights
607           stpc = gsl_matrix_get(counts,stpi,stpj);
608           weig = gsl_matrix_get(weight,stpi,stpj);
609 
610           // initialize the counts, if necessary
611           if (isnan(stpc) && (arr!=0.0))
612             stpc = 0.0;
613 
614           // compute the new, total weight of the current output pixel
615           //      allweig = weig + jacob*arr;
616           allweig = weig + arr;
617 
618           // do a weighted sum of the count value at the current output pixel
619           value = (stpc*weig + arr*cur_p->count*jacob) / (allweig);
620 
621           // store the new count value and the new weight
622           gsl_matrix_set(counts,stpi,stpj,value);
623           gsl_matrix_set(weight,stpi,stpj,allweig);
624           //      totweigth = totweigth + arr;
625         }
626       }
627     }
628 
629   // fill the output structure
630   res->counts = counts;
631   res->weight = weight;
632 
633   // return the output
634   return res;
635 }
\end{DoxyCode}
\hypertarget{spce__output_8h_a7bdb9f552a53b43dd53813e8f3037ac7}{
\index{spce\_\-output.h@{spce\_\-output.h}!drizzled\_\-stamp\_\-img\_\-orig@{drizzled\_\-stamp\_\-img\_\-orig}}
\index{drizzled\_\-stamp\_\-img\_\-orig@{drizzled\_\-stamp\_\-img\_\-orig}!spce_output.h@{spce\_\-output.h}}
\subsubsection[{drizzled\_\-stamp\_\-img\_\-orig}]{\setlength{\rightskip}{0pt plus 5cm}gsl\_\-matrix$\ast$ drizzled\_\-stamp\_\-img\_\-orig (const {\bf ap\_\-pixel} $\ast$const  {\em ap\_\-p}, \/  float {\em width}, \/  {\bf aperture\_\-conf} $\ast$ {\em conf})}}
\label{spce__output_8h_a7bdb9f552a53b43dd53813e8f3037ac7}
Produce a gsl array containing a 'drizzled aperture'. That is, an image of the spectum showing count on an xi,dist grid instead of the traditional image grid x,y. Returns NULL is input \hyperlink{structobject}{object} is NULL. \mbox{[}modifies ap\_\-p!!\mbox{]} 
\begin{DoxyParams}{Parameters}
\item[{\em ap\_\-p}]a pointer to a -\/1 terminated \hyperlink{structap__pixel}{ap\_\-pixel} array \item[{\em width}]extraction width used \item[{\em resampwidth}]A per pixel of output drizzled spectra \end{DoxyParams}
\begin{DoxyReturn}{Returns}
a pointer to a newly allocated gsl\_\-matrix containing the rectified \hyperlink{structspectrum}{spectrum} 
\end{DoxyReturn}



\begin{DoxyCode}
951 {
952   const ap_pixel *cur_p;
953 
954   double min_xi   = 1e32;
955   double max_xi   = -1e32;
956   double min_dist = 1e32;
957   double max_dist = -1e32;
958   double min_dlam = 1e32;
959   double max_dlam = -1e32;
960 
961   double resampwidth = 0.0;
962 
963   gsl_matrix *res;
964 
965   long xsize,ysize,i,j,n=0;
966 
967   double xi;
968 
969   if (ap_p==NULL) {
970     /* Create a dummy stamp image */
971     res = gsl_matrix_alloc(10,10);
972     /* Fill stamp with 0.0 values */
973     gsl_matrix_set_all(res, 0.0);
974     return res;
975   }
976 
977   i=0;
978   for (cur_p = ap_p; cur_p->p_x != -1; cur_p++)
979     {
980       if (fabs(cur_p->dist)>width+.5) continue; /* Skip this pixel if it was not 
      actually used */
981       i++;
982 
983       xi = cur_p->lambda;
984 
985       min_xi = MIN (min_xi, xi);
986       max_xi = MAX (max_xi, xi);
987 
988       min_dist = MIN (min_dist, cur_p->dist);
989       max_dist = MAX (max_dist, cur_p->dist);
990 
991       min_dlam = MIN (min_dlam, cur_p->dlambda);
992       max_dlam = MAX (max_dlam, cur_p->dlambda);
993 
994       n++;
995     }
996 
997   if (conf->drz_resol)
998     {
999       resampwidth = (double)conf->drz_resol;
1000     }
1001   else
1002     {
1003       resampwidth = (max_dlam+min_dlam)/2.0;
1004     }
1005 
1006   fprintf(stdout, "resamplewidth: %f\n", resampwidth);
1007 
1008   if (i==0) {
1009     /* Create a dummy stamp image */
1010     res = gsl_matrix_alloc(10,10);
1011     /* Fill stamp with 0.0 values */
1012     gsl_matrix_set_all(res, 0.0);
1013     return res;
1014   }
1015 
1016   min_dist = floor(min_dist);
1017   max_dist = floor(max_dist);
1018   min_xi = floor(min_xi/resampwidth);
1019   max_xi = floor(max_xi/resampwidth);
1020 
1021   xsize = max_xi-min_xi+2;
1022   ysize = max_dist-min_dist+2;
1023 
1024   if (n>0)
1025     {
1026       res = gsl_matrix_alloc(xsize,ysize);
1027     } else {
1028       /* Create a dummy stamp image */
1029       res = gsl_matrix_alloc(10,10);
1030       /* Fill stamp with 0.0 values */
1031       gsl_matrix_set_all(res, 0.0);
1032       return res;
1033     }
1034 
1035   res = gsl_matrix_alloc(xsize,ysize);
1036   /* Fill stamp with NaN values */
1037   gsl_matrix_set_all(res, GSL_NAN);
1038 
1039 
1040   for (cur_p = ap_p; cur_p->p_x != -1; cur_p++)
1041     {
1042       int ii,jj;
1043       double x,y,xp,yp,arr;
1044       double xx[4],yy[4];
1045       int stpi,stpj;
1046       double stpc;
1047 
1048       /* Skip this pixel if it was not actually used */
1049       if (fabs(cur_p->dist)>width+.5)
1050         continue;
1051 
1052 
1053       //cur_p->dxs=0.;
1054       //cur_p->xi = 100.5 + min_xi;
1055       //cur_p->dist = 10. + min_dist;
1056       xi = cur_p->lambda/resampwidth;
1057 
1058       i = (long) floor(xi - min_xi+.5);
1059       j = (long) floor(cur_p->dist - min_dist+.5);
1060 
1061       /* The center of this PET entry should fall in pixel (i.j) */
1062       /* Bottom left corner (-.5, -.5) */
1063       x = -0.5;
1064       y = -0.5;
1065       xp =  x*cos(cur_p->dxs) + y*sin(cur_p->dxs);
1066       yp = -x*sin(cur_p->dxs) + y*cos(cur_p->dxs);
1067       xx[0] = xp+xi - min_xi;
1068       yy[0] = yp+cur_p->dist - min_dist;
1069 
1070       /* Top left corner (-.5, +.5) */
1071       x = -0.5;
1072       y = +0.5;
1073       xp =  x*cos(cur_p->dxs) + y*sin(cur_p->dxs);
1074       yp = -x*sin(cur_p->dxs) + y*cos(cur_p->dxs);
1075       xx[1] = xp+ xi - min_xi;
1076       yy[1] = yp+cur_p->dist - min_dist;
1077 
1078       /* Top right corner (+.5, +.5) */
1079       x = +0.5;
1080       y = +0.5;
1081       xp =  x*cos(cur_p->dxs) + y*sin(cur_p->dxs);
1082       yp = -x*sin(cur_p->dxs) + y*cos(cur_p->dxs);
1083       xx[2] = xp+ xi - min_xi;
1084       yy[2] = yp+cur_p->dist - min_dist;
1085 
1086       /* Bottom right corner (+.5, -.5) */
1087       x = +0.5;
1088       y = -0.5;
1089       xp =  x*cos(cur_p->dxs) + y*sin(cur_p->dxs);
1090       yp = -x*sin(cur_p->dxs) + y*cos(cur_p->dxs);
1091       // fprintf(stderr,"1 %f %f\n",cur_p->xi - min_xi,cur_p->dist - min_dist);
1092       xx[3] = xp+ xi - min_xi;
1093       yy[3] = yp+cur_p->dist - min_dist;
1094 
1095       for (ii=-1;ii<=1;ii++) {
1096         for (jj=-1;jj<=1;jj++) {
1097           //fprintf(stderr,"PET: XI: %f DIST: %f DXS: %f cos:%f\n",cur_p->xi,cur_
      p->dist,cur_p->dxs,cos(cur_p->dxs));
1098           arr = boxer((int) floor(xi - min_xi)+ii,(int) floor(cur_p->dist - min_d
      ist)+jj,xx,yy);
1099 
1100           //fprintf(stderr,"STP: i:%d j:%d arr: %f\n",(int) floor(cur_p->xi - min
      _xi)+ii,(int) floor(cur_p->dist - min_dist)+jj,arr);
1101           stpi = (int) floor(xi - min_xi)+ii;
1102           stpj = (int) floor(cur_p->dist - min_dist)+jj;
1103           if ( (stpi>=xsize)||(stpi<0)||(stpj>=ysize)||(stpj<0) ) continue;
1104           stpc = gsl_matrix_get(res,stpi,stpj);
1105           if (isnan(stpc) && (arr!=0.0)) stpc = 0.0;
1106           gsl_matrix_set(res,stpi,stpj,stpc+arr*cur_p->count);
1107         }
1108       }
1109 
1110 
1111     }
1112 
1113   return res;
1114 }
\end{DoxyCode}
\hypertarget{spce__output_8h_ac02af5218e62e713615c31e68fb3e808}{
\index{spce\_\-output.h@{spce\_\-output.h}!free\_\-drzprep@{free\_\-drzprep}}
\index{free\_\-drzprep@{free\_\-drzprep}!spce_output.h@{spce\_\-output.h}}
\subsubsection[{free\_\-drzprep}]{\setlength{\rightskip}{0pt plus 5cm}void free\_\-drzprep ({\bf drzprep} $\ast$ {\em drzprep\_\-stamps})}}
\label{spce__output_8h_ac02af5218e62e713615c31e68fb3e808}



\begin{DoxyCode}
1181 {
1182   // release the individual matrixes
1183   gsl_matrix_free(drzprep_stamps->counts);
1184   gsl_matrix_free(drzprep_stamps->error);
1185   gsl_matrix_free(drzprep_stamps->cont);
1186   if (drzprep_stamps->model)
1187     gsl_matrix_free(drzprep_stamps->model);
1188   if (drzprep_stamps->vari)
1189     gsl_matrix_free(drzprep_stamps->vari);
1190 
1191   // release the struct
1192   free(drzprep_stamps);
1193 }
\end{DoxyCode}
\hypertarget{spce__output_8h_a699a311158a0c8b9a81792c304e212f4}{
\index{spce\_\-output.h@{spce\_\-output.h}!free\_\-drzstamp@{free\_\-drzstamp}}
\index{free\_\-drzstamp@{free\_\-drzstamp}!spce_output.h@{spce\_\-output.h}}
\subsubsection[{free\_\-drzstamp}]{\setlength{\rightskip}{0pt plus 5cm}void free\_\-drzstamp ({\bf drzstamp} $\ast$ {\em rstamp})}}
\label{spce__output_8h_a699a311158a0c8b9a81792c304e212f4}
Function: free\_\-drzstamp Function to free the memeory allocated by a drizzled stamp image.

Parameters: 
\begin{DoxyParams}{Parameters}
\item[{\em rstamp}]-\/ the structure for the drizzled stamp image \end{DoxyParams}



\begin{DoxyCode}
1218 {
1219   // release each component
1220   gsl_matrix_free(rstamp->counts);
1221   gsl_matrix_free(rstamp->weight);
1222 
1223   // release the rest
1224   free(rstamp);
1225 }
\end{DoxyCode}
\hypertarget{spce__output_8h_a307bc04cf548af0968aecb683338713f}{
\index{spce\_\-output.h@{spce\_\-output.h}!free\_\-stamp\_\-img@{free\_\-stamp\_\-img}}
\index{free\_\-stamp\_\-img@{free\_\-stamp\_\-img}!spce_output.h@{spce\_\-output.h}}
\subsubsection[{free\_\-stamp\_\-img}]{\setlength{\rightskip}{0pt plus 5cm}void free\_\-stamp\_\-img (gsl\_\-matrix $\ast$ {\em rstamp})}}
\label{spce__output_8h_a307bc04cf548af0968aecb683338713f}
Function: free\_\-stamp\_\-img Function to free the memeory allocated by a stamp image

Parameters: 
\begin{DoxyParams}{Parameters}
\item[{\em rstamp}]-\/ the stamp image \end{DoxyParams}



\begin{DoxyCode}
1204 {
1205   // simply free it and "basta"!
1206   gsl_matrix_free(rstamp);
1207 }
\end{DoxyCode}
\hypertarget{spce__output_8h_a26cf5661457b717143b4bfb97c3a440d}{
\index{spce\_\-output.h@{spce\_\-output.h}!get\_\-drzprep\_\-dim@{get\_\-drzprep\_\-dim}}
\index{get\_\-drzprep\_\-dim@{get\_\-drzprep\_\-dim}!spce_output.h@{spce\_\-output.h}}
\subsubsection[{get\_\-drzprep\_\-dim}]{\setlength{\rightskip}{0pt plus 5cm}{\bf drzstamp\_\-dim} get\_\-drzprep\_\-dim (const {\bf ap\_\-pixel} $\ast$const  {\em ap\_\-p}, \/  float {\em width}, \/  int {\em boxwidth}, \/  int {\em boxheight})}}
\label{spce__output_8h_a26cf5661457b717143b4bfb97c3a440d}
Function: get\_\-drzprep\_\-dim The function computes the dimensional properties of the stamp images created in the drizzle prepare task. Those properties fix the image size and the offsets in both coordinates.

Parameter: 
\begin{DoxyParams}{Parameters}
\item[{\em ap\_\-p}]-\/ the list of \hyperlink{structbeam}{beam} pixels to find the diemnsions for \item[{\em width}]-\/ the extraction width of the \hyperlink{structbeam}{beam} \item[{\em boxwidth}]-\/ the boxsize \item[{\em boxheight}]-\/ the boxwidth\end{DoxyParams}
Returns: \begin{DoxyReturn}{Returns}
dimensions -\/ the filled \hyperlink{structquadrangle}{quadrangle} sturcture 
\end{DoxyReturn}



\begin{DoxyCode}
656 {
657 
658   drzstamp_dim dimensions;
659 
660   const ap_pixel *cur_p;
661 
662   double min_px = 1e32;
663   double max_px = -1e32;
664   double min_py = 1e32;
665   double max_py = -1e32;
666 
667   // return a dummy if the PET is NULL
668   if (ap_p==NULL)
669     {
670       dimensions.xstart=0.0;
671       dimensions.ystart=0.0;
672 
673       dimensions.xsize=0;
674       dimensions.ysize=0;
675 
676       return dimensions;
677     }
678 
679   // go over each pixel, find minimum and maximum in x,y
680   for (cur_p = ap_p; cur_p->p_x != -1; cur_p++)
681     {
682       // if (fabs(cur_p->dist)>width+.5) continue; /* Skip this pixel if it was n
      ot actually used */
683       min_px = MIN (min_px, cur_p->p_x);
684       max_px = MAX (max_px, cur_p->p_x);
685       min_py = MIN (min_py, cur_p->p_y);
686       max_py = MAX (max_py, cur_p->p_y);
687     }
688 
689   // compute the dimension of the stamps
690   dimensions.xsize = max_px-min_px+1;
691   dimensions.ysize = max_py-min_py+1;
692 
693   // correct the dimesions if necessary
694   if (boxwidth > dimensions.xsize){
695     dimensions.xsize = (long)boxwidth;
696   }
697   if (boxheight > dimensions.ysize){
698     dimensions.ysize = boxheight;
699   }
700 
701   // fix the start coordinates
702   dimensions.xstart= min_px;
703   dimensions.ystart= min_py;
704 
705   // return the structure
706   return dimensions;
707 }
\end{DoxyCode}
\hypertarget{spce__output_8h_a294f187040188cd530ca348373ae6b9f}{
\index{spce\_\-output.h@{spce\_\-output.h}!get\_\-maxxy\_\-from\_\-PET@{get\_\-maxxy\_\-from\_\-PET}}
\index{get\_\-maxxy\_\-from\_\-PET@{get\_\-maxxy\_\-from\_\-PET}!spce_output.h@{spce\_\-output.h}}
\subsubsection[{get\_\-maxxy\_\-from\_\-PET}]{\setlength{\rightskip}{0pt plus 5cm}{\bf d\_\-point} get\_\-maxxy\_\-from\_\-PET (const {\bf ap\_\-pixel} $\ast$const  {\em ap\_\-p})}}
\label{spce__output_8h_a294f187040188cd530ca348373ae6b9f}



\begin{DoxyCode}
164 {
165   const ap_pixel *cur_p;
166   //double min_px = 1e32;
167   double max_px = -1e32;
168   //double min_py = 1e32;
169   double max_py = -1e32;
170   d_point res;
171 
172   // return -1 in case of an empty PET
173   if (ap_p==NULL) {
174     res.x = -1;
175     res.y = -1;
176     return res;
177   }
178 
179   // go over each pixel, determine the maximum
180   for (cur_p = ap_p; cur_p->p_x != -1; cur_p++)
181     {
182       max_px = MAX (max_px, cur_p->p_x);
183       max_py = MAX (max_py, cur_p->p_y);
184     }
185 
186   // fill the return
187   res.x = max_px;
188   res.y = max_py;
189 
190   // return the result
191   return res;
192 }
\end{DoxyCode}
\hypertarget{spce__output_8h_a727084323c00d05a5549164d2820c77e}{
\index{spce\_\-output.h@{spce\_\-output.h}!get\_\-minxy\_\-from\_\-PET@{get\_\-minxy\_\-from\_\-PET}}
\index{get\_\-minxy\_\-from\_\-PET@{get\_\-minxy\_\-from\_\-PET}!spce_output.h@{spce\_\-output.h}}
\subsubsection[{get\_\-minxy\_\-from\_\-PET}]{\setlength{\rightskip}{0pt plus 5cm}{\bf d\_\-point} get\_\-minxy\_\-from\_\-PET (const {\bf ap\_\-pixel} $\ast$const  {\em ap\_\-p})}}
\label{spce__output_8h_a727084323c00d05a5549164d2820c77e}



\begin{DoxyCode}
120 {
121   const ap_pixel *cur_p;
122   double min_px = 1e32;
123   //double max_px = -1e32;
124   double min_py = 1e32;
125   //double max_py = -1e32;
126   d_point res;
127 
128   // return -1 in case of an empty PET
129   if (ap_p==NULL) {
130     res.x = -1;
131     res.y = -1;
132     return res;
133   }
134 
135   // go over each pixel, determine the maximum
136   for (cur_p = ap_p; cur_p->p_x != -1; cur_p++)
137     {
138       min_px = MIN (min_px, cur_p->p_x);
139       min_py = MIN (min_py, cur_p->p_y);
140     }
141 
142   // fill the return
143   res.x = min_px;
144   res.y = min_py;
145 
146   // return the result
147   return res;
148 }
\end{DoxyCode}
\hypertarget{spce__output_8h_a0b04392e15823b7d3e07a84cc698d56d}{
\index{spce\_\-output.h@{spce\_\-output.h}!get\_\-quad\_\-from\_\-pixel@{get\_\-quad\_\-from\_\-pixel}}
\index{get\_\-quad\_\-from\_\-pixel@{get\_\-quad\_\-from\_\-pixel}!spce_output.h@{spce\_\-output.h}}
\subsubsection[{get\_\-quad\_\-from\_\-pixel}]{\setlength{\rightskip}{0pt plus 5cm}{\bf quadrangle} get\_\-quad\_\-from\_\-pixel (const {\bf ap\_\-pixel} $\ast$ {\em cur\_\-p}, \/  const double {\em orient}, \/  const {\bf drzstamp\_\-dim} {\em dimension})}}
\label{spce__output_8h_a0b04392e15823b7d3e07a84cc698d56d}
Function: get\_\-quad\_\-from\_\-pixel The subroutine creates a \hyperlink{structquadrangle}{quadrangle} for a PET pixel in the coordinate system of a drizzled stam image. The \hyperlink{structquadrangle}{quadrangle} later serves as an input to the boxer routine to resample the PET pixel. Form the math point of view, the generation of the quadrange corresponds to executing an affine transformation of the pixel (x,y) corners into the coordinate system spanned by the wavelength and the crossdispersion direction.

Parameters: 
\begin{DoxyParams}{Parameters}
\item[{\em cur\_\-p}]-\/ the PET pixel to construct the \hyperlink{structquadrangle}{quadrangle} for \item[{\em dimension}]-\/ the dimensions of the stamp image\end{DoxyParams}
Returns: \begin{DoxyReturn}{Returns}
quad -\/ the filled \hyperlink{structquadrangle}{quadrangle} sturcture 
\end{DoxyReturn}



\begin{DoxyCode}
861 {
862   quadrangle quad;
863 
864   double dxi, ddist;
865   double x, y;
866 
867   double phi_1, phi_2;
868   double cos_phi_1, sin_phi_1, tan_phi_2;
869   double term_1, term_2;
870 
871   // nomenclature: see contamination.dvi
872   phi_1 = orient - 1.5707963267948966;  // crossdispersion direction corresponds 
      to beta; numeric=90deg in rad
873   phi_2 = cur_p->dxs - orient + 1.5707963267948966; // traceangle corresponds to 
      alpha
874 
875   // nomenclature: see contamination.dvi
876   cos_phi_1 = cos(phi_1);
877   sin_phi_1 = sin(phi_1);
878   tan_phi_2 = tan(phi_2);
879 
880   // nomenclature: see contamination.dvi
881   term_1 = cos_phi_1*tan_phi_2 + sin_phi_1;
882   term_2 = cos_phi_1           - sin_phi_1*tan_phi_2;
883 
884   // Bottom left corner (-.5, -.5):
885   // get the coos of that corner in the stamp image coo system
886   x = -0.5;
887   y = -0.5;
888   dxi   = +x*cos_phi_1 + y*sin_phi_1;
889   ddist = -x*term_1    + y*term_2;
890   /*** IMPORTANT:
891    * the division by "cos(cur_p->dxs)" in the equations below is
892    * is necessary to cover the whole lambda-crossdisp plane.
893    * However then the counts are not anymore preserved.
894    * This must be taken into account in the calling routine!!
895    **/
896   quad.x[0] = (cur_p->lambda + cur_p->dlambda*dxi/cos(cur_p->dxs))/dimension.
      resolution - dimension.xstart;
897   quad.y[0] = cur_p->dist + ddist - dimension.ystart;
898   //  fprintf(stdout, "%f %f\n", quad.x[0], quad.y[0]);
899 
900   // Top left corner (-.5, +.5):
901   // get the coos of that corner in the stamp image coo system
902   x = -0.5;
903   y = +0.5;
904   dxi   = +x*cos_phi_1 + y*sin_phi_1;
905   ddist = -x*term_1    + y*term_2;
906   //  quad.x[1] = cur_p->xi + dxi/cos(cur_p->dxs);
907   quad.x[1] = (cur_p->lambda + cur_p->dlambda*dxi/cos(cur_p->dxs))/dimension.
      resolution - dimension.xstart;
908   quad.y[1] = cur_p->dist + ddist - dimension.ystart;
909 
910   // Top right corner (+.5, +.5):
911   // get the coos of that corner in the stamp image coo system
912   x = +0.5;
913   y = +0.5;
914   dxi   = +x*cos_phi_1 + y*sin_phi_1;
915   ddist = -x*term_1    + y*term_2;
916   quad.x[2] = (cur_p->lambda + cur_p->dlambda*dxi/cos(cur_p->dxs))/dimension.
      resolution - dimension.xstart;
917   quad.y[2] = cur_p->dist + ddist - dimension.ystart;
918 
919   // Bottom right corner (+.5, -.5):
920   // get the coos of that corner in the stamp image coo system
921   x = +0.5;
922   y = -0.5;
923   dxi   = +x*cos_phi_1 + y*sin_phi_1;
924   ddist = -x*term_1    + y*term_2;
925   quad.x[3] = (cur_p->lambda + cur_p->dlambda*dxi/cos(cur_p->dxs))/dimension.
      resolution - dimension.xstart;
926   quad.y[3] = cur_p->dist + ddist - dimension.ystart;
927 
928   // get the maximum and minimum of the quadrangle
929   // in each dimension
930   quad.xmax = MAX(quad.x[3],MAX(quad.x[2],MAX(quad.x[1],quad.x[0])));
931   quad.xmin = MIN(quad.x[3],MIN(quad.x[2],MIN(quad.x[1],quad.x[0])));
932   quad.ymax = MAX(quad.y[3],MAX(quad.y[2],MAX(quad.y[1],quad.y[0])));
933   quad.ymin = MIN(quad.y[3],MIN(quad.y[2],MIN(quad.y[1],quad.y[0])));
934 
935   return quad;
936 }
\end{DoxyCode}
\hypertarget{spce__output_8h_aece0dc2dd2738020829c96e9413f5494}{
\index{spce\_\-output.h@{spce\_\-output.h}!get\_\-stamp\_\-dim@{get\_\-stamp\_\-dim}}
\index{get\_\-stamp\_\-dim@{get\_\-stamp\_\-dim}!spce_output.h@{spce\_\-output.h}}
\subsubsection[{get\_\-stamp\_\-dim}]{\setlength{\rightskip}{0pt plus 5cm}{\bf drzstamp\_\-dim} get\_\-stamp\_\-dim (const {\bf ap\_\-pixel} $\ast$const  {\em ap\_\-p}, \/  float {\em width}, \/  {\bf aperture\_\-conf} $\ast$ {\em conf}, \/  const int {\em beamID}, \/  {\bf d\_\-point} $\ast$ {\em stp\_\-min})}}
\label{spce__output_8h_aece0dc2dd2738020829c96e9413f5494}
Function: get\_\-stamp\_\-dim The function computes the dimensional properties of the drizzled stamp image associated to a \hyperlink{structbeam}{beam}. Those properties fix the image size, dispersion and the offsets in both coordinates

Parameters: 
\begin{DoxyParams}{Parameters}
\item[{\em ap\_\-p}]-\/ the list of \hyperlink{structbeam}{beam} pixels to find the diemnsions for \item[{\em width}]-\/ the extraction width of the \hyperlink{structbeam}{beam} \item[{\em conf}]-\/ the configuration structure \item[{\em beamID}]-\/ the the \hyperlink{structbeam}{beam} ID\end{DoxyParams}
Returns: \begin{DoxyReturn}{Returns}
dimensions -\/ the filled \hyperlink{structquadrangle}{quadrangle} sturcture 
\end{DoxyReturn}



\begin{DoxyCode}
728 {
729   drzstamp_dim dimensions;
730 
731   const ap_pixel *cur_p;
732 
733   double min_lam  = 1e32;
734   double max_lam  = -1e32;
735   double min_xi   = 1e32;
736   double max_xi   = -1e32;
737   double min_dist = 1e32;
738   double max_dist = -1e32;
739   double min_dlam = 1e32;
740   double max_dlam = -1e32;
741 
742   //double resampwidth = 0.0;
743 
744   //long xsize,ysize,j;
745   long npixel=0;
746 
747   // check whether there are entries;
748   // if not, return a dummy structure
749   if (ap_p==NULL)
750     {
751       dimensions.resolution=0.0;
752 
753       dimensions.xstart=0.0;
754       dimensions.ystart=0.0;
755 
756       dimensions.xsize=0;
757       dimensions.ysize=0;
758 
759       return dimensions;
760     }
761 
762 
763   // reset the pixel counter
764   npixel=0;
765 
766   // go over each pixel
767   for (cur_p = ap_p; cur_p->p_x != -1; cur_p++)
768     {
769 
770       // Skip the pixel if it was not actually used
771       if (fabs(cur_p->dist)>width+.5)
772         continue;
773 
774       // search for minimum/maximum in wavelength
775       min_lam = MIN (min_lam, cur_p->lambda);
776       max_lam = MAX (max_lam, cur_p->lambda);
777 
778       // search for minimum/maximum in crossdispersion direction
779       min_dist = MIN (min_dist, cur_p->dist);
780       max_dist = MAX (max_dist, cur_p->dist);
781 
782       // search for minimum/maximum in dispersion
783       min_dlam = MIN (min_dlam, cur_p->dlambda);
784       max_dlam = MAX (max_dlam, cur_p->dlambda);
785 
786       // enhance the pixel counter
787       npixel++;
788     }
789 
790   // in case there were no valid pixels,
791   // return a dummy structure
792   if (!npixel)
793     {
794       dimensions.resolution=0.0;
795 
796       dimensions.xstart=0.0;
797       dimensions.ystart=0.0;
798 
799       dimensions.xsize=0;
800       dimensions.ysize=0;
801 
802       return dimensions;
803     }
804 
805   // fill the resolution value
806   // if the drizzle resolution is defined in the
807   // configuration file and it is a first order beam
808   if (conf->drz_resol && !beamID)
809     // take the drizzle value from the config file
810     dimensions.resolution = (double)conf->drz_resol;
811   // otherwise
812   else
813     // take the average resoution
814     dimensions.resolution = (max_dlam+min_dlam)/2.0;
815 
816   // round up and off in crossdispersion direction
817   min_dist = floor(min_dist);
818   max_dist = ceil(max_dist);
819 
820   // round up and off in dispersion direction
821   min_xi = floor(min_lam/dimensions.resolution);
822   max_xi = ceil(max_lam/dimensions.resolution);
823 
824   // derive and store the stamp image dimensions
825   dimensions.xsize = max_xi-min_xi+2;
826   dimensions.ysize = max_dist-min_dist+2;
827 
828   // store the start values
829   dimensions.xstart = min_xi;
830   dimensions.ystart = min_dist;
831 
832   stp_min->x = min_xi * dimensions.resolution;
833   stp_min->y = min_dist;
834 
835   // return the structure
836   return dimensions;
837 }
\end{DoxyCode}
\hypertarget{spce__output_8h_a487a01f9e88471517124284a4047bd44}{
\index{spce\_\-output.h@{spce\_\-output.h}!get\_\-trace\_\-inds@{get\_\-trace\_\-inds}}
\index{get\_\-trace\_\-inds@{get\_\-trace\_\-inds}!spce_output.h@{spce\_\-output.h}}
\subsubsection[{get\_\-trace\_\-inds}]{\setlength{\rightskip}{0pt plus 5cm}gsl\_\-vector\_\-int$\ast$ get\_\-trace\_\-inds (const {\bf ap\_\-pixel} $\ast$const  {\em ap\_\-p})}}
\label{spce__output_8h_a487a01f9e88471517124284a4047bd44}
Find the indices of pixels corresponding to the trace (i.e. the one with the smallest dist in each column). If we get traces with a slope of significantly more than one, a similar function would have to be written operating on rows.


\begin{DoxyParams}{Parameters}
\item[{\em ap\_\-p}]the aperture pixel table \end{DoxyParams}
\begin{DoxyReturn}{Returns}
a gsl\_\-matrix with the indices of the trace pixels in ap\_\-p 
\end{DoxyReturn}



\begin{DoxyCode}
1238 {
1239   const ap_pixel *cur_p;
1240   int trace_resolution = 10000; /* Number of xi bins in which to follow the
1241                                    trace */
1242   gsl_vector_int *trace_inds = gsl_vector_int_alloc (trace_resolution);
1243   gsl_vector_int *trace_inds2;
1244   int n, i;
1245   double distmin;
1246 
1247   gsl_vector_int_set_all (trace_inds, -1);
1248 
1249   /* Find the minimum pixel-to-trace distance in this aperture */
1250   distmin = 1e32;
1251   for (cur_p = ap_p; cur_p->p_x != -1; cur_p++)
1252     {
1253       distmin = MIN (distmin, fabs(cur_p->dist));
1254     }
1255 
1256   n = 0;
1257   for (cur_p = ap_p; cur_p->p_x != -1; cur_p++)
1258     {
1259       if (fabs(cur_p->dist) < (distmin + .25))
1260         {
1261           gsl_vector_int_set (trace_inds, n, cur_p - ap_p);
1262           n++;
1263         }
1264     }
1265   trace_inds2 = gsl_vector_int_alloc (n);
1266   n = 0;
1267   for (i = 0; i < trace_inds->size; i++)
1268     {
1269       if (gsl_vector_int_get (trace_inds, i) != -1)
1270         {
1271           gsl_vector_int_set (trace_inds2, n,
1272                               gsl_vector_int_get (trace_inds, i));
1273           n++;
1274         }
1275     }
1276 
1277   return trace_inds2;
1278 }
\end{DoxyCode}
\hypertarget{spce__output_8h_a863b4bf317f0bd06437963cd958db9ba}{
\index{spce\_\-output.h@{spce\_\-output.h}!interpolate\_\-over\_\-NaN@{interpolate\_\-over\_\-NaN}}
\index{interpolate\_\-over\_\-NaN@{interpolate\_\-over\_\-NaN}!spce_output.h@{spce\_\-output.h}}
\subsubsection[{interpolate\_\-over\_\-NaN}]{\setlength{\rightskip}{0pt plus 5cm}void interpolate\_\-over\_\-NaN (gsl\_\-matrix $\ast$ {\em data})}}
\label{spce__output_8h_a863b4bf317f0bd06437963cd958db9ba}
Function: interpolate\_\-over\_\-NaN Function to interpolate over and replace NaN values in a rectified stamp image. This is done by interpolating in the vertical direction. The original gsl\_\-matrix is free'd and is replaced by a new gsl\_\-matrix pointer. Does nothing if input data is NULL.

Parameters: 
\begin{DoxyParams}{Parameters}
\item[{\em data}]-\/ the gsl\_\-matrix where NaN values are to be interpolated over \end{DoxyParams}



\begin{DoxyCode}
1128 {
1129   double *x,*y;
1130   int i,j,n;
1131   gsl_interp_accel *acc;
1132   gsl_spline *spline ;
1133 
1134   if (data==NULL) return;
1135 
1136   x = malloc(sizeof(double)*data->size2*data->size1);
1137   y = malloc(sizeof(double)*data->size2*data->size1);
1138 
1139   for (i=0;i<data->size1;i++) {
1140     n = 0;
1141     for (j=0;j<data->size2;j++) {
1142       if ( !isnan(gsl_matrix_get(data,i,j)) )  {
1143         x[n] = j;
1144         y[n] = gsl_matrix_get(data,i,j);
1145         n++;
1146       }
1147     }
1148     //if (n<data->size2) fprintf(stderr,"%d elements non-NaN found out of %d.\n",
      n,data->size2);
1149     if (n<3) continue;
1150 
1151     acc = gsl_interp_accel_alloc ();
1152     spline = gsl_spline_alloc (gsl_interp_cspline, n);
1153 
1154     /* Interpolating */
1155     gsl_spline_init (spline, x, y, n);
1156 
1157     for (j=0;j<data->size2;j++) {
1158       double xi = j;
1159       double yi = gsl_spline_eval(spline,xi,acc);
1160       //if (n<data->size2)  fprintf(stderr,"%d %g => %d %g\n",j,gsl_matrix_get(da
      ta,i,j),j,yi);
1161       gsl_matrix_set(data,i,j,yi);
1162     }
1163     gsl_spline_free (spline);
1164     gsl_interp_accel_free(acc);
1165   }
1166 
1167   free(x);
1168   free(y);
1169 }
\end{DoxyCode}
\hypertarget{spce__output_8h_acfb8de045d5147f405aac44a201d51a1}{
\index{spce\_\-output.h@{spce\_\-output.h}!rectified\_\-stamp\_\-img@{rectified\_\-stamp\_\-img}}
\index{rectified\_\-stamp\_\-img@{rectified\_\-stamp\_\-img}!spce_output.h@{spce\_\-output.h}}
\subsubsection[{rectified\_\-stamp\_\-img}]{\setlength{\rightskip}{0pt plus 5cm}gsl\_\-matrix$\ast$ rectified\_\-stamp\_\-img (const {\bf ap\_\-pixel} $\ast$const  {\em ap\_\-p}, \/  float {\em width}, \/  {\bf d\_\-point} $\ast$ {\em stp\_\-min})}}
\label{spce__output_8h_acfb8de045d5147f405aac44a201d51a1}
Function: rectified\_\-stamp\_\-img Produce a gsl array containing a 'rectified aperture'. That is, an image of the spectum showing count on an xi,dist grid instead of the traditional image grid x,y. Returns NULL is input \hyperlink{structobject}{object} is NULL.

Parameters: 
\begin{DoxyParams}{Parameters}
\item[{\em ap\_\-p}]-\/ a pointer to a -\/1 terminated \hyperlink{structap__pixel}{ap\_\-pixel} array \item[{\em width}]-\/ extraction width used\end{DoxyParams}
Returns: \begin{DoxyReturn}{Returns}
res -\/ a pointer to a newly allocated gsl\_\-matrix containing the rectified \hyperlink{structspectrum}{spectrum} 
\end{DoxyReturn}



\begin{DoxyCode}
395 {
396   const ap_pixel *cur_p;
397   double min_xi = 1e32;
398   double max_xi = -1e32;
399   double min_dist = 1e32;
400   double max_dist = -1e32;
401   gsl_matrix *res;
402   long xsize,ysize,i,j,n=0;
403 
404   if (ap_p==NULL) {
405     /* Create a dummy stamp image */
406     res = gsl_matrix_alloc(10,10);
407     /* Fill stamp with 0.0 values */
408     gsl_matrix_set_all(res, 0.0);
409     return res;
410   }
411 
412   i=0;
413   for (cur_p = ap_p; cur_p->p_x != -1; cur_p++)
414     {
415       if (fabs(cur_p->dist)>width+.5) continue; /* Skip this pixel if it was not 
      actually used */
416       i++;
417       min_xi = MIN (min_xi, cur_p->xi);
418       max_xi = MAX (max_xi, cur_p->xi);
419       min_dist = MIN (min_dist, cur_p->dist);
420       max_dist = MAX (max_dist, cur_p->dist);
421       n++;
422     }
423 
424   if (i==0) {
425     /* Create a dummy stamp image */
426     res = gsl_matrix_alloc(10,10);
427     /* Fill stamp with 0.0 values */
428     gsl_matrix_set_all(res, 0.0);
429     return res;
430   }
431 
432   min_dist = floor(min_dist);
433   max_dist = floor(max_dist);
434   min_xi = floor(min_xi);
435   max_xi = floor(max_xi);
436 
437   // compute the array dimensions
438   xsize = max_xi-min_xi+2;
439   ysize = max_dist-min_dist+2;
440 
441   // store the minima in both coords
442   stp_min->x = min_xi;
443   stp_min->y = min_dist;
444 
445   if (n>0)
446     {
447       res = gsl_matrix_alloc(xsize,ysize);
448     } else {
449       /* Create a dummy stamp image */
450       res = gsl_matrix_alloc(10,10);
451       /* Fill stamp with 0.0 values */
452       gsl_matrix_set_all(res, 0.0);
453       return res;
454     }
455 
456   res = gsl_matrix_alloc(xsize,ysize);
457   /* Fill stamp with NaN values */
458   gsl_matrix_set_all(res, GSL_NAN);
459 
460 
461   for (cur_p = ap_p; cur_p->p_x != -1; cur_p++)
462     {
463       if (fabs(cur_p->dist)>width+.5) continue; /* Skip this pixel if it was not 
      actually used */
464       i = (long) floor(cur_p->xi - min_xi+.5);
465       j = (long) floor(cur_p->dist - min_dist+.5);
466       //fprintf(stderr,"i: %d j: %d\n",i,j);
467       gsl_matrix_set(res,i,j,cur_p->count);
468     }
469 
470   return res;
471 }
\end{DoxyCode}
\hypertarget{spce__output_8h_adecd7e61360bb4de56f06143b2f070ac}{
\index{spce\_\-output.h@{spce\_\-output.h}!stamp\_\-img@{stamp\_\-img}}
\index{stamp\_\-img@{stamp\_\-img}!spce_output.h@{spce\_\-output.h}}
\subsubsection[{stamp\_\-img}]{\setlength{\rightskip}{0pt plus 5cm}gsl\_\-matrix$\ast$ stamp\_\-img (const {\bf ap\_\-pixel} $\ast$const  {\em ap\_\-p}, \/  float {\em width}, \/  {\bf d\_\-point} $\ast$ {\em stp\_\-min})}}
\label{spce__output_8h_adecd7e61360bb4de56f06143b2f070ac}
Function: stamp\_\-img Produce a gsl array containing a stamp image. Returns NULL is input \hyperlink{structobject}{object} is NULL.

Parameters: 
\begin{DoxyParams}{Parameters}
\item[{\em ap\_\-p}]-\/ a pointer to a -\/1 terminated \hyperlink{structap__pixel}{ap\_\-pixel} array \item[{\em width}]-\/ extraction width used \item[{\em stp\_\-min}]-\/ xy-\/coords of the lower left corner on image\end{DoxyParams}
Returns: \begin{DoxyReturn}{Returns}
res -\/ a pointer to a newly allocated gsl\_\-matrix containing the \hyperlink{structspectrum}{spectrum} 
\end{DoxyReturn}



\begin{DoxyCode}
45 {
46   const ap_pixel *cur_p;
47   double min_px = 1e32;
48   double max_px = -1e32;
49   double min_py = 1e32;
50   double max_py = -1e32;
51   gsl_matrix *res;
52   long xsize,ysize,i,j,n=0;
53 
54   if (ap_p==NULL) {
55     /* Create a dummy stamp image */
56     res = gsl_matrix_alloc(10,10);
57     /* Fill stamp with 0.0 values */
58     gsl_matrix_set_all(res, 0.0);
59 
60     return res;
61   }
62 
63   for (cur_p = ap_p; cur_p->p_x != -1; cur_p++)
64     {
65       if (fabs(cur_p->dist)>width+.5) continue; /* Skip this pixel if it was not 
      actually used */
66       min_px = MIN (min_px, cur_p->p_x);
67       max_px = MAX (max_px, cur_p->p_x);
68       min_py = MIN (min_py, cur_p->p_y);
69       max_py = MAX (max_py, cur_p->p_y);
70       n++;
71     }
72 
73   xsize = max_px-min_px+2;
74   ysize = max_py-min_py+2;
75 
76   stp_min->x = min_px;
77   stp_min->y = min_py;
78 
79   if (n>0)
80     {
81       res = gsl_matrix_alloc(xsize,ysize);
82     } else {
83       /* Create a dummy stamp image */
84       res = gsl_matrix_alloc(10,10);
85       /* Fill stamp with 0.0 values */
86       gsl_matrix_set_all(res, 0.0);
87       return res;
88     }
89 
90   /* Fill stamp with NaN values */
91   gsl_matrix_set_all(res, 0.0);
92   for (cur_p = ap_p; cur_p->p_x != -1; cur_p++)
93     {
94       if (fabs(cur_p->dist)>width+.5) continue; /* Skip this pixel if it was not 
      actually used */
95       i = (long) floor(cur_p->p_x - min_px+.5);
96       j = (long) floor(cur_p->p_y - min_py+.5);
97       if ((i<0) || (i>=xsize)) continue;
98       if ((j<0) || (j>=ysize)) continue;
99 
100       //fprintf(stderr,"i: %d j: %d\n",i,j);
101       gsl_matrix_set(res,i,j,cur_p->count);
102     }
103 
104   return res;
105 }
\end{DoxyCode}
\hypertarget{spce__output_8h_ae73fef882d3f2e909f83b4d9784eaba8}{
\index{spce\_\-output.h@{spce\_\-output.h}!stamp\_\-img\_\-drzprep@{stamp\_\-img\_\-drzprep}}
\index{stamp\_\-img\_\-drzprep@{stamp\_\-img\_\-drzprep}!spce_output.h@{spce\_\-output.h}}
\subsubsection[{stamp\_\-img\_\-drzprep}]{\setlength{\rightskip}{0pt plus 5cm}{\bf drzprep}$\ast$ stamp\_\-img\_\-drzprep (const int {\em opt\_\-extr}, \/  const {\bf ap\_\-pixel} $\ast$const  {\em ap\_\-p}, \/  const {\bf ap\_\-pixel} $\ast$const  {\em se\_\-p}, \/  float {\em width}, \/  float {\em nullval}, \/  int {\em quant\_\-cont}, \/  {\bf drzstamp\_\-dim} {\em dimension}, \/  gsl\_\-matrix $\ast$ {\em drzcoeffs}, \/  double {\em exptime}, \/  double {\em sky\_\-cps}, \/  double {\em rdnoise}, \/  const int {\em bckmode})}}
\label{spce__output_8h_ae73fef882d3f2e909f83b4d9784eaba8}
Function: stamp\_\-img\_\-drzprep Creates all drizzle prepare stamp images from a PET vector. In case of an empty PET, dummy stamps are returned.

Parameters: 
\begin{DoxyParams}{Parameters}
\item[{\em opt\_\-extr}]-\/ flagg to indicate optimal extraction \item[{\em ap\_\-p}]-\/ a pointer to a -\/1 terminated \hyperlink{structap__pixel}{ap\_\-pixel} array \item[{\em width}]-\/ extraction width used \item[{\em nullval}]-\/ the default pixel value \item[{\em quant\_\-cont}]-\/ flag to indicate quantitative cont. \item[{\em dimension}]-\/ size information \item[{\em drzcoeffs}]-\/ the drizzle coefficients \item[{\em exptime}]-\/ the exposure time \item[{\em sky\_\-cps}]-\/ the sky background\end{DoxyParams}
Returns: \begin{DoxyReturn}{Returns}
drzprep\_\-stamps -\/ a pointer to the new struct with the \hyperlink{structdrzprep}{drzprep} stamp images 
\end{DoxyReturn}



\begin{DoxyCode}
219 {
220   drzprep *drzprep_stamps;
221   const ap_pixel *cur_p;
222   const ap_pixel *xxx_p;
223 
224   int i, j;
225 
226   double var;
227   double corr;
228   double sqr_expt;
229   double sqr_rdns;
230 
231   // allocate space for the output structure
232   drzprep_stamps = (drzprep *)malloc(sizeof(drzprep));
233 
234   if (ap_p==NULL) {
235 
236     // create a dummy count image and set it to default
237     drzprep_stamps->counts = gsl_matrix_alloc(10,10);
238     gsl_matrix_set_all(drzprep_stamps->counts, nullval);
239 
240     // create a dummy error image and set it to default
241     drzprep_stamps->error = gsl_matrix_alloc(10,10);
242     gsl_matrix_set_all(drzprep_stamps->error, nullval);
243 
244     // create a dummy contamination image and set it to default
245     drzprep_stamps->cont = gsl_matrix_alloc(10,10);
246     gsl_matrix_set_all(drzprep_stamps->cont, nullval);
247 
248     // create a dummy model image and set it to default
249     drzprep_stamps->model = gsl_matrix_alloc(10,10);
250     gsl_matrix_set_all(drzprep_stamps->model, nullval);
251 
252     // create a dummy model image and set it to default
253     drzprep_stamps->vari = gsl_matrix_alloc(10,10);
254     gsl_matrix_set_all(drzprep_stamps->vari, nullval);
255 
256     return drzprep_stamps;
257   }
258 
259   // allocate the count matrix and fill it with default value
260   drzprep_stamps->counts  = gsl_matrix_alloc(dimension.xsize, dimension.ysize);
261   gsl_matrix_set_all(drzprep_stamps->counts, nullval);
262 
263   // allocate the error matrix and fill it with default value
264   drzprep_stamps->error  = gsl_matrix_alloc(dimension.xsize, dimension.ysize);
265   gsl_matrix_set_all(drzprep_stamps->error, 0.0);
266 
267   // allocate the contamination matrix and fill it with default value
268   drzprep_stamps->cont  = gsl_matrix_alloc(dimension.xsize, dimension.ysize);
269   gsl_matrix_set_all(drzprep_stamps->cont, 0.0);
270 
271   // set the two extentions
272   // which are only somethimes
273   // used to NULL
274   drzprep_stamps->model  = NULL;
275   drzprep_stamps->vari  = NULL;
276 
277   if (opt_extr)
278     {
279       // allocate the mode; matrix and fill it with default value
280       drzprep_stamps->model  = gsl_matrix_alloc(dimension.xsize, dimension.ysize)
      ;
281       gsl_matrix_set_all(drzprep_stamps->model, 0.0);
282 
283       // allocate the mode; matrix and fill it with default value
284       drzprep_stamps->vari  = gsl_matrix_alloc(dimension.xsize, dimension.ysize);
      
285       gsl_matrix_set_all(drzprep_stamps->vari, 0.0);
286     }
287 
288   // square the exposure time for speed
289   sqr_expt = exptime*exptime;
290   sqr_rdns = rdnoise*rdnoise;
291 
292   // go over each PET pixel
293   if (opt_extr && bckmode)
294     xxx_p = se_p;
295   for (cur_p = ap_p; cur_p->p_x != -1; cur_p++)
296     {
297 
298       // compute the coordinates in the stamp images
299       // if (fabs(cur_p->dist)>width+.5) continue; /* Skip this pixel if it was n
      ot actually used */
300       i = (int)(cur_p->p_x - dimension.xstart);
301       j = (int)(cur_p->p_y - dimension.ystart);
302 
303 
304       // check whether the coordinates are inside
305       if ((i<0) || (i>=dimension.xsize) || (j<0) || (j>=dimension.ysize))
306         {
307           if (opt_extr && bckmode)
308             xxx_p++;
309         continue;
310         }
311 
312       // comute the jacobian of the drizzle coefficients
313       corr = fabs(get_det_jacobian(i+1, j+1, drzcoeffs, (int)dimension.xsize,(int
      )dimension.ysize));
314 
315       //      fprintf(stdout, "corr: %f\n", corr);
316       // compute the count value
317       gsl_matrix_set(drzprep_stamps->counts,i,j,(cur_p->count)/corr);
318 
319       // aXe-1.4
320       // compute the true error value in electrons
321       gsl_matrix_set(drzprep_stamps->error,i,j,(cur_p->error*cur_p->error*sqr_exp
      t)/corr);
322 
323 
324       // inverse variance weighting:
325       // compute the error value
326       //gsl_matrix_set(drzprep_stamps->error,i,j,(1.0/(cur_p->error*cur_p->error)
      ));
327 
328       // compute the contamination value
329       if (quant_cont)
330         gsl_matrix_set(drzprep_stamps->cont,i,j,(cur_p->contam)/corr);
331       else
332         gsl_matrix_set(drzprep_stamps->cont,i,j,(cur_p->contam));
333 
334       if (opt_extr)
335         {
336 
337           if (bckmode)
338             {
339               // check that the foreground and background
340               // PET element describe the same pixel
341               if (xxx_p->x != cur_p->x || xxx_p->y != cur_p->y)
342                 aXe_message (aXe_M_FATAL, __FILE__, __LINE__,
343                              "aXe_DRZPREP: Background PET and Object PET "
344                              "have different pixel orders in PET's.\n");
345 
346               // compute the inverse variance value for the object PET
347               // derived from the noise characteristics
348               var = ((xxx_p->model+xxx_p->contam+sky_cps+cur_p->count)*exptime + 
      sqr_rdns)/sqr_expt;
349               //              var = cur_p->count*exptime / sqr_expt;
350 
351               // compute the model value
352               gsl_matrix_set(drzprep_stamps->model,i,j,(xxx_p->model/corr));
353             }
354           else
355             {
356               // compute the inverse variance value for the object PET
357               // derived from the noise characteristics
358               var = ((cur_p->model+cur_p->contam+sky_cps)*exptime + sqr_rdns)/sqr
      _expt;
359 
360               // compute the model value
361               gsl_matrix_set(drzprep_stamps->model,i,j,(cur_p->model/corr));
362             }
363 
364           if (var != 0.0)
365             gsl_matrix_set(drzprep_stamps->vari,i,j,1.0/var);
366 
367 
368         }
369 
370       if (opt_extr && bckmode)
371         xxx_p++;
372     }
373 
374   // return the result structure
375   return drzprep_stamps;
376 }
\end{DoxyCode}
