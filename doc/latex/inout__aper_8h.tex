\hypertarget{inout__aper_8h}{
\section{/renoir/fourmano/Desktop/OUSIM/TIPS/branches/tips\_\-build/include/axesim/inout\_\-aper.h File Reference}
\label{inout__aper_8h}\index{/renoir/fourmano/Desktop/OUSIM/TIPS/branches/tips\_\-build/include/axesim/inout\_\-aper.h@{/renoir/fourmano/Desktop/OUSIM/TIPS/branches/tips\_\-build/include/axesim/inout\_\-aper.h}}
}
{\ttfamily \#include $<$stdio.h$>$}\par
{\ttfamily \#include $<$stdlib.h$>$}\par
{\ttfamily \#include $<$string.h$>$}\par
{\ttfamily \#include $<$ctype.h$>$}\par
{\ttfamily \#include $<$math.h$>$}\par
{\ttfamily \#include $<$gsl/gsl\_\-vector.h$>$}\par
{\ttfamily \#include \char`\"{}aXe\_\-grism.h\char`\"{}}\par
{\ttfamily \#include \char`\"{}aXe\_\-utils.h\char`\"{}}\par
{\ttfamily \#include \char`\"{}aXe\_\-errors.h\char`\"{}}\par
{\ttfamily \#include \char`\"{}spc\_\-cfg.h\char`\"{}}\par
{\ttfamily \#include \char`\"{}spc\_\-trace\_\-functions.h\char`\"{}}\par
\subsection*{Namespaces}
\begin{DoxyCompactItemize}
\item 
namespace \hyperlink{namespaceinout__aper}{inout\_\-aper}
\end{DoxyCompactItemize}
\subsection*{Defines}
\begin{DoxyCompactItemize}
\item 
\#define \hyperlink{inout__aper_8h_a70f7918155ed928e50a64ba4ce7af81a}{APER\_\-MAXLINE}~14
\end{DoxyCompactItemize}
\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
int \hyperlink{inout__aper_8h_ad6c178c268863d6fa3f2bbe3b3d8f8af}{nbeams\_\-from\_\-char\_\-array2} (char $\ast$$\ast$apers, int num)
\item 
gsl\_\-vector\_\-int $\ast$ \hyperlink{inout__aper_8h_a5bfbf8150f27a4b1df4ab1d10d5bca7d}{nbeams\_\-from\_\-char\_\-array} (char $\ast$$\ast$apers, int num)
\item 
int \hyperlink{inout__aper_8h_a881264311a05c31fe2ce9343bfb7f2d5}{object\_\-list\_\-to\_\-file} (\hyperlink{structobject}{object} $\ast$const $\ast$oblist, char $\ast$filename, int leaveout\_\-ignored)
\item 
int \hyperlink{inout__aper_8h_adbb32d5fc9947145e815e0fd33a1cd34}{get\_\-beam\_\-from\_\-aper\_\-file} (char $\ast$filename, int aperID, int beamID, \hyperlink{structbeam}{beam} $\ast$b)
\item 
gsl\_\-vector\_\-int $\ast$ \hyperlink{inout__aper_8h_a5ae38f66e6732c36d3aaef11f37842a2}{aper\_\-file\_\-aperlist} (char $\ast$filename)
\item 
int \hyperlink{inout__aper_8h_a493b0450d9124855228d1d2e6e66d2f5}{aper\_\-file\_\-apernum} (char $\ast$filename)
\item 
\hyperlink{structobject}{object} $\ast$ \hyperlink{inout__aper_8h_ab3d3154507c93e7d0222531d0734c63a}{get\_\-aperture\_\-from\_\-aper\_\-file} (char $\ast$filename, int aperID)
\item 
\hyperlink{structobject}{object} $\ast$$\ast$ \hyperlink{inout__aper_8h_a9b711702cce1bd598ac506bd8f75af38}{file\_\-to\_\-object\_\-list} (char filename\mbox{[}$\,$\mbox{]}, \hyperlink{structobservation}{observation} $\ast$obs)
\item 
char $\ast$$\ast$ \hyperlink{inout__aper_8h_a5610d36eaa966760f40180225de8faeb}{return\_\-next\_\-aperture} (FILE $\ast$input)
\item 
\hyperlink{structobject}{object} $\ast$$\ast$ \hyperlink{inout__aper_8h_ae18fecd8e762c35bae1376a8d637d8e8}{file\_\-to\_\-object\_\-list\_\-seq} (char filename\mbox{[}$\,$\mbox{]}, \hyperlink{structobservation}{observation} $\ast$obs)
\item 
int \hyperlink{inout__aper_8h_a12854533fd67781a0bf70a93a6ad91e4}{find\_\-object\_\-in\_\-object\_\-list} (\hyperlink{structobject}{object} $\ast$$\ast$oblist, const int ID)
\item 
\hyperlink{structbeam}{beam} \hyperlink{inout__aper_8h_a515c7167b798f972e4614a5404595e25}{find\_\-beam\_\-in\_\-object\_\-list} (\hyperlink{structobject}{object} $\ast$$\ast$oblist, const int objID, const int beamID)
\item 
\hyperlink{structbeam}{beam} $\ast$ \hyperlink{inout__aper_8h_a435c8a237804e5f641b7401dfa81a059}{find\_\-beamptr\_\-in\_\-object\_\-list} (\hyperlink{structobject}{object} $\ast$$\ast$oblist, const int objID, const int beamID)
\item 
void \hyperlink{inout__aper_8h_a76950235f36088ca98cd60aa2e431086}{refurbish\_\-object\_\-list} (\hyperlink{structobject}{object} $\ast$$\ast$oblist, const int new\_\-default, const int old\_\-value, const int new\_\-value)
\item 
int \hyperlink{inout__aper_8h_aa4bd812673400180537c7ea98650d3fe}{object\_\-list\_\-size} (\hyperlink{structobject}{object} $\ast$$\ast$oblist)
\item 
int \hyperlink{inout__aper_8h_aa120fb983e10b94e79858e51b4d3e25e}{get\_\-beamspec\_\-size} (\hyperlink{structobject}{object} $\ast$$\ast$oblist)
\end{DoxyCompactItemize}


\subsection{Define Documentation}
\hypertarget{inout__aper_8h_a70f7918155ed928e50a64ba4ce7af81a}{
\index{inout\_\-aper.h@{inout\_\-aper.h}!APER\_\-MAXLINE@{APER\_\-MAXLINE}}
\index{APER\_\-MAXLINE@{APER\_\-MAXLINE}!inout_aper.h@{inout\_\-aper.h}}
\subsubsection[{APER\_\-MAXLINE}]{\setlength{\rightskip}{0pt plus 5cm}\#define APER\_\-MAXLINE~14}}
\label{inout__aper_8h_a70f7918155ed928e50a64ba4ce7af81a}


\subsection{Function Documentation}
\hypertarget{inout__aper_8h_a5ae38f66e6732c36d3aaef11f37842a2}{
\index{inout\_\-aper.h@{inout\_\-aper.h}!aper\_\-file\_\-aperlist@{aper\_\-file\_\-aperlist}}
\index{aper\_\-file\_\-aperlist@{aper\_\-file\_\-aperlist}!inout_aper.h@{inout\_\-aper.h}}
\subsubsection[{aper\_\-file\_\-aperlist}]{\setlength{\rightskip}{0pt plus 5cm}gsl\_\-vector\_\-int$\ast$ aper\_\-file\_\-aperlist (char $\ast$ {\em filename})}}
\label{inout__aper_8h_a5ae38f66e6732c36d3aaef11f37842a2}
Function: aper\_\-file\_\-aperlist This function returns a gsl\_\-vector containing the list of apertures found in the given aperture file.

Parameters: 
\begin{DoxyParams}{Parameters}
\item[{\em filename}]-\/ the name of the aperture file\end{DoxyParams}
Returns: \begin{DoxyReturn}{Returns}
apers -\/ a gsl\_\-vector\_\-int $\ast$ containing the list of aperture IDs 
\end{DoxyReturn}



\begin{DoxyCode}
301   {
302     int n = 0;
303     char Buffer[BUFFERSIZE] = "\0";
304     char *WorkPtr= NULL;
305     char *CfgName= NULL;
306     char *CfgData= NULL;
307     FILE *CfgFile= NULL;
308     int napers;
309     gsl_vector_int *apers;
310 
311     napers = aper_file_apernum(filename);
312     if (!(napers>0))
313       return NULL;
314 
315     apers = gsl_vector_int_alloc(napers);
316 
317     CfgFile = fopen(filename, "r");
318     if (NULL == CfgFile)
319       {
320         aXe_message(aXe_M_FATAL, __FILE__, __LINE__,
321         "Could not open aperture file %s\n", filename);
322       }
323 
324     while (NULL != fgets (Buffer, BUFFERSIZE, CfgFile))
325       {
326         /* clip off optional comment tail indicated by a semi-colon
327          */
328         if (NULL != (WorkPtr = strchr (Buffer, ';')))
329           *WorkPtr = '\0';
330         else
331           WorkPtr = Buffer + strlen(Buffer);
332 
333         /* clip off trailing and leading white space
334          */
335         WorkPtr--;
336         while (isspace ((int) *WorkPtr) && WorkPtr >= Buffer)
337           *WorkPtr-- = '\0';
338         WorkPtr = Buffer;
339         while (isspace ((int) *WorkPtr))
340           WorkPtr++;
341         if (0 == strlen(WorkPtr))
342           continue;
343 
344         CfgName = strtok(WorkPtr, " =");
345         CfgData = NULL;
346         if (NULL != CfgName)
347           {
348             /* Condition the name (lower case required),
349              and strip leading white and a 'late' = from data part.
350              */
351             //strlwr( CfgName );
352             CfgData = strtok(NULL, "");
353             if (CfgData != NULL)
354               {
355                 while (isspace ((int) *CfgData))
356                   CfgData++;
357                 if ('=' == *CfgData)
358                   CfgData++;
359                 while (isspace ((int) *CfgData))
360                   CfgData++;
361               }
362           }
363         if (!strcmp("APERTURE", CfgName) && strcmp("END", CfgData))
364           {
365             gsl_vector_int_set(apers, n, atoi(CfgData));
366             n++;
367             if (n > napers)
368               {
369                 aXe_message(aXe_M_FATAL, __FILE__, __LINE__,
370                 "File format error in aperture file %s",
371                 filename);
372               }
373           }
374       }
375     fclose(CfgFile);
376     return apers;
377   }
\end{DoxyCode}
\hypertarget{inout__aper_8h_a493b0450d9124855228d1d2e6e66d2f5}{
\index{inout\_\-aper.h@{inout\_\-aper.h}!aper\_\-file\_\-apernum@{aper\_\-file\_\-apernum}}
\index{aper\_\-file\_\-apernum@{aper\_\-file\_\-apernum}!inout_aper.h@{inout\_\-aper.h}}
\subsubsection[{aper\_\-file\_\-apernum}]{\setlength{\rightskip}{0pt plus 5cm}int aper\_\-file\_\-apernum (char $\ast$ {\em filename})}}
\label{inout__aper_8h_a493b0450d9124855228d1d2e6e66d2f5}
Function: aper\_\-file\_\-apernum A helper function which returns the number of time the keyword APERTURE appears in an Aperture File and returns that number.

Parameters: 
\begin{DoxyParams}{Parameters}
\item[{\em name}]of an Aperture File\end{DoxyParams}
Returns: \begin{DoxyReturn}{Returns}
number of time APERTURE appears in the file 
\end{DoxyReturn}



\begin{DoxyCode}
232 {
233   int n = 0;
234   char Buffer[BUFFERSIZE] = "\0";
235   char *WorkPtr           = NULL;
236   char *CfgName           = NULL;
237   char *CfgData           = NULL;
238   FILE *CfgFile;
239 
240   CfgFile = fopen (filename, "r");
241   if (NULL == CfgFile)
242     aXe_message (aXe_M_FATAL, __FILE__, __LINE__, "Could not open %s", filename);
      
243 
244 
245   while (NULL != fgets (Buffer, BUFFERSIZE, CfgFile))
246     {
247       /* clip off optional comment tail indicated by a semi-colon
248        */
249       if (NULL != (WorkPtr = strchr (Buffer, ';')))
250         *WorkPtr = '\0';
251       else
252         WorkPtr = Buffer + strlen (Buffer);
253 
254       /* clip off trailing and leading white space
255        */
256       WorkPtr--;
257       while (isspace ((int) *WorkPtr) && WorkPtr >= Buffer)
258         *WorkPtr-- = '\0';
259       WorkPtr = Buffer;
260       while (isspace ((int) *WorkPtr))
261         WorkPtr++;
262       if (0 == strlen (WorkPtr))
263         continue;
264 
265       CfgName = strtok (WorkPtr, " =");
266       if (NULL != CfgName)
267         {
268           /* Condition the name (lower case required),
269              and strip leading white and a 'late' = from data part.
270            */
271           CfgData = strtok (NULL, "");
272           if (CfgData != NULL)
273             {
274               while (isspace ((int) *CfgData))
275                 CfgData++;
276               if ('=' == *CfgData)
277                 CfgData++;
278               while (isspace ((int) *CfgData))
279                 CfgData++;
280             }
281         }
282       if (!strcmp ("APERTURE", CfgName)  && strcmp ("END", CfgData) )
283         n++;
284     }
285   fclose(CfgFile);
286   return n;
287 }
\end{DoxyCode}
\hypertarget{inout__aper_8h_a9b711702cce1bd598ac506bd8f75af38}{
\index{inout\_\-aper.h@{inout\_\-aper.h}!file\_\-to\_\-object\_\-list@{file\_\-to\_\-object\_\-list}}
\index{file\_\-to\_\-object\_\-list@{file\_\-to\_\-object\_\-list}!inout_aper.h@{inout\_\-aper.h}}
\subsubsection[{file\_\-to\_\-object\_\-list}]{\setlength{\rightskip}{0pt plus 5cm}{\bf object}$\ast$$\ast$ file\_\-to\_\-object\_\-list (char {\em filename}\mbox{[}$\,$\mbox{]}, \/  {\bf observation} $\ast$ {\em obs})}}
\label{inout__aper_8h_a9b711702cce1bd598ac506bd8f75af38}
\hypertarget{inout__aper_8h_ae18fecd8e762c35bae1376a8d637d8e8}{
\index{inout\_\-aper.h@{inout\_\-aper.h}!file\_\-to\_\-object\_\-list\_\-seq@{file\_\-to\_\-object\_\-list\_\-seq}}
\index{file\_\-to\_\-object\_\-list\_\-seq@{file\_\-to\_\-object\_\-list\_\-seq}!inout_aper.h@{inout\_\-aper.h}}
\subsubsection[{file\_\-to\_\-object\_\-list\_\-seq}]{\setlength{\rightskip}{0pt plus 5cm}{\bf object}$\ast$$\ast$ file\_\-to\_\-object\_\-list\_\-seq (char {\em filename}\mbox{[}$\,$\mbox{]}, \/  {\bf observation} $\ast$ {\em obs})}}
\label{inout__aper_8h_ae18fecd8e762c35bae1376a8d637d8e8}
Function: file\_\-to\_\-object\_\-list\_\-seq Read all apertures from n aperture file and return an array of \hyperlink{structobject}{object} pointers. This function use a sequential read of the aperture file which requires apertures to be clearly separated by APERTURE \#/APERTURE END keys in the Aperture File. It is faster than the more generic file\_\-to\_\-object\_\-list function. This function relies on the from\_\-char-\/array() functions.

Parameters: 
\begin{DoxyParams}{Parameters}
\item[{\em filename}]-\/ the name of the aperture file. \item[{\em obs}]-\/ a pointer to an existing non NULL \hyperlink{structobservation}{observation} structure\end{DoxyParams}
Returns: \begin{DoxyReturn}{Returns}
oblist -\/ a newly allocated array of \hyperlink{structobject}{object} pointers 
\end{DoxyReturn}



\begin{DoxyCode}
925   {
926     gsl_vector_int *l;
927     object **oblist;
928     int i, j, aperID;
929     char **aper;
930     FILE *input;
931     l = aper_file_aperlist(filename);
932     if (l==NULL)
933       return NULL; // no aperture was found
934     /* Allocate memory for enough objects */
935     oblist = (object **) malloc((l->size + 1) * sizeof(object *));
936 
937     // open the file;
938     // report any problems
939     input=fopen(filename, "r");
940     if (input==NULL)
941       aXe_message(aXe_M_FATAL, __FILE__, __LINE__, "Could not open %s", filename)
      ;
942 
943     for (i = 0; i < l->size; i++)
944       {
945         aperID = gsl_vector_int_get(l, i);
946         aper = return_next_aperture(input);
947         oblist[i] = get_aperture_from_char_array(aper, aperID);
948         oblist[i]->grism_obs = obs;
949 
950         // clean up memory allocated
951         for (j=0; j<MAX_BEAMS*APER_MAXLINE; j++)
952           free(aper[j]);
953         free(aper);
954       }
955 
956     oblist[i++] = NULL;
957     fclose(input);
958     gsl_vector_int_free(l);
959 
960     // return the object list
961     return oblist;
962   }
\end{DoxyCode}
\hypertarget{inout__aper_8h_a515c7167b798f972e4614a5404595e25}{
\index{inout\_\-aper.h@{inout\_\-aper.h}!find\_\-beam\_\-in\_\-object\_\-list@{find\_\-beam\_\-in\_\-object\_\-list}}
\index{find\_\-beam\_\-in\_\-object\_\-list@{find\_\-beam\_\-in\_\-object\_\-list}!inout_aper.h@{inout\_\-aper.h}}
\subsubsection[{find\_\-beam\_\-in\_\-object\_\-list}]{\setlength{\rightskip}{0pt plus 5cm}{\bf beam} find\_\-beam\_\-in\_\-object\_\-list ({\bf object} $\ast$$\ast$ {\em oblist}, \/  const int {\em objID}, \/  const int {\em beamID})}}
\label{inout__aper_8h_a515c7167b798f972e4614a5404595e25}
Function: find\_\-beam\_\-in\_\-object\_\-list This function returns the array index of the \hyperlink{structobject}{object} in a NULL terminated array of objects which corresponds to the passed ID

Parameters: 
\begin{DoxyParams}{Parameters}
\item[{\em oblist}]-\/ a NULL terminated array of objects \item[{\em objID}]-\/ the numeric ID of the object/aperture to look for \item[{\em beamID}]-\/ the numeric ID of the \hyperlink{structbeam}{beam} to look for\end{DoxyParams}
Returns: \begin{DoxyReturn}{Returns}
actbeam -\/ the \hyperlink{structbeam}{beam} identitified 
\end{DoxyReturn}



\begin{DoxyCode}
1075 {
1076   beam actbeam;
1077 
1078   int obj_index=0;
1079   int j=0;
1080 
1081   // set the beam ID to -1 to identify
1082   // failed identification
1083   actbeam.ID = -1;
1084 
1085   // identify the correct index in the object list
1086   obj_index = find_object_in_object_list(oblist, objID);
1087 
1088   //
1089   if (obj_index > -1)
1090     {
1091       // go over all beams in the matchin object
1092       for (j=0; j < oblist[obj_index]->nbeams; j++)
1093         {
1094 
1095           // search for a matching beam ID
1096           if (oblist[obj_index]->beams[j].ID == beamID)
1097             // copy the matching beam
1098             actbeam = oblist[obj_index]->beams[j];
1099         }
1100     }
1101 
1102   // return the beam
1103   return actbeam;
1104 }
\end{DoxyCode}
\hypertarget{inout__aper_8h_a435c8a237804e5f641b7401dfa81a059}{
\index{inout\_\-aper.h@{inout\_\-aper.h}!find\_\-beamptr\_\-in\_\-object\_\-list@{find\_\-beamptr\_\-in\_\-object\_\-list}}
\index{find\_\-beamptr\_\-in\_\-object\_\-list@{find\_\-beamptr\_\-in\_\-object\_\-list}!inout_aper.h@{inout\_\-aper.h}}
\subsubsection[{find\_\-beamptr\_\-in\_\-object\_\-list}]{\setlength{\rightskip}{0pt plus 5cm}{\bf beam}$\ast$ find\_\-beamptr\_\-in\_\-object\_\-list ({\bf object} $\ast$$\ast$ {\em oblist}, \/  const int {\em objID}, \/  const int {\em beamID})}}
\label{inout__aper_8h_a435c8a237804e5f641b7401dfa81a059}
Function: find\_\-beamptr\_\-in\_\-object\_\-list This function returns the array index of the \hyperlink{structobject}{object} in a NULL terminated array of objects which corresponds to the passed ID

Parameters: 
\begin{DoxyParams}{Parameters}
\item[{\em oblist}]-\/ a NULL terminated array of objects \item[{\em objID}]-\/ the numeric ID of the object/aperture to look for \item[{\em beamID}]-\/ the numeric ID of the \hyperlink{structbeam}{beam} to look for\end{DoxyParams}
Returns: \begin{DoxyReturn}{Returns}
actbeam -\/ the \hyperlink{structbeam}{beam} identitified 
\end{DoxyReturn}



\begin{DoxyCode}
1122 {
1123   beam *actbeam;
1124 
1125   int obj_index=0;
1126   int j=0;
1127 
1128   // set the beam ID to -1 to identify
1129   // failed identification
1130   //actbeam->ID = -1;
1131 
1132   // identify the correct index in the object list
1133   obj_index = find_object_in_object_list(oblist, objID);
1134   //fprintf(stderr, "found index: %i\n", obj_index);
1135   //
1136   if (obj_index > -1)
1137     {
1138       // go over all beams in the matchin object
1139       for (j=0; j < oblist[obj_index]->nbeams; j++)
1140         {
1141 
1142           // search for a matching beam ID
1143           if (oblist[obj_index]->beams[j].ID == beamID)
1144             // copy the matching beam
1145             actbeam = &oblist[obj_index]->beams[j];
1146         }
1147     }
1148 
1149   // return the beam
1150   return actbeam;
1151 }
\end{DoxyCode}
\hypertarget{inout__aper_8h_a12854533fd67781a0bf70a93a6ad91e4}{
\index{inout\_\-aper.h@{inout\_\-aper.h}!find\_\-object\_\-in\_\-object\_\-list@{find\_\-object\_\-in\_\-object\_\-list}}
\index{find\_\-object\_\-in\_\-object\_\-list@{find\_\-object\_\-in\_\-object\_\-list}!inout_aper.h@{inout\_\-aper.h}}
\subsubsection[{find\_\-object\_\-in\_\-object\_\-list}]{\setlength{\rightskip}{0pt plus 5cm}int find\_\-object\_\-in\_\-object\_\-list ({\bf object} $\ast$$\ast$ {\em oblist}, \/  const int {\em ID})}}
\label{inout__aper_8h_a12854533fd67781a0bf70a93a6ad91e4}
Function: find\_\-object\_\-in\_\-object\_\-list This function returns the array index of the \hyperlink{structobject}{object} in a NULL terminated array of objects which corresponds to the passed ID

Parameters: 
\begin{DoxyParams}{Parameters}
\item[{\em oblist}]-\/ a NULL terminated array of objects \item[{\em ID}]-\/ the numeric ID of the object/aperture to look for\end{DoxyParams}
Returns: \begin{DoxyReturn}{Returns}
i/-\/1 -\/ the array index to the object/aperture with the wanted ID 
\end{DoxyReturn}



\begin{DoxyCode}
1043 {
1044   int i;
1045 
1046   i=0;
1047   while (oblist != NULL && oblist[i] != NULL)
1048     {
1049       if (oblist[i]->ID == ID) return i;
1050       i++;
1051     }
1052 
1053   //    return NULL;
1054   // this is critical and not throughout testet!
1055   return -1;
1056 }
\end{DoxyCode}
\hypertarget{inout__aper_8h_ab3d3154507c93e7d0222531d0734c63a}{
\index{inout\_\-aper.h@{inout\_\-aper.h}!get\_\-aperture\_\-from\_\-aper\_\-file@{get\_\-aperture\_\-from\_\-aper\_\-file}}
\index{get\_\-aperture\_\-from\_\-aper\_\-file@{get\_\-aperture\_\-from\_\-aper\_\-file}!inout_aper.h@{inout\_\-aper.h}}
\subsubsection[{get\_\-aperture\_\-from\_\-aper\_\-file}]{\setlength{\rightskip}{0pt plus 5cm}{\bf object}$\ast$ get\_\-aperture\_\-from\_\-aper\_\-file (char $\ast$ {\em filename}, \/  int {\em aperID})}}
\label{inout__aper_8h_ab3d3154507c93e7d0222531d0734c63a}
\hypertarget{inout__aper_8h_adbb32d5fc9947145e815e0fd33a1cd34}{
\index{inout\_\-aper.h@{inout\_\-aper.h}!get\_\-beam\_\-from\_\-aper\_\-file@{get\_\-beam\_\-from\_\-aper\_\-file}}
\index{get\_\-beam\_\-from\_\-aper\_\-file@{get\_\-beam\_\-from\_\-aper\_\-file}!inout_aper.h@{inout\_\-aper.h}}
\subsubsection[{get\_\-beam\_\-from\_\-aper\_\-file}]{\setlength{\rightskip}{0pt plus 5cm}int get\_\-beam\_\-from\_\-aper\_\-file (char $\ast$ {\em filename}, \/  int {\em aperID}, \/  int {\em beamID}, \/  {\bf beam} $\ast$ {\em b})}}
\label{inout__aper_8h_adbb32d5fc9947145e815e0fd33a1cd34}
\hypertarget{inout__aper_8h_aa120fb983e10b94e79858e51b4d3e25e}{
\index{inout\_\-aper.h@{inout\_\-aper.h}!get\_\-beamspec\_\-size@{get\_\-beamspec\_\-size}}
\index{get\_\-beamspec\_\-size@{get\_\-beamspec\_\-size}!inout_aper.h@{inout\_\-aper.h}}
\subsubsection[{get\_\-beamspec\_\-size}]{\setlength{\rightskip}{0pt plus 5cm}int get\_\-beamspec\_\-size ({\bf object} $\ast$$\ast$ {\em oblist})}}
\label{inout__aper_8h_aa120fb983e10b94e79858e51b4d3e25e}
Function: get\_\-beamspec\_\-size The function computes the numbers of beams that are supposed to modelled. This is done by checking the ignore flag of each \hyperlink{structbeam}{beam} in an \hyperlink{structobject}{object} list. Some of the beams might be completely outside of the image are. So the number delivered here is only an upper limit.

Parameter: 
\begin{DoxyParams}{Parameters}
\item[{\em oblist}]-\/ the list of objects\end{DoxyParams}
Returns: \begin{DoxyReturn}{Returns}
specsize -\/ the number of objects to be modeled 
\end{DoxyReturn}



\begin{DoxyCode}
1218 {
1219   int specsize=0;
1220   int objectsize=0;
1221   int i=0;
1222   int j=0;
1223 
1224   // determine the number of objects
1225   objectsize = object_list_size(oblist);
1226 
1227   // go over each object
1228   for (i=0; i< objectsize; i++)
1229     {
1230       // go over each beam
1231       for (j=0; j < oblist[i]->nbeams; j++)
1232         {
1233           // check the ignore flag
1234           // sum up the counter if permitted
1235           if (oblist[i]->beams[j].ignore != 1)
1236             specsize++;
1237         }
1238     }
1239 
1240   // return the counter
1241   return specsize;
1242 }
\end{DoxyCode}
\hypertarget{inout__aper_8h_a5bfbf8150f27a4b1df4ab1d10d5bca7d}{
\index{inout\_\-aper.h@{inout\_\-aper.h}!nbeams\_\-from\_\-char\_\-array@{nbeams\_\-from\_\-char\_\-array}}
\index{nbeams\_\-from\_\-char\_\-array@{nbeams\_\-from\_\-char\_\-array}!inout_aper.h@{inout\_\-aper.h}}
\subsubsection[{nbeams\_\-from\_\-char\_\-array}]{\setlength{\rightskip}{0pt plus 5cm}gsl\_\-vector\_\-int$\ast$ nbeams\_\-from\_\-char\_\-array (char $\ast$$\ast$ {\em apers}, \/  int {\em num})}}
\label{inout__aper_8h_a5bfbf8150f27a4b1df4ab1d10d5bca7d}
Function: nbeams\_\-from\_\-char\_\-array Read an Aperture File and returns an integer array which lists the integer ID's of the beams found in the given aperture.

Parameters: 
\begin{DoxyParams}{Parameters}
\item[{\em filename}]-\/ name of Aperture File \item[{\em num}]-\/ number of apertures found in Aperture File\end{DoxyParams}
Returns: \begin{DoxyReturn}{Returns}
beamIDs -\/ the array with \hyperlink{structbeam}{beam} ID's 
\end{DoxyReturn}



\begin{DoxyCode}
471   {
472     int i, j, nbeam = 0;
473     char refpixel[MAXCHAR];
474 
475     gsl_vector_int *beamIDs;
476 
477     // allocate space for all possible beams
478     beamIDs = gsl_vector_int_alloc(MAX_BEAMS);
479 
480     // set all integer ID's to the default value -1
481     gsl_vector_int_set_all(beamIDs, -1);
482 
483     for (i = 0; i < MAX_BEAMS; i++)
484       {
485         struct CfgStrings AperData[] =
486           {
487             { refpixel, NULL },
488             { NULL, NULL } /* array terminator. REQUIRED !!! */
489           };
490         sprintf(refpixel, "REFPIXEL%d%c", num, BEAM (i));
491         CfgRead_from_array(apers, AperData);
492 
493         if (!strcmp(AperData[0].name, refpixel))
494           {
495             if (AperData[0].data != NULL)
496               {
497                 // set the integer array to the ID
498                 gsl_vector_int_set(beamIDs, nbeam, i);
499                 nbeam++;
500               }
501           }
502 
503         j = 0;
504         while (AperData[j].name!=NULL)
505           free(AperData[j++].data);
506       }
507     return beamIDs;
508   }
\end{DoxyCode}
\hypertarget{inout__aper_8h_ad6c178c268863d6fa3f2bbe3b3d8f8af}{
\index{inout\_\-aper.h@{inout\_\-aper.h}!nbeams\_\-from\_\-char\_\-array2@{nbeams\_\-from\_\-char\_\-array2}}
\index{nbeams\_\-from\_\-char\_\-array2@{nbeams\_\-from\_\-char\_\-array2}!inout_aper.h@{inout\_\-aper.h}}
\subsubsection[{nbeams\_\-from\_\-char\_\-array2}]{\setlength{\rightskip}{0pt plus 5cm}int nbeams\_\-from\_\-char\_\-array2 (char $\ast$$\ast$ {\em apers}, \/  int {\em num})}}
\label{inout__aper_8h_ad6c178c268863d6fa3f2bbe3b3d8f8af}
Function: nbeams\_\-from\_\-char\_\-array2 Read an Aperture File and returns the number of beams found for a given aperture number (up to MAX\_\-BEAMS)

Parameters: 
\begin{DoxyParams}{Parameters}
\item[{\em filename}]-\/ name of Aperture File \item[{\em num}]-\/ number of apertures found in Aperture File\end{DoxyParams}
Returns: \begin{DoxyReturn}{Returns}
nbeam -\/ the number of beams for the aperture 
\end{DoxyReturn}



\begin{DoxyCode}
429   {
430     int i, j, nbeam = 0;
431     char refpixel[MAXCHAR];
432 
433     for (i = 0; i < MAX_BEAMS; i++)
434       {
435         struct CfgStrings AperData[] = {
436               {refpixel, NULL},
437               {NULL, NULL}    /* array terminator. REQUIRED !!! */
438         };
439         sprintf (refpixel, "REFPIXEL%d%c", num, BEAM (i));
440         CfgRead_from_array (apers, AperData);
441 
442         if (!strcmp (AperData[0].name, refpixel))
443           {
444             if (AperData[0].data != NULL)
445               {
446                 nbeam++;
447               }
448           }
449         j = 0;
450         while(AperData[j].name!=NULL){
451           free(AperData[j++].data);
452         }
453       }
454     return nbeam;
455   }
\end{DoxyCode}
\hypertarget{inout__aper_8h_aa4bd812673400180537c7ea98650d3fe}{
\index{inout\_\-aper.h@{inout\_\-aper.h}!object\_\-list\_\-size@{object\_\-list\_\-size}}
\index{object\_\-list\_\-size@{object\_\-list\_\-size}!inout_aper.h@{inout\_\-aper.h}}
\subsubsection[{object\_\-list\_\-size}]{\setlength{\rightskip}{0pt plus 5cm}int object\_\-list\_\-size ({\bf object} $\ast$$\ast$ {\em oblist})}}
\label{inout__aper_8h_aa4bd812673400180537c7ea98650d3fe}
Function: object\_\-list\_\-size This function returns the number of element in an array of objects.

Parameters: 
\begin{DoxyParams}{Parameters}
\item[{\em oblist}]-\/ a NULL terminated array of objects\end{DoxyParams}
Returns: \begin{DoxyReturn}{Returns}
i -\/ number of elements 
\end{DoxyReturn}



\begin{DoxyCode}
1191 {
1192     int i=0;
1193 
1194     if (oblist==NULL) return 0;
1195 
1196     while (oblist[i] != NULL)
1197       i++;
1198 
1199     return i;
1200 }
\end{DoxyCode}
\hypertarget{inout__aper_8h_a881264311a05c31fe2ce9343bfb7f2d5}{
\index{inout\_\-aper.h@{inout\_\-aper.h}!object\_\-list\_\-to\_\-file@{object\_\-list\_\-to\_\-file}}
\index{object\_\-list\_\-to\_\-file@{object\_\-list\_\-to\_\-file}!inout_aper.h@{inout\_\-aper.h}}
\subsubsection[{object\_\-list\_\-to\_\-file}]{\setlength{\rightskip}{0pt plus 5cm}int object\_\-list\_\-to\_\-file ({\bf object} $\ast$const $\ast$ {\em oblist}, \/  char $\ast$ {\em filename}, \/  int {\em leaveout\_\-ignored})}}
\label{inout__aper_8h_a881264311a05c31fe2ce9343bfb7f2d5}
Function: object\_\-list\_\-to\_\-file Dump an \hyperlink{structobject}{object} apperture list into a file

Parameters: 
\begin{DoxyParams}{Parameters}
\item[{\em oblist}]-\/ a point to an \hyperlink{structobject}{object} list \item[{\em filename}]-\/ name of the file to write output \item[{\em leaveout\_\-ignored}]-\/ if ignore=1 beams are left out of the aper file\end{DoxyParams}
Returns: \begin{DoxyReturn}{Returns}
num -\/ number of beams written to the aperture file 
\end{DoxyReturn}



\begin{DoxyCode}
28 {
29   FILE *file;
30   object *const *obp;
31   const beam *b;
32   char refpixel[MAXCHAR];
33   char corners[MAXCHAR];
34   char curve[MAXCHAR];
35   char width[MAXCHAR];
36   char orient[MAXCHAR];
37   //char bwindow[MAXCHAR];
38   char awidth[MAXCHAR];
39   char bwidth[MAXCHAR];
40   char aorient[MAXCHAR];
41   char flux[MAXCHAR];
42   char slitgeom[MAXCHAR];
43   char modspec[MAXCHAR];
44   char modimage[MAXCHAR];
45   char ignore[MAXCHAR];
46   char tmps[MAXCHAR];
47   int oid, i, ii, num = 0;
48   char label[80];
49   double *cf;
50   int wrote_aper;
51   //int j = 0;
52 
53   // open the output file;
54   // give error in case of problems
55   file = fopen (filename, "w");
56   if (file==NULL)
57     {
58       aXe_message (aXe_M_FATAL, __FILE__, __LINE__, "Could not open %s", filename
      );
59     }
60 
61   // go over the apertures
62   for (obp = oblist; *obp; obp++)
63     {
64       oid = (*obp)->ID;
65       wrote_aper = 0;
66       for (i = 0; i < (*obp)->nbeams; i++)
67         {
68           b = &((*obp)->beams[i]);
69           if ((leaveout_ignored) && (b->ignore == 1))
70             continue;
71 
72           if (!wrote_aper)
73             {
74               fprintf (file, "APERTURE %i\n", oid);
75               wrote_aper = 1;
76             }
77 
78           sprintf (label, "Aperture %i, BEAM %c", oid, BEAM (i));
79 
80           fprintf (file, "  BEAM %c\n", BEAM (i));
81 
82           /* Output REFPIXEL info */
83           sprintf (refpixel,
84               "     REFPIXEL%i%c %.3f %.3f"
85               " \t\t\t\t;%s Reference Pixel.", oid, BEAM (i),
86               b->refpoint.x, b->refpoint.y, label);
87 
88           /* Output CORNERS aperture info */
89           sprintf (corners,
90               "     CORNERS%i%c  %i %i %i %i %i %i %i %i"
91               " \t\t;%s Aperture Coordinates.", oid, BEAM (i),
92               b->corners[0].x, b->corners[0].y, b->corners[1].x,
93               b->corners[1].y, b->corners[2].x, b->corners[2].y,
94               b->corners[3].x, b->corners[3].y, label);
95 
96           /* Output CURVE trace description info */
97           sprintf (curve,"     CURVE%i%c    %i", oid, BEAM (i), b->spec_trace->
      type);
98           cf = b->spec_trace->data;
99 
100           for (ii=0;ii<b->spec_trace->type + 1;ii++)
101             {
102               sprintf(tmps," %.3e",cf[ii+1]);
103               strcat(curve,tmps);
104             }
105           sprintf(tmps,"\t\t\t;%s Trace description.",label);
106           strcat(curve,tmps);
107 
108           /* Output WIDTH width of object info */
109           sprintf (width,
110               "     WIDTH%i%c    %.3f \t\t\t\t\t;%s Object Width.",
111               oid, BEAM (i), b->width, label);
112 
113           /* Output ORIENT orientation angle of object info */
114           /* Angle reference frame is converted from aXe's to SeXtractor */
115           sprintf (orient,
116               "     ORIENT%i%c   %.3f \t\t\t\t\t;%s Object Orientation.",
117               oid, BEAM (i), ((b->orient) / M_PI * 180. - 180.), label);
118 
119 
120           if (b->slitgeom[0] > -1.0)
121             {
122               /* Output CORNERS aperture info */
123               sprintf (slitgeom,
124                   "     SLITGEOM%i%c %.2f %.2f %.2f %.2f \t\t; %s Object Orientat
      ion.", oid, BEAM (i),
125                   b->slitgeom[0],
126                   b->slitgeom[1] / M_PI * 180. - 180.,
127                   b->slitgeom[2],
128                   b->slitgeom[3],
129                   label);
130             }
131 
132           if (b->modspec >-1)
133             {
134               // outputmodel spectrum value
135               sprintf (modspec,
136                   "     MODSPEC%i%c  %3i \t\t\t\t;%s, Index for model spectrum.",
      
137                   oid, BEAM (i), b->modspec, label);
138             }
139           if (b->modimage >-1)
140             {
141               // output model image value
142               sprintf (modimage,
143                   "     MODIMAGE%i%c  %3i \t\t\t\t;%s, Index for direct emission.
      ",
144                   oid, BEAM (i), b->modimage, label);
145             }
146 
147           if (b->awidth > 0.0)
148             {
149               /* Output AWIDTH width of object info */
150               sprintf (awidth,
151                   "     AWIDTH%i%c   %.3f \t\t\t\t\t\t;%s Maximum Object Width.",
      
152                   oid, BEAM (i), b->awidth, label);
153 
154               /* Output BWIDTH width of object info */
155               sprintf (bwidth,
156                   "     BWIDTH%i%c   %.3f \t\t\t\t\t\t;%s Minimum Object Width.",
      
157                   oid, BEAM (i), b->bwidth, label);
158 
159               /* Output AORIENT angle of object info */
160               sprintf (aorient,
161                   "     AORIENT%i%c  %.3f \t\t\t\t\t\t;%s Orientation of Max. Obj
      ect Width.",
162                   oid, BEAM (i), b->aorient, label);
163 
164               // print the identifier
165               sprintf (flux,"     FLUX%i%c    ", oid, BEAM (i));
166 
167               // go over all flux vector values
168               for (ii=0;ii<b->flux->size;ii++)
169                 {
170                   // print and append the current value
171                   sprintf(tmps," %.5e", gsl_vector_get(b->flux, ii));
172                   strcat(flux,tmps);
173                 }
174               // print an append the comment
175               sprintf(tmps,"\t\t;%s Flux values.",label);
176               strcat(flux,tmps);
177             }
178 
179           /* Output IGNORE flag */
180           sprintf (ignore,
181               "     IGNORE%i%c   %1d  \t\t\t\t\t;%s ignore this beam.",
182               oid, BEAM (i), b->ignore, label);
183 
184           // write the beam components to the file
185           fprintf (file, "%s\n", refpixel);
186           fprintf (file, "%s\n", corners);
187           fprintf (file, "%s\n", curve);
188           fprintf (file, "%s\n", width);
189           fprintf (file, "%s\n", orient);
190           if (b->slitgeom[0] > -1.0)
191             fprintf (file, "%s\n", slitgeom);
192           if (b->modspec > -1)
193             fprintf (file, "%s\n", modspec);
194           if (b->modimage > -1)
195               fprintf (file, "%s\n", modimage);
196           if (b->awidth > 0.0)
197             {
198               fprintf (file, "%s\n", awidth);
199               fprintf (file, "%s\n", bwidth);
200               fprintf (file, "%s\n", aorient);
201               fprintf (file, "%s\n", flux);
202             }
203           fprintf (file, "%s\n", ignore);
204 
205           // mark the beam end
206           fprintf (file, "  BEAM END\n");
207 
208           // enhance the beam counter
209           num++;
210         }
211       if (wrote_aper)
212         fprintf (file, "APERTURE END\n\n");
213       }
214   fclose (file);
215   return num;
216 }
\end{DoxyCode}
\hypertarget{inout__aper_8h_a76950235f36088ca98cd60aa2e431086}{
\index{inout\_\-aper.h@{inout\_\-aper.h}!refurbish\_\-object\_\-list@{refurbish\_\-object\_\-list}}
\index{refurbish\_\-object\_\-list@{refurbish\_\-object\_\-list}!inout_aper.h@{inout\_\-aper.h}}
\subsubsection[{refurbish\_\-object\_\-list}]{\setlength{\rightskip}{0pt plus 5cm}void refurbish\_\-object\_\-list ({\bf object} $\ast$$\ast$ {\em oblist}, \/  const int {\em new\_\-default}, \/  const int {\em old\_\-value}, \/  const int {\em new\_\-value})}}
\label{inout__aper_8h_a76950235f36088ca98cd60aa2e431086}



\begin{DoxyCode}
1156 {
1157   //object *act_obj;
1158   beam   *act_beam;
1159 
1160   int j=0;
1161   int i=0;
1162 
1163   i=0;
1164   while (oblist != NULL && oblist[i] != NULL)
1165     {
1166       // go over all beams in the matchin object
1167       for (j=0; j < oblist[i]->nbeams; j++)
1168         {
1169           act_beam = &oblist[i]->beams[j];
1170           if (act_beam->ignore == old_value)
1171             act_beam->ignore = new_value;
1172           else
1173             act_beam->ignore = new_default;
1174         }
1175       i++;
1176     }
1177 }
\end{DoxyCode}
\hypertarget{inout__aper_8h_a5610d36eaa966760f40180225de8faeb}{
\index{inout\_\-aper.h@{inout\_\-aper.h}!return\_\-next\_\-aperture@{return\_\-next\_\-aperture}}
\index{return\_\-next\_\-aperture@{return\_\-next\_\-aperture}!inout_aper.h@{inout\_\-aper.h}}
\subsubsection[{return\_\-next\_\-aperture}]{\setlength{\rightskip}{0pt plus 5cm}char$\ast$$\ast$ return\_\-next\_\-aperture (FILE $\ast$ {\em input})}}
\label{inout__aper_8h_a5610d36eaa966760f40180225de8faeb}
Function: return\_\-next\_\-aperture this function allocates and returns an array of strings containing the content of the next APERTURE in an already opened aperture file.

Parameters: 
\begin{DoxyParams}{Parameters}
\item[{\em input}]-\/ a pointer to an opened Aperture File\end{DoxyParams}
Returns: \begin{DoxyReturn}{Returns}
aper -\/ a pointer to a newly allocated array of strings 
\end{DoxyReturn}



\begin{DoxyCode}
976   {
977     char *WorkPtr;
978     char Buffer[BUFFERSIZE], Buffer2[BUFFERSIZE];
979     char *key;
980     int new_aper=0;
981     char **aper=NULL;
982     int nlines= MAX_BEAMS*APER_MAXLINE, i=0;
983 
984     /* Allocate enough room to allow for MAXBEAM in returned string array */
985 
986     aper = (char **) malloc(sizeof(char *)*nlines);
987     for (i=0; i<nlines; i++)
988       aper[i] = malloc(sizeof(char)*BUFFERSIZE);
989 
990     i=0;
991     while (NULL != fgets (Buffer, BUFFERSIZE, input))
992       {
993         strcpy(Buffer2,Buffer);
994         /* clip off optional comment tail indicated by a semi-colon */
995         if (NULL != (WorkPtr = strchr (Buffer, ';')))
996           *WorkPtr = '\0';
997         else
998           WorkPtr = Buffer + strlen (Buffer);
999 
1000         /* clip off trailing and leading white space*/
1001         WorkPtr--;
1002         while (isspace ((int) *WorkPtr) && WorkPtr >= Buffer)
1003           *WorkPtr-- = '\0';
1004 
1005         WorkPtr = Buffer;
1006         while (isspace ((int) *WorkPtr))
1007           WorkPtr++;
1008 
1009         if (0 == strlen (WorkPtr))
1010           continue;
1011         key = strtok (WorkPtr, " =");
1012 
1013         if (!strcmp(key,"APERTURE"))
1014           new_aper++;
1015 
1016         sprintf(aper[i++],"%s",Buffer2);
1017 
1018         if (new_aper==2)
1019           {
1020             //sprintf(aper[i++],"NULL\0");
1021                         sprintf(aper[i++],"NULL");
1022             return aper;
1023           }
1024         }
1025     return aper;
1026   }
\end{DoxyCode}
