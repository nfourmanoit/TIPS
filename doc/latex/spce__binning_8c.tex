\hypertarget{spce__binning_8c}{
\section{/renoir/fourmano/Desktop/OUSIM/TIPS/branches/tips\_\-build/src/axesim/spce\_\-binning.c File Reference}
\label{spce__binning_8c}\index{/renoir/fourmano/Desktop/OUSIM/TIPS/branches/tips\_\-build/src/axesim/spce\_\-binning.c@{/renoir/fourmano/Desktop/OUSIM/TIPS/branches/tips\_\-build/src/axesim/spce\_\-binning.c}}
}
{\ttfamily \#include $<$gsl/gsl\_\-matrix.h$>$}\par
{\ttfamily \#include $<$gsl/gsl\_\-vector.h$>$}\par
{\ttfamily \#include \char`\"{}aXe\_\-grism.h\char`\"{}}\par
{\ttfamily \#include \char`\"{}aper\_\-conf.h\char`\"{}}\par
{\ttfamily \#include \char`\"{}spc\_\-driz.h\char`\"{}}\par
{\ttfamily \#include \char`\"{}spce\_\-output.h\char`\"{}}\par
{\ttfamily \#include \char`\"{}spc\_\-optimum.h\char`\"{}}\par
{\ttfamily \#include \char`\"{}spce\_\-binning.h\char`\"{}}\par
\subsection*{Namespaces}
\begin{DoxyCompactItemize}
\item 
namespace \hyperlink{namespacespce__binning}{spce\_\-binning}
\end{DoxyCompactItemize}
\subsection*{Defines}
\begin{DoxyCompactItemize}
\item 
\#define \hyperlink{spce__binning_8c_aa7866fa5e4e0ee9b034e9dab6599a9cc}{SQR}(x)~((x)$\ast$(x))
\item 
\#define \hyperlink{spce__binning_8c_a74e75242132eaabbc1c512488a135926}{MIN}(x, y)~(((x)$<$(y))?(x):(y))
\item 
\#define \hyperlink{spce__binning_8c_aacc3ee1a7f283f8ef65cea31f4436a95}{MAX}(x, y)~(((x)$>$(y))?(x):(y))
\item 
\#define \hyperlink{spce__binning_8c_ad57376dfb2aea29e68fe39f8072f1522}{DEBUG\_\-ME}~0x200
\item 
\#define \hyperlink{spce__binning_8c_a9f2dc7b6f44300d5c964969937761d6c}{PIXWEIGHT}(x1, y1, x2, y2, pix)
\item 
\#define \hyperlink{spce__binning_8c_a8dfe5270d79dd418c3e41042a3f59e07}{NAIVE\_\-VAL\_\-TO\_\-BININD}(x)~((int)floor((x)+1e-\/6))
\end{DoxyCompactItemize}
\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
static void \hyperlink{spce__binning_8c_a7518304380f3c574b4fd1564de70ef1a}{add\_\-to\_\-spec\_\-table} (\hyperlink{structspectrum}{spectrum} $\ast$const spec, const int bin, const \hyperlink{structap__pixel}{ap\_\-pixel} $\ast$const cur\_\-p, const int quant\_\-cont, const double weight)
\item 
double \hyperlink{spce__binning_8c_aa622d2775b7989396320f7714424dff7}{pixweight\_\-x} (const double x1, const double y1, const double x2, const double y2, const struct \hyperlink{structw__pixel__s}{w\_\-pixel\_\-s} $\ast$const pix)
\item 
double \hyperlink{spce__binning_8c_a779dbcd6b7ffb343f78c061db7bf44fe}{pixweight\_\-y} (const double x1, const double y1, const double x2, const double y2, const struct \hyperlink{structw__pixel__s}{w\_\-pixel\_\-s} $\ast$const pix)
\item 
static void \hyperlink{spce__binning_8c_ab30f3a9057424879b1e59d544efe5f43}{fill\_\-w\_\-pixel} (\hyperlink{structw__pixel__s}{w\_\-pixel} $\ast$const pix, const double x0, const double y0, const double angle)
\item 
\hyperlink{structspectrum}{spectrum} $\ast$ \hyperlink{spce__binning_8c_aae5d0848d8dac6d3cecf1c6c4de7747d}{bin\_\-naive} (const \hyperlink{structap__pixel}{ap\_\-pixel} $\ast$const ap\_\-p, const double ob\_\-width, const double ob\_\-orient, const int quant\_\-cont)
\item 
\hyperlink{structspectrum}{spectrum} $\ast$ \hyperlink{spce__binning_8c_a48edf641b650f9cded24b2616dc93072}{bin\_\-optimal} (const \hyperlink{structap__pixel}{ap\_\-pixel} $\ast$const ap\_\-p, const \hyperlink{structbeam}{beam} curbeam, const int quant\_\-cont, const gsl\_\-matrix $\ast$weights, const \hyperlink{structdrzstamp__dim}{drzstamp\_\-dim} dimension, gsl\_\-matrix $\ast$coverage)
\item 
\hyperlink{structspectrum}{spectrum} $\ast$ \hyperlink{spce__binning_8c_a49f87c0ee85edafe3f007ded3eb2bef9}{bin\_\-weighted} (const \hyperlink{structap__pixel}{ap\_\-pixel} $\ast$const ap\_\-p, const double ob\_\-orient, const \hyperlink{structtrace__func}{trace\_\-func} $\ast$const trace, const int n\_\-sub, const int flags)
\end{DoxyCompactItemize}


\subsection{Define Documentation}
\hypertarget{spce__binning_8c_ad57376dfb2aea29e68fe39f8072f1522}{
\index{spce\_\-binning.c@{spce\_\-binning.c}!DEBUG\_\-ME@{DEBUG\_\-ME}}
\index{DEBUG\_\-ME@{DEBUG\_\-ME}!spce_binning.c@{spce\_\-binning.c}}
\subsubsection[{DEBUG\_\-ME}]{\setlength{\rightskip}{0pt plus 5cm}\#define DEBUG\_\-ME~0x200}}
\label{spce__binning_8c_ad57376dfb2aea29e68fe39f8072f1522}
\hypertarget{spce__binning_8c_aacc3ee1a7f283f8ef65cea31f4436a95}{
\index{spce\_\-binning.c@{spce\_\-binning.c}!MAX@{MAX}}
\index{MAX@{MAX}!spce_binning.c@{spce\_\-binning.c}}
\subsubsection[{MAX}]{\setlength{\rightskip}{0pt plus 5cm}\#define MAX(x, \/  y)~(((x)$>$(y))?(x):(y))}}
\label{spce__binning_8c_aacc3ee1a7f283f8ef65cea31f4436a95}
\hypertarget{spce__binning_8c_a74e75242132eaabbc1c512488a135926}{
\index{spce\_\-binning.c@{spce\_\-binning.c}!MIN@{MIN}}
\index{MIN@{MIN}!spce_binning.c@{spce\_\-binning.c}}
\subsubsection[{MIN}]{\setlength{\rightskip}{0pt plus 5cm}\#define MIN(x, \/  y)~(((x)$<$(y))?(x):(y))}}
\label{spce__binning_8c_a74e75242132eaabbc1c512488a135926}
\hypertarget{spce__binning_8c_a8dfe5270d79dd418c3e41042a3f59e07}{
\index{spce\_\-binning.c@{spce\_\-binning.c}!NAIVE\_\-VAL\_\-TO\_\-BININD@{NAIVE\_\-VAL\_\-TO\_\-BININD}}
\index{NAIVE\_\-VAL\_\-TO\_\-BININD@{NAIVE\_\-VAL\_\-TO\_\-BININD}!spce_binning.c@{spce\_\-binning.c}}
\subsubsection[{NAIVE\_\-VAL\_\-TO\_\-BININD}]{\setlength{\rightskip}{0pt plus 5cm}\#define NAIVE\_\-VAL\_\-TO\_\-BININD(x)~((int)floor((x)+1e-\/6))}}
\label{spce__binning_8c_a8dfe5270d79dd418c3e41042a3f59e07}
\hypertarget{spce__binning_8c_a9f2dc7b6f44300d5c964969937761d6c}{
\index{spce\_\-binning.c@{spce\_\-binning.c}!PIXWEIGHT@{PIXWEIGHT}}
\index{PIXWEIGHT@{PIXWEIGHT}!spce_binning.c@{spce\_\-binning.c}}
\subsubsection[{PIXWEIGHT}]{\setlength{\rightskip}{0pt plus 5cm}\#define PIXWEIGHT(x1, \/  y1, \/  x2, \/  y2, \/  pix)}}
\label{spce__binning_8c_a9f2dc7b6f44300d5c964969937761d6c}
{\bfseries Value:}
\begin{DoxyCode}
((pix)->weight_function((x1), (y1), (x2),\
  (y2),(pix)))
\end{DoxyCode}
\hypertarget{spce__binning_8c_aa7866fa5e4e0ee9b034e9dab6599a9cc}{
\index{spce\_\-binning.c@{spce\_\-binning.c}!SQR@{SQR}}
\index{SQR@{SQR}!spce_binning.c@{spce\_\-binning.c}}
\subsubsection[{SQR}]{\setlength{\rightskip}{0pt plus 5cm}\#define SQR(x)~((x)$\ast$(x))}}
\label{spce__binning_8c_aa7866fa5e4e0ee9b034e9dab6599a9cc}


\subsection{Function Documentation}
\hypertarget{spce__binning_8c_a7518304380f3c574b4fd1564de70ef1a}{
\index{spce\_\-binning.c@{spce\_\-binning.c}!add\_\-to\_\-spec\_\-table@{add\_\-to\_\-spec\_\-table}}
\index{add\_\-to\_\-spec\_\-table@{add\_\-to\_\-spec\_\-table}!spce_binning.c@{spce\_\-binning.c}}
\subsubsection[{add\_\-to\_\-spec\_\-table}]{\setlength{\rightskip}{0pt plus 5cm}static void add\_\-to\_\-spec\_\-table ({\bf spectrum} $\ast$const  {\em spec}, \/  const int {\em bin}, \/  const {\bf ap\_\-pixel} $\ast$const  {\em cur\_\-p}, \/  const int {\em quant\_\-cont}, \/  const double {\em weight})\hspace{0.3cm}{\ttfamily  \mbox{[}static\mbox{]}}}}
\label{spce__binning_8c_a7518304380f3c574b4fd1564de70ef1a}
Function: add\_\-to\_\-spec\_\-table adds some count to an entry in the \hyperlink{structspectrum}{spectrum} table

Parameters: 
\begin{DoxyParams}{Parameters}
\item[{\em spec}]the \hyperlink{structspectrum}{spectrum} table to work on \item[{\em bin}]index of \hyperlink{structspectrum}{spectrum} table entry to add cur\_\-p to \item[{\em cur\_\-p}]the \hyperlink{structap__pixel}{ap\_\-pixel} to add \item[{\em weight}]weight of the count \end{DoxyParams}



\begin{DoxyCode}
46 {
47 
48   spc_entry *const sp_e = spec->spec + bin;
49 
50   // some conditions which should not be violated
51   if ((bin < 0) || (bin > spec->spec_len))
52     {
53       aXe_message (aXe_M_WARN4, __FILE__, __LINE__,
54                    "Assignment out of spectrum: %d", bin);
55       return;
56     }
57   if (weight < 0)
58     {
59       aXe_message (aXe_M_FATAL, __FILE__, __LINE__,
60                    "Weight cannot be negative " "but is %f", weight);
61     }
62 
63   // check whether the spectral element is new
64   // and without values up to now
65   if (isnan (sp_e->lambda_mean))
66     {
67 
68       // initialize the spectral element
69       sp_e->lambda_mean = cur_p->lambda;
70       sp_e->dlambda = cur_p->dlambda;
71       sp_e->lambda_max = cur_p->lambda;
72       sp_e->lambda_min = cur_p->lambda;
73       sp_e->weight = weight;
74       sp_e->count = cur_p->count * weight;
75       sp_e->error = fabs(cur_p->error) * weight;
76       sp_e->dq = cur_p->dq;
77 
78       // initialize the contamination
79       // this is different for quantitative and
80       // geometrical contamination
81       if (quant_cont)
82         {
83           if ((int)(sp_e->contam==-1)&&((int)cur_p->contam!=-1))
84             {
85               sp_e->contam = cur_p->contam * weight;
86             }
87         }
88       else
89         {
90           if ((int)(sp_e->contam==-1)&&((int)cur_p->contam!=-1))
91             {
92               sp_e->contam = cur_p->contam;
93             }
94         }
95     }
96   else
97     {
98 
99       // update an existing spectral bin
100 
101       // find new maxima and minima
102       sp_e->lambda_max = MAX (cur_p->lambda, sp_e->lambda_max);
103       sp_e->lambda_min = MIN (cur_p->lambda, sp_e->lambda_min);
104 
105       // find new mean lambda via weighted summation
106       sp_e->lambda_mean =
107         (sp_e->lambda_mean * sp_e->weight +
108          cur_p->lambda * weight) / (weight + sp_e->weight);
109 
110       // NEWNEWNEW::
111       // find dlambda via weighted summation
112       sp_e->dlambda =
113         (sp_e->dlambda * sp_e->weight +
114          cur_p->dlambda * weight) / (weight + sp_e->weight);
115 
116       // add the weight
117       sp_e->weight += weight;
118 
119       // add the counts
120       sp_e->count += cur_p->count * weight;
121 
122       // process the error
123       sp_e->error = sqrt (SQR (sp_e->error) + SQR (fabs(cur_p->error) * weight));
      
124 
125       // logically XOR the dq
126       sp_e->dq = (sp_e->dq | cur_p->dq);
127 
128       // update the contamination,
129       // take into account the quantitative
130       // contamination
131       if (quant_cont)
132         {
133           if (((int)sp_e->contam==-1)&&((int)cur_p->contam!=-1))
134             {
135               sp_e->contam = cur_p->contam * weight;
136             }
137           if (((int)sp_e->contam!=-1)&&((int)cur_p->contam!=-1))
138             {
139               sp_e->contam += cur_p->contam * weight;
140             }
141         }
142       else
143         {
144           if (((int)sp_e->contam==-1)&&((int)cur_p->contam!=-1))
145             {
146               sp_e->contam = cur_p->contam;
147             }
148           if (((int)sp_e->contam!=-1)&&((int)cur_p->contam!=-1))
149             {
150               sp_e->contam += cur_p->contam;
151             }
152         }
153     }
154 }
\end{DoxyCode}
\hypertarget{spce__binning_8c_aae5d0848d8dac6d3cecf1c6c4de7747d}{
\index{spce\_\-binning.c@{spce\_\-binning.c}!bin\_\-naive@{bin\_\-naive}}
\index{bin\_\-naive@{bin\_\-naive}!spce_binning.c@{spce\_\-binning.c}}
\subsubsection[{bin\_\-naive}]{\setlength{\rightskip}{0pt plus 5cm}{\bf spectrum}$\ast$ bin\_\-naive (const {\bf ap\_\-pixel} $\ast$const  {\em ap\_\-p}, \/  const double {\em ob\_\-width}, \/  const double {\em ob\_\-orient}, \/  const int {\em quant\_\-cont})}}
\label{spce__binning_8c_aae5d0848d8dac6d3cecf1c6c4de7747d}
Function: bin\_\-naive computes a \hyperlink{structspectrum}{spectrum} from a table of aperture pixels generated from \hyperlink{namespacespc__extract}{spc\_\-extract}. This is adds up the pixel values, distributing them over the trace, taking into account the fracton of the pixel that projects onto the given \mbox{[}xi,xi+1\mbox{]} interval. Return NULL if ap\_\-p is NULL

Parameters: 
\begin{DoxyParams}{Parameters}
\item[{\em ap\_\-p}]the table of aperture pixels \item[{\em px\_\-width}]width of a pixel (=1 if not subsampled) \item[{\em ob\_\-width}]the width of the \hyperlink{structobject}{object} that has generated the \hyperlink{structspectrum}{spectrum} \item[{\em ob\_\-orientation}]the orientation of the \hyperlink{structobject}{object} that has generated the \hyperlink{structspectrum}{spectrum} \item[{\em flags}]problems that were accumulated in generating ap\_\-p; possible flags are defined for the warning member of the \hyperlink{structspectrum}{spectrum} struct\end{DoxyParams}
Returns: \begin{DoxyReturn}{Returns}
spec -\/ the 1D \hyperlink{structspectrum}{spectrum} 
\end{DoxyReturn}



\begin{DoxyCode}
340 {
341   const ap_pixel *cur_p;
342   int upper, lower;
343 
344   int bin;
345   spectrum *spec, *tspec;
346   double phi_trace;
347   spc_entry *spec_table;
348   double d, frac;
349 
350   // immediately return empty PET's
351   if (ap_p==NULL)
352     return NULL;
353 
354   // go through the PET,
355   // find the minimum and
356   // maximum in trace distance
357   cur_p = ap_p;
358   upper = NAIVE_VAL_TO_BININD (cur_p->xi);
359   lower = NAIVE_VAL_TO_BININD (cur_p->xi);
360   while (cur_p->p_x != -1)
361     {
362       bin = NAIVE_VAL_TO_BININD (cur_p->xi);
363       upper = MAX (bin, upper);
364       lower = MIN (bin, lower);
365       cur_p++;
366     }
367 
368   // check whether the spectrum
369   // will ahve a finite length,
370   // exit if not
371   if (upper == lower)
372     {
373       aXe_message (aXe_M_WARN4, __FILE__, __LINE__,
374                    "Pixel table empty.\n");
375       return NULL;
376     }
377 
378   // Thresh in some headway so we don't need to worry too much about
379   //     accessing invalid elements now and then
380   lower -= 10;
381   upper += 10;
382   spec = allocate_spectrum (upper - lower);
383 
384   spec_table = spec->spec;
385   cur_p = ap_p;
386 
387   while (cur_p->p_x != -1)
388     {
389       // Compute any fractional pixel that might fall within the
390       //desired extraction width
391       d = ob_width;
392       frac = 1.;
393 
394       // continue if the pixel is outside
395       // of the extraction region
396       if (fabs (cur_p->dist) > d + .5)
397         {
398           cur_p++;
399           continue;
400         }
401       if ((fabs (cur_p->dist) >= d - .5) && (fabs (cur_p->dist) <= d + .5))
402         {
403           frac = fabs (d - (fabs (cur_p->dist) - 0.5));
404         }
405 
406       // store the local trace angle
407       phi_trace = cur_p->dxs;
408 
409       if (1)
410         {
411           double xi;
412           w_pixel pix;
413           double sinp = sin (phi_trace);
414           double cosp = cos (phi_trace);
415           double xc, yc;
416           double w;
417           double sum = 0;
418 
419           fill_w_pixel (&pix, cur_p->x, cur_p->y, ob_orient);
420 
421           xc = cur_p->xs;
422           yc = cur_p->ys;
423 
424           // at cur_p->xi, there has to be some contribution. We go back
425           // collecting, until w is zero
426           for (xi = cur_p->xi;; xi -= 1)
427             {
428               bin = NAIVE_VAL_TO_BININD (xi);
429               w = PIXWEIGHT (xc + (bin - cur_p->xi) * cosp,
430                              yc + (bin - cur_p->xi) * sinp,
431                              xc + (bin + 1 - cur_p->xi) * cosp,
432                              yc + (bin + 1 - cur_p->xi) * sinp,
433                              &pix);
434               if (w < 1e-10)
435                 break;
436 
437               add_to_spec_table (spec, bin - lower, cur_p, quant_cont,
438                                  w * frac * cur_p->weight);
439               //              if (cur_p->weight > 10.0){
440               //                fprintf(stdout,"weight: %f, distance: %f, ewidth:
       %f\n",
441               //                        cur_p->weight, cur_p->dist, d+0.5);
442               //              }
443               sum += w;
444             }
445 
446           /* Now collect contributions upward of cur_p->xi */
447           for (xi = cur_p->xi + 1;; xi += 1)
448             {
449               bin = NAIVE_VAL_TO_BININD (xi);
450 
451               w = PIXWEIGHT (xc + (bin - cur_p->xi) * cosp,
452                              yc + (bin - cur_p->xi) * sinp,
453                              xc + (bin + 1 - cur_p->xi) * cosp,
454                              yc + (bin + 1 - cur_p->xi) * sinp,
455                              &pix);
456               if (w < 1e-10)
457                 break;
458 
459               add_to_spec_table (spec, bin - lower, cur_p, quant_cont,
460                                  w * frac * cur_p->weight);
461               sum += w;
462             }
463 
464           if (fabs (sum - 1) > 1e-6)
465             {
466               fprintf(stdout,
467                       "Weights added up to only %f for pixel from %4d,%4d\n",
468                       sum, cur_p->p_x, cur_p->p_y);
469             }
470         }
471       cur_p++;
472     }
473 
474   /* Trimming the INDEF beginning and ending values in spectrum */
475   tspec = trim_spectrum (spec);
476   free_spectrum (spec);
477   spec = NULL;
478 
479   // return the spectrum
480   return tspec;
481 }
\end{DoxyCode}
\hypertarget{spce__binning_8c_a48edf641b650f9cded24b2616dc93072}{
\index{spce\_\-binning.c@{spce\_\-binning.c}!bin\_\-optimal@{bin\_\-optimal}}
\index{bin\_\-optimal@{bin\_\-optimal}!spce_binning.c@{spce\_\-binning.c}}
\subsubsection[{bin\_\-optimal}]{\setlength{\rightskip}{0pt plus 5cm}{\bf spectrum}$\ast$ bin\_\-optimal (const {\bf ap\_\-pixel} $\ast$const  {\em ap\_\-p}, \/  const {\bf beam} {\em curbeam}, \/  const int {\em quant\_\-cont}, \/  const gsl\_\-matrix $\ast$ {\em weights}, \/  const {\bf drzstamp\_\-dim} {\em dimension}, \/  gsl\_\-matrix $\ast$ {\em coverage})}}
\label{spce__binning_8c_a48edf641b650f9cded24b2616dc93072}
Function: bin\_\-optimal computes a \hyperlink{structspectrum}{spectrum} from a table of aperture pixels generated from \hyperlink{namespacespc__extract}{spc\_\-extract}. This is adds up the pixel values, distributing them over the trace, taking into account the fracton of the pixel that projects onto the given \mbox{[}xi,xi+1\mbox{]} interval. Return NULL if ap\_\-p is NULL

Parameters: 
\begin{DoxyParams}{Parameters}
\item[{\em ap\_\-p}]the table of aperture pixels \item[{\em px\_\-width}]width of a pixel (=1 if not subsampled) \item[{\em ob\_\-width}]the width of the \hyperlink{structobject}{object} that has generated the \hyperlink{structspectrum}{spectrum} \item[{\em ob\_\-orientation}]the orientation of the \hyperlink{structobject}{object} that has generated the \hyperlink{structspectrum}{spectrum} \item[{\em flags}]problems that were accumulated in generating ap\_\-p; possible flags are defined for the warning member of the \hyperlink{structspectrum}{spectrum} struct\end{DoxyParams}
Returns: \begin{DoxyReturn}{Returns}
spec -\/ the 1D \hyperlink{structspectrum}{spectrum} 
\end{DoxyReturn}



\begin{DoxyCode}
507 {
508 
509   const ap_pixel *cur_p;
510   ap_pixel *tmp_p;
511   spectrum *spec;
512   spectrum *tspec;
513   spc_entry *spec_table;
514 
515   quadrangle quad;
516   //  drzstamp_dim dimension;
517 
518   double jacob, arr;
519   double frac, totweight;
520 
521   int jcen, icen;
522   int jupp, iupp;
523   int jlow, ilow;
524 
525   int ii, jj;
526   int stpi, stpj;
527 
528   // return NULL if
529   // empty PET
530   if (ap_p==NULL)
531     return NULL;
532 
533   // allocate memory
534   tmp_p = (ap_pixel *) malloc(sizeof(ap_pixel));
535 
536 
537   // allocate memory for the spectrum
538   spec = allocate_spectrum (weights->size1);
539   spec_table = spec->spec;
540 
541 
542   // go over each PET pixel
543   cur_p = ap_p;
544   for (cur_p = ap_p; cur_p->p_x != -1; cur_p++)
545     {
546 
547       // continue if the pixel is outside
548       // of the extraction region
549       if (fabs (cur_p->dist) > curbeam.width + .5)
550           continue;
551 
552       // determine which fraction
553       // of the pixel is inside of the extraction area
554       if ((fabs (cur_p->dist) >= curbeam.width - .5) && (fabs (cur_p->dist) <= cu
      rbeam.width + .5))
555         frac = fabs (curbeam.width - (fabs (cur_p->dist) - 0.5));
556       else
557         frac = 1.;
558 
559       // transfer values to the temporary pixel
560       tmp_p->lambda  = cur_p->xi;
561       tmp_p->dist    = cur_p->dist;
562       tmp_p->dxs     = cur_p->dxs;
563       tmp_p->dlambda = 1.0;
564 
565       // create the quadrangle for the current pixel
566       quad = get_quad_from_pixel(tmp_p, curbeam.orient, dimension);
567 
568       // get the jacobian (well, easy here)
569       // the term "cos(cur_p->dxs)" must be there
570       // to correct the enlargement necessary
571       // to cover the whole lambda-crossdispersion area!
572       // NOT COMPLETELY understood
573       jacob = cos(cur_p->dxs);
574 
575       // get the central pixel (icen, jcen) of the current PET-pixel
576       icen = (int) floor(cur_p->xi   - dimension.xstart+.5);
577       jcen = (int) floor(cur_p->dist - dimension.ystart+.5);
578 
579       // get the uper and lower extend of the quadrangle in x
580       iupp = (int)floor(quad.xmax - (double)icen + 0.5)+1;
581       ilow = (int)floor(quad.xmin - (double)icen + 0.5);
582 
583       // get the uper and lower extend of the quadrangle in x
584       jupp = (int)floor(quad.ymax - (double)jcen + 0.5)+1;
585       jlow = (int)floor(quad.ymin - (double)jcen + 0.5);
586 
587       // go over the extend in x
588       for (ii=ilow;ii<iupp;ii++)
589         {
590           // go over the extend in x
591           for (jj=jlow;jj<jupp;jj++)
592             {
593 
594               // get the coordinates of the current output pixel
595               stpi = icen+ii;
596               stpj = jcen+jj;
597 
598               // check whether the current output pixel is within
599               // the stamp image; continue if not
600               if ( (stpi>=dimension.xsize)||(stpi<0)||(stpj>=dimension.ysize)||(s
      tpj<0) )
601                 continue;
602 
603               // get the area which falls onto the current output pixel
604               arr = boxer(stpi,stpj,quad.x,quad.y);
605 
606               // compute the pixel weight from
607               // the various inputs
608               totweight =  arr*frac*jacob*gsl_matrix_get(weights, stpi, stpj);
609               //totweight =  arr*frac*jacob;//*gsl_matrix_get(weights, stpi, stpj
      );
610 
611               //gsl_matrix_set(coverage, stpi, stpj, gsl_matrix_get(coverage, stp
      i, stpj) + arr*frac*jacob);
612 
613               // add the pixel to the spectrum
614               if (totweight > 0.0)
615                 add_to_spec_table (spec, stpi, cur_p, quant_cont,totweight);
616               //              gsl_matrix_set(coverage, stpi, stpj, sqrt (SQR (gsl
      _matrix_get(coverage, stpi, stpj)) + SQR (fabs(cur_p->error) * totweight)));
617             }
618         }
619     }
620 
621 
622 
623   /* Trimming the INDEF beginning and ending values in spectrum */
624   tspec = trim_spectrum (spec);
625   free_spectrum (spec);
626   spec = NULL;
627 
628   free(tmp_p);
629 
630   // return the spectrum
631   return tspec;
632 }
\end{DoxyCode}
\hypertarget{spce__binning_8c_a49f87c0ee85edafe3f007ded3eb2bef9}{
\index{spce\_\-binning.c@{spce\_\-binning.c}!bin\_\-weighted@{bin\_\-weighted}}
\index{bin\_\-weighted@{bin\_\-weighted}!spce_binning.c@{spce\_\-binning.c}}
\subsubsection[{bin\_\-weighted}]{\setlength{\rightskip}{0pt plus 5cm}{\bf spectrum}$\ast$ bin\_\-weighted (const {\bf ap\_\-pixel} $\ast$const  {\em ap\_\-p}, \/  const double {\em ob\_\-orient}, \/  const {\bf trace\_\-func} $\ast$const  {\em trace}, \/  const int {\em n\_\-sub}, \/  const int {\em flags})}}
\label{spce__binning_8c_a49f87c0ee85edafe3f007ded3eb2bef9}
does a straight forward summation/binning of an aperture pixel table with appropriate weights (cf. Hornes 1986)


\begin{DoxyParams}{Parameters}
\item[{\em ap\_\-p}]the table of aperture pixels \item[{\em ob\_\-orient}]the orientation of the \hyperlink{structobject}{object} that has generated the \hyperlink{structspectrum}{spectrum} \item[{\em flags}]problems that were accumulated in generating ap\_\-p; possible flags are defined for the warning member of the \hyperlink{structspectrum}{spectrum} struct \item[{\em n\_\-sub}]subsampling factor \end{DoxyParams}
\begin{DoxyReturn}{Returns}
an allocated \hyperlink{structspectrum}{spectrum} 
\end{DoxyReturn}
\begin{DoxySeeAlso}{See also}
\hyperlink{structspectrum}{spectrum} 
\end{DoxySeeAlso}



\begin{DoxyCode}
654 {
655      gsl_vector *binned_table;
656      gsl_vector *wei_table;
657      gsl_vector *wei2_table;
658 
659      double xi, d, w, wei, wei2;
660      int xii, num_bin, bin;
661      const ap_pixel *cur_p = ap_p;
662      double upper = cur_p->xi, lower = cur_p->xi;
663      spectrum *spec;
664 
665      while (cur_p->p_x != -1)
666        {
667             upper = MAX (cur_p->xi, upper);
668             lower = MIN (cur_p->xi, lower);
669             cur_p++;
670        }
671 
672      lower -= 10;
673      upper += 10;
674 
675      lower = floor (lower);
676      upper = floor (upper + 1);
677 
678      num_bin = floor ((upper - lower) / n_sub);
679      spec = allocate_spectrum (num_bin);
680 
681      binned_table = gsl_vector_alloc (num_bin);
682      wei_table = gsl_vector_alloc (num_bin);
683      wei2_table = gsl_vector_alloc (num_bin);
684 
685      gsl_vector_set_all (binned_table, 0);
686      gsl_vector_set_all (wei_table, 0);
687      gsl_vector_set_all (wei2_table, 0);
688 
689      cur_p = ap_p;
690      while (cur_p->p_x != -1)
691        {
692             xi = (cur_p->xi - lower) / n_sub;
693             xii = floor (xi);
694 
695             d = fabs(cur_p->dist);
696             w = exp (-d * d / (2 * 6.66));
697             w = 1.;
698             add_to_spec_table (spec, xii - 1,cur_p, 0, w * (1 - (xi - xii)));
699             add_to_spec_table (spec, xii   , cur_p, 0, w * (xi - xii));
700 
701             gsl_vector_set (wei_table, xii - 1,
702                             gsl_vector_get (wei_table, xii - 1) + w);
703             gsl_vector_set (wei_table, xii,
704                             gsl_vector_get (wei_table, xii) + w);
705 
706             gsl_vector_set (wei2_table, xii - 1,
707                             gsl_vector_get (wei2_table, xii - 1) + w * w);
708             gsl_vector_set (wei2_table, xii,
709                             gsl_vector_get (wei2_table, xii) + w * w);
710 
711             //fprintf(stderr,"%f,%d,%d\n",xi,xii,xii+1);
712             cur_p++;
713        }
714      cur_p = ap_p;
715      for (bin = 0; bin < num_bin; bin++)
716        {
717             wei = gsl_vector_get (wei_table, bin);
718             wei2 = gsl_vector_get (wei2_table, bin);
719             if (wei2 != 0)
720               {
721                    spec->spec[bin].count = spec->spec[bin].count * wei / wei2;
722               }
723        }
724 
725      spec->warning = 0;
726      return spec;
727 }
\end{DoxyCode}
\hypertarget{spce__binning_8c_ab30f3a9057424879b1e59d544efe5f43}{
\index{spce\_\-binning.c@{spce\_\-binning.c}!fill\_\-w\_\-pixel@{fill\_\-w\_\-pixel}}
\index{fill\_\-w\_\-pixel@{fill\_\-w\_\-pixel}!spce_binning.c@{spce\_\-binning.c}}
\subsubsection[{fill\_\-w\_\-pixel}]{\setlength{\rightskip}{0pt plus 5cm}static void fill\_\-w\_\-pixel ({\bf w\_\-pixel} $\ast$const  {\em pix}, \/  const double {\em x0}, \/  const double {\em y0}, \/  const double {\em angle})\hspace{0.3cm}{\ttfamily  \mbox{[}static\mbox{]}}}}
\label{spce__binning_8c_ab30f3a9057424879b1e59d544efe5f43}
Function: fill\_\-w\_\-pixel precomputes some properties of a given pixel for purposes of computing the weights it contributes to a given xi bin.

Parameters: 
\begin{DoxyParams}{Parameters}
\item[{\em pix}]a pointer to the w\_\-pix structure to fill \item[{\em x0}]the x coordinate of the pixel's lower left corner \item[{\em y0}]the y coordinate of the pixel's lower left corner \item[{\em size}]the size of the pixel \item[{\em angle}]the orientation of the \hyperlink{structobject}{object} that has generated the \hyperlink{structspectrum}{spectrum} \end{DoxyParams}



\begin{DoxyCode}
277 {
278   pix->tana = tan (angle);
279   pix->cota = 1 / pix->tana;
280   pix->angle = angle;
281   pix->x0 = x0;
282   pix->y0 = y0;
283 
284   if ((angle >= M_PI / 4) && (angle <= 3 * M_PI / 4))
285     {
286       pix->p0 = MIN (x0, x0 - 1 * pix->cota);
287       pix->p1 = MAX (x0, x0 - 1 * pix->cota);
288       pix->p2 = MIN (x0 + 1, x0 + 1 - 1 * pix->cota);
289       pix->p3 = MAX (x0 + 1, x0 + 1 - 1 * pix->cota);
290       pix->fmax = 1 / sin (angle);
291 
292       if (fabs (pix->p1 - pix->p0) < 1e-7)
293         pix->slope = 0;
294       else
295         pix->slope = pix->fmax / (pix->p1 - pix->p0);
296 
297       pix->weight_function = &pixweight_x;
298     }
299   else
300     {                   /* angle between 0 and pi/4 or 3*pi/4 and pi */
301       pix->p0 = MIN (y0, y0 - 1 * pix->tana);
302       pix->p1 = MAX (y0, y0 - 1 * pix->tana);
303       pix->p2 = MIN (y0 + 1, y0 + 1 - 1 * pix->tana);
304       pix->p3 = MAX (y0 + 1, y0 + 1 - 1 * pix->tana);
305       pix->fmax = 1 / cos (angle);
306 
307       if (fabs (pix->p1 - pix->p0) < 1e-7)
308         pix->slope = 0;
309       else
310         pix->slope = pix->fmax / (pix->p1 - pix->p0);
311 
312       pix->weight_function = &pixweight_y;
313     }
314 }
\end{DoxyCode}
\hypertarget{spce__binning_8c_aa622d2775b7989396320f7714424dff7}{
\index{spce\_\-binning.c@{spce\_\-binning.c}!pixweight\_\-x@{pixweight\_\-x}}
\index{pixweight\_\-x@{pixweight\_\-x}!spce_binning.c@{spce\_\-binning.c}}
\subsubsection[{pixweight\_\-x}]{\setlength{\rightskip}{0pt plus 5cm}double pixweight\_\-x (const double {\em x1}, \/  const double {\em y1}, \/  const double {\em x2}, \/  const double {\em y2}, \/  const struct {\bf w\_\-pixel\_\-s} $\ast$const  {\em pix})}}
\label{spce__binning_8c_aa622d2775b7989396320f7714424dff7}
Function: pixweight\_\-x computes a weight for the bin between coordinates (x1,y1) and (x2,y2) if the pi/4$<$=angle$<$=3 pi/4.

Parameters: 
\begin{DoxyParams}{Parameters}
\item[{\em x1}]-\/ x coordinate for the start point of the bin on the trace \item[{\em y1}]-\/ y coordinate for the start point of the bin on the trace \item[{\em x2}]-\/ x coordinate for the end point of the bin on the trace \item[{\em y2}]-\/ y coordinate for the end point of the bin on the trace \item[{\em pix}]the pixel to compute the weight for in the form of a w\_\-pixel structure filled out by fill\_\-w\_\-pixel\end{DoxyParams}
Returns: \begin{DoxyReturn}{Returns}
sum -\/ the pixel weight 
\end{DoxyReturn}



\begin{DoxyCode}
176 {
177   double a, b;
178   double sum = 0;
179 
180   a = x1 - pix->cota * (y1 - pix->y0);
181   b = x2 - pix->cota * (y2 - pix->y0);
182   if ((b >= pix->p0) && (a <= pix->p1))
183     {
184       sum += pix->slope / 2 * (MIN (b, pix->p1) - MAX (a, pix->p0))
185         * (MAX (a, pix->p0) - 2 * pix->p0 + MIN (b, pix->p1))
186         * sin (pix->angle);
187     }
188   if ((b >= pix->p1) && (a <= pix->p2))
189     {
190       sum += pix->fmax * (MIN (b, pix->p2) - MAX (a, pix->p1))
191         * sin (pix->angle);
192        }
193   if ((b >= pix->p2) && (a <= pix->p3))
194     {
195       sum += pix->slope / 2 * (MAX (a, pix->p2) - MIN (b, pix->p3))
196         * (MAX (a, pix->p2) - 2 * pix->p3 + MIN (b, pix->p3))
197         * sin (pix->angle);
198     }
199   return sum;
200 }
\end{DoxyCode}
\hypertarget{spce__binning_8c_a779dbcd6b7ffb343f78c061db7bf44fe}{
\index{spce\_\-binning.c@{spce\_\-binning.c}!pixweight\_\-y@{pixweight\_\-y}}
\index{pixweight\_\-y@{pixweight\_\-y}!spce_binning.c@{spce\_\-binning.c}}
\subsubsection[{pixweight\_\-y}]{\setlength{\rightskip}{0pt plus 5cm}double pixweight\_\-y (const double {\em x1}, \/  const double {\em y1}, \/  const double {\em x2}, \/  const double {\em y2}, \/  const struct {\bf w\_\-pixel\_\-s} $\ast$const  {\em pix})}}
\label{spce__binning_8c_a779dbcd6b7ffb343f78c061db7bf44fe}
Funtion: pixweight\_\-y Computes a weight for the bin between coordinates (x1,y1) and (x2,y2) if the angle$<$=pi/4 or 3 pi/4$<$=angle.


\begin{DoxyParams}{Parameters}
\item[{\em x1}]-\/ x coordinate for the start point of the bin on the trace \item[{\em y1}]-\/ y coordinate for the start point of the bin on the trace \item[{\em x2}]-\/ x coordinate for the end point of the bin on the trace \item[{\em y2}]-\/ y coordinate for the end point of the bin on the trace \item[{\em pix}]-\/ the pixel to compute the weight for in the form of a w\_\-pixel structure filled out by fill\_\-w\_\-pixel\end{DoxyParams}
Returns: \begin{DoxyReturn}{Returns}
sum -\/ the pixel weight 
\end{DoxyReturn}



\begin{DoxyCode}
221 {
222   double a, b;
223   double sum = 0;
224 
225   a = y1 + pix->tana * (pix->x0 - x1);
226   b = y2 + pix->tana * (pix->x0 - x2);
227   if (a > b)
228     {
229       double tmp;
230       tmp = a;
231       a = b;
232       b = tmp;
233     }
234 
235   if ((b >= pix->p0) && (a <= pix->p1))
236     {
237       sum += pix->slope / 2 * (MIN (b, pix->p1) - MAX (a, pix->p0))
238         * (MAX (a, pix->p0) - 2 * pix->p0 + MIN (b, pix->p1))
239         * cos (pix->angle);
240     }
241   if ((b >= pix->p1) && (a <= pix->p2))
242     {
243       sum += pix->fmax * (MIN (b, pix->p2) - MAX (a, pix->p1))
244         * cos (pix->angle);
245     }
246   if ((b >= pix->p2) && (a <= pix->p3))
247     {
248       sum += pix->slope / 2 * (MAX (a, pix->p2) - MIN (b, pix->p3))
249         * (MAX (a, pix->p2) - 2 * pix->p3 + MIN (b, pix->p3))
250         * cos (pix->angle);
251     }
252   return sum;
253 }
\end{DoxyCode}
