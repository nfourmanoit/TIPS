\hypertarget{aXe__AF2PET_8c}{
\section{/renoir/fourmano/Desktop/OUSIM/TIPS/branches/tips\_\-build/src/axesim/aXe\_\-AF2PET.c File Reference}
\label{aXe__AF2PET_8c}\index{/renoir/fourmano/Desktop/OUSIM/TIPS/branches/tips\_\-build/src/axesim/aXe\_\-AF2PET.c@{/renoir/fourmano/Desktop/OUSIM/TIPS/branches/tips\_\-build/src/axesim/aXe\_\-AF2PET.c}}
}
{\ttfamily \#include $<$stdio.h$>$}\par
{\ttfamily \#include $<$stdlib.h$>$}\par
{\ttfamily \#include $<$string.h$>$}\par
{\ttfamily \#include $<$math.h$>$}\par
{\ttfamily \#include \char`\"{}aXe\_\-grism.h\char`\"{}}\par
{\ttfamily \#include \char`\"{}aXe\_\-utils.h\char`\"{}}\par
{\ttfamily \#include \char`\"{}spce\_\-PET.h\char`\"{}}\par
{\ttfamily \#include \char`\"{}inout\_\-aper.h\char`\"{}}\par
{\ttfamily \#include \char`\"{}trace\_\-conf.h\char`\"{}}\par
{\ttfamily \#include \char`\"{}aper\_\-conf.h\char`\"{}}\par
{\ttfamily \#include \char`\"{}spc\_\-sex.h\char`\"{}}\par
{\ttfamily \#include \char`\"{}disp\_\-conf.h\char`\"{}}\par
{\ttfamily \#include \char`\"{}spc\_\-wl\_\-calib.h\char`\"{}}\par
\subsection*{Defines}
\begin{DoxyCompactItemize}
\item 
\#define \hyperlink{aXe__AF2PET_8c_a7a38b874452a6cde6ebee9e98c980eef}{AXE\_\-IMAGE\_\-PATH}~\char`\"{}AXE\_\-IMAGE\_\-PATH\char`\"{}
\item 
\#define \hyperlink{aXe__AF2PET_8c_a75c154942e560254898bcafaf48bdf3d}{AXE\_\-OUTPUT\_\-PATH}~\char`\"{}AXE\_\-OUTPUT\_\-PATH\char`\"{}
\item 
\#define \hyperlink{aXe__AF2PET_8c_a0b0be957330d9c69fa325ee014ce4dad}{AXE\_\-CONFIG\_\-PATH}~\char`\"{}AXE\_\-CONFIG\_\-PATH\char`\"{}
\end{DoxyCompactItemize}
\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
int \hyperlink{aXe__AF2PET_8c_a0ddf1224851353fc92bfbff6f499fa97}{main} (int argc, char $\ast$argv\mbox{[}$\,$\mbox{]})
\end{DoxyCompactItemize}


\subsection{Define Documentation}
\hypertarget{aXe__AF2PET_8c_a0b0be957330d9c69fa325ee014ce4dad}{
\index{aXe\_\-AF2PET.c@{aXe\_\-AF2PET.c}!AXE\_\-CONFIG\_\-PATH@{AXE\_\-CONFIG\_\-PATH}}
\index{AXE\_\-CONFIG\_\-PATH@{AXE\_\-CONFIG\_\-PATH}!aXe_AF2PET.c@{aXe\_\-AF2PET.c}}
\subsubsection[{AXE\_\-CONFIG\_\-PATH}]{\setlength{\rightskip}{0pt plus 5cm}\#define AXE\_\-CONFIG\_\-PATH~\char`\"{}AXE\_\-CONFIG\_\-PATH\char`\"{}}}
\label{aXe__AF2PET_8c_a0b0be957330d9c69fa325ee014ce4dad}
\hypertarget{aXe__AF2PET_8c_a7a38b874452a6cde6ebee9e98c980eef}{
\index{aXe\_\-AF2PET.c@{aXe\_\-AF2PET.c}!AXE\_\-IMAGE\_\-PATH@{AXE\_\-IMAGE\_\-PATH}}
\index{AXE\_\-IMAGE\_\-PATH@{AXE\_\-IMAGE\_\-PATH}!aXe_AF2PET.c@{aXe\_\-AF2PET.c}}
\subsubsection[{AXE\_\-IMAGE\_\-PATH}]{\setlength{\rightskip}{0pt plus 5cm}\#define AXE\_\-IMAGE\_\-PATH~\char`\"{}AXE\_\-IMAGE\_\-PATH\char`\"{}}}
\label{aXe__AF2PET_8c_a7a38b874452a6cde6ebee9e98c980eef}
\hypertarget{aXe__AF2PET_8c_a75c154942e560254898bcafaf48bdf3d}{
\index{aXe\_\-AF2PET.c@{aXe\_\-AF2PET.c}!AXE\_\-OUTPUT\_\-PATH@{AXE\_\-OUTPUT\_\-PATH}}
\index{AXE\_\-OUTPUT\_\-PATH@{AXE\_\-OUTPUT\_\-PATH}!aXe_AF2PET.c@{aXe\_\-AF2PET.c}}
\subsubsection[{AXE\_\-OUTPUT\_\-PATH}]{\setlength{\rightskip}{0pt plus 5cm}\#define AXE\_\-OUTPUT\_\-PATH~\char`\"{}AXE\_\-OUTPUT\_\-PATH\char`\"{}}}
\label{aXe__AF2PET_8c_a75c154942e560254898bcafaf48bdf3d}


\subsection{Function Documentation}
\hypertarget{aXe__AF2PET_8c_a0ddf1224851353fc92bfbff6f499fa97}{
\index{aXe\_\-AF2PET.c@{aXe\_\-AF2PET.c}!main@{main}}
\index{main@{main}!aXe_AF2PET.c@{aXe\_\-AF2PET.c}}
\subsubsection[{main}]{\setlength{\rightskip}{0pt plus 5cm}int main (int {\em argc}, \/  char $\ast$ {\em argv}\mbox{[}$\,$\mbox{]})}}
\label{aXe__AF2PET_8c_a0ddf1224851353fc92bfbff6f499fa97}



\begin{DoxyCode}
42 {
43 
44   char           *opt;
45   char            grism_image[MAXCHAR];
46   char            grism_image_path[MAXCHAR];
47 
48   char            conf_file[MAXCHAR];
49   char            conf_file_path[MAXCHAR];
50 
51   char            aper_file[MAXCHAR];
52   char            aper_file_path[MAXCHAR];
53 
54   char            PET_file[MAXCHAR];
55   char            PET_file_path[MAXCHAR];
56 
57   char            hdu_name[MAXCHAR];
58 
59   int             i, j, flags, for_grism;
60 
61   object        **oblist;
62   observation    *obs;
63 
64   ap_pixel       *result = NULL;
65   d_point         pixel;
66   aperture_conf  *conf;
67 
68   dispstruct     *disp;
69   calib_function *wl_calibration;
70   global_disp    *gdisp;
71 
72   gsl_vector     *p_range=NULL;
73 
74   FITScards      *cards;
75 
76   int             f_status = 0;
77 
78   int             bckmode = 0;
79 
80   fitsfile       *PET_fitsptr;
81 
82   int err_num=0, dq_num=0, extver=0;
83 
84   double exptime;
85 
86   if ((argc < 3) || (opt = get_online_option("help", argc, argv))) {
87     fprintf(stdout,
88             "aXe_AF2PET Version %s:\n"
89             "           aXe task that produce an Object or Background  Pixel Extr
      action\n"
90             "           Table (-bck option) using an input aperture file (AF) and
       an aXe\n"
91             "           config file which defines the geometry involved (a polyno
      mial\n"
92             "           describing the position of the spectral trace for each be
      am\n"
93             "           (order), and a polynomial description of the wavelength\n
      "
94             "           dispersion. Both of these can be field dependent. The PET
      \n"
95             "           files are multi extension FITS binary table. Each extensi
      on\n"
96             "           contains information about each of the pixel inside one o
      f the\n"
97             "           beam listed in the input aperture file.\n"
98             "\n"
99             "           Input FITS mages are looked for in $AXE_IMAGE_PATH\n"
100             "           aXe config file is looked for in $AXE_CONFIG_PATH\n"
101             "           All outputs are writen to $AXE_OUTPUT_PATH\n"
102             "\n"
103             "Usage:\n"
104             "      aXe_AF2PET [g/prism image filename] [aXe config filename] [opt
      ions]\n"
105             "\n"
106             "Options:\n"
107             "           -bck               - generating a PET for a background im
      age\n"
108             "                                using a BAF file instead of a OAF fi
      le and\n"
109             "                                using a background image generated b
      y aXe_BE\n"
110             "           -out_PET           - overwrite the default output PET fil
      ename\n"
111             "           -SCI_hdu=[integer] - overwrite the default from the aXe c
      onfig file\n"
112             "           -ERR_hdu=[integer] - overwrite the default from the aXe c
      onfig file\n"
113             "           -DQ_hdu=[integer]  - overwrite the default from the aXe c
      onfig file \n"
114             "\n"
115             "Example:\n"
116             "        aXe_AF2PET slim_grismb.fits SLIM.conf.A.0\n"
117             "\n", RELEASE);
118     exit(1);
119   }
120   fprintf(stdout, "aXe_AF2PET: Starting...\n");
121 
122   /* Get the data file name */
123   strcpy(grism_image, argv[1]);
124 
125   /* Get the configuration file name */
126   strcpy(conf_file, argv[2]);
127   build_path(AXE_CONFIG_PATH, conf_file, conf_file_path);
128 
129   /* Read the configuration file */
130   conf = get_aperture_descriptor(conf_file_path);
131 
132 
133   /* Determine where the various extensions are in the FITS file */
134   build_path(AXE_IMAGE_PATH, grism_image, grism_image_path);
135   get_extension_numbers(grism_image_path, conf, conf->optkey1, conf->optval1);
136   /* Determine if we are using the special bck mode */
137   /* In this mode, file names are handled diferently */
138   if ((opt = get_online_option("bck", argc, argv)))
139     bckmode = 1;
140 
141   /* Get or set up the input AF file name */
142   if (opt = get_online_option("in_AF", argc, argv))
143     {
144       strcpy(aper_file, opt);
145       strcpy(aper_file_path, opt);
146     }
147   else
148     {
149       replace_file_extension(grism_image, aper_file, ".fits",
150                            ".OAF", conf->science_numext);
151       build_path(AXE_OUTPUT_PATH, aper_file, aper_file_path);
152     }
153 
154   if (bckmode) {
155     /* apply aXe_AF2PET to a background image */
156     build_path(AXE_OUTPUT_PATH, grism_image, grism_image_path);
157 
158     /* Fix the aperture file name */
159     //replace_file_extension(grism_image, aper_file, ".fits",
160     //                       ".OAF", conf->science_numext);
161     //build_path(AXE_OUTPUT_PATH, aper_file, aper_file_path);
162                 /* Fix the grism image name to include a .BCK.fits */
163     {
164       char tmp[MAXCHAR];
165       strcpy(tmp, grism_image);
166       replace_file_extension(tmp, grism_image, ".fits"
167                              ,".BCK.fits", conf->science_numext);
168 
169       build_path(AXE_OUTPUT_PATH, grism_image, grism_image_path);
170       /* Get the proper extension number from the BCK file */
171       get_extension_numbers(grism_image_path, conf, "None", 0);
172     }
173   } else {
174 
175     build_path(AXE_IMAGE_PATH, grism_image, grism_image_path);
176     get_extension_numbers(grism_image_path, conf, conf->optkey1, conf->optval1);
177     /* Fix the aperture file name */
178     //replace_file_extension(grism_image, aper_file, ".fits",
179     //                       ".OAF", conf->science_numext);
180     //build_path(AXE_OUTPUT_PATH, aper_file, aper_file_path);
181 
182   }
183 
184   /* Online parameter overwrite all */
185   if ((opt = get_online_option("SCI_hdu", argc, argv))) {
186     conf->science_numext = atoi(opt);
187   }
188   if ((opt = get_online_option("ERR_hdu", argc, argv))) {
189     conf->errors_numext = atoi(opt);
190   }
191   if ((opt = get_online_option("DQ_hdu", argc, argv))) {
192     conf->dq_numext = atoi(opt);
193   }
194   /* Get or set up the output PET file name */
195   if ((opt = get_online_option("out_PET", argc, argv))) {
196     strcpy(PET_file, opt);
197     strcpy(PET_file_path, opt);
198   } else {
199     strcpy(PET_file, grism_image);
200     if (bckmode) {
201       replace_file_extension(grism_image, PET_file, ".fits",
202                              ".PET.fits", -1);
203     } else {
204       replace_file_extension(grism_image, PET_file, ".fits",
205                              ".PET.fits", conf->science_numext);
206     }
207     build_path(AXE_OUTPUT_PATH, PET_file, PET_file_path);
208   }
209 
210   fprintf(stdout,
211           "aXe_AF2PET: Input configuration file name:   %s\n",
212           conf_file_path);
213   fprintf(stdout,
214           "aXe_AF2PET: Input data file name:            %s\n",
215           grism_image_path);
216   fprintf(stdout,
217           "aXe_AF2PET: SCI extension number:            %d\n",
218           conf->science_numext);
219   fprintf(stdout,
220           "aXe_AF2PET: ERR extension number:            %d\n",
221           conf->errors_numext);
222   fprintf(stdout,
223           "aXe_AF2PET: DQ extension number:             %d\n",
224           conf->dq_numext);
225   fprintf(stdout,
226           "aXe_AF2PET: DQ mask:                         %d\n",
227           conf->dqmask);
228   fprintf(stdout,
229           "aXe_AF2PET: Input aperture file name:        %s\n",
230           aper_file_path);
231   fprintf(stdout,
232           "aXe_AF2PET: Output Pixel Extraction Table \n"
233           "            (PET) file name:                 %s\n",
234           PET_file_path);
235   fprintf(stdout, "\n\n");
236 
237   /* Loading the observation data */
238   fprintf(stdout, "aXe_AF2PET: ");
239 
240   //
241   // try to get the descriptor 'exptime' from the 'sci'-extension
242   //
243   exptime = (double)get_float_from_keyword(grism_image_path, conf->
      science_numext, conf->exptimekey);
244   if (isnan(exptime))
245     exptime = (double)get_float_from_keyword(grism_image_path, 1, conf->
      exptimekey);
246   if (isnan(exptime))
247     exptime = 1.0;
248 
249   if (bckmode)
250     {
251       sprintf (hdu_name, "ERR");
252       err_num = get_hdunum_from_hduname(grism_image_path, hdu_name,
253                                         conf->optkey1,conf->optval1,extver);
254       sprintf (hdu_name, "DQ");
255       dq_num = get_hdunum_from_hduname(grism_image_path, hdu_name,
256                                        conf->optkey1,conf->optval1,extver);
257 
258 
259       /* Load a background image from AXE_OUTPUT_PATH */
260       obs = load_image_t(grism_image_path, 2, err_num, dq_num, conf->dqmask, expt
      ime, conf->rdnoise);
261     }
262   else
263     {
264       /* Load an image from AXE_DATA_PATH */
265       obs = load_image_t(grism_image_path, conf->science_numext,
266                          conf->errors_numext, conf->dq_numext,
267                          conf->dqmask, exptime, conf->rdnoise);
268     }
269 
270 
271 
272   /* Loading the object list */
273   fprintf(stdout, "aXe_AF2PET: Loading object list...");
274   oblist = file_to_object_list_seq(aper_file_path, obs);
275   fprintf(stdout, "%d objects loaded.\n", object_list_size(oblist));
276 
277   /* Create a new empty PET file */
278   PET_fitsptr = create_PET_opened(PET_file_path, 1);
279   /* Copy the header info from the grism image */
280   {
281     FITScards      *cards;
282     cards = get_FITS_cards(grism_image_path, 1);
283     put_FITS_cards_opened(PET_fitsptr, cards);
284     free_FITScards(cards);
285   }
286 
287 
288   i = 0;
289   if (oblist != NULL) {
290     while (oblist[i] != NULL) {
291       fprintf(stdout, "aXe_AF2PET: Extracting object ID:%d",
292               oblist[i]->ID);
293       for (j = 0; j < oblist[i]->nbeams; j++) {
294         /*
295          * skip beam if ignore flag for thisbeam is
296          * set
297          */
298         if (oblist[i]->beams[j].ignore !=0)
299           {
300             fprintf(stdout,", %c ( Ignored )",
301                     BEAM(oblist[i]->beams[j].ID));
302             continue;
303           }
304         fprintf(stdout, ", %c (Extracted)",
305                 BEAM(oblist[i]->beams[j].ID));
306 
307         quad_to_bbox(oblist[i]->beams[j].corners,
308                      oblist[i]->beams[j].bbox,
309                      oblist[i]->beams[j].bbox + 1);
310         result = make_spc_table(oblist[i], j, &flags);
311 
312         /************************/
313         /* Wavelength calibrate */
314         /************************/
315 
316         /*
317          * get the wavelength dispersion relation at
318          * position "refpoint". conf->refx and conf->refy
319          * are used at this point to allow for a non (0,0) centered
320          * 2D field dependence.
321          */
322         pixel.x = oblist[i]->beams[j].refpoint.x - conf->refx;
323         pixel.y = oblist[i]->beams[j].refpoint.y - conf->refy;
324 
325         /*
326          * check whether it is grism (for_grism=1)
327          * or prism (for_grism=0) data
328          */
329         for_grism = check_for_grism (conf_file_path,oblist[i]->beams[j].ID);
330 
331         // this should be done better
332         // the hard limit to FORS applications
333         // is no good!
334         if (!strcmp(conf->camera, "FORS2"))
335           {
336             fprintf(stdout, "camera: %s\n", conf->camera);
337             disp = get_dispstruct_at_pos(conf_file_path, for_grism,
338                                          oblist[i]->beams[j].ID,pixel);
339             wl_calibration = create_calib_from_gsl_vector(for_grism, disp->pol);
340 
341             gdisp = get_global_disp(conf_file_path, for_grism, oblist[i]->beams[j
      ].ID);
342 
343             pwise_wl_calib(gdisp, pixel, oblist[i]->beams[j], for_grism, result, 
      wl_calibration);
344 
345             free_global_disp(gdisp);
346             free_calib(wl_calibration);
347           }
348         else
349           {
350             disp = get_dispstruct_at_pos(conf_file_path, for_grism,
351                                          oblist[i]->beams[j].ID,pixel);
352 
353             wl_calibration = create_calib_from_gsl_vector(for_grism, disp->pol);
354 
355             /* for grism data: get the allowed trace range */
356             if (!for_grism){
357               p_range = get_prange(conf_file_path, oblist[i]->beams[j].ID);
358               /* in case that a trace range is defined,
359                * trim the PET down to only the allowed
360                * trace range
361                */
362               if (p_range != NULL)
363                 result = prange_cut(result, p_range, wl_calibration);
364             }
365 
366             /* apply the wavelength calibration */
367             wl_calib(result, wl_calibration);
368 
369             /* free the memory in the calibration structure */
370             free_calib(wl_calibration);
371 
372           }
373 
374         {
375           char            ID[60], IDindex[60];
376           sprintf(ID, "%d%c", oblist[i]->ID, BEAM(oblist[i]->beams[j].ID));
377           sprintf(IDindex, "ID%s", ID);
378           add_ALL_to_PET(result, ID, PET_fitsptr, 0);
379         }
380 
381         /*
382          * Add information about the object/beam into
383          * FITS header
384          */
385         cards = beam_to_FITScards(oblist[i], j);
386         put_FITS_cards_opened(PET_fitsptr, cards);
387         free_FITScards(cards);
388 
389         /*
390          * Add information about the wavelength
391          * calibration
392          */
393         cards = dispstruct_to_FITScards(disp);
394         put_FITS_cards_opened(PET_fitsptr, cards);
395         free_FITScards(cards);
396 
397         //fprintf_ap_pixel_list (stdout, result);
398 
399         free_dispstruct(disp);
400         if (result!=NULL)
401           {
402             free(result);
403             result = NULL;
404           }
405       }
406       fprintf(stdout, " Done.\n");
407       i++;
408     }
409   }
410   fits_close_file(PET_fitsptr, &f_status);
411   if (f_status) {
412     aXe_message(aXe_M_FATAL, __FILE__, __LINE__,
413                 "aXe_AF2PET: " "Error closing PET: %s \n",
414                 PET_file_path);
415   }
416   free_observation(obs);
417   if (oblist != NULL){
418         free_oblist(oblist);}
419   fprintf(stdout, "aXe_AF2PET: Done...\n");
420 
421   exit(0);
422 }
\end{DoxyCode}
