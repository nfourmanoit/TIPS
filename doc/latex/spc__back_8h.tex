\hypertarget{spc__back_8h}{
\section{/renoir/fourmano/Desktop/OUSIM/TIPS/branches/tips\_\-build/include/axesim/spc\_\-back.h File Reference}
\label{spc__back_8h}\index{/renoir/fourmano/Desktop/OUSIM/TIPS/branches/tips\_\-build/include/axesim/spc\_\-back.h@{/renoir/fourmano/Desktop/OUSIM/TIPS/branches/tips\_\-build/include/axesim/spc\_\-back.h}}
}
{\ttfamily \#include \char`\"{}spce\_\-is\_\-in.h\char`\"{}}\par
\subsection*{Data Structures}
\begin{DoxyCompactItemize}
\item 
struct \hyperlink{structs__background}{s\_\-background}
\item 
struct \hyperlink{structfullimg__background}{fullimg\_\-background}
\end{DoxyCompactItemize}
\subsection*{Namespaces}
\begin{DoxyCompactItemize}
\item 
namespace \hyperlink{namespacespc__back}{spc\_\-back}
\end{DoxyCompactItemize}
\subsection*{Defines}
\begin{DoxyCompactItemize}
\item 
\#define \hyperlink{spc__back_8h_a84af820cbb7ca83ada7bf0c1aba8d02f}{DQ\_\-KAPPA\_\-SIGMA}~-\/1.0
\end{DoxyCompactItemize}
\subsection*{Typedefs}
\begin{DoxyCompactItemize}
\item 
typedef struct \hyperlink{structs__background}{s\_\-background} \hyperlink{spc__back_8h_ab2c0ecaa7f56a327523e82008703ae91}{background}
\end{DoxyCompactItemize}
\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
int \hyperlink{spc__back_8h_ac1c2518944b7c7dbaa14041f46c07187}{is\_\-pt\_\-in\_\-a\_\-beam} (const \hyperlink{structpx__point}{px\_\-point} $\ast$const apoint, const \hyperlink{structis__in__descriptor}{is\_\-in\_\-descriptor} $\ast$const iids, const int tnbeams)
\item 
void \hyperlink{spc__back_8h_a522b515cc91be30ce47801291ac7a752}{compute\_\-background2} (\hyperlink{structobject}{object} $\ast$$\ast$oblist, const int obj\_\-index, const int beamorder, gsl\_\-matrix $\ast$bck\_\-mask, const int tnbeams, \hyperlink{structfullimg__background}{fullimg\_\-background} $\ast$fib, int npoints, int interporder)
\item 
gsl\_\-vector\_\-int $\ast$ \hyperlink{spc__back_8h_a55bae5da45fa33dec8efc0f57981f1e4}{get\_\-interp\_\-points} (\hyperlink{structobservation}{observation} $\ast$obs, gsl\_\-matrix $\ast$bck\_\-mask, int np, \hyperlink{structpx__point}{px\_\-point} tr\_\-point)
\item 
void \hyperlink{spc__back_8h_ad45826f8c0ede1b55ed2f5d6fd67e875}{compute\_\-background} (\hyperlink{structobservation}{observation} $\ast$obs, \hyperlink{structbeam}{beam} actbeam, gsl\_\-matrix $\ast$bck\_\-mask, \hyperlink{structfullimg__background}{fullimg\_\-background} $\ast$fib, int npoints, int interporder, const int niter\_\-med, const int niter\_\-fit, const double kappa)
\item 
void \hyperlink{spc__back_8h_ac5915dcfa3d4bd357a95fcd4f827c3a1}{compute\_\-global\_\-background} (\hyperlink{structobject}{object} $\ast$$\ast$oblist, const int obj\_\-index, gsl\_\-matrix $\ast$bck\_\-mask, \hyperlink{structfullimg__background}{fullimg\_\-background} $\ast$fib, int interporder)
\item 
void \hyperlink{spc__back_8h_a312989afed586d6646f6c5e46d94c5b2}{fullimg\_\-background\_\-function} (const int x, const int y, PIXEL\_\-T $\ast$const val, PIXEL\_\-T $\ast$const err, const \hyperlink{structs__background}{background} $\ast$const back)
\item 
\hyperlink{structs__background}{background} $\ast$ \hyperlink{spc__back_8h_a6f31bd7324fece185dcac65eb5582b41}{compute\_\-fullimg\_\-background2} (\hyperlink{structobservation}{observation} $\ast$obs, \hyperlink{structobject}{object} $\ast$$\ast$oblist, int npoints, int interporder)
\item 
\hyperlink{structs__background}{background} $\ast$ \hyperlink{spc__back_8h_ac8525170561017c1ebf7946f1e37b57b}{compute\_\-fullimg\_\-background} (\hyperlink{structobservation}{observation} $\ast$obs, \hyperlink{structobject}{object} $\ast$$\ast$oblist, int npoints, int interporder, const int niter\_\-med, const int niter\_\-fit, const double kappa, int nor\_\-flag, const int sm\_\-length, const double fwhm)
\item 
\hyperlink{structs__background}{background} $\ast$ \hyperlink{spc__back_8h_ae8622f5f1124511fcbc7ddf2205d4e0f}{compute\_\-backsub\_\-mask} (\hyperlink{structobservation}{observation} $\ast$obs, \hyperlink{structobject}{object} $\ast$$\ast$oblist)
\item 
\hyperlink{structs__background}{background} $\ast$ \hyperlink{spc__back_8h_af64d42951a54cd249fcbb6f793096acd}{compute\_\-fullimg\_\-global\_\-background} (\hyperlink{structobservation}{observation} $\ast$obs, \hyperlink{structobject}{object} $\ast$$\ast$oblist, int interporder, const int sm\_\-length, const double fwhm)
\item 
void \hyperlink{spc__back_8h_a93385bb1fe9bbdba33d07ccfa28fbad9}{free\_\-fullimg\_\-background} (\hyperlink{structs__background}{background} $\ast$const fib)
\item 
void \hyperlink{spc__back_8h_a5244945f780b5c1e41997c970df2ee49}{background\_\-to\_\-FITSimage} (char filename\mbox{[}$\,$\mbox{]}, \hyperlink{structs__background}{background} $\ast$bck, \hyperlink{structobservation}{observation} $\ast$obs)
\item 
gsl\_\-matrix $\ast$ \hyperlink{spc__back_8h_a84505bc11501c5f2abc6c1f45d68e79b}{aperture\_\-mask} (\hyperlink{structobservation}{observation} $\ast$const obs, \hyperlink{structobject}{object} $\ast$$\ast$oblist)
\item 
void \hyperlink{spc__back_8h_a17d5c8763243b26091aceb119ac98557}{comp\_\-vector\_\-interp} (const double $\ast$const xs, double $\ast$const ys, double $\ast$const ws, double $\ast$const yi, const int n, const int interp, const int final)
\item 
void \hyperlink{spc__back_8h_a135c17132984f8af8cf6d4f13ee9dbb7}{comp\_\-kappasigma\_\-interp} (const double $\ast$const xs, double $\ast$const ys, double $\ast$const ws, const int n, const int interp, const int niter, const double kappa, \hyperlink{structobservation}{observation} $\ast$obs, int colnum)
\item 
void \hyperlink{spc__back_8h_afe2e18a7ee7b967b8d71d7e1fb316ea7}{kappa\_\-sigma\_\-clipp} (const double $\ast$const xs, double $\ast$const ys, double $\ast$const ws, const int n, const double kappa, \hyperlink{structobservation}{observation} $\ast$obs, int colnum)
\item 
\hyperlink{structpx__point}{px\_\-point} \hyperlink{spc__back_8h_ad7c9963cb80da0010581906c46dde765}{get\_\-xrange} (\hyperlink{structobservation}{observation} $\ast$obs, \hyperlink{structbeam}{beam} actbeam)
\item 
void \hyperlink{spc__back_8h_a7e25af7fc45ffda6d9b8c6612219a32f}{gsmooth\_\-background} (const gsl\_\-matrix $\ast$bck\_\-mask, const int smooth\_\-length, const double fwhm, \hyperlink{structfullimg__background}{fullimg\_\-background} $\ast$fib)
\item 
double \hyperlink{spc__back_8h_ace0c3cfc253b812f88ed84838d0abec2}{get\_\-weighted\_\-mean} (const gsl\_\-vector $\ast$pixvalues, const gsl\_\-vector $\ast$weights, const gsl\_\-vector $\ast$pmask)
\item 
void \hyperlink{spc__back_8h_afa7a0622ef0b42500dbce17be8f268a4}{fill\_\-pixvalues} (const gsl\_\-matrix $\ast$bck\_\-mask, const int smooth\_\-length, const \hyperlink{structfullimg__background}{fullimg\_\-background} $\ast$fib, const int ix, const int iy, gsl\_\-vector $\ast$pixvalues, gsl\_\-vector $\ast$pmask)
\item 
double \hyperlink{spc__back_8h_abf5f23ed5ff402f6f7f71fd32eed9164}{compute\_\-gvalue} (const double xdiff, const double efactor)
\item 
double \hyperlink{spc__back_8h_ad1ce027d8c85366289610daf4ee9ac12}{compute\_\-efactor} (const double fwhm)
\end{DoxyCompactItemize}


\subsection{Define Documentation}
\hypertarget{spc__back_8h_a84af820cbb7ca83ada7bf0c1aba8d02f}{
\index{spc\_\-back.h@{spc\_\-back.h}!DQ\_\-KAPPA\_\-SIGMA@{DQ\_\-KAPPA\_\-SIGMA}}
\index{DQ\_\-KAPPA\_\-SIGMA@{DQ\_\-KAPPA\_\-SIGMA}!spc_back.h@{spc\_\-back.h}}
\subsubsection[{DQ\_\-KAPPA\_\-SIGMA}]{\setlength{\rightskip}{0pt plus 5cm}\#define DQ\_\-KAPPA\_\-SIGMA~-\/1.0}}
\label{spc__back_8h_a84af820cbb7ca83ada7bf0c1aba8d02f}


\subsection{Typedef Documentation}
\hypertarget{spc__back_8h_ab2c0ecaa7f56a327523e82008703ae91}{
\index{spc\_\-back.h@{spc\_\-back.h}!background@{background}}
\index{background@{background}!spc_back.h@{spc\_\-back.h}}
\subsubsection[{background}]{\setlength{\rightskip}{0pt plus 5cm}typedef struct {\bf s\_\-background}
 {\bf background}}}
\label{spc__back_8h_ab2c0ecaa7f56a327523e82008703ae91}
A descriptor of a background, consisting of a function to compute the background at absolute position x,y and a parameter block (e.g., matrices containing the background) 

\subsection{Function Documentation}
\hypertarget{spc__back_8h_a84505bc11501c5f2abc6c1f45d68e79b}{
\index{spc\_\-back.h@{spc\_\-back.h}!aperture\_\-mask@{aperture\_\-mask}}
\index{aperture\_\-mask@{aperture\_\-mask}!spc_back.h@{spc\_\-back.h}}
\subsubsection[{aperture\_\-mask}]{\setlength{\rightskip}{0pt plus 5cm}gsl\_\-matrix$\ast$ aperture\_\-mask ({\bf observation} $\ast$const  {\em obs}, \/  {\bf object} $\ast$$\ast$ {\em oblist})}}
\label{spc__back_8h_a84505bc11501c5f2abc6c1f45d68e79b}
Function: aperture\_\-mask This functions returns an image mask where pixels that are within an aperture are set to the number of aperture they appear. Skips any beams which are set to be ignored (ignore=1)

Parameters: 
\begin{DoxyParams}{Parameters}
\item[{\em obs}]-\/ a pointer to an \hyperlink{structobservation}{observation} structure \item[{\em oblist}]-\/ a pointer to an \hyperlink{structobject}{object} list\end{DoxyParams}
Returns: \begin{DoxyReturn}{Returns}
bck -\/ a pointer to a gsl\_\-matrix 
\end{DoxyReturn}



\begin{DoxyCode}
1336 {
1337 
1338   int x, y,i=0,j;
1339 
1340   double xrel, yrel, width;
1341 
1342   is_in_descriptor iid;
1343   px_point ll, ur;
1344   gsl_matrix *bck;
1345   sectionfun sf;
1346 
1347   // create the image,
1348   // set all values to zero
1349   bck = gsl_matrix_alloc(obs->grism->size1,obs->grism->size2);
1350   gsl_matrix_set_all(bck,0.0);
1351   
1352   // Return a zero image when there is no
1353   // beam in the list
1354   if (oblist==NULL)
1355     return bck;
1356 
1357   // go over each object
1358   while(oblist[i]!=NULL) 
1359     {
1360       // go over each beam
1361       for(j=0;j<oblist[i]->nbeams;j++)
1362         {         
1363           // continue if the beam is to be ignored
1364           if ((oblist[i]->beams[j]).ignore==1)
1365             continue;
1366 
1367           // check whther the trace is second order or
1368           // even higher
1369           if ((oblist[i]->beams[j]).spec_trace->type > 1)
1370             {
1371               // create the section function for second order
1372               // traces such as FORSII
1373               fill_in_sectionfun (&sf, (oblist[i]->beams[j]).orient,
1374                                   &(oblist[i]->beams[j]));
1375             }
1376           else
1377             {
1378               // create the descriptor to set up the quadrangle routines
1379               fill_is_in_descriptor (&iid, (oblist[i]->beams[j]).corners);
1380             }
1381           
1382           // check for the corners of the quadrangle.
1383           // go over each point in x and y.
1384           quad_to_bbox ((oblist[i]->beams[j]).corners, &ll, &ur);
1385           for (x = ll.x; x <= ur.x; x++)
1386             {
1387               for (y = ll.y; y <= ur.y; y++)
1388                 {
1389 
1390                   // neglect the pixel if it is a]outside the
1391                   // image area
1392                   if ((x < 0) || (y < 0) || (x >= obs->grism->size1)
1393                       || (y >= obs->grism->size2))
1394                     continue;
1395 
1396                   // check the order of the trace polynomial
1397                   if ((oblist[i]->beams[j]).spec_trace->type > 1)
1398                     {
1399 
1400                       // determine the trace distance and
1401                       // enhance the image value if the pixel
1402                       // satisfies the distance criterium
1403                       xrel = x-(oblist[i]->beams[j]).refpoint.x;
1404                       yrel = y-(oblist[i]->beams[j]).refpoint.y;
1405                       width = (oblist[i]->beams[j]).width+0.5;
1406                       if (tracedist_criteria(xrel, yrel, &sf, (oblist[i]->beams[j
      ]).spec_trace, width))
1407                         gsl_matrix_set (bck,x,y,gsl_matrix_get (bck,x,y)+1);
1408                     }
1409                   else
1410                     {
1411                       //                      if (oblist[i]->ID == 11 && x == 59)
      
1412                       //                        fprintf(stdout, "xx: %i, yy: %i: 
      %i\n", x, y, is_in (x, y, &iid));
1413 
1414                       // check whether the pixel is inside the quadrangle
1415                       // which defines the beam are, and enhance the image
1416                       // value if yes.
1417                       if (is_in (x, y, &iid))
1418                         gsl_matrix_set (bck,x,y,gsl_matrix_get (bck,x,y)+1);
1419                     }
1420                 }
1421             }
1422         }
1423       
1424       // enhance the object counter
1425       i++;
1426     }
1427 
1428   // return the resulting image  
1429   return bck;
1430 }
\end{DoxyCode}
\hypertarget{spc__back_8h_a5244945f780b5c1e41997c970df2ee49}{
\index{spc\_\-back.h@{spc\_\-back.h}!background\_\-to\_\-FITSimage@{background\_\-to\_\-FITSimage}}
\index{background\_\-to\_\-FITSimage@{background\_\-to\_\-FITSimage}!spc_back.h@{spc\_\-back.h}}
\subsubsection[{background\_\-to\_\-FITSimage}]{\setlength{\rightskip}{0pt plus 5cm}void background\_\-to\_\-FITSimage (char {\em filename}\mbox{[}$\,$\mbox{]}, \/  {\bf background} $\ast$ {\em bck}, \/  {\bf observation} $\ast$ {\em obs})}}
\label{spc__back_8h_a5244945f780b5c1e41997c970df2ee49}
Function: background\_\-to\_\-FITSimage Function to write the data and error content of a backgound \hyperlink{structobservation}{observation} pars component (if it is of type \hyperlink{structfullimg__background}{fullimg\_\-background} only) into the main HDU (data) and first extension (error) of a FITS file. A GQ array can be appended if an \hyperlink{structobservation}{observation} with a non NULL DQ is passed to this function

Parameters: 
\begin{DoxyParams}{Parameters}
\item[{\em filename}]-\/ name of the image \item[{\em bck}]-\/ filled background structure \item[{\em obs}]-\/ the \hyperlink{structobservation}{observation} the background is based upon \end{DoxyParams}



\begin{DoxyCode}
1448 {
1449   fitsfile *output;
1450   long naxes[2];
1451   int f_status = 0;
1452   PIXEL_T *storage, *dp;
1453   int x, y;
1454   fullimg_background *pars;
1455   int hdunum,hdutype;
1456   
1457   pars = (fullimg_background *) bck->pars;
1458   
1459   // Open the file for creating/appending
1460   create_FITSimage (filename, 1);
1461   fits_open_file (&output, filename, READWRITE, &f_status);
1462   if (f_status)
1463     {
1464       ffrprt (stderr, f_status);
1465       aXe_message (aXe_M_FATAL, __FILE__, __LINE__,
1466                    "gsl_to_FITSimage: " "Could not open file: %s",
1467                    filename);
1468     }
1469 
1470   // count the number of extentions
1471   fits_get_num_hdus (output, &hdunum, &f_status);
1472   if (f_status)
1473     {
1474       ffrprt (stderr, f_status);
1475       aXe_message (aXe_M_FATAL, __FILE__, __LINE__,
1476                    "gsl_to_FITSimage: Could not get"
1477                    " number of HDU from: %s", filename);
1478     }
1479   
1480   // Move to last HDU
1481   fits_movabs_hdu (output, hdunum, &hdutype, &f_status);
1482   if (f_status)
1483     {
1484       ffrprt (stderr, f_status);
1485       aXe_message (aXe_M_FATAL, __FILE__, __LINE__,
1486                    "gsl_to_FITSimage: Could not mov"
1487                    " to HDU number %d in file: %s", hdunum, filename);
1488     }
1489   /* Get current HDU number */
1490   fits_get_hdu_num (output, &hdunum);
1491   
1492   // Deal with the SCI part of the background
1493   naxes[0] = pars->bck->size1;
1494   naxes[1] = pars->bck->size2;
1495 
1496   // Allocate storage room
1497   if (!(storage = malloc (naxes[0] * naxes[1] * sizeof (double))))
1498     aXe_message (aXe_M_FATAL, __FILE__, __LINE__, "Out of memory");
1499 
1500   // Populate the storage array
1501   dp = storage;
1502   for (y = 0; y < naxes[1]; y++)
1503     {
1504       for (x = 0; x < naxes[0]; x++)
1505         {
1506           *dp = gsl_matrix_get (pars->bck, x, y);
1507           dp++;
1508         }
1509     }
1510   /* create HDU extname */
1511   fits_create_img (output, -32, 2, naxes, &f_status);
1512   if (f_status)
1513     {
1514       ffrprt (stderr, f_status);
1515       aXe_message (aXe_M_FATAL, __FILE__, __LINE__,
1516                    "gsl_to_FITSimage: Could create SCI HDU in file: %s", filename
      );
1517     }
1518   fits_write_img (output, TFLOAT, 1, naxes[0] * naxes[1], storage,
1519                   &f_status);
1520   if (f_status)
1521     {
1522       ffrprt (stderr, f_status);
1523       aXe_message (aXe_M_FATAL, __FILE__, __LINE__,
1524                    "gsl_to_FITSimage: Could write SCI HDU in file: %s", filename)
      ;
1525     }
1526 
1527   /* write the HDU EXTNAME */
1528   {
1529     char comment[FLEN_COMMENT];
1530     char str[FLEN_KEYWORD];
1531     strcpy (str, "SCI");
1532     strcpy (comment, "Extension name");
1533     fits_write_key_str (output, "EXTNAME", str, comment, &f_status);
1534   }
1535   free (storage);
1536   storage = NULL;
1537   
1538   if (pars->err)
1539     {
1540       /* Deal with the error part of the background */
1541       naxes[0] = pars->err->size1;
1542       naxes[1] = pars->err->size2;
1543       /* Allocate storage room */
1544       if (!(storage = malloc (naxes[0] * naxes[1] * sizeof (double))))
1545         {
1546           aXe_message (aXe_M_FATAL, __FILE__, __LINE__, "Out of memory");
1547         }
1548       /* Populate the storage array */
1549       dp = storage;
1550       for (y = 0; y < naxes[1]; y++)
1551         {
1552           for (x = 0; x < naxes[0]; x++)
1553             {
1554               *dp = gsl_matrix_get (pars->err, x, y);
1555               dp++;
1556             }
1557         }
1558       /* create HDU extname */
1559       /* Get current HDU number */
1560       fits_get_hdu_num (output, &hdunum);
1561       
1562       fits_create_img (output, -32, 2, naxes, &f_status);
1563       fits_write_img (output, TFLOAT, 1, naxes[0] * naxes[1], storage,
1564                       &f_status);
1565       
1566       /* Get current HDU number */
1567       fits_get_hdu_num (output, &hdunum);
1568       /* write the HDU EXTNAME */
1569       {
1570         char comment[FLEN_COMMENT];
1571         char str[FLEN_KEYWORD];
1572         strcpy (str, "ERR");
1573         strcpy (comment, "Extension name");
1574         fits_write_key_str (output, "EXTNAME", str, comment, &f_status);
1575       }
1576       free (storage);
1577       storage = NULL;
1578     }
1579 
1580   /* Deal with the DQ part of the background */
1581   if (obs->dq != NULL) 
1582     {
1583       naxes[0] = obs->dq->size1;
1584       naxes[1] = obs->dq->size2;
1585       /* Allocate storage room */
1586       if (!(storage = malloc (naxes[0] * naxes[1] * sizeof (double))))
1587         {
1588           aXe_message (aXe_M_FATAL, __FILE__, __LINE__, "Out of memory");
1589         }
1590       /* Populate the storage array */
1591       dp = storage;
1592       for (y = 0; y < naxes[1]; y++)
1593         {
1594           for (x = 0; x < naxes[0]; x++)
1595             {
1596               *dp = gsl_matrix_get (obs->dq, x, y);
1597               dp++;
1598             }
1599         }
1600       /* create HDU extname */
1601       fits_create_img (output, 16, 2, naxes, &f_status);
1602       fits_write_img (output, TFLOAT, 1, naxes[0] * naxes[1], storage,
1603                       &f_status);
1604       /* write the HDU EXTNAME */
1605       {
1606         char comment[FLEN_COMMENT];
1607         char str[FLEN_KEYWORD];
1608         strcpy (str, "DQ");
1609         strcpy (comment, "Extension name");
1610         fits_write_key_str (output, "EXTNAME", str, comment, &f_status);
1611       }
1612       free (storage);
1613       storage = NULL;    
1614     } 
1615 
1616   /* close file */
1617   fits_close_file (output, &f_status);
1618 }
\end{DoxyCode}
\hypertarget{spc__back_8h_a135c17132984f8af8cf6d4f13ee9dbb7}{
\index{spc\_\-back.h@{spc\_\-back.h}!comp\_\-kappasigma\_\-interp@{comp\_\-kappasigma\_\-interp}}
\index{comp\_\-kappasigma\_\-interp@{comp\_\-kappasigma\_\-interp}!spc_back.h@{spc\_\-back.h}}
\subsubsection[{comp\_\-kappasigma\_\-interp}]{\setlength{\rightskip}{0pt plus 5cm}void comp\_\-kappasigma\_\-interp (const double $\ast$const  {\em xs}, \/  double $\ast$const  {\em ys}, \/  double $\ast$const  {\em ws}, \/  const int {\em n}, \/  const int {\em interp}, \/  const int {\em niter}, \/  const double {\em kappa}, \/  {\bf observation} $\ast$ {\em obs}, \/  int {\em colnum})}}
\label{spc__back_8h_a135c17132984f8af8cf6d4f13ee9dbb7}
Function: comp\_\-kappasigma\_\-interp The function performs a kappa-\/sigma clipping rejection on a set of data given in vectors for indipendent, dipendent and weight values. The differences to base the clipping on is \char`\"{}true value minus background value\char`\"{}, where background value is determined using the identical algorithm as the final background determination.

Parameters: 
\begin{DoxyParams}{Parameters}
\item[{\em xs}]-\/ array for independent values \item[{\em ys}]-\/ array for dependent values \item[{\em ws}]-\/ weight array \item[{\em n}]-\/ number of pixels \item[{\em interp}]-\/ number indicating the interpolation scheme \item[{\em niter}]-\/ the number of iterations \item[{\em kappa}]-\/ the kappa value for rejection \item[{\em obs}]-\/ the \hyperlink{structobject}{object} list \item[{\em colnum}]-\/ the column number \end{DoxyParams}



\begin{DoxyCode}
613 {
614   double *ys_tmp;
615   double *yi_tmp;
616   double *y_diff;
617 
618   double stdev;
619 
620   int *iindex;
621 
622 
623   int i, m, j;
624 
625   // allocate temporary vectors
626   ys_tmp = (double *) malloc (n * sizeof (double));
627   yi_tmp = (double *) malloc (n * sizeof (double));
628   y_diff = (double *) malloc (n * sizeof (double));
629   iindex = (int *) malloc (n * sizeof (int));
630 
631   // transfer the dependent value
632   // to the tmp vector
633   for (i=0; i < n; i++)
634     ys_tmp[i] = ys[i];
635 
636 
637   // do niter times
638   for (j=0; j < niter; j++)
639     {
640       
641       // make the background determination
642       comp_vector_interp(xs, ys_tmp, ws, yi_tmp, n, interp, 0);
643 
644       // calculate for all background
645       // pixels the differences between
646       // the original and background value
647       m=0;
648       for (i=0; i < n; i++)
649         {
650           if (ws[i] != 0.0)
651             {
652               y_diff[m] = ys[i] - yi_tmp[i];
653               iindex[m] = i;
654               m++;
655             }
656         }
657 
658       // compute the standard deviation
659       // on the differences
660       stdev = gsl_stats_sd (y_diff, 1, m);
661 
662       // do the clipping
663       for (i=0; i < m; i++)
664         {
665           // check for pixels to exclude
666           if (fabs(y_diff[i]) > kappa*stdev)
667             {
668               // set its weight to 0.0
669               ws[iindex[i]] = 0.0;
670               // mark the pixel in the dq-array
671               if ( xs[iindex[i]] >= 0 &&  xs[iindex[i]] < obs->dq->size2)
672                 gsl_matrix_set(obs->dq, colnum, xs[iindex[i]], DQ_KAPPA_SIGMA);
673             }
674         }
675     }
676 
677 
678   for (i=0; i < n; i++)    
679     ys[i] = ys_tmp[i];
680   
681   // free memory
682   free(ys_tmp);
683   free(yi_tmp);
684   free(y_diff);
685   free(iindex);
686 }
\end{DoxyCode}
\hypertarget{spc__back_8h_a17d5c8763243b26091aceb119ac98557}{
\index{spc\_\-back.h@{spc\_\-back.h}!comp\_\-vector\_\-interp@{comp\_\-vector\_\-interp}}
\index{comp\_\-vector\_\-interp@{comp\_\-vector\_\-interp}!spc_back.h@{spc\_\-back.h}}
\subsubsection[{comp\_\-vector\_\-interp}]{\setlength{\rightskip}{0pt plus 5cm}void comp\_\-vector\_\-interp (const double $\ast$const  {\em xs}, \/  double $\ast$const  {\em ys}, \/  double $\ast$const  {\em ws}, \/  double $\ast$const  {\em yi}, \/  const int {\em n}, \/  const int {\em interp}, \/  const int {\em final})}}
\label{spc__back_8h_a17d5c8763243b26091aceb119ac98557}
Function: comp\_\-vector\_\-interp The function passes the interpolation data to the desired interpolating function.

Parameters: 
\begin{DoxyParams}{Parameters}
\item[{\em xs}]-\/ double vector containing the x values \item[{\em ys}]-\/ double vector containing the y values \item[{\em ws}]-\/ double vector containing the weights associated with ys \item[{\em n}]-\/ number of points in xs,ys, and ws (must be greater than m!) \item[{\em interp}]-\/ desired interpolation type \item[{\em final}]-\/ indicates a final interpolation \end{DoxyParams}



\begin{DoxyCode}
784 {
785   /* Median the background */
786   if (interp == -1)
787     {
788       comp_vector_median(xs, ys, ws, yi, n, final);
789     }
790   /* Straight average of the background */
791   else if (interp == 0)
792     {
793       comp_vector_average(xs, ys, ws, yi, n, final);
794     }
795   /* Linear interpolation of the background */
796   else if (interp == 1)
797     {
798       comp_vector_linear(xs, ys, ws, yi, n, final);
799     }
800   /* n(>1) order interpolation of the background */
801   else if (interp > 1)
802     {
803       comp_vector_polyN (interp + 1, xs, ys, ws, yi, n, final);
804     }
805   else
806     {
807       aXe_message(aXe_M_FATAL, __FILE__, __LINE__,
808                   "Do not know what to do with interpolation: %i %s\n", interp);
809     }
810 }
\end{DoxyCode}
\hypertarget{spc__back_8h_ad45826f8c0ede1b55ed2f5d6fd67e875}{
\index{spc\_\-back.h@{spc\_\-back.h}!compute\_\-background@{compute\_\-background}}
\index{compute\_\-background@{compute\_\-background}!spc_back.h@{spc\_\-back.h}}
\subsubsection[{compute\_\-background}]{\setlength{\rightskip}{0pt plus 5cm}void compute\_\-background ({\bf observation} $\ast$ {\em obs}, \/  {\bf beam} {\em actbeam}, \/  gsl\_\-matrix $\ast$ {\em bck\_\-mask}, \/  {\bf fullimg\_\-background} $\ast$ {\em fib}, \/  int {\em npoints}, \/  int {\em interporder}, \/  const int {\em niter\_\-med}, \/  const int {\em niter\_\-fit}, \/  const double {\em kappa})}}
\label{spc__back_8h_ad45826f8c0ede1b55ed2f5d6fd67e875}
Function: compute\_\-background The function extracts possible background pixels for a given \hyperlink{structbeam}{beam} using a specified interpolation functions. After possibly rejecting cosmics, the background is interpolated on the areas which are masked out. The interpolated values are filled into a background structure. If kappa-\/sigma klipping is applied, the clipped pixels are flagged in the dq-\/array of the background image.

Parameters: 
\begin{DoxyParams}{Parameters}
\item[{\em obs}]-\/ the \hyperlink{structobject}{object} list \item[{\em actbeam}]-\/ the \hyperlink{structbeam}{beam} to compute the background for \item[{\em bck\_\-mask}]-\/ the background mask \item[{\em fib}]-\/ the baground structure \item[{\em npoints}]-\/ the number of interpolation points \item[{\em interporder}]-\/ the interpolation order \item[{\em niter\_\-med}]-\/ the number of iterations around the median \item[{\em niter\_\-fit}]-\/ the number of iterations around the fit \item[{\em kappa}]-\/ the kappa value \end{DoxyParams}



\begin{DoxyCode}
398 {
399   px_point xborder;  
400   gsl_vector_int *yvec;
401   trace_func *tracefun;
402   px_point tpoint;
403   double *ys, *fs, *ws, *yi;
404   //double var;
405   
406   int i, ii;
407   int j, n;
408   int min_y, max_y;
409 
410 
411   // define the beam and the trace function
412   tracefun = actbeam.spec_trace;
413 
414   /* If this beam's ignore flag is set to 1 then do nothing */
415   if (actbeam.ignore == 1)
416     return;
417     
418   // determine the start and end point in x
419   xborder = get_xrange(obs, actbeam);
420 
421 
422   // Loop over all columns
423   for (i = xborder.x; i < xborder.y; i++)
424     {
425 
426       // determine the pixel closest to the trace
427       tpoint.x = i;
428       tpoint.y = (int)floor(tracefun->func((double)i-actbeam.refpoint.x,
429                                            tracefun->data)
430                             + actbeam.refpoint.y+0.5);
431       
432       // determine the interpolation points
433       // around the trace
434       yvec = get_interp_points(obs, bck_mask, npoints, tpoint);
435 
436       //-----------------------------------------------------------------
437       //   some code for FORS2 MXU
438       //      if (actbeam.backwindow.x < 0.0)
439       //        yvec = get_interp_points(obs, bck_mask, npoints, tpoint);
440       //      else
441       //        yvec = get_window_points(obs, bck_mask, actbeam, tpoint);
442         
443 
444       // give a warning and go to the next
445       // column if there are no background points
446       if (!yvec)
447         {
448           aXe_message (aXe_M_WARN4, __FILE__, __LINE__,
449                        "No backgound points could be found for beam %C. "
450                        "at collumn %d %d",
451                        BEAM(actbeam.ID), i, tpoint.y );
452           continue;
453         }
454 
455       // extract maximum and minimum 0f the y-values
456       min_y = gsl_vector_int_get(yvec, 0);
457       max_y = gsl_vector_int_get(yvec, yvec->size-1);
458       //      if (actbeam.backwindow.x == 23.3 && actbeam.backwindow.y == 4.0)
459       //        {
460           //    fprintf(stdout, "%i <--> %i; ", min_y, max_y);
461       //      if (min_y > tpoint.y - actbeam.width 
462       //          || max_y < tpoint.y + actbeam.width)
463       //        fprintf(stdout, "%i %f <--> %f %i;  ", min_y, tpoint.y - actbeam.
      width,
464       //                tpoint.y + actbeam.width, max_y);
465               //        }
466 
467       // determine the size of the double vectors
468       // to make the background determination
469       // allocater the space and initialize
470       // all values to default
471       n = max_y - min_y + 1;
472       ys = (double *) malloc (n * sizeof (double));
473       fs = (double *) malloc (n * sizeof (double));
474       ws = (double *) malloc (n * sizeof (double));
475       yi = (double *) malloc (n * sizeof (double));
476       for (ii = 0; ii < n; ii++)
477         {
478           ys[ii] = min_y + ii;
479           fs[ii] = 0.0;
480           ws[ii] = 0.0;
481         }
482 
483 
484       // transfer the values from the image column
485       // to the double vectors, set the weight
486       for (ii = 0; ii < yvec->size; ii++)
487         {
488           // extract the row number 
489           j = gsl_vector_int_get (yvec, ii);
490 
491           // check whether the row is inside the imag
492           // and whether the is no object on the pixel
493           if ((j != -1) && (j != obs->grism->size2)
494               && !gsl_matrix_get(bck_mask, tpoint.x, j))
495             {
496               // set the values and the weight
497               fs[j - min_y] = gsl_matrix_get (obs->grism, tpoint.x, j);
498               ws[j - min_y] = gsl_matrix_get (obs->pixerrs, tpoint.x, j);
499             }
500         }
501 
502       // iterate on the background points to
503       // reject e.g. cosmics
504       if (niter_med > 0 || niter_fit > 0)
505         {
506           // iterate on the median
507           for (j=0; j < niter_med; j++)
508             kappa_sigma_clipp(ys, fs,ws, n,kappa, obs, tpoint.x);
509 
510           // iterate on the fit
511           if (niter_fit > 0)
512             comp_kappasigma_interp( ys, fs, ws, n, interporder,
513                                     niter_fit, kappa, obs, tpoint.x);
514         }
515 
516       // do the final background determination
517       comp_vector_interp( ys, fs, ws, yi, n, interporder, 1);
518   
519       // copy the intepolated values 
520       // to the background matrix
521       for (j = 0; j < n; j++)
522         {
523           if ((ys[j] < 0) || (ys[j] >= obs->grism->size2))
524             continue;
525           gsl_matrix_set (fib->bck, tpoint.x, (int) floor (ys[j]), fs[j]);
526           gsl_matrix_set (fib->err, tpoint.x, (int) floor (ys[j]), ws[j]);
527         }
528 
529       // release memory
530       free (ys);
531       ys = NULL;
532       free (fs);
533       fs = NULL;
534       free (yi);
535       yi = NULL;
536       free (ws);
537       ws = NULL;
538 
539       // release memory
540       gsl_vector_int_free(yvec);
541     }
542 }
\end{DoxyCode}
\hypertarget{spc__back_8h_a522b515cc91be30ce47801291ac7a752}{
\index{spc\_\-back.h@{spc\_\-back.h}!compute\_\-background2@{compute\_\-background2}}
\index{compute\_\-background2@{compute\_\-background2}!spc_back.h@{spc\_\-back.h}}
\subsubsection[{compute\_\-background2}]{\setlength{\rightskip}{0pt plus 5cm}void compute\_\-background2 ({\bf object} $\ast$$\ast$ {\em oblist}, \/  const int {\em obj\_\-index}, \/  const int {\em beamorder}, \/  gsl\_\-matrix $\ast$ {\em bck\_\-mask}, \/  const int {\em tnbeams}, \/  {\bf fullimg\_\-background} $\ast$ {\em fib}, \/  int {\em npoints}, \/  int {\em interporder})}}
\label{spc__back_8h_a522b515cc91be30ce47801291ac7a752}
\hypertarget{spc__back_8h_ae8622f5f1124511fcbc7ddf2205d4e0f}{
\index{spc\_\-back.h@{spc\_\-back.h}!compute\_\-backsub\_\-mask@{compute\_\-backsub\_\-mask}}
\index{compute\_\-backsub\_\-mask@{compute\_\-backsub\_\-mask}!spc_back.h@{spc\_\-back.h}}
\subsubsection[{compute\_\-backsub\_\-mask}]{\setlength{\rightskip}{0pt plus 5cm}{\bf background}$\ast$ compute\_\-backsub\_\-mask ({\bf observation} $\ast$ {\em obs}, \/  {\bf object} $\ast$$\ast$ {\em oblist})}}
\label{spc__back_8h_ae8622f5f1124511fcbc7ddf2205d4e0f}
Function: compute\_\-backsub\_\-mask Computes a mask image for the background subtraction. All pixels covered by at least one \hyperlink{structbeam}{beam} are set to a vale -\/100000 to distinguish them from pixels which are part of the background.

Parameters: 
\begin{DoxyParams}{Parameters}
\item[{\em obs}]a pointer to the \hyperlink{structobservation}{observation} structure to fill out \item[{\em oblist}]a list of all objects of the \hyperlink{structobservation}{observation} \item[{\em npoints}]number of points to examine when fitting the background \item[{\em interporder}]order of the polynomial to fit to the background\end{DoxyParams}
Returns: \begin{DoxyReturn}{Returns}
an allocated background structure 
\end{DoxyReturn}



\begin{DoxyCode}
1144 {
1145   fullimg_background *fib;// = malloc (sizeof (fullimg_background));
1146   background *backg; // = malloc (sizeof (background));
1147   gsl_matrix *bck_mask;
1148   int i, j;
1149   //object *const *obp;
1150   //int tnbeams;
1151   
1152   // make the mask image
1153   bck_mask = aperture_mask(obs,oblist);
1154 
1155   // allocate memory for the return structure
1156   // and fill in some dummy values
1157   fib = malloc (sizeof (fullimg_background));
1158   fib->bck = gsl_matrix_alloc (obs->grism->size1, obs->grism->size2);
1159   gsl_matrix_set_all (fib->bck, 0.);
1160   fib->err = NULL;
1161 
1162   // allocate memory for the return structure
1163   backg = malloc (sizeof (background));
1164 
1165   // transfer the pixel values from the grism image
1166   // to the mask image
1167   for (i = 0; i < fib->bck->size1; i++)
1168     {
1169       for (j = 0; j < fib->bck->size2; j++)
1170         {
1171           gsl_matrix_set (fib->bck, i, j,
1172                           gsl_matrix_get (obs->grism, i, j));
1173         }
1174     }
1175 
1176   // set pixels occupied by beams 
1177   // to the value -10000000
1178   for (i = 0; i < fib->bck->size1; i++)
1179     {
1180       for (j = 0; j < fib->bck->size2; j++)
1181         {
1182 
1183           if (gsl_matrix_get (bck_mask, i, j))
1184             gsl_matrix_set (fib->bck, i, j, -1000000.0);
1185         }
1186     }
1187 
1188   // release the dq-structure,
1189   // otherwise it is saved to
1190   // the mask image
1191   if (obs->dq != NULL)
1192     {
1193       gsl_matrix_free (obs->dq);
1194       obs->dq=NULL;
1195     } 
1196 
1197   // release memory
1198   gsl_matrix_free(bck_mask);
1199 
1200   // assemble the return structure
1201   backg->pars = fib;
1202   backg->bck_func = &fullimg_background_function;
1203 
1204   // return the result
1205   return backg;
1206 }
\end{DoxyCode}
\hypertarget{spc__back_8h_ad1ce027d8c85366289610daf4ee9ac12}{
\index{spc\_\-back.h@{spc\_\-back.h}!compute\_\-efactor@{compute\_\-efactor}}
\index{compute\_\-efactor@{compute\_\-efactor}!spc_back.h@{spc\_\-back.h}}
\subsubsection[{compute\_\-efactor}]{\setlength{\rightskip}{0pt plus 5cm}double compute\_\-efactor (const double {\em fwhm})}}
\label{spc__back_8h_ad1ce027d8c85366289610daf4ee9ac12}
Function: compute\_\-efactor The function computes the appropriate factor of the Gaussian for any FWHM given as input. This speeds up any later computation of the Gaussian.

Parameters: 
\begin{DoxyParams}{Parameters}
\item[{\em fwhm}]-\/ the input FWHM\end{DoxyParams}
Returns: \begin{DoxyReturn}{Returns}
expfactor -\/ the factor for the Gaussian 
\end{DoxyReturn}



\begin{DoxyCode}
1841 {
1842   double sigma;
1843   double expfactor;
1844 
1845   // get the sigma value [sig = fwhm / (2 sqrt(2 ln(2)))]
1846   sigma = fwhm / 2.3458;
1847 
1848   // compute the factor for the Gaussian
1849   expfactor =  -1.0 / (2.0* sigma * sigma);
1850 
1851   // return the factor
1852   return expfactor;
1853 }
\end{DoxyCode}
\hypertarget{spc__back_8h_ac8525170561017c1ebf7946f1e37b57b}{
\index{spc\_\-back.h@{spc\_\-back.h}!compute\_\-fullimg\_\-background@{compute\_\-fullimg\_\-background}}
\index{compute\_\-fullimg\_\-background@{compute\_\-fullimg\_\-background}!spc_back.h@{spc\_\-back.h}}
\subsubsection[{compute\_\-fullimg\_\-background}]{\setlength{\rightskip}{0pt plus 5cm}{\bf background}$\ast$ compute\_\-fullimg\_\-background ({\bf observation} $\ast$ {\em obs}, \/  {\bf object} $\ast$$\ast$ {\em oblist}, \/  int {\em npoints}, \/  int {\em interporder}, \/  const int {\em niter\_\-med}, \/  const int {\em niter\_\-fit}, \/  const double {\em kappa}, \/  int {\em nor\_\-flag}, \/  const int {\em sm\_\-length}, \/  const double {\em fwhm})}}
\label{spc__back_8h_ac8525170561017c1ebf7946f1e37b57b}
Function: compute\_\-fullimg\_\-background Computes a background image. All beams with ignore=1 are completely ignored. Anything else is not.

Parameters: 
\begin{DoxyParams}{Parameters}
\item[{\em obs}]-\/ a pointer to the \hyperlink{structobservation}{observation} structure to fill out \item[{\em oblist}]-\/ a list of all objects of the \hyperlink{structobservation}{observation} \item[{\em npoints}]-\/ number of points to examine when fitting the background \item[{\em interporder}]-\/ order of the polynomial to fit to the background \item[{\em niter\_\-med}]-\/ order of the polynomial to fit to the background \item[{\em niter\_\-fit}]-\/ order of the polynomial to fit to the background \item[{\em kappa}]-\/ order of the polynomial to fit to the background\end{DoxyParams}
Returns: \begin{DoxyReturn}{Returns}
background -\/ an allocated background structure 
\end{DoxyReturn}



\begin{DoxyCode}
1025 {
1026   fullimg_background *fib;
1027   background *backg;
1028   gsl_matrix *bck_mask;
1029   int i, j;
1030   //object *const *obp;
1031 
1032   // allocate space for the backgrounds
1033   fib   = (fullimg_background *)malloc (sizeof (fullimg_background));
1034   fib->bck = gsl_matrix_alloc (obs->grism->size1, obs->grism->size2);
1035   gsl_matrix_set_all (fib->bck, 0.);
1036   fib->err = gsl_matrix_alloc (obs->grism->size1, obs->grism->size2);
1037   gsl_matrix_set_all (fib->err, 0.);
1038 
1039   if (nor_flag)
1040     {
1041       for (i = 0; i < fib->bck->size1; i++)
1042         {
1043           for (j = 0; j < fib->bck->size2; j++)
1044             {
1045               gsl_matrix_set (fib->bck, i, j,
1046                               gsl_matrix_get (obs->grism, i, j));
1047               gsl_matrix_set (fib->err, i, j,
1048                               gsl_matrix_get (obs->pixerrs, i, j));
1049             }
1050         }
1051     }
1052 
1053   // allocate memory
1054   backg = (background *)malloc (sizeof (background));
1055 
1056   // create the mask image
1057   bck_mask = aperture_mask(obs,oblist);
1058 
1059   // in case that pixels may get dq values,
1060   // make sure that there will be a dq-array
1061   //  if (niter_med > 0 || niter_fit > 0)
1062   //    {
1063   if (!obs->dq)
1064     obs->dq = gsl_matrix_alloc (obs->grism->size1, obs->grism->size2);
1065 
1066   // initialize the dq-array
1067   //      gsl_matrix_set_all (obs->dq, 0.0);
1068   //    }
1069   
1070   if (oblist != NULL)
1071     {
1072       // Now compute background for each beam, one after the other
1073       // go over the whole object list
1074       i=0;
1075       while (oblist[i] != NULL) {
1076         // go over each beam
1077         for (j = 0; j < oblist[i]->nbeams; j++)
1078           {
1079             // check for beams to be neglected
1080             if (oblist[i]->beams[j].ignore == 1)
1081               {
1082                 continue;
1083               }
1084             else
1085               {
1086                 // start the background interpolation
1087                 // for a specific beam
1088                 fprintf(stdout,"Computing background of BEAM %d%c.",
1089                         oblist[i]->ID,BEAM(oblist[i]->beams[j].ID));
1090                 compute_background(obs, oblist[i]->beams[j], bck_mask,
1091                                    fib, npoints, interporder, niter_med,
1092                                    niter_fit, kappa);
1093                 fprintf(stdout," Done.\n");
1094               }     
1095           }
1096         // increment the counter
1097         i++;
1098       }
1099     }
1100   // replace all NAN's with values 0.0
1101   for (i = 0; i < fib->bck->size1; i++)
1102     {
1103       for (j = 0; j < fib->bck->size2; j++)
1104         {
1105           if(isnan(gsl_matrix_get (fib->bck, i, j))) 
1106             gsl_matrix_set (fib->bck, i, j,0.0);
1107           if(isnan(gsl_matrix_get (fib->err, i, j))) 
1108             gsl_matrix_set (fib->err, i, j,0.0);
1109         }
1110     }
1111 
1112   if (sm_length && fwhm)
1113     gsmooth_background (bck_mask, sm_length, fwhm, fib);
1114 
1115   // put together the result
1116   backg->pars = fib;
1117   backg->bck_func = &fullimg_background_function;
1118 
1119   // free space
1120   gsl_matrix_free(bck_mask);
1121 
1122   // return the result
1123   return backg;
1124 }
\end{DoxyCode}
\hypertarget{spc__back_8h_a6f31bd7324fece185dcac65eb5582b41}{
\index{spc\_\-back.h@{spc\_\-back.h}!compute\_\-fullimg\_\-background2@{compute\_\-fullimg\_\-background2}}
\index{compute\_\-fullimg\_\-background2@{compute\_\-fullimg\_\-background2}!spc_back.h@{spc\_\-back.h}}
\subsubsection[{compute\_\-fullimg\_\-background2}]{\setlength{\rightskip}{0pt plus 5cm}{\bf background}$\ast$ compute\_\-fullimg\_\-background2 ({\bf observation} $\ast$ {\em obs}, \/  {\bf object} $\ast$$\ast$ {\em oblist}, \/  int {\em npoints}, \/  int {\em interporder})}}
\label{spc__back_8h_a6f31bd7324fece185dcac65eb5582b41}
\hypertarget{spc__back_8h_af64d42951a54cd249fcbb6f793096acd}{
\index{spc\_\-back.h@{spc\_\-back.h}!compute\_\-fullimg\_\-global\_\-background@{compute\_\-fullimg\_\-global\_\-background}}
\index{compute\_\-fullimg\_\-global\_\-background@{compute\_\-fullimg\_\-global\_\-background}!spc_back.h@{spc\_\-back.h}}
\subsubsection[{compute\_\-fullimg\_\-global\_\-background}]{\setlength{\rightskip}{0pt plus 5cm}{\bf background}$\ast$ compute\_\-fullimg\_\-global\_\-background ({\bf observation} $\ast$ {\em obs}, \/  {\bf object} $\ast$$\ast$ {\em oblist}, \/  int {\em interporder}, \/  const int {\em sm\_\-length}, \/  const double {\em fwhm})}}
\label{spc__back_8h_af64d42951a54cd249fcbb6f793096acd}
Function: compute\_\-fullimg\_\-global\_\-background The subroutine computes the background image based on all pixels in a column which are not part of an \hyperlink{structobject}{object}.

Parameters: 
\begin{DoxyParams}{Parameters}
\item[{\em obs}]-\/ a pointer to the \hyperlink{structobservation}{observation} structure to fill out \item[{\em oblist}]-\/ a list of all objects of the \hyperlink{structobservation}{observation} \item[{\em interporder}]-\/ order of the polynomial to fit to the background\end{DoxyParams}
Returns: \begin{DoxyReturn}{Returns}
background -\/ an allocated background structure 
\end{DoxyReturn}



\begin{DoxyCode}
1226 {
1227   fullimg_background *fib;
1228   background *backg;
1229   gsl_matrix *bck_mask;
1230   int i, j;
1231   object *const *obp;
1232   int tnbeams;
1233   
1234   // allocate memory
1235   fib = (fullimg_background *)malloc (sizeof (fullimg_background));
1236   backg = (background *)malloc (sizeof (background));
1237 
1238   // allocate memory
1239   bck_mask = aperture_mask(obs,oblist);
1240   fib->bck = gsl_matrix_alloc (obs->grism->size1, obs->grism->size2);
1241   fib->err = gsl_matrix_alloc (obs->grism->size1, obs->grism->size2);
1242 
1243   // initialize the new arrays
1244   gsl_matrix_set_all (fib->bck, 0.);
1245   gsl_matrix_set_all (fib->err, 0.);
1246   
1247   /* Count beams in observation */
1248   if (oblist!=NULL) 
1249     {
1250       tnbeams = 0;
1251       for (obp = oblist; *obp; obp++)
1252         {
1253           for (i = 0; i < (*obp)->nbeams; i++)
1254             {
1255               // if (((*obp)->beams[i]).ignore!=1)
1256               tnbeams++; /* Count ALL the beams */
1257             }
1258         }
1259     }
1260   
1261 
1262   /* Now compute global background using first beam grism info */
1263   if (oblist != NULL) {
1264     compute_global_background (oblist, 0, bck_mask,
1265                                fib, interporder);
1266   }
1267 
1268 
1269   // replace all NAN's with values 0.0
1270   for (i = 0; i < fib->bck->size1; i++)
1271     {
1272       for (j = 0; j < fib->bck->size2; j++)
1273         {
1274           if(isnan(gsl_matrix_get (fib->bck, i, j))) 
1275             {
1276               gsl_matrix_set (fib->bck, i, j,0.0);
1277             }
1278           if(isnan(gsl_matrix_get (fib->err, i, j))) 
1279             {
1280               gsl_matrix_set (fib->err, i, j,0.0);
1281             }
1282         }
1283     }
1284 
1285   // make a Gaussian smoothing
1286   // if requested
1287   if (sm_length && fwhm)
1288     gsmooth_background (bck_mask, sm_length, fwhm, fib);
1289 
1290   // compose the result structure
1291   backg->pars = fib;
1292   backg->bck_func = &fullimg_background_function;
1293 
1294   // return the result
1295   return backg;
1296 }
\end{DoxyCode}
\hypertarget{spc__back_8h_ac5915dcfa3d4bd357a95fcd4f827c3a1}{
\index{spc\_\-back.h@{spc\_\-back.h}!compute\_\-global\_\-background@{compute\_\-global\_\-background}}
\index{compute\_\-global\_\-background@{compute\_\-global\_\-background}!spc_back.h@{spc\_\-back.h}}
\subsubsection[{compute\_\-global\_\-background}]{\setlength{\rightskip}{0pt plus 5cm}void compute\_\-global\_\-background ({\bf object} $\ast$$\ast$ {\em oblist}, \/  const int {\em obj\_\-index}, \/  gsl\_\-matrix $\ast$ {\em bck\_\-mask}, \/  {\bf fullimg\_\-background} $\ast$ {\em fib}, \/  int {\em interporder})}}
\label{spc__back_8h_ac5915dcfa3d4bd357a95fcd4f827c3a1}



\begin{DoxyCode}
817 {
818   int i, j, n;
819   double *ys, *fs, *ws, *yi;
820   //double *ws0;
821   observation *grism = oblist[obj_index]->grism_obs;
822   //long ma;
823   //double var;
824   
825   for (i = 0; i < grism->grism->size1; i++)
826     {                   
827       /* Loop over the columns of interest */
828       
829       n = grism->grism->size2;
830       
831       ys = (double *) malloc (n * sizeof (double));
832       fs = (double *) malloc (n * sizeof (double));
833       ws = (double *) malloc (n * sizeof (double));
834       yi = (double *) malloc (n * sizeof (double));
835 
836       for (j = 0; j < n; j++)
837         {
838           ys[j] = j;
839           fs[j] = 0.0;
840           ws[j] = 0.0;
841           if ((gsl_matrix_get(bck_mask,i,j)==0) &&
842               (!(isnan(gsl_matrix_get(grism->grism, i,j)))))
843             {
844               fs[j]=gsl_matrix_get (grism->grism,i,j);
845               ws[j]=gsl_matrix_get (grism->grism,i,j);
846             }
847         }
848 
849                 
850       /* Median the background */
851       if (interporder == -1)
852         {
853           double *tmp, med, std;
854           int nn = 0;
855           for (j = 0; j < n; j++)
856             {
857               if (ws[j] != 0.0)
858                 {
859                   nn++;
860                 }
861             }
862           tmp = malloc (nn * sizeof (double));
863           nn = 0;
864           for (j = 0; j < n; j++)
865             {
866               if (ws[j] != 0.0)
867                 {
868                   tmp[nn] = fs[j];
869                   nn++;
870                 }
871             }
872           gsl_sort (tmp, 1, nn);
873           med = gsl_stats_median_from_sorted_data (tmp, 1, nn);
874           std = gsl_stats_sd (tmp, 1, nn);
875           //fprintf(stderr,"med: %g\n",med);
876           for (j = 0; j < n; j++)
877             {
878               if (ws[j] == 0.0)
879                 {
880                   fs[j] = med;
881                   ws[j] = std;
882                 }
883               //              else
884               //                {
885               //                  ws[j] = 1.0/sqrt(ws[j]);
886               //                }
887             }
888           free (tmp);
889           tmp = NULL;
890         }
891 
892       /* Straight average of the background */
893       if (interporder == 0)
894         {
895           double *tmp, sum = 0.0, avg = 0.0, std = 0.0;
896           int nn = 0;
897           
898           nn = 0;
899           for (j = 0; j < n; j++)
900             {
901               if (ws[j] != 0.0)
902                 {
903                   nn++;
904                 }
905             }
906           tmp = malloc (nn * sizeof (double));
907           nn = 0;
908           for (j = 0; j < n; j++)
909             {
910               if (ws[j] != 0.0)
911                 {
912                   sum += fs[j];
913                   tmp[nn] = fs[j];
914                   nn++;
915                 }
916             }
917           if (nn > 0)
918             avg = sum / nn;
919           std = gsl_stats_sd (tmp, 1, nn);
920           for (j = 0; j < n; j++)
921             {
922               if (ws[j] == 0.0)
923                 {
924                   fs[j] = avg;
925                   ws[j] = std;
926                 }
927               //              else
928               //                {
929               //                  ws[j] = 1.0/sqrt(ws[j]);
930               //                }
931             }
932           free (tmp);
933           tmp = NULL;
934         }
935 
936       /* Linear interpolation of the background */
937       if (interporder == 1)
938         {
939           comp_vector_linear (ys, fs, ws, yi, n, 1);
940           //      fit_vector_linear_t (ys, fs, ws, n);
941         }
942       
943       /* n(>1) order interpolation of the background */
944       if (interporder > 1)
945         {
946           comp_vector_polyN (interporder + 1, ys,fs, ws, yi, n, 1);
947       //          fit_vector_poly_N_t (interporder + 1, ys, fs, ws, n);
948         }
949       
950       for (j = 0; j < n; j++)
951         {
952           if ((ys[j] < 0) || (ys[j] >= grism->grism->size2))
953             continue;
954             gsl_matrix_set (fib->bck, i, j,fs[j]);
955             gsl_matrix_set (fib->err, i, j,ws[j]);
956         }
957       free (ys);
958       ys = NULL;
959       free (fs);
960       fs = NULL;
961       free (ws);
962       ws = NULL;
963     }  
964 }
\end{DoxyCode}
\hypertarget{spc__back_8h_abf5f23ed5ff402f6f7f71fd32eed9164}{
\index{spc\_\-back.h@{spc\_\-back.h}!compute\_\-gvalue@{compute\_\-gvalue}}
\index{compute\_\-gvalue@{compute\_\-gvalue}!spc_back.h@{spc\_\-back.h}}
\subsubsection[{compute\_\-gvalue}]{\setlength{\rightskip}{0pt plus 5cm}double compute\_\-gvalue (const double {\em xdiff}, \/  const double {\em efactor})}}
\label{spc__back_8h_abf5f23ed5ff402f6f7f71fd32eed9164}
Function: compute\_\-gvalue The function computes the values of a Gauss function \mbox{[}exp(factor $\ast$ xdiff$^\wedge$2)\mbox{]}. NO normalization factor is applied.

Parameters: 
\begin{DoxyParams}{Parameters}
\item[{\em xdiff}]-\/ the value \mbox{[}x-\/x\_\-0\mbox{]} \item[{\em efactor}]-\/ the factor for the exponent\end{DoxyParams}
Returns: \begin{DoxyReturn}{Returns}
value -\/ the Gaussian value 
\end{DoxyReturn}



\begin{DoxyCode}
1817 {
1818   double value;
1819     
1820   // just compose the exp-function
1821   value = exp(efactor * xdiff * xdiff);
1822 
1823   // return the value
1824   return value;
1825 }
\end{DoxyCode}
\hypertarget{spc__back_8h_afa7a0622ef0b42500dbce17be8f268a4}{
\index{spc\_\-back.h@{spc\_\-back.h}!fill\_\-pixvalues@{fill\_\-pixvalues}}
\index{fill\_\-pixvalues@{fill\_\-pixvalues}!spc_back.h@{spc\_\-back.h}}
\subsubsection[{fill\_\-pixvalues}]{\setlength{\rightskip}{0pt plus 5cm}void fill\_\-pixvalues (const gsl\_\-matrix $\ast$ {\em bck\_\-mask}, \/  const int {\em smooth\_\-length}, \/  const {\bf fullimg\_\-background} $\ast$ {\em fib}, \/  const int {\em ix}, \/  const int {\em iy}, \/  gsl\_\-vector $\ast$ {\em pixvalues}, \/  gsl\_\-vector $\ast$ {\em pmask})}}
\label{spc__back_8h_afa7a0622ef0b42500dbce17be8f268a4}
Function: fill\_\-pixvalues The function provides the essential information for Gaussian smoothing for a single pixel. It fills a vector with the values of all pixels within the smoothing length. Not interpolated pixels are excluded. A mask vector provides the information on which position is filled with pixel values.

Parameters: 
\begin{DoxyParams}{Parameters}
\item[{\em bck\_\-mask}]-\/ the background mask \item[{\em smoot\_\-length}]-\/ number of pixels on either side to use for smoothing \item[{\em fib}]-\/ the background structure \item[{\em bck\_\-mask}]-\/ the background mask \item[{\em ix}]-\/ x-\/value of central pixel \item[{\em iy}]-\/ y-\/value of central pixel \item[{\em pixvalues}]-\/ vector for pixel values \item[{\em pmask}]-\/ vector for pixel mask \end{DoxyParams}



\begin{DoxyCode}
1771 {
1772   int iact;
1773   int index;
1774   
1775   // initialize the pixel values 
1776   // and the mask
1777   gsl_vector_set_all(pixvalues, 0.0);
1778   gsl_vector_set_all(pmask, 0.0);
1779 
1780   // iterate over the x-direction
1781   index=0;
1782   for (iact=ix-smooth_length; iact<=ix+smooth_length; iact++)
1783     {
1784       // check if you are within the chip
1785       if (iact > -1 && iact < bck_mask->size1)
1786         {
1787           // check whether the pixel was interpolated
1788           // and whether the background is non-zero
1789           if (gsl_matrix_get(bck_mask, iact, iy) != 0.0
1790                && gsl_matrix_get(fib->bck, iact, iy) != 0.0)
1791             {
1792               // if yes, get the pixel value and set the mask
1793               gsl_vector_set(pixvalues, index, gsl_matrix_get(fib->bck, iact, iy)
      );
1794               gsl_vector_set(pmask,     index, 1.0);
1795             }
1796         }
1797       // enhance the vector index
1798       index++;
1799     }
1800 }
\end{DoxyCode}
\hypertarget{spc__back_8h_a93385bb1fe9bbdba33d07ccfa28fbad9}{
\index{spc\_\-back.h@{spc\_\-back.h}!free\_\-fullimg\_\-background@{free\_\-fullimg\_\-background}}
\index{free\_\-fullimg\_\-background@{free\_\-fullimg\_\-background}!spc_back.h@{spc\_\-back.h}}
\subsubsection[{free\_\-fullimg\_\-background}]{\setlength{\rightskip}{0pt plus 5cm}void free\_\-fullimg\_\-background ({\bf background} $\ast$ {\em backg})}}
\label{spc__back_8h_a93385bb1fe9bbdba33d07ccfa28fbad9}
Function: free\_\-fullimg\_\-background Frees a background structure allocated using make\_\-fullimg\_\-background

Parameters: 
\begin{DoxyParams}{Parameters}
\item[{\em backg}]-\/ a pointer to the background structure to free \end{DoxyParams}



\begin{DoxyCode}
1307 {
1308   fullimg_background *fib = backg->pars;
1309   
1310   gsl_matrix_free (fib->bck);
1311   if (fib->err)
1312     {
1313       gsl_matrix_free (fib->err);
1314     }
1315   free (backg);
1316   backg = NULL;
1317 }
\end{DoxyCode}
\hypertarget{spc__back_8h_a312989afed586d6646f6c5e46d94c5b2}{
\index{spc\_\-back.h@{spc\_\-back.h}!fullimg\_\-background\_\-function@{fullimg\_\-background\_\-function}}
\index{fullimg\_\-background\_\-function@{fullimg\_\-background\_\-function}!spc_back.h@{spc\_\-back.h}}
\subsubsection[{fullimg\_\-background\_\-function}]{\setlength{\rightskip}{0pt plus 5cm}void fullimg\_\-background\_\-function (const int {\em x}, \/  const int {\em y}, \/  PIXEL\_\-T $\ast$const  {\em val}, \/  PIXEL\_\-T $\ast$const  {\em err}, \/  const {\bf background} $\ast$const  {\em back})}}
\label{spc__back_8h_a312989afed586d6646f6c5e46d94c5b2}
Function: fullimg\_\-background\_\-function Returns the background level for the point x, y if a complete gsl\_\-matrix of the background is available. This function is exposed to the outside through a pointer in the \hyperlink{structobservation}{observation} structure.

Parameters: 
\begin{DoxyParams}{Parameters}
\item[{\em x}]ad nauseam \item[{\em y}]ad nauseam \item[{\em val}]pointer to a double to leave the background value in \item[{\em err}]pointer to a double to leave the absolute error of val in \item[{\em pars}]a gsl\_\-matrix containing the background \end{DoxyParams}



\begin{DoxyCode}
986 {
987   const fullimg_background *const fib = back->pars;
988   
989   *val = gsl_matrix_get (fib->bck, (int) rint (x), (int) rint (y));
990   if (fib->err)
991     {
992       *err = gsl_matrix_get (fib->err, (int) rint (x), (int) rint (y));
993     }
994   else
995     {
996       *err = 0;
997     }
998 }
\end{DoxyCode}
\hypertarget{spc__back_8h_a55bae5da45fa33dec8efc0f57981f1e4}{
\index{spc\_\-back.h@{spc\_\-back.h}!get\_\-interp\_\-points@{get\_\-interp\_\-points}}
\index{get\_\-interp\_\-points@{get\_\-interp\_\-points}!spc_back.h@{spc\_\-back.h}}
\subsubsection[{get\_\-interp\_\-points}]{\setlength{\rightskip}{0pt plus 5cm}gsl\_\-vector\_\-int$\ast$ get\_\-interp\_\-points ({\bf observation} $\ast$ {\em obs}, \/  gsl\_\-matrix $\ast$ {\em bck\_\-mask}, \/  int {\em np}, \/  {\bf px\_\-point} {\em tr\_\-point})}}
\label{spc__back_8h_a55bae5da45fa33dec8efc0f57981f1e4}
Function: get\_\-window\_\-points The subroutine searches in a window around the tracepoint for pixels which are suited for the background determination. The extend of the window is specified in the \hyperlink{structbeam}{beam} structured, and pixel which are part of any \hyperlink{structbeam}{beam} can not be used.

Parameters: 
\begin{DoxyParams}{Parameters}
\item[{\em obs}]-\/ the \hyperlink{structobservation}{observation} \item[{\em bck\_\-mask}]-\/ the background mask \item[{\em actbeam}]-\/ the \hyperlink{structbeam}{beam} to search interp points for \item[{\em tr\_\-point}]-\/ the integer trace point\end{DoxyParams}
Returns: \begin{DoxyReturn}{Returns}
ret -\/ the vector with the row numbers Function: get\_\-interp\_\-points The function searches for 2$\ast$n interpolation points above and below the trace. The search is iteratively from the trace in both directions. In case that the fram borders are met, the respective direction is \char`\"{}closed\char`\"{}. The subroutine then tries to get more background pixels on the other size to reach the desired number.
\end{DoxyReturn}
Parameters: 
\begin{DoxyParams}{Parameters}
\item[{\em obs}]-\/ the \hyperlink{structobservation}{observation} \item[{\em bck\_\-mask}]-\/ the background mask \item[{\em np}]-\/ the desired number of interp. points \item[{\em tr\_\-point}]-\/ the integer trace point\end{DoxyParams}
Returns: \begin{DoxyReturn}{Returns}
ret -\/ the vector with the row numbers 
\end{DoxyReturn}



\begin{DoxyCode}
251 {
252   gsl_vector_int *tmp;
253   gsl_vector_int *ret;
254   int np_act=0;
255   //int y_low;
256   //int y_upp;
257   int l_space=1;
258   int u_space=1;
259   int l_act;
260   int u_act;
261   int l_np=0;
262   int u_np=0;
263   int ncols=obs->grism->size2;
264   int ii;
265 
266   // allocate the vector
267   tmp = gsl_vector_int_alloc(2*np+2);
268   
269   // limit the starting ppoint of the search 
270   // to values within the image dimension
271   tr_point.y = MAX(0,tr_point.y);
272   tr_point.y = MIN((int)obs->grism->size2,tr_point.y);
273 
274   // initialize the row numbers
275   // to search up- and downwards
276   l_act = tr_point.y -1;
277   u_act = tr_point.y;
278 
279   // as long as interpolation points are missing 
280   // and one direction, either up or down,
281   // is 'open', continue searching
282   while (np_act < 2*np && (l_space || u_space))
283     {
284 
285       // check whether the direction
286       // downwards is still open
287       if (l_space)
288         {
289           // move downward until you either find 
290           // and interp. point or the end of the frame
291           while (l_act > -1 && (gsl_matrix_get(bck_mask,tr_point.x,l_act)
292                                 !=0 ||
293                                 isnan(gsl_matrix_get(obs->grism,
294                                                      tr_point.x, l_act))))
295             {
296               l_act--;
297             }
298 
299           // if you are at the end of the frame
300           if (l_act < 0)
301             {
302               // close the direction downwards
303               l_space=0;
304             }
305           else
306             {
307               // else store the interpolation point,
308               // do the various increments
309               gsl_vector_int_set(tmp, np_act, l_act);
310               np_act++;
311               l_np++;
312               l_act--;
313             }
314         }
315       
316       // check whether the direction
317       // upwards is still open
318       if (u_space)
319         {
320           // move upward until you either find 
321           // and interp. point or the end of the frame
322           while (u_act < ncols && (gsl_matrix_get(bck_mask,tr_point.x,u_act)
323                                    !=0 ||
324                                    isnan(gsl_matrix_get(obs->grism,
325                                                         tr_point.x, u_act))))
326             {
327               u_act++;
328             }
329 
330           // if you are at the end of the frame
331           if (u_act >= ncols)
332             {
333               // close the direction upwards
334               u_space=0;
335             }
336           else
337             {
338               // else store the interpolation point,
339               // do the various increments
340               gsl_vector_int_set(tmp, np_act, u_act);
341               np_act++;
342               u_np++;
343               u_act++;
344             }     
345         }
346     }
347   
348   // check whether the beam extends over
349   // the image. Add an artificial start or
350   // end point if necessary
351   if (!l_np)
352     gsl_vector_int_set(tmp, np_act++, -1);
353   if (!u_np)
354     gsl_vector_int_set(tmp, np_act++, ncols);
355 
356   // transfer the row numbers to a
357   // vector of the right size
358   ret = gsl_vector_int_alloc(np_act);
359   for (ii=0; ii < np_act; ii++)
360     gsl_vector_int_set(ret, ii, gsl_vector_int_get(tmp, ii));
361 
362   // sort the row numbers
363   gsl_sort_vector_int(ret);
364 
365   // release memory
366   gsl_vector_int_free(tmp);
367 
368   //  return the result
369   return ret;
370 }
\end{DoxyCode}
\hypertarget{spc__back_8h_ace0c3cfc253b812f88ed84838d0abec2}{
\index{spc\_\-back.h@{spc\_\-back.h}!get\_\-weighted\_\-mean@{get\_\-weighted\_\-mean}}
\index{get\_\-weighted\_\-mean@{get\_\-weighted\_\-mean}!spc_back.h@{spc\_\-back.h}}
\subsubsection[{get\_\-weighted\_\-mean}]{\setlength{\rightskip}{0pt plus 5cm}double get\_\-weighted\_\-mean (const gsl\_\-vector $\ast$ {\em pixvalues}, \/  const gsl\_\-vector $\ast$ {\em weights}, \/  const gsl\_\-vector $\ast$ {\em pmask})}}
\label{spc__back_8h_ace0c3cfc253b812f88ed84838d0abec2}
Function: get\_\-weighted\_\-mean The function computes the weighted mean of values stored in a value vector and a weight vector. As mask vector marks values pixels not to be considered. Using a separate mask vectorhas the advantage the weights can be kept constant and do not have to be re-\/calculated in repeated runs.

Parameters: 
\begin{DoxyParams}{Parameters}
\item[{\em pixvalues}]-\/ vector with pixel values \item[{\em weights}]-\/ vector with weights \item[{\em pmask}]-\/ mask vector\end{DoxyParams}
Returns: \begin{DoxyReturn}{Returns}
sum/www -\/ the weighted mean 
\end{DoxyReturn}



\begin{DoxyCode}
1722 {
1723   int index;
1724 
1725   // initialize the total
1726   // sum and weight
1727   double sum=0.0;
1728   double www=0.0;
1729 
1730   for (index=0; index < pixvalues->size; index ++)
1731     {
1732 
1733       if (gsl_vector_get(pmask, index))
1734         {
1735           // enhance the total sum
1736           sum += gsl_vector_get(pixvalues, index) * gsl_vector_get(weights, index
      );
1737           
1738           // enhance the total weight
1739           www += gsl_vector_get(weights, index);
1740         }
1741     }
1742 
1743   // return the total sum,
1744   // divided by the total weight
1745   return sum / www;
1746 }
\end{DoxyCode}
\hypertarget{spc__back_8h_ad7c9963cb80da0010581906c46dde765}{
\index{spc\_\-back.h@{spc\_\-back.h}!get\_\-xrange@{get\_\-xrange}}
\index{get\_\-xrange@{get\_\-xrange}!spc_back.h@{spc\_\-back.h}}
\subsubsection[{get\_\-xrange}]{\setlength{\rightskip}{0pt plus 5cm}{\bf px\_\-point} get\_\-xrange ({\bf observation} $\ast$ {\em obs}, \/  {\bf beam} {\em actbeam})}}
\label{spc__back_8h_ad7c9963cb80da0010581906c46dde765}
Function: get\_\-xrange The subroutine determines the extend of a \hyperlink{structbeam}{beam} in x-\/direction. The minimum and maximum value in x of pixels which are part of the particular \hyperlink{structbeam}{beam} are determined and returned.

Parameters: 
\begin{DoxyParams}{Parameters}
\item[{\em obs}]-\/ the \hyperlink{structobject}{object} list \item[{\em actbeam}]-\/ the \hyperlink{structbeam}{beam} to determine the extent for\end{DoxyParams}
Returns: \begin{DoxyReturn}{Returns}
ret -\/ Min/Max values of the \hyperlink{structbeam}{beam} in x 
\end{DoxyReturn}



\begin{DoxyCode}
559 {
560 
561   px_point ret;
562 
563   // Find the object starting and ending column
564   // for the beam of interest actbeam.corners
565   ret.x = MIN (MIN (MIN (actbeam.corners[0].x, actbeam.corners[1].x),
566                     actbeam.corners[2].x), actbeam.corners[3].x);
567   ret.y  = MAX (MAX (MAX (actbeam.corners[0].x, actbeam.corners[1].x),
568                      actbeam.corners[2].x), actbeam.corners[3].x);
569   
570   // limit the start and end column
571   // to the image size
572   ret.x = MAX(ret.x, 0);
573   ret.y = MIN(ret.y, (int)obs->grism->size1);
574 
575   // warn if the beam is completely outside
576   // the grism image
577   if (ret.x > obs->grism->size1 || ret.y < 0)
578     {
579       aXe_message (aXe_M_WARN4, __FILE__, __LINE__,
580                    "Object  is not in the image start_i:%d end_i:%d",
581                    ret.x, ret.y);
582     }
583 
584   // return the result
585   return ret;
586 }
\end{DoxyCode}
\hypertarget{spc__back_8h_a7e25af7fc45ffda6d9b8c6612219a32f}{
\index{spc\_\-back.h@{spc\_\-back.h}!gsmooth\_\-background@{gsmooth\_\-background}}
\index{gsmooth\_\-background@{gsmooth\_\-background}!spc_back.h@{spc\_\-back.h}}
\subsubsection[{gsmooth\_\-background}]{\setlength{\rightskip}{0pt plus 5cm}void gsmooth\_\-background (const gsl\_\-matrix $\ast$ {\em bck\_\-mask}, \/  const int {\em smooth\_\-length}, \/  const double {\em fwhm}, \/  {\bf fullimg\_\-background} $\ast$ {\em fib})}}
\label{spc__back_8h_a7e25af7fc45ffda6d9b8c6612219a32f}
Function: gsmooth\_\-background Smooth all interpolated pixel in the background using a Gaussian function. The smoothing is done exclusively towards the x-\/values. The smoothing should help to reduce the noise from the limited number of background pixels.

Parameters: 
\begin{DoxyParams}{Parameters}
\item[{\em bck\_\-mask}]-\/ the background mask \item[{\em smoot\_\-length}]-\/ number of pixels on either side to use for smoothing \item[{\em fwhm}]-\/ fwhm of the Gaussian \item[{\em fib}]-\/ the background structure \end{DoxyParams}



\begin{DoxyCode}
1637 {
1638   double efactor;
1639 
1640   int ix, iy;
1641 
1642   gsl_vector *pixvalues;
1643   gsl_vector *weights;
1644   gsl_vector *pmask;
1645 
1646   gsl_matrix *new_bck;
1647 
1648   // allocate memory for the vectors
1649   pixvalues = gsl_vector_alloc(2 * smooth_length + 1);
1650   weights   = gsl_vector_alloc(2 * smooth_length + 1);
1651   pmask     = gsl_vector_alloc(2 * smooth_length + 1);
1652 
1653   // allocate the new background
1654   // and initialize it
1655   new_bck = gsl_matrix_alloc(bck_mask->size1, bck_mask->size2);
1656   gsl_matrix_set_all(new_bck, 0.0);
1657 
1658   // prepare the Gaussian
1659   efactor = compute_efactor(fwhm);
1660 
1661   // fill the weights
1662   for (ix=0; ix < weights->size; ix++)
1663     gsl_vector_set(weights, ix, compute_gvalue((double)ix - (double)smooth_length
      , efactor));
1664   
1665 
1666   // go over all rows
1667   for (iy=0; iy < fib->bck->size2; iy++)
1668     {
1669       // go over all columns
1670       for (ix=0; ix < fib->bck->size1; ix++)
1671         {
1672           // check whether the pixel IS part of a beam
1673           if (!(gsl_matrix_get(bck_mask, ix, iy) != 0.0
1674                 && gsl_matrix_get(fib->bck, ix, iy) !=0.0))
1675             {
1676               // transfer the old background value
1677               gsl_matrix_set(new_bck, ix, iy, gsl_matrix_get(fib->bck, ix, iy));
1678             }
1679           else
1680             {
1681               // fill the pixel and mask values
1682               fill_pixvalues(bck_mask, smooth_length, fib, ix, iy, pixvalues, pma
      sk);
1683 
1684               // fill in the weighted mean
1685               gsl_matrix_set(new_bck, ix, iy, get_weighted_mean(pixvalues, weight
      s, pmask));
1686             }
1687         } 
1688     }
1689 
1690   // release the allocated dspace
1691   gsl_vector_free(pixvalues);
1692   gsl_vector_free(weights);
1693   gsl_vector_free(pmask);
1694 
1695   // release the memory of the
1696   // old background
1697   gsl_matrix_free(fib->bck);
1698 
1699   // transfer the new background
1700   // to the background structure
1701   fib->bck = new_bck;
1702 }
\end{DoxyCode}
\hypertarget{spc__back_8h_ac1c2518944b7c7dbaa14041f46c07187}{
\index{spc\_\-back.h@{spc\_\-back.h}!is\_\-pt\_\-in\_\-a\_\-beam@{is\_\-pt\_\-in\_\-a\_\-beam}}
\index{is\_\-pt\_\-in\_\-a\_\-beam@{is\_\-pt\_\-in\_\-a\_\-beam}!spc_back.h@{spc\_\-back.h}}
\subsubsection[{is\_\-pt\_\-in\_\-a\_\-beam}]{\setlength{\rightskip}{0pt plus 5cm}int is\_\-pt\_\-in\_\-a\_\-beam (const {\bf px\_\-point} $\ast$const  {\em apoint}, \/  const {\bf is\_\-in\_\-descriptor} $\ast$const  {\em iids}, \/  const int {\em tnbeams})}}
\label{spc__back_8h_ac1c2518944b7c7dbaa14041f46c07187}
Function: is\_\-pt\_\-in\_\-a\_\-beam The function checks whether a particular image pixel is part of a \hyperlink{structbeam}{beam} or not. The pixel is checked against an array of beams it could be part of.

Parameters: 
\begin{DoxyParams}{Parameters}
\item[{\em apoint}]-\/ the point to check \item[{\em iids}]-\/ an array of is\_\-in\_\-descriptors for all the beams that should be checked \item[{\em tnbeams}]-\/ number of beams in iids\end{DoxyParams}
Returns: \begin{DoxyReturn}{Returns}
1/0 -\/ fixed values 
\end{DoxyReturn}



\begin{DoxyCode}
55 {
56   int i;
57   
58   for (i = 0; i < tnbeams; i++)
59     {
60       if (apoint->x < (iids + i)->mini)
61         continue;
62       if (apoint->x > (iids + i)->maxi)
63         continue;
64       if (apoint->y < (iids + i)->minj)
65         continue;
66       if (apoint->y > (iids + i)->maxj)
67         continue;
68       if (is_in (apoint->x, apoint->y, iids + i))
69         {
70           return 1;
71         }
72     }
73   return 0;
74 }
\end{DoxyCode}
\hypertarget{spc__back_8h_afe2e18a7ee7b967b8d71d7e1fb316ea7}{
\index{spc\_\-back.h@{spc\_\-back.h}!kappa\_\-sigma\_\-clipp@{kappa\_\-sigma\_\-clipp}}
\index{kappa\_\-sigma\_\-clipp@{kappa\_\-sigma\_\-clipp}!spc_back.h@{spc\_\-back.h}}
\subsubsection[{kappa\_\-sigma\_\-clipp}]{\setlength{\rightskip}{0pt plus 5cm}void kappa\_\-sigma\_\-clipp (const double $\ast$const  {\em xs}, \/  double $\ast$const  {\em ys}, \/  double $\ast$const  {\em ws}, \/  const int {\em n}, \/  const double {\em kappa}, \/  {\bf observation} $\ast$ {\em obs}, \/  int {\em colnum})}}
\label{spc__back_8h_afe2e18a7ee7b967b8d71d7e1fb316ea7}
Function: kappa\_\-sigma\_\-clipp The subroutine performs one kappa-\/sigma step on the data given in various vectors for independent, dipendent and weight data. The difference to apply the clipping on is \char`\"{}original value $<$minus$>$ median of the data set\char`\"{}.

Parameters: 
\begin{DoxyParams}{Parameters}
\item[{\em xs}]-\/ array for independent values \item[{\em ys}]-\/ array for dependent values \item[{\em ws}]-\/ weight array \item[{\em n}]-\/ number of pixels \item[{\em kappa}]-\/ the kappa value for rejection \item[{\em obs}]-\/ the \hyperlink{structobject}{object} list \item[{\em colnum}]-\/ the column number \end{DoxyParams}



\begin{DoxyCode}
709 {
710   double *ys_tmp, *ys_med;
711 
712   int *iindex;
713 
714   int ii, m=0, npixel=0;
715 
716   double median=0.0, stdev=0.0;
717 
718   // allocate memory for temporay vectors
719   ys_tmp = (double *) malloc (n * sizeof (double));
720   ys_med = (double *) malloc (n * sizeof (double));
721   iindex = (int *) malloc (n * sizeof (int));
722 
723   // store the background values 
724   // in the temporary vectors
725   for (ii=0; ii < n; ii++)
726     {
727       if (ws[ii] != 0.0)
728         {
729           ys_tmp[m] = ys[ii];
730           ys_med[m] = ys[ii];
731           iindex[m] = ii;
732           m++;
733         }
734     }
735 
736   // derive median and standard deviation
737   gsl_sort (ys_tmp, 1, m);
738   median = gsl_stats_median_from_sorted_data(ys_tmp, 1, m); 
739   stdev = gsl_stats_sd_m (ys_med, 1, m, median);
740 
741   // apply the clipping
742   npixel=0;
743   for (ii=0; ii < m; ii++)
744     {
745       // check whether the pixel should
746       // be clipped
747       if (fabs(ys_med[ii]-median) > kappa*stdev)
748         {
749           // set the weight of a clipped pixel to 0.0
750           ws[iindex[ii]] = 0.0;
751           // mark the clipped pixel in the dq-array
752           gsl_matrix_set(obs->dq, colnum, xs[iindex[ii]], DQ_KAPPA_SIGMA);
753         }
754       else
755         {
756           npixel++;
757         }
758 
759     }
760 
761   // release memory
762   free(ys_med);
763   free(ys_tmp);
764   free(iindex);
765 }
\end{DoxyCode}
