\hypertarget{lmmin_8c}{
\section{/renoir/fourmano/Desktop/OUSIM/TIPS/branches/tips\_\-build/src/axesim/lmmin.c File Reference}
\label{lmmin_8c}\index{/renoir/fourmano/Desktop/OUSIM/TIPS/branches/tips\_\-build/src/axesim/lmmin.c@{/renoir/fourmano/Desktop/OUSIM/TIPS/branches/tips\_\-build/src/axesim/lmmin.c}}
}
{\ttfamily \#include $<$stdlib.h$>$}\par
{\ttfamily \#include $<$math.h$>$}\par
{\ttfamily \#include \char`\"{}lmmin.h\char`\"{}}\par
\subsection*{Defines}
\begin{DoxyCompactItemize}
\item 
\#define \hyperlink{lmmin_8c_a643e0537bce53ecbbbab1d0db857d52c}{\_\-LMDIF}
\item 
\#define \hyperlink{lmmin_8c_ae92477bf5af64a0486e8b99c45790c9c}{BUG}~0
\item 
\#define \hyperlink{lmmin_8c_a01b46cc2cae4eee231acb7702df379db}{LM\_\-MACHEP}~.555e-\/16
\item 
\#define \hyperlink{lmmin_8c_a2ee34e0a4f4a4b860c14a8ab07e3cec3}{LM\_\-DWARF}~9.9e-\/324
\item 
\#define \hyperlink{lmmin_8c_a65e2a867eb21938170bb9a8a850b64ec}{LM\_\-SQRT\_\-DWARF}~1.e-\/160
\item 
\#define \hyperlink{lmmin_8c_a057d1d13f0effa33d81c7615e4f3664d}{LM\_\-SQRT\_\-GIANT}~1.e150
\item 
\#define \hyperlink{lmmin_8c_a3acffbd305ee72dcd4593c0d8af64a4f}{MIN}(a, b)~(((a)$<$=(b)) ? (a) : (b))
\item 
\#define \hyperlink{lmmin_8c_afa99ec4acc4ecb2dc3c2d05da15d0e3f}{MAX}(a, b)~(((a)$>$=(b)) ? (a) : (b))
\item 
\#define \hyperlink{lmmin_8c_aa7866fa5e4e0ee9b034e9dab6599a9cc}{SQR}(x)~(x)$\ast$(x)
\end{DoxyCompactItemize}
\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
void \hyperlink{lmmin_8c_acca4ad218695fb19545602619924c1d4}{lm\_\-initialize\_\-control} (\hyperlink{structlm__control__type}{lm\_\-control\_\-type} $\ast$control)
\item 
void \hyperlink{lmmin_8c_acccb5d208acdc6abd1cd784fc16f37f3}{lm\_\-minimize} (int m\_\-dat, int n\_\-par, double $\ast$par, \hyperlink{lmmin_8h_afdeb6de6c69fbcb763f18605fe248cd4}{lm\_\-evaluate\_\-ftype} $\ast$evaluate, \hyperlink{lmmin_8h_ae6bdc55b42e1ebd56053992d041b288b}{lm\_\-print\_\-ftype} $\ast$printout, void $\ast$data, \hyperlink{structlm__control__type}{lm\_\-control\_\-type} $\ast$control)
\item 
void \hyperlink{lmmin_8c_aa72b372e483c92753b89a59aa3128b64}{lm\_\-qrfac} (int m, int n, double $\ast$a, int pivot, int $\ast$ipvt, double $\ast$rdiag, double $\ast$acnorm, double $\ast$wa)
\item 
void \hyperlink{lmmin_8c_a0543234dc4a8534dffcec238a778916a}{lm\_\-qrsolv} (int n, double $\ast$r, int ldr, int $\ast$ipvt, double $\ast$diag, double $\ast$qtb, double $\ast$x, double $\ast$sdiag, double $\ast$wa)
\item 
void \hyperlink{lmmin_8c_a64fcb82c1daa55fe6571c80e00e57f91}{lm\_\-lmpar} (int n, double $\ast$r, int ldr, int $\ast$ipvt, double $\ast$diag, double $\ast$qtb, double delta, double $\ast$par, double $\ast$x, double $\ast$sdiag, double $\ast$wa1, double $\ast$wa2)
\item 
void \hyperlink{lmmin_8c_ad9d7115eaad1df34edf2efd92c794dbf}{lm\_\-lmdif} (int m, int n, double $\ast$x, double $\ast$fvec, double ftol, double xtol, double gtol, int maxfev, double epsfcn, double $\ast$diag, int mode, double factor, int $\ast$info, int $\ast$nfev, double $\ast$fjac, int $\ast$ipvt, double $\ast$qtf, double $\ast$wa1, double $\ast$wa2, double $\ast$wa3, double $\ast$wa4, \hyperlink{lmmin_8h_afdeb6de6c69fbcb763f18605fe248cd4}{lm\_\-evaluate\_\-ftype} $\ast$evaluate, \hyperlink{lmmin_8h_ae6bdc55b42e1ebd56053992d041b288b}{lm\_\-print\_\-ftype} $\ast$printout, void $\ast$data)
\item 
double \hyperlink{lmmin_8c_a1d52749c735c535bc1de4b3787606b80}{lm\_\-enorm} (int n, double $\ast$x)
\end{DoxyCompactItemize}
\subsection*{Variables}
\begin{DoxyCompactItemize}
\item 
char $\ast$ \hyperlink{lmmin_8c_a70193f2f4a5345b9f9bacb3ed580309a}{lm\_\-infmsg} \mbox{[}$\,$\mbox{]}
\item 
char $\ast$ \hyperlink{lmmin_8c_adf858362eeb838628ef333f11773cdb6}{lm\_\-shortmsg} \mbox{[}$\,$\mbox{]}
\end{DoxyCompactItemize}


\subsection{Define Documentation}
\hypertarget{lmmin_8c_a643e0537bce53ecbbbab1d0db857d52c}{
\index{lmmin.c@{lmmin.c}!\_\-LMDIF@{\_\-LMDIF}}
\index{\_\-LMDIF@{\_\-LMDIF}!lmmin.c@{lmmin.c}}
\subsubsection[{\_\-LMDIF}]{\setlength{\rightskip}{0pt plus 5cm}\#define \_\-LMDIF}}
\label{lmmin_8c_a643e0537bce53ecbbbab1d0db857d52c}
\hypertarget{lmmin_8c_ae92477bf5af64a0486e8b99c45790c9c}{
\index{lmmin.c@{lmmin.c}!BUG@{BUG}}
\index{BUG@{BUG}!lmmin.c@{lmmin.c}}
\subsubsection[{BUG}]{\setlength{\rightskip}{0pt plus 5cm}\#define BUG~0}}
\label{lmmin_8c_ae92477bf5af64a0486e8b99c45790c9c}
\hypertarget{lmmin_8c_a2ee34e0a4f4a4b860c14a8ab07e3cec3}{
\index{lmmin.c@{lmmin.c}!LM\_\-DWARF@{LM\_\-DWARF}}
\index{LM\_\-DWARF@{LM\_\-DWARF}!lmmin.c@{lmmin.c}}
\subsubsection[{LM\_\-DWARF}]{\setlength{\rightskip}{0pt plus 5cm}\#define LM\_\-DWARF~9.9e-\/324}}
\label{lmmin_8c_a2ee34e0a4f4a4b860c14a8ab07e3cec3}
\hypertarget{lmmin_8c_a01b46cc2cae4eee231acb7702df379db}{
\index{lmmin.c@{lmmin.c}!LM\_\-MACHEP@{LM\_\-MACHEP}}
\index{LM\_\-MACHEP@{LM\_\-MACHEP}!lmmin.c@{lmmin.c}}
\subsubsection[{LM\_\-MACHEP}]{\setlength{\rightskip}{0pt plus 5cm}\#define LM\_\-MACHEP~.555e-\/16}}
\label{lmmin_8c_a01b46cc2cae4eee231acb7702df379db}
\hypertarget{lmmin_8c_a65e2a867eb21938170bb9a8a850b64ec}{
\index{lmmin.c@{lmmin.c}!LM\_\-SQRT\_\-DWARF@{LM\_\-SQRT\_\-DWARF}}
\index{LM\_\-SQRT\_\-DWARF@{LM\_\-SQRT\_\-DWARF}!lmmin.c@{lmmin.c}}
\subsubsection[{LM\_\-SQRT\_\-DWARF}]{\setlength{\rightskip}{0pt plus 5cm}\#define LM\_\-SQRT\_\-DWARF~1.e-\/160}}
\label{lmmin_8c_a65e2a867eb21938170bb9a8a850b64ec}
\hypertarget{lmmin_8c_a057d1d13f0effa33d81c7615e4f3664d}{
\index{lmmin.c@{lmmin.c}!LM\_\-SQRT\_\-GIANT@{LM\_\-SQRT\_\-GIANT}}
\index{LM\_\-SQRT\_\-GIANT@{LM\_\-SQRT\_\-GIANT}!lmmin.c@{lmmin.c}}
\subsubsection[{LM\_\-SQRT\_\-GIANT}]{\setlength{\rightskip}{0pt plus 5cm}\#define LM\_\-SQRT\_\-GIANT~1.e150}}
\label{lmmin_8c_a057d1d13f0effa33d81c7615e4f3664d}
\hypertarget{lmmin_8c_afa99ec4acc4ecb2dc3c2d05da15d0e3f}{
\index{lmmin.c@{lmmin.c}!MAX@{MAX}}
\index{MAX@{MAX}!lmmin.c@{lmmin.c}}
\subsubsection[{MAX}]{\setlength{\rightskip}{0pt plus 5cm}\#define MAX(a, \/  b)~(((a)$>$=(b)) ? (a) : (b))}}
\label{lmmin_8c_afa99ec4acc4ecb2dc3c2d05da15d0e3f}
\hypertarget{lmmin_8c_a3acffbd305ee72dcd4593c0d8af64a4f}{
\index{lmmin.c@{lmmin.c}!MIN@{MIN}}
\index{MIN@{MIN}!lmmin.c@{lmmin.c}}
\subsubsection[{MIN}]{\setlength{\rightskip}{0pt plus 5cm}\#define MIN(a, \/  b)~(((a)$<$=(b)) ? (a) : (b))}}
\label{lmmin_8c_a3acffbd305ee72dcd4593c0d8af64a4f}
\hypertarget{lmmin_8c_aa7866fa5e4e0ee9b034e9dab6599a9cc}{
\index{lmmin.c@{lmmin.c}!SQR@{SQR}}
\index{SQR@{SQR}!lmmin.c@{lmmin.c}}
\subsubsection[{SQR}]{\setlength{\rightskip}{0pt plus 5cm}\#define SQR(x)~(x)$\ast$(x)}}
\label{lmmin_8c_aa7866fa5e4e0ee9b034e9dab6599a9cc}


\subsection{Function Documentation}
\hypertarget{lmmin_8c_a1d52749c735c535bc1de4b3787606b80}{
\index{lmmin.c@{lmmin.c}!lm\_\-enorm@{lm\_\-enorm}}
\index{lm\_\-enorm@{lm\_\-enorm}!lmmin.c@{lmmin.c}}
\subsubsection[{lm\_\-enorm}]{\setlength{\rightskip}{0pt plus 5cm}double lm\_\-enorm (int {\em n}, \/  double $\ast$ {\em x})}}
\label{lmmin_8c_a1d52749c735c535bc1de4b3787606b80}



\begin{DoxyCode}
1233 {
1234 /*     given an n-vector x, this function calculates the
1235  *     euclidean norm of x.
1236  *
1237  *     the euclidean norm is computed by accumulating the sum of
1238  *     squares in three different sums. the sums of squares for the
1239  *     small and large components are scaled so that no overflows
1240  *     occur. non-destructive underflows are permitted. underflows
1241  *     and overflows do not occur in the computation of the unscaled
1242  *     sum of squares for the intermediate components.
1243  *     the definitions of small, intermediate and large components
1244  *     depend on two constants, LM_SQRT_DWARF and LM_SQRT_GIANT. the main
1245  *     restrictions on these constants are that LM_SQRT_DWARF**2 not
1246  *     underflow and LM_SQRT_GIANT**2 not overflow.
1247  *
1248  *     parameters
1249  *
1250  *      n is a positive integer input variable.
1251  *
1252  *      x is an input array of length n.
1253  */
1254     int i;
1255     double agiant, s1, s2, s3, xabs, x1max, x3max, temp;
1256 
1257     s1 = 0;
1258     s2 = 0;
1259     s3 = 0;
1260     x1max = 0;
1261     x3max = 0;
1262     agiant = LM_SQRT_GIANT/( (double) n);
1263 
1264     for ( i=0; i<n; i++ )
1265     {
1266         xabs = fabs(x[i]);
1267         if ( xabs > LM_SQRT_DWARF && xabs < agiant )
1268         {
1269 // **  sum for intermediate components.
1270             s2 += xabs*xabs;
1271             continue;
1272         }
1273 
1274         if ( xabs >  LM_SQRT_DWARF )
1275         {
1276 // **  sum for large components.
1277             if (xabs > x1max)
1278             {
1279                 temp = x1max/xabs;
1280                 s1 = 1 + s1*SQR(temp);
1281                 x1max = xabs;
1282             }
1283             else
1284             {
1285                 temp = xabs/x1max;
1286                 s1 += SQR(temp);
1287             }
1288             continue;
1289         }
1290 // **  sum for small components.
1291         if (xabs > x3max)
1292         {
1293             temp = x3max/xabs;
1294             s3 = 1 + s3*SQR(temp);
1295             x3max = xabs;
1296         }
1297         else    
1298         {
1299             if (xabs != 0.)
1300             {
1301                 temp = xabs/x3max;
1302                 s3 += SQR(temp);
1303             }
1304         }
1305     }
1306 
1307 // *** calculation of norm.
1308 
1309     if (s1 != 0)
1310         return x1max*sqrt(s1 + (s2/x1max)/x1max);
1311     if (s2 != 0)
1312     {
1313         if (s2 >= x3max)
1314             return sqrt( s2*(1+(x3max/s2)*(x3max*s3)) );
1315         else
1316             return sqrt( x3max*((s2/x3max)+(x3max*s3)) );
1317     }
1318 
1319     return x3max*sqrt(s3);
1320 }
\end{DoxyCode}
\hypertarget{lmmin_8c_acca4ad218695fb19545602619924c1d4}{
\index{lmmin.c@{lmmin.c}!lm\_\-initialize\_\-control@{lm\_\-initialize\_\-control}}
\index{lm\_\-initialize\_\-control@{lm\_\-initialize\_\-control}!lmmin.c@{lmmin.c}}
\subsubsection[{lm\_\-initialize\_\-control}]{\setlength{\rightskip}{0pt plus 5cm}void lm\_\-initialize\_\-control ({\bf lm\_\-control\_\-type} $\ast$ {\em control})}}
\label{lmmin_8c_acca4ad218695fb19545602619924c1d4}



\begin{DoxyCode}
26 {
27     control->maxcall = 100;
28     control->epsilon = 1.e-14;
29     control->stepbound = 100.;
30     control->ftol = 1.e-14;
31     control->xtol = 1.e-14;
32     control->gtol = 1.e-14;
33 }
\end{DoxyCode}
\hypertarget{lmmin_8c_ad9d7115eaad1df34edf2efd92c794dbf}{
\index{lmmin.c@{lmmin.c}!lm\_\-lmdif@{lm\_\-lmdif}}
\index{lm\_\-lmdif@{lm\_\-lmdif}!lmmin.c@{lmmin.c}}
\subsubsection[{lm\_\-lmdif}]{\setlength{\rightskip}{0pt plus 5cm}void lm\_\-lmdif (int {\em m}, \/  int {\em n}, \/  double $\ast$ {\em x}, \/  double $\ast$ {\em fvec}, \/  double {\em ftol}, \/  double {\em xtol}, \/  double {\em gtol}, \/  int {\em maxfev}, \/  double {\em epsfcn}, \/  double $\ast$ {\em diag}, \/  int {\em mode}, \/  double {\em factor}, \/  int $\ast$ {\em info}, \/  int $\ast$ {\em nfev}, \/  double $\ast$ {\em fjac}, \/  int $\ast$ {\em ipvt}, \/  double $\ast$ {\em qtf}, \/  double $\ast$ {\em wa1}, \/  double $\ast$ {\em wa2}, \/  double $\ast$ {\em wa3}, \/  double $\ast$ {\em wa4}, \/  {\bf lm\_\-evaluate\_\-ftype} $\ast$ {\em evaluate}, \/  {\bf lm\_\-print\_\-ftype} $\ast$ {\em printout}, \/  void $\ast$ {\em data})}}
\label{lmmin_8c_ad9d7115eaad1df34edf2efd92c794dbf}



\begin{DoxyCode}
168 {
169 /*
170  *   the purpose of lmdif is to minimize the sum of the squares of
171  *   m nonlinear functions in n variables by a modification of
172  *   the levenberg-marquardt algorithm. the user must provide a
173  *   subroutine evaluate which calculates the functions. the jacobian
174  *   is then calculated by a forward-difference approximation.
175  *
176  *   the multi-parameter interface lm_lmdif is for users who want
177  *   full control and flexibility. most users will be better off using
178  *   the simpler interface lmfit provided above.
179  *
180  *   the parameters are the same as in the legacy FORTRAN implementation,
181  *   with the following exceptions:
182  *      the old parameter ldfjac which gave leading dimension of fjac has
183  *        been deleted because this C translation makes no use of two-
184  *        dimensional arrays;
185  *      the old parameter nprint has been deleted; printout is now controlled
186  *        by the user-supplied routine *printout;
187  *      the parameter field *data and the function parameters *evaluate and
188  *        *printout have been added; they help avoiding global variables.
189  *
190  *   parameters:
191  *
192  *      m is a positive integer input variable set to the number
193  *        of functions.
194  *
195  *      n is a positive integer input variable set to the number
196  *        of variables. n must not exceed m.
197  *
198  *      x is an array of length n. on input x must contain
199  *        an initial estimate of the solution vector. on output x
200  *        contains the final estimate of the solution vector.
201  *
202  *      fvec is an output array of length m which contains
203  *        the functions evaluated at the output x.
204  *
205  *      ftol is a nonnegative input variable. termination
206  *        occurs when both the actual and predicted relative
207  *        reductions in the sum of squares are at most ftol.
208  *        therefore, ftol measures the relative error desired
209  *        in the sum of squares.
210  *
211  *      xtol is a nonnegative input variable. termination
212  *        occurs when the relative error between two consecutive
213  *        iterates is at most xtol. therefore, xtol measures the
214  *        relative error desired in the approximate solution.
215  *
216  *      gtol is a nonnegative input variable. termination
217  *        occurs when the cosine of the angle between fvec and
218  *        any column of the jacobian is at most gtol in absolute
219  *        value. therefore, gtol measures the orthogonality
220  *        desired between the function vector and the columns
221  *        of the jacobian.
222  *
223  *      maxfev is a positive integer input variable. termination
224  *        occurs when the number of calls to lm_fcn is at least
225  *        maxfev by the end of an iteration.
226  *
227  *      epsfcn is an input variable used in determining a suitable
228  *        step length for the forward-difference approximation. this
229  *        approximation assumes that the relative errors in the
230  *        functions are of the order of epsfcn. if epsfcn is less
231  *        than the machine precision, it is assumed that the relative
232  *        errors in the functions are of the order of the machine
233  *        precision.
234  *
235  *      diag is an array of length n. if mode = 1 (see below), diag is
236  *        internally set. if mode = 2, diag must contain positive entries
237  *        that serve as multiplicative scale factors for the variables.
238  *
239  *      mode is an integer input variable. if mode = 1, the
240  *        variables will be scaled internally. if mode = 2,
241  *        the scaling is specified by the input diag. other
242  *        values of mode are equivalent to mode = 1.
243  *
244  *      factor is a positive input variable used in determining the
245  *        initial step bound. this bound is set to the product of
246  *        factor and the euclidean norm of diag*x if nonzero, or else
247  *        to factor itself. in most cases factor should lie in the
248  *        interval (.1,100.). 100. is a generally recommended value.
249  *
250  *      info is an integer output variable that indicates the termination
251  *        status of lm_lmdif as follows:
252  *
253  *        info < 0  termination requested by user-supplied routine *evaluate;
254  *
255  *        info = 0  improper input parameters;
256  *
257  *        info = 1  both actual and predicted relative reductions
258  *                  in the sum of squares are at most ftol;
259  *
260  *        info = 2  relative error between two consecutive iterates
261  *                  is at most xtol;
262  *
263  *        info = 3  conditions for info = 1 and info = 2 both hold;
264  *
265  *        info = 4  the cosine of the angle between fvec and any
266  *                  column of the jacobian is at most gtol in
267  *                  absolute value;
268  *
269  *        info = 5  number of calls to lm_fcn has reached or
270  *                  exceeded maxfev;
271  *
272  *        info = 6  ftol is too small. no further reduction in
273  *                  the sum of squares is possible;
274  *
275  *        info = 7  xtol is too small. no further improvement in
276  *                  the approximate solution x is possible;
277  *
278  *        info = 8  gtol is too small. fvec is orthogonal to the
279  *                  columns of the jacobian to machine precision;
280  *
281  *      nfev is an output variable set to the number of calls to the
282  *        user-supplied routine *evaluate.
283  *
284  *      fjac is an output m by n array. the upper n by n submatrix
285  *        of fjac contains an upper triangular matrix r with
286  *        diagonal elements of nonincreasing magnitude such that
287  *
288  *               t     t           t
289  *              p *(jac *jac)*p = r *r,
290  *
291  *        where p is a permutation matrix and jac is the final
292  *        calculated jacobian. column j of p is column ipvt(j)
293  *        (see below) of the identity matrix. the lower trapezoidal
294  *        part of fjac contains information generated during
295  *        the computation of r.
296  *
297  *      ipvt is an integer output array of length n. ipvt
298  *        defines a permutation matrix p such that jac*p = q*r,
299  *        where jac is the final calculated jacobian, q is
300  *        orthogonal (not stored), and r is upper triangular
301  *        with diagonal elements of nonincreasing magnitude.
302  *        column j of p is column ipvt(j) of the identity matrix.
303  *
304  *      qtf is an output array of length n which contains
305  *        the first n elements of the vector (q transpose)*fvec.
306  *
307  *      wa1, wa2, and wa3 are work arrays of length n.
308  *
309  *      wa4 is a work array of length m.
310  *
311  *   the following parameters are newly introduced in this C translation:
312  *
313  *      evaluate is the name of the subroutine which calculates the functions.
314  *        a default implementation lm_evaluate_default is provided in lm_eval.c;
315  *        alternatively, evaluate can be provided by a user calling program.
316  *        it should be written as follows:
317  *
318  *        void evaluate ( double* par, int m_dat, double* fvec, 
319  *                       void *data, int *info )
320  *        {
321  *           // for ( i=0; i<m_dat; ++i )
322  *           //     calculate fvec[i] for given parameters par;
323  *           // to stop the minimization, 
324  *           //     set *info to a negative integer.
325  *        }
326  *
327  *      printout is the name of the subroutine which nforms about fit progress.
328  *        a default implementation lm_print_default is provided in lm_eval.c;
329  *        alternatively, printout can be provided by a user calling program.
330  *        it should be written as follows:
331  *
332  *        void printout ( int n_par, double* par, int m_dat, double* fvec, 
333  *                       void *data, int iflag, int iter, int nfev )
334  *        {
335  *           // iflag : 0 (init) 1 (outer loop) 2(inner loop) -1(terminated)
336  *           // iter  : outer loop counter
337  *           // nfev  : number of calls to *evaluate
338  *        }
339  *
340  *      data is an input pointer to an arbitrary structure that is passed to
341  *        evaluate. typically, it contains experimental data to be fitted.
342  *
343  */
344     int i, iter, j;
345     double actred, delta, dirder, eps, fnorm, fnorm1, gnorm, par, pnorm,
346         prered, ratio, step, sum, temp, temp1, temp2, temp3, xnorm;
347     static double p1 = 0.1;
348     static double p5 = 0.5;
349     static double p25 = 0.25;
350     static double p75 = 0.75;
351     static double p0001 = 1.0e-4;
352 
353     *nfev = 0; // function evaluation counter
354     iter = 1;  // outer loop counter
355     par = 0;   // levenberg-marquardt parameter 
356     delta = 0; // just to prevent a warning (initialization within if-clause)
357     xnorm = 0; // dito
358 
359     temp = MAX(epsfcn,LM_MACHEP);
360     eps = sqrt(temp); // used in calculating the Jacobian by forward differences
361 
362 // *** check the input parameters for errors.
363 
364     if ( (n <= 0) || (m < n) || (ftol < 0.)
365         || (xtol < 0.) || (gtol < 0.) || (maxfev <= 0) || (factor <= 0.) )
366     {
367         *info = 0; // invalid parameter
368         return;
369     }
370     if ( mode == 2 )  /* scaling by diag[] */
371     {
372         for ( j=0; j<n; j++ )  /* check for nonpositive elements */
373         {
374             if ( diag[j] <= 0.0 )
375             {
376                 *info = 0; // invalid parameter
377                 return;
378             }
379         }       
380     }
381 #if BUG
382     printf( "lmdif\n" );
383 #endif
384 
385 // *** evaluate the function at the starting point and calculate its norm.
386 
387     *info = 0;
388     (*evaluate)( x, m, fvec, data, info );
389     (*printout)( n, x, m, fvec, data, 0, 0, ++(*nfev) );
390     if ( *info < 0 ) return;
391     fnorm = lm_enorm(m,fvec);
392 
393 // *** the outer loop.
394 
395     do { 
396 #if BUG 
397         printf( "lmdif/ outer loop iter=%d nfev=%d fnorm=%.10e\n",
398                 iter, *nfev, fnorm );
399 #endif
400 
401 // O** calculate the jacobian matrix.
402 
403         for ( j=0; j<n; j++ )
404         {
405             temp = x[j];
406             step = eps * fabs(temp);
407             if (step == 0.) step = eps;
408             x[j] = temp + step;
409             *info = 0;
410             (*evaluate)( x, m, wa4, data, info );
411             (*printout)( n, x, m, wa4, data, 1, iter, ++(*nfev) );
412             if ( *info < 0 ) return;  // user requested break
413             x[j] = temp;
414             for ( i=0; i<m; i++ )
415                 fjac[j*m+i] = (wa4[i] - fvec[i]) / step;
416         }
417 #if BUG>1
418         // DEBUG: print the entire matrix
419         for ( i=0; i<m; i++ )
420         {
421             for ( j=0; j<n; j++ )
422                 printf( "%.5e ", y[j*m+i] );
423             printf( "\n" );
424         }
425 #endif
426 
427 // O** compute the qr factorization of the jacobian.
428 
429         lm_qrfac( m, n, fjac, 1, ipvt, wa1, wa2, wa3);
430 
431 // O** on the first iteration ... 
432 
433         if (iter == 1)
434         {
435             if (mode != 2)
436 //      ... scale according to the norms of the columns of the initial jacobian.
437             {
438                 for ( j=0; j<n; j++ )
439                 {
440                     diag[j] = wa2[j];
441                     if ( wa2[j] == 0. )
442                         diag[j] = 1.;
443                 }
444             }
445 
446 //      ... calculate the norm of the scaled x and 
447 //          initialize the step bound delta.
448 
449             for ( j=0; j<n; j++ )
450                 wa3[j] = diag[j] * x[j];
451 
452             xnorm = lm_enorm( n, wa3 );
453             delta = factor*xnorm;
454             if (delta == 0.)
455                 delta = factor;
456         }
457 
458 // O** form (q transpose)*fvec and store the first n components in qtf.
459 
460         for ( i=0; i<m; i++ )
461             wa4[i] = fvec[i];
462 
463         for ( j=0; j<n; j++ )
464         {
465             temp3 = fjac[j*m+j];
466             if (temp3 != 0.)
467             {
468                 sum = 0;
469                 for ( i=j; i<m; i++ )
470                     sum += fjac[j*m+i] * wa4[i];
471                 temp = -sum / temp3;
472                 for ( i=j; i<m; i++ )
473                     wa4[i] += fjac[j*m+i] * temp;
474             }
475             fjac[j*m+j] = wa1[j];
476             qtf[j] = wa4[j];
477         }
478 
479 // O** compute the norm of the scaled gradient and test for convergence.
480 
481         gnorm = 0;
482         if ( fnorm != 0 )
483         {
484             for ( j=0; j<n; j++ )
485             {
486                 if ( wa2[ ipvt[j] ] == 0 ) continue;
487                 
488                 sum = 0.;
489                 for ( i=0; i<=j; i++ )
490                     sum += fjac[j*m+i] * qtf[i] / fnorm;
491                 gnorm = MAX( gnorm, fabs(sum/wa2[ ipvt[j] ]) );
492             }
493         }
494 
495         if ( gnorm <= gtol )
496         {
497             *info = 4;
498             return;
499         }
500 
501 // O** rescale if necessary.
502 
503         if ( mode != 2 )
504         {
505             for ( j=0; j<n; j++ )
506                 diag[j] = MAX(diag[j],wa2[j]);
507         }
508 
509 // O** the inner loop.
510 
511         do {
512 #if BUG 
513             printf( "lmdif/ inner loop iter=%d nfev=%d\n", iter, *nfev );
514 #endif
515 
516 // OI* determine the levenberg-marquardt parameter.
517 
518             lm_lmpar( n,fjac,m,ipvt,diag,qtf,delta,&par,wa1,wa2,wa3,wa4 );
519 
520 // OI* store the direction p and x + p. calculate the norm of p.
521 
522             for ( j=0; j<n; j++ )
523             {
524                 wa1[j] = -wa1[j];
525                 wa2[j] = x[j] + wa1[j];
526                 wa3[j] = diag[j]*wa1[j];
527             }
528             pnorm = lm_enorm(n,wa3);
529 
530 // OI* on the first iteration, adjust the initial step bound.
531 
532             if ( *nfev<= 1+n ) // bug corrected by J. Wuttke in 2004
533                 delta = MIN(delta,pnorm);
534 
535 // OI* evaluate the function at x + p and calculate its norm.
536 
537             *info = 0;
538             (*evaluate)( wa2, m, wa4, data, info );
539             (*printout)( n, x, m, wa4, data, 2, iter, ++(*nfev) );
540             if ( *info < 0 ) return;  // user requested break
541 
542             fnorm1 = lm_enorm(m,wa4);
543 #if BUG 
544             printf( "lmdif/ pnorm %.10e  fnorm1 %.10e  fnorm %.10e"
545                     " delta=%.10e par=%.10e\n",
546                     pnorm, fnorm1, fnorm, delta, par );
547 #endif
548 
549 // OI* compute the scaled actual reduction.
550 
551             if ( p1*fnorm1 < fnorm )
552                 actred = 1 - SQR( fnorm1/fnorm );
553             else
554                 actred = -1;
555 
556 // OI* compute the scaled predicted reduction and 
557 //     the scaled directional derivative.
558 
559             for ( j=0; j<n; j++ )
560             {
561                 wa3[j] = 0;
562                 for ( i=0; i<=j; i++ )
563                     wa3[i] += fjac[j*m+i]*wa1[ ipvt[j] ];
564             }
565             temp1 = lm_enorm(n,wa3) / fnorm;
566             temp2 = sqrt(par) * pnorm / fnorm;
567             prered = SQR(temp1) + 2 * SQR(temp2);
568             dirder = - ( SQR(temp1) + SQR(temp2) );
569 
570 // OI* compute the ratio of the actual to the predicted reduction.
571 
572             ratio = prered!=0 ? actred/prered : 0;
573 #if BUG 
574             printf( "lmdif/ actred=%.10e prered=%.10e ratio=%.10e"
575                     " sq(1)=%.10e sq(2)=%.10e dd=%.10e\n",
576                     actred, prered, prered!=0 ? ratio : 0.,
577                     SQR(temp1), SQR(temp2), dirder );
578 #endif
579 
580 // OI* update the step bound.
581 
582             if (ratio <= p25)
583             {
584                 if (actred >= 0.)
585                     temp = p5;
586                 else
587                     temp = p5*dirder/(dirder + p5*actred);
588                 if ( p1*fnorm1 >= fnorm || temp < p1 )
589                     temp = p1;
590                 delta = temp * MIN(delta,pnorm/p1);
591                 par /= temp;
592             }
593             else if ( par == 0. || ratio >= p75 )
594             {
595                 delta = pnorm/p5;
596                 par *= p5;
597             }
598 
599 // OI* test for successful iteration...
600 
601             if (ratio >= p0001)
602             {
603 
604 //     ... successful iteration. update x, fvec, and their norms.
605 
606                 for ( j=0; j<n; j++ )
607                 {
608                     x[j] = wa2[j];
609                     wa2[j] = diag[j]*x[j];
610                 }
611                 for ( i=0; i<m; i++ )
612                     fvec[i] = wa4[i];
613                 xnorm = lm_enorm(n,wa2);
614                 fnorm = fnorm1;
615                 iter++;
616             }
617 #if BUG 
618             else {
619                 printf( "ATTN: iteration considered unsuccessful\n" );
620             } 
621 #endif
622 
623 // OI* tests for convergence ( otherwise *info = 1, 2, or 3 )
624 
625             *info = 0; // do not terminate (unless overwritten by nonzero value)
626             if ( fabs(actred) <= ftol && prered <= ftol && p5*ratio <= 1 )
627                 *info = 1;
628             if (delta <= xtol*xnorm)
629                 *info += 2;
630             if ( *info != 0)
631                 return;
632 
633 // OI* tests for termination and stringent tolerances.
634 
635             if ( *nfev >= maxfev)
636                 *info = 5;
637             if ( fabs(actred) <= LM_MACHEP &&
638                  prered <= LM_MACHEP && p5*ratio <= 1 )
639                 *info = 6;
640             if (delta <= LM_MACHEP*xnorm)
641                 *info = 7;
642             if (gnorm <= LM_MACHEP)
643                 *info = 8;
644             if ( *info != 0)
645                 return;
646 
647 // OI* end of the inner loop. repeat if iteration unsuccessful.
648 
649         } while (ratio < p0001);
650 
651 // O** end of the outer loop.
652 
653     } while (1);
654         
655 }
\end{DoxyCode}
\hypertarget{lmmin_8c_a64fcb82c1daa55fe6571c80e00e57f91}{
\index{lmmin.c@{lmmin.c}!lm\_\-lmpar@{lm\_\-lmpar}}
\index{lm\_\-lmpar@{lm\_\-lmpar}!lmmin.c@{lmmin.c}}
\subsubsection[{lm\_\-lmpar}]{\setlength{\rightskip}{0pt plus 5cm}void lm\_\-lmpar (int {\em n}, \/  double $\ast$ {\em r}, \/  int {\em ldr}, \/  int $\ast$ {\em ipvt}, \/  double $\ast$ {\em diag}, \/  double $\ast$ {\em qtb}, \/  double {\em delta}, \/  double $\ast$ {\em par}, \/  double $\ast$ {\em x}, \/  double $\ast$ {\em sdiag}, \/  double $\ast$ {\em wa1}, \/  double $\ast$ {\em wa2})}}
\label{lmmin_8c_a64fcb82c1daa55fe6571c80e00e57f91}



\begin{DoxyCode}
662 {
663 /*     given an m by n matrix a, an n by n nonsingular diagonal
664  *     matrix d, an m-vector b, and a positive number delta,
665  *     the problem is to determine a value for the parameter
666  *     par such that if x solves the system
667  *
668  *          a*x = b ,     sqrt(par)*d*x = 0 ,
669  *
670  *     in the least squares sense, and dxnorm is the euclidean
671  *     norm of d*x, then either par is 0. and
672  *
673  *          (dxnorm-delta) .le. 0.1*delta ,
674  *
675  *     or par is positive and
676  *
677  *          abs(dxnorm-delta) .le. 0.1*delta .
678  *
679  *     this subroutine completes the solution of the problem
680  *     if it is provided with the necessary information from the
681  *     qr factorization, with column pivoting, of a. that is, if
682  *     a*p = q*r, where p is a permutation matrix, q has orthogonal
683  *     columns, and r is an upper triangular matrix with diagonal
684  *     elements of nonincreasing magnitude, then lmpar expects
685  *     the full upper triangle of r, the permutation matrix p,
686  *     and the first n components of (q transpose)*b. on output
687  *     lmpar also provides an upper triangular matrix s such that
688  *
689  *           t   t                   t
690  *          p *(a *a + par*d*d)*p = s *s .
691  *
692  *     s is employed within lmpar and may be of separate interest.
693  *
694  *     only a few iterations are generally needed for convergence
695  *     of the algorithm. if, however, the limit of 10 iterations
696  *     is reached, then the output par will contain the best
697  *     value obtained so far.
698  *
699  *     parameters:
700  *
701  *      n is a positive integer input variable set to the order of r.
702  *
703  *      r is an n by n array. on input the full upper triangle
704  *        must contain the full upper triangle of the matrix r.
705  *        on output the full upper triangle is unaltered, and the
706  *        strict lower triangle contains the strict upper triangle
707  *        (transposed) of the upper triangular matrix s.
708  *
709  *      ldr is a positive integer input variable not less than n
710  *        which specifies the leading dimension of the array r.
711  *
712  *      ipvt is an integer input array of length n which defines the
713  *        permutation matrix p such that a*p = q*r. column j of p
714  *        is column ipvt(j) of the identity matrix.
715  *
716  *      diag is an input array of length n which must contain the
717  *        diagonal elements of the matrix d.
718  *
719  *      qtb is an input array of length n which must contain the first
720  *        n elements of the vector (q transpose)*b.
721  *
722  *      delta is a positive input variable which specifies an upper
723  *        bound on the euclidean norm of d*x.
724  *
725  *      par is a nonnegative variable. on input par contains an
726  *        initial estimate of the levenberg-marquardt parameter.
727  *        on output par contains the final estimate.
728  *
729  *      x is an output array of length n which contains the least
730  *        squares solution of the system a*x = b, sqrt(par)*d*x = 0,
731  *        for the output par.
732  *
733  *      sdiag is an output array of length n which contains the
734  *        diagonal elements of the upper triangular matrix s.
735  *
736  *      wa1 and wa2 are work arrays of length n.
737  *
738  */
739     int i, iter, j, nsing;
740     double dxnorm, fp, fp_old, gnorm, parc, parl, paru;
741     double sum, temp;
742     static double p1 = 0.1;
743     static double p001 = 0.001;
744 
745 #if BUG
746     printf( "lmpar\n" );
747 #endif
748 
749 // *** compute and store in x the gauss-newton direction. if the
750 //     jacobian is rank-deficient, obtain a least squares solution.
751 
752     nsing = n;
753     for ( j=0; j<n; j++ )
754     {
755         wa1[j] = qtb[j];
756         if ( r[j*ldr+j] == 0 && nsing == n )
757             nsing = j;
758         if (nsing < n)
759             wa1[j] = 0;
760     }
761 #if BUG
762     printf( "nsing %d ", nsing );
763 #endif
764     for ( j=nsing-1; j>=0; j-- )
765     {
766         wa1[j] = wa1[j]/r[j+ldr*j];
767         temp = wa1[j];
768         for ( i=0; i<j; i++ )
769             wa1[i] -= r[j*ldr+i]*temp;
770     }
771 
772     for ( j=0; j<n; j++ )
773         x[ ipvt[j] ] = wa1[j];
774 
775 // *** initialize the iteration counter.
776 //     evaluate the function at the origin, and test
777 //     for acceptance of the gauss-newton direction.
778 
779     iter = 0;
780     for ( j=0; j<n; j++ )
781         wa2[j] = diag[j]*x[j];
782     dxnorm = lm_enorm(n,wa2);
783     fp = dxnorm - delta;
784     if (fp <= p1*delta)
785     {
786 #if BUG
787         printf( "lmpar/ terminate (fp<delta/10\n" );
788 #endif
789         *par = 0;
790         return;
791     }
792 
793 // *** if the jacobian is not rank deficient, the newton
794 //     step provides a lower bound, parl, for the 0. of
795 //     the function. otherwise set this bound to 0..
796 
797     parl = 0;
798     if (nsing >= n)
799     {
800         for ( j=0; j<n; j++ )
801             wa1[j] = diag[ ipvt[j] ] * wa2[ ipvt[j] ] / dxnorm;
802 
803         for ( j=0; j<n; j++ )
804         {
805             sum = 0.;
806             for ( i=0; i<j; i++ )
807                 sum += r[j*ldr+i]*wa1[i];
808             wa1[j] = (wa1[j] - sum)/r[j+ldr*j];
809         }
810         temp = lm_enorm(n,wa1);
811         parl = fp/delta/temp/temp;
812     }
813 
814 // *** calculate an upper bound, paru, for the 0. of the function.
815 
816     for ( j=0; j<n; j++ )
817     {
818         sum = 0;
819         for ( i=0; i<=j; i++ )
820             sum += r[j*ldr+i]*qtb[i];
821         wa1[j] = sum/diag[ ipvt[j] ];
822     }
823     gnorm = lm_enorm(n,wa1);
824     paru = gnorm/delta;
825     if (paru == 0.)
826         paru = LM_DWARF/MIN(delta,p1);
827 
828 // *** if the input par lies outside of the interval (parl,paru),
829 //     set par to the closer endpoint.
830 
831     *par = MAX( *par,parl);
832     *par = MIN( *par,paru);
833     if ( *par == 0.)
834         *par = gnorm/dxnorm;
835 #if BUG
836     printf( "lmpar/ parl %.4e  par %.4e  paru %.4e\n", parl, *par, paru );
837 #endif
838 
839 // *** iterate.
840 
841     for ( ; ; iter++ ) {
842 
843 // *** evaluate the function at the current value of par.
844 
845         if ( *par == 0.)
846             *par = MAX(LM_DWARF,p001*paru);
847         temp = sqrt( *par );
848         for ( j=0; j<n; j++ )
849             wa1[j] = temp*diag[j];
850         lm_qrsolv( n, r, ldr, ipvt, wa1, qtb, x, sdiag, wa2);
851         for ( j=0; j<n; j++ )
852             wa2[j] = diag[j]*x[j];
853         dxnorm = lm_enorm(n,wa2);
854         fp_old = fp;
855         fp = dxnorm - delta;
856 
857 // ***   if the function is small enough, accept the current value
858 //       of par. also test for the exceptional cases where parl
859 //       is 0. or the number of iterations has reached 10.
860 
861         if ( fabs(fp) <= p1*delta
862              || (parl == 0. && fp <= fp_old && fp_old < 0.)
863              || iter == 10 )
864             break; // the only exit from this loop
865 
866 // *** compute the Newton correction.
867 
868         for ( j=0; j<n; j++ )
869             wa1[j] = diag[ ipvt[j] ] * wa2[ ipvt[j] ] / dxnorm;
870 
871         for ( j=0; j<n; j++ )
872         {
873             wa1[j] = wa1[j]/sdiag[j];
874             for ( i=j+1; i<n; i++ )
875                 wa1[i] -= r[j*ldr+i]*wa1[j];
876         }
877         temp = lm_enorm( n, wa1);
878         parc = fp/delta/temp/temp;
879 
880 // *** depending on the sign of the function, update parl or paru.
881 
882         if (fp > 0)
883             parl = MAX(parl, *par);
884         else if (fp < 0)
885             paru = MIN(paru, *par);
886         // the case fp==0 is precluded by the break condition 
887 
888 // *** compute an improved estimate for par.
889 
890         *par = MAX(parl, *par + parc);
891 
892     }
893 
894 }
\end{DoxyCode}
\hypertarget{lmmin_8c_acccb5d208acdc6abd1cd784fc16f37f3}{
\index{lmmin.c@{lmmin.c}!lm\_\-minimize@{lm\_\-minimize}}
\index{lm\_\-minimize@{lm\_\-minimize}!lmmin.c@{lmmin.c}}
\subsubsection[{lm\_\-minimize}]{\setlength{\rightskip}{0pt plus 5cm}void lm\_\-minimize (int {\em m\_\-dat}, \/  int {\em n\_\-par}, \/  double $\ast$ {\em par}, \/  {\bf lm\_\-evaluate\_\-ftype} $\ast$ {\em evaluate}, \/  {\bf lm\_\-print\_\-ftype} $\ast$ {\em printout}, \/  void $\ast$ {\em data}, \/  {\bf lm\_\-control\_\-type} $\ast$ {\em control})}}
\label{lmmin_8c_acccb5d208acdc6abd1cd784fc16f37f3}



\begin{DoxyCode}
38 {
39 
40 // *** allocate work space.
41 
42     double *fvec, *diag, *fjac, *qtf, *wa1, *wa2, *wa3, *wa4;
43     int *ipvt;
44 
45     int n = n_par;
46     int m = m_dat;
47 
48     if (!(fvec = (double*) malloc(  m*sizeof(double))) ||
49         !(diag = (double*) malloc(n*  sizeof(double))) ||
50         !(qtf =  (double*) malloc(n*  sizeof(double))) ||
51         !(fjac = (double*) malloc(n*m*sizeof(double))) ||
52         !(wa1 =  (double*) malloc(n*  sizeof(double))) ||
53         !(wa2 =  (double*) malloc(n*  sizeof(double))) ||
54         !(wa3 =  (double*) malloc(n*  sizeof(double))) ||
55         !(wa4 =  (double*) malloc(  m*sizeof(double))) ||
56         !(ipvt = (int*)    malloc(n*  sizeof(int)))) {
57             control->info = 9;
58             return;
59     }
60 
61 // *** perform fit.
62                         
63     control->info = 0;
64     control->nfev = 0;
65 
66     // this goes through the modified legacy interface:
67     lm_lmdif( m, n, par, fvec, control->ftol, control->xtol, control->gtol,
68               control->maxcall*(n+1), control->epsilon, diag, 1,
69               control->stepbound, &(control->info),
70               &(control->nfev), fjac, ipvt, qtf, wa1, wa2, wa3, wa4,
71               evaluate, printout, data );
72 
73     (*printout)( n, par, m, fvec, data, -1, 0, control->nfev );
74     control->fnorm = lm_enorm(m, fvec);
75     if (control->info < 0 ) control->info = 10;
76 
77 // *** clean up.
78 
79     free(fvec);
80     free(diag);
81     free(qtf); 
82     free(fjac);
83     free(wa1); 
84     free(wa2); 
85     free(wa3 );
86     free(wa4); 
87     free(ipvt);
88 }
\end{DoxyCode}
\hypertarget{lmmin_8c_aa72b372e483c92753b89a59aa3128b64}{
\index{lmmin.c@{lmmin.c}!lm\_\-qrfac@{lm\_\-qrfac}}
\index{lm\_\-qrfac@{lm\_\-qrfac}!lmmin.c@{lmmin.c}}
\subsubsection[{lm\_\-qrfac}]{\setlength{\rightskip}{0pt plus 5cm}void lm\_\-qrfac (int {\em m}, \/  int {\em n}, \/  double $\ast$ {\em a}, \/  int {\em pivot}, \/  int $\ast$ {\em ipvt}, \/  double $\ast$ {\em rdiag}, \/  double $\ast$ {\em acnorm}, \/  double $\ast$ {\em wa})}}
\label{lmmin_8c_aa72b372e483c92753b89a59aa3128b64}



\begin{DoxyCode}
900 {
901 /*
902  *     this subroutine uses householder transformations with column
903  *     pivoting (optional) to compute a qr factorization of the
904  *     m by n matrix a. that is, qrfac determines an orthogonal
905  *     matrix q, a permutation matrix p, and an upper trapezoidal
906  *     matrix r with diagonal elements of nonincreasing magnitude,
907  *     such that a*p = q*r. the householder transformation for
908  *     column k, k = 1,2,...,min(m,n), is of the form
909  *
910  *                          t
911  *          i - (1/u(k))*u*u
912  *
913  *     where u has 0.s in the first k-1 positions. the form of
914  *     this transformation and the method of pivoting first
915  *     appeared in the corresponding linpack subroutine.
916  *
917  *     parameters:
918  *
919  *      m is a positive integer input variable set to the number
920  *        of rows of a.
921  *
922  *      n is a positive integer input variable set to the number
923  *        of columns of a.
924  *
925  *      a is an m by n array. on input a contains the matrix for
926  *        which the qr factorization is to be computed. on output
927  *        the strict upper trapezoidal part of a contains the strict
928  *        upper trapezoidal part of r, and the lower trapezoidal
929  *        part of a contains a factored form of q (the non-trivial
930  *        elements of the u vectors described above).
931  *
932  *      pivot is a logical input variable. if pivot is set true,
933  *        then column pivoting is enforced. if pivot is set false,
934  *        then no column pivoting is done.
935  *
936  *      ipvt is an integer output array of length lipvt. ipvt
937  *        defines the permutation matrix p such that a*p = q*r.
938  *        column j of p is column ipvt(j) of the identity matrix.
939  *        if pivot is false, ipvt is not referenced.
940  *
941  *      rdiag is an output array of length n which contains the
942  *        diagonal elements of r.
943  *
944  *      acnorm is an output array of length n which contains the
945  *        norms of the corresponding columns of the input matrix a.
946  *        if this information is not needed, then acnorm can coincide
947  *        with rdiag.
948  *
949  *      wa is a work array of length n. if pivot is false, then wa
950  *        can coincide with rdiag.
951  *
952  */
953     int i, j, k, kmax, minmn;
954     double ajnorm, sum, temp;
955     static double p05 = 0.05;
956 
957 // *** compute the initial column norms and initialize several arrays.
958 
959     for ( j=0; j<n; j++ )
960     {
961         acnorm[j] = lm_enorm(m, &a[j*m]);
962         rdiag[j] = acnorm[j];
963         wa[j] = rdiag[j];
964         if ( pivot )
965             ipvt[j] = j;
966     }
967 #if BUG
968     printf( "qrfac\n" );
969 #endif
970 
971 // *** reduce a to r with householder transformations.
972 
973     minmn = MIN(m,n);
974     for ( j=0; j<minmn; j++ )
975     {
976         if ( !pivot ) goto pivot_ok;
977 
978 // *** bring the column of largest norm into the pivot position.
979 
980         kmax = j;
981         for ( k=j+1; k<n; k++ )
982             if (rdiag[k] > rdiag[kmax])
983                 kmax = k;
984         if (kmax == j) goto pivot_ok; // bug fixed in rel 2.1
985 
986         for ( i=0; i<m; i++ )
987         {
988             temp        = a[j*m+i];
989             a[j*m+i]    = a[kmax*m+i];
990             a[kmax*m+i] = temp;
991         }
992         rdiag[kmax] = rdiag[j];
993         wa[kmax] = wa[j];
994         k = ipvt[j];
995         ipvt[j] = ipvt[kmax];
996         ipvt[kmax] = k;
997 
998     pivot_ok:
999 
1000 // *** compute the Householder transformation to reduce the
1001 //     j-th column of a to a multiple of the j-th unit vector.
1002 
1003         ajnorm = lm_enorm( m-j, &a[j*m+j] );
1004         if (ajnorm == 0.)
1005         {
1006             rdiag[j] = 0;
1007             continue;
1008         }
1009 
1010         if (a[j*m+j] < 0.)
1011             ajnorm = -ajnorm;
1012         for ( i=j; i<m; i++ )
1013             a[j*m+i] /= ajnorm;
1014         a[j*m+j] += 1;
1015 
1016 // *** apply the transformation to the remaining columns
1017 //     and update the norms.
1018 
1019         for ( k=j+1; k<n; k++ )
1020         {
1021             sum = 0;
1022 
1023             for ( i=j; i<m; i++ )
1024                 sum += a[j*m+i]*a[k*m+i];
1025 
1026             temp = sum/a[j+m*j];
1027 
1028             for ( i=j; i<m; i++ )
1029                 a[k*m+i] -= temp * a[j*m+i];
1030 
1031             if ( pivot && rdiag[k] != 0. )
1032             {
1033                 temp = a[m*k+j]/rdiag[k];
1034                 temp = MAX( 0., 1-temp*temp );
1035                 rdiag[k] *= sqrt(temp);
1036                 temp = rdiag[k]/wa[k];
1037                 if ( p05*SQR(temp) <= LM_MACHEP )
1038                 {
1039                     rdiag[k] = lm_enorm( m-j-1, &a[m*k+j+1]);
1040                     wa[k] = rdiag[k];
1041                 }
1042             }
1043         }
1044 
1045         rdiag[j] = -ajnorm;
1046     }
1047 }
\end{DoxyCode}
\hypertarget{lmmin_8c_a0543234dc4a8534dffcec238a778916a}{
\index{lmmin.c@{lmmin.c}!lm\_\-qrsolv@{lm\_\-qrsolv}}
\index{lm\_\-qrsolv@{lm\_\-qrsolv}!lmmin.c@{lmmin.c}}
\subsubsection[{lm\_\-qrsolv}]{\setlength{\rightskip}{0pt plus 5cm}void lm\_\-qrsolv (int {\em n}, \/  double $\ast$ {\em r}, \/  int {\em ldr}, \/  int $\ast$ {\em ipvt}, \/  double $\ast$ {\em diag}, \/  double $\ast$ {\em qtb}, \/  double $\ast$ {\em x}, \/  double $\ast$ {\em sdiag}, \/  double $\ast$ {\em wa})}}
\label{lmmin_8c_a0543234dc4a8534dffcec238a778916a}



\begin{DoxyCode}
1053 {
1054 /*
1055  *     given an m by n matrix a, an n by n diagonal matrix d,
1056  *     and an m-vector b, the problem is to determine an x which
1057  *     solves the system
1058  *
1059  *          a*x = b ,     d*x = 0 ,
1060  *
1061  *     in the least squares sense.
1062  *
1063  *     this subroutine completes the solution of the problem
1064  *     if it is provided with the necessary information from the
1065  *     qr factorization, with column pivoting, of a. that is, if
1066  *     a*p = q*r, where p is a permutation matrix, q has orthogonal
1067  *     columns, and r is an upper triangular matrix with diagonal
1068  *     elements of nonincreasing magnitude, then qrsolv expects
1069  *     the full upper triangle of r, the permutation matrix p,
1070  *     and the first n components of (q transpose)*b. the system
1071  *     a*x = b, d*x = 0, is then equivalent to
1072  *
1073  *                 t       t
1074  *          r*z = q *b ,  p *d*p*z = 0 ,
1075  *
1076  *     where x = p*z. if this system does not have full rank,
1077  *     then a least squares solution is obtained. on output qrsolv
1078  *     also provides an upper triangular matrix s such that
1079  *
1080  *           t   t               t
1081  *          p *(a *a + d*d)*p = s *s .
1082  *
1083  *     s is computed within qrsolv and may be of separate interest.
1084  *
1085  *     parameters
1086  *
1087  *      n is a positive integer input variable set to the order of r.
1088  *
1089  *      r is an n by n array. on input the full upper triangle
1090  *        must contain the full upper triangle of the matrix r.
1091  *        on output the full upper triangle is unaltered, and the
1092  *        strict lower triangle contains the strict upper triangle
1093  *        (transposed) of the upper triangular matrix s.
1094  *
1095  *      ldr is a positive integer input variable not less than n
1096  *        which specifies the leading dimension of the array r.
1097  *
1098  *      ipvt is an integer input array of length n which defines the
1099  *        permutation matrix p such that a*p = q*r. column j of p
1100  *        is column ipvt(j) of the identity matrix.
1101  *
1102  *      diag is an input array of length n which must contain the
1103  *        diagonal elements of the matrix d.
1104  *
1105  *      qtb is an input array of length n which must contain the first
1106  *        n elements of the vector (q transpose)*b.
1107  *
1108  *      x is an output array of length n which contains the least
1109  *        squares solution of the system a*x = b, d*x = 0.
1110  *
1111  *      sdiag is an output array of length n which contains the
1112  *        diagonal elements of the upper triangular matrix s.
1113  *
1114  *      wa is a work array of length n.
1115  *
1116  */
1117     int i, kk, j, k, nsing;
1118     double qtbpj, sum, temp;
1119     double sin, cos, tan, cotan; // these are local variables, not functions
1120     static double p25 = 0.25;
1121     static double p5 = 0.5;
1122 
1123 // *** copy r and (q transpose)*b to preserve input and initialize s.
1124 //     in particular, save the diagonal elements of r in x.
1125 
1126     for ( j=0; j<n; j++ )
1127     {
1128         for ( i=j; i<n; i++ )
1129             r[j*ldr+i] = r[i*ldr+j];
1130         x[j] = r[j*ldr+j];
1131         wa[j] = qtb[j];
1132     }
1133 #if BUG
1134     printf( "qrsolv\n" );
1135 #endif
1136 
1137 // *** eliminate the diagonal matrix d using a givens rotation.
1138 
1139     for ( j=0; j<n; j++ )
1140     {
1141 
1142 // ***   prepare the row of d to be eliminated, locating the
1143 //       diagonal element using p from the qr factorization.
1144 
1145         if (diag[ ipvt[j] ] == 0.)
1146             goto L90;
1147         for ( k=j; k<n; k++ )
1148             sdiag[k] = 0.;
1149         sdiag[j] = diag[ ipvt[j] ];
1150 
1151 // ***   the transformations to eliminate the row of d
1152 //       modify only a single element of (q transpose)*b
1153 //       beyond the first n, which is initially 0..
1154 
1155         qtbpj = 0.;
1156         for ( k=j; k<n; k++ )
1157         {
1158 
1159 //          determine a givens rotation which eliminates the
1160 //          appropriate element in the current row of d.
1161 
1162             if (sdiag[k] == 0.)
1163                 continue;
1164             kk = k + ldr * k; // <! keep this shorthand !>
1165             if ( fabs(r[kk]) < fabs(sdiag[k]) )
1166             {
1167                 cotan = r[kk]/sdiag[k];
1168                 sin = p5/sqrt(p25+p25*SQR(cotan));
1169                 cos = sin*cotan;
1170             }
1171             else
1172             {
1173                 tan = sdiag[k]/r[kk];
1174                 cos = p5/sqrt(p25+p25*SQR(tan));
1175                 sin = cos*tan;
1176             }
1177 
1178 // ***      compute the modified diagonal element of r and
1179 //          the modified element of ((q transpose)*b,0).
1180 
1181             r[kk] = cos*r[kk] + sin*sdiag[k];
1182             temp = cos*wa[k] + sin*qtbpj;
1183             qtbpj = -sin*wa[k] + cos*qtbpj;
1184             wa[k] = temp;
1185 
1186 // *** accumulate the tranformation in the row of s.
1187 
1188             for ( i=k+1; i<n; i++ )
1189             {
1190                 temp = cos*r[k*ldr+i] + sin*sdiag[i]; 
1191                 sdiag[i] = -sin*r[k*ldr+i] + cos*sdiag[i];
1192                 r[k*ldr+i] = temp;
1193             }
1194         }
1195     L90:
1196 
1197 // *** store the diagonal element of s and restore
1198 //     the corresponding diagonal element of r.
1199 
1200         sdiag[j] = r[j*ldr+j];
1201         r[j*ldr+j] = x[j];
1202     }
1203 
1204 // *** solve the triangular system for z. if the system is
1205 //     singular, then obtain a least squares solution.
1206 
1207     nsing = n;
1208     for ( j=0; j<n; j++ )
1209     {
1210         if ( sdiag[j] == 0. && nsing == n )
1211             nsing = j;
1212         if (nsing < n)
1213             wa[j] = 0;
1214     }
1215 
1216     for ( j=nsing-1; j>=0; j-- )
1217     {
1218         sum = 0;
1219         for ( i=j+1; i<nsing; i++ )
1220             sum += r[j*ldr+i]*wa[i];
1221         wa[j] = (wa[j] - sum)/sdiag[j];
1222     }
1223 
1224 // *** permute the components of z back to components of x.
1225 
1226     for ( j=0; j<n; j++ )
1227         x[ ipvt[j] ] = wa[j];
1228 }
\end{DoxyCode}


\subsection{Variable Documentation}
\hypertarget{lmmin_8c_a70193f2f4a5345b9f9bacb3ed580309a}{
\index{lmmin.c@{lmmin.c}!lm\_\-infmsg@{lm\_\-infmsg}}
\index{lm\_\-infmsg@{lm\_\-infmsg}!lmmin.c@{lmmin.c}}
\subsubsection[{lm\_\-infmsg}]{\setlength{\rightskip}{0pt plus 5cm}char$\ast$ {\bf lm\_\-infmsg}\mbox{[}$\,$\mbox{]}}}
\label{lmmin_8c_a70193f2f4a5345b9f9bacb3ed580309a}
{\bfseries Initial value:}
\begin{DoxyCode}
 {
    "improper input parameters",
    "the relative error in the sum of squares is at most tol",
    "the relative error between x and the solution is at most tol",
    "both errors are at most tol",
    "fvec is orthogonal to the columns of the jacobian to machine precision",
    "number of calls to fcn has reached or exceeded 200*(n+1)",
    "ftol is too small. no further reduction in the sum of squares is possible",
    "xtol too small. no further improvement in approximate solution x possible",
    "gtol too small. no further improvement in approximate solution x possible",
    "not enough memory",
    "break requested within function evaluation"
}
\end{DoxyCode}
\hypertarget{lmmin_8c_adf858362eeb838628ef333f11773cdb6}{
\index{lmmin.c@{lmmin.c}!lm\_\-shortmsg@{lm\_\-shortmsg}}
\index{lm\_\-shortmsg@{lm\_\-shortmsg}!lmmin.c@{lmmin.c}}
\subsubsection[{lm\_\-shortmsg}]{\setlength{\rightskip}{0pt plus 5cm}char$\ast$ {\bf lm\_\-shortmsg}\mbox{[}$\,$\mbox{]}}}
\label{lmmin_8c_adf858362eeb838628ef333f11773cdb6}
{\bfseries Initial value:}
\begin{DoxyCode}
 {
        "invalid input",
        "success (f)",
        "success (p)",
        "success (f,p)",
        "degenerate",
        "call limit",
        "failed (f)",
        "failed (p)",
        "failed (o)",
        "no memory",
        "user break"
}
\end{DoxyCode}
