\hypertarget{aXe__utils_8h}{
\section{/renoir/fourmano/Desktop/OUSIM/TIPS/branches/tips\_\-build/include/axesim/aXe\_\-utils.h File Reference}
\label{aXe__utils_8h}\index{/renoir/fourmano/Desktop/OUSIM/TIPS/branches/tips\_\-build/include/axesim/aXe\_\-utils.h@{/renoir/fourmano/Desktop/OUSIM/TIPS/branches/tips\_\-build/include/axesim/aXe\_\-utils.h}}
}
{\ttfamily \#include $<$unistd.h$>$}\par
{\ttfamily \#include \char`\"{}aXe\_\-grism.h\char`\"{}}\par
{\ttfamily \#include \char`\"{}spc\_\-FITScards.h\char`\"{}}\par
\subsection*{Data Structures}
\begin{DoxyCompactItemize}
\item 
struct \hyperlink{structCol__Descr}{Col\_\-Descr}
\end{DoxyCompactItemize}
\subsection*{Defines}
\begin{DoxyCompactItemize}
\item 
\#define \hyperlink{aXe__utils_8h_a06be4aa9150783f3722be133a28c8ef8}{MAXNCONF}~10
\end{DoxyCompactItemize}
\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
gsl\_\-matrix $\ast$ \hyperlink{aXe__utils_8h_a265457e88fc46b602e539e9a7b2a6c1e}{simulate\_\-errors} (gsl\_\-matrix $\ast$img, float exptime, float gain)
\item 
gsl\_\-matrix $\ast$ \hyperlink{aXe__utils_8h_ad05c49b54279d1e4f6f49fe675ce254f}{simulate\_\-errors\_\-t} (gsl\_\-matrix $\ast$img, const double exptime, const double rdnoise)
\item 
void \hyperlink{aXe__utils_8h_a203bace423c84b28d48d305a99dfa81a}{apply\_\-DQ} (\hyperlink{structobservation}{observation} $\ast$obs, int dqmask)
\item 
\hyperlink{structobservation}{observation} $\ast$ \hyperlink{aXe__utils_8h_a661333de2efcbef321b27520d40cc9cf}{load\_\-image} (const char $\ast$const fname, int hdunum\_\-data, int hdunum\_\-err, int hdunum\_\-dq, int dqmask, float exptime, float gain)
\item 
\hyperlink{structobservation}{observation} $\ast$ \hyperlink{aXe__utils_8h_ac87755b847abbd2c375032e14bd5561c}{load\_\-image\_\-t} (const char $\ast$const fname, int hdunum\_\-data, int hdunum\_\-err, int hdunum\_\-dq, int dqmask, const double exptime, const double rdnoise)
\item 
\hyperlink{structobservation}{observation} $\ast$ \hyperlink{aXe__utils_8h_a1aa6f31280704fd7678c78b97d0f5456}{load\_\-sci\_\-image} (const char $\ast$const fname, int hdunum\_\-data)
\item 
int \hyperlink{aXe__utils_8h_a791e8209e46381315c39a27890280053}{FITSextnum} (const char $\ast$const fname)
\item 
gsl\_\-matrix $\ast$ \hyperlink{aXe__utils_8h_a74a75b4d9d74b257e44e6ec61ca79bf5}{FITSnaxes\_\-to\_\-gsl} (const char $\ast$const fname, int hdunum)
\item 
gsl\_\-matrix $\ast$ \hyperlink{aXe__utils_8h_a18f07b887bcf78c0c0105912818b8a2b}{FITSimage\_\-to\_\-gslOld} (const char $\ast$const fname, int hdunum, int fatal)
\item 
gsl\_\-matrix $\ast$ \hyperlink{aXe__utils_8h_ae608ee7bf2717c17c842cd3dfd327884}{FITSimage\_\-to\_\-gsl} (const char $\ast$const fname, int hdunum, int fatal)
\item 
gsl\_\-matrix $\ast$ \hyperlink{aXe__utils_8h_afdee57669eb437afcad30e96223b48a2}{FITSHDU\_\-to\_\-gsl} (const char $\ast$const fname, fitsfile $\ast$fptr, int fatal)
\item 
gsl\_\-matrix $\ast$ \hyperlink{aXe__utils_8h_a616ed3bbb3c1b15f8127548fbe1d4701}{storage\_\-to\_\-gsl} (long $\ast$naxes, PIXEL\_\-T $\ast$storage)
\item 
\hyperlink{structpx__point}{px\_\-point} \hyperlink{aXe__utils_8h_a7eb3cbe5ef0277544b00b2cc9c990e4c}{get\_\-npixels} (const char $\ast$const fname, int hdunum)
\item 
int \hyperlink{aXe__utils_8h_a6a5d64fa0baa598fc20741fa603bee11}{gsl\_\-to\_\-FITSimage} (gsl\_\-matrix $\ast$data, char filename\mbox{[}$\,$\mbox{]}, int overwrite, char ID\mbox{[}$\,$\mbox{]})
\item 
int \hyperlink{aXe__utils_8h_ae3c5e11b29793d5fa85913a0df2f7761}{gsl\_\-to\_\-FITSimageHDU} (gsl\_\-matrix $\ast$data, char filename\mbox{[}$\,$\mbox{]}, int overwrite, char ID\mbox{[}$\,$\mbox{]}, int hdu\_\-num)
\item 
void \hyperlink{aXe__utils_8h_a40b0ba7efd067d860b4f2a6948fea20b}{quad\_\-to\_\-bbox} (const \hyperlink{structpx__point}{px\_\-point} $\ast$const corners, \hyperlink{structpx__point}{px\_\-point} $\ast$const ll, \hyperlink{structpx__point}{px\_\-point} $\ast$const ur)
\item 
int \hyperlink{aXe__utils_8h_a57559b109efa08c59a49d92479619d0d}{gsl\_\-matrix\_\-to\_\-pgm} (const char $\ast$const fname, const gsl\_\-matrix $\ast$const m)
\item 
void \hyperlink{aXe__utils_8h_a6775cf9397e918007afce6147fa92ec8}{build\_\-path} (char envpathname\mbox{[}$\,$\mbox{]}, const char file\mbox{[}$\,$\mbox{]}, char $\ast$filename)
\item 
char $\ast$$\ast$ \hyperlink{aXe__utils_8h_adb066a0a2f011d58fb3a8ecfce732d9f}{alloc\_\-char\_\-arr} (int nrows, int ncols)
\item 
void \hyperlink{aXe__utils_8h_ac8d8059b1a87e608b4570096fba84d01}{free\_\-char\_\-arr} (char $\ast$$\ast$char\_\-arr, int nrows)
\item 
int \hyperlink{aXe__utils_8h_a1b9693d2f0e0ff78e226ede6a839881c}{build\_\-config\_\-files} (char list\_\-file\mbox{[}$\,$\mbox{]}, char $\ast$$\ast$list\_\-files, int maxnrows)
\item 
void \hyperlink{aXe__utils_8h_a94637b37589d1f9b3c9418d620156519}{replace\_\-file\_\-extension} (char infile\mbox{[}$\,$\mbox{]}, char outfile\mbox{[}$\,$\mbox{]}, char from\_\-ext\mbox{[}$\,$\mbox{]}, char to\_\-ext\mbox{[}$\,$\mbox{]}, int hdu)
\item 
void \hyperlink{aXe__utils_8h_a1f63bfb071e9d0ea1f8854efdfae4692}{free\_\-oblist} (\hyperlink{structobject}{object} $\ast$$\ast$oblist)
\item 
void \hyperlink{aXe__utils_8h_ab728171bc22cb503b1904ed113a8c36e}{fprintf\_\-object} (FILE $\ast$output, \hyperlink{structobject}{object} $\ast$o)
\item 
char $\ast$ \hyperlink{aXe__utils_8h_a831cd1049c0c8b8e918404c5035d5411}{get\_\-online\_\-option} (char option\_\-name\mbox{[}$\,$\mbox{]}, int argc, char $\ast$argv\mbox{[}$\,$\mbox{]})
\item 
int \hyperlink{aXe__utils_8h_a7c64494989064de2c0ca57df3d7f43a2}{get\_\-online\_\-option2} (char option\_\-name\mbox{[}$\,$\mbox{]}, char option\_\-value\mbox{[}$\,$\mbox{]}, int argc, char $\ast$argv\mbox{[}$\,$\mbox{]})
\item 
void \hyperlink{aXe__utils_8h_aaf6850286e924fd44f65af2cf80894f0}{free\_\-observation} (\hyperlink{structobservation}{observation} $\ast$obs)
\item 
int \hyperlink{aXe__utils_8h_ae2b196b3eec481bec79c35394e75e4fc}{get\_\-hdunum\_\-from\_\-hduname} (char filename\mbox{[}$\,$\mbox{]}, char extname\mbox{[}$\,$\mbox{]}, char keyword\mbox{[}$\,$\mbox{]}, char keyval\mbox{[}$\,$\mbox{]}, int extver)
\item 
\hyperlink{structFITScards}{FITScards} $\ast$ \hyperlink{aXe__utils_8h_aa1a7ef7b7d19206e1df681bf2bea0d7c}{get\_\-FITS\_\-cards} (char filename\mbox{[}$\,$\mbox{]}, int hdu)
\item 
\hyperlink{structFITScards}{FITScards} $\ast$ \hyperlink{aXe__utils_8h_a27dd022a77729a35640126b146b35825}{get\_\-FITS\_\-cards\_\-opened} (fitsfile $\ast$input)
\item 
void \hyperlink{aXe__utils_8h_a8abd9ee69f161e0ac3ee47dc722cebf0}{put\_\-FITS\_\-cards} (char filename\mbox{[}$\,$\mbox{]}, int hdu, \hyperlink{structFITScards}{FITScards} $\ast$cards)
\item 
void \hyperlink{aXe__utils_8h_a6652d52eca381c6c7fbc9913f2b42a0e}{put\_\-FITS\_\-cards\_\-opened} (fitsfile $\ast$output, \hyperlink{structFITScards}{FITScards} $\ast$cards)
\item 
void \hyperlink{aXe__utils_8h_ad7667e161c8b5af380d7ff9f2433cd06}{gsl\_\-to\_\-FITSimage\_\-opened} (gsl\_\-matrix $\ast$data, fitsfile $\ast$ouput, int overwrite, char ID\mbox{[}$\,$\mbox{]})
\item 
fitsfile $\ast$ \hyperlink{aXe__utils_8h_aeed8cb8563260b750fda48d5636c92f2}{create\_\-FITSimage\_\-opened} (char filename\mbox{[}$\,$\mbox{]}, int overwrite)
\item 
float \hyperlink{aXe__utils_8h_a8817e86558786acb16965f3ac1215992}{get\_\-float\_\-from\_\-keyword} (char $\ast$filename, int hdunum, char $\ast$keyword)
\item 
void \hyperlink{aXe__utils_8h_a19a55b09e92561a904ece2b41f6a67e2}{create\_\-FITSimage} (char $\ast$filename, int overwrite)
\item 
int \hyperlink{aXe__utils_8h_a6def7f1cbe94897d599552d9f95e1d7e}{drzprep\_\-fitstrans} (char filename\mbox{[}$\,$\mbox{]}, int hdunum, fitsfile $\ast$PET\_\-ptr)
\item 
\hyperlink{structpx__point}{px\_\-point} \hyperlink{aXe__utils_8h_ae7f4f277c2b5d03b7ce52b2392d176b2}{get\_\-npixel} (const \hyperlink{structobservation}{observation} $\ast$obs)
\end{DoxyCompactItemize}


\subsection{Define Documentation}
\hypertarget{aXe__utils_8h_a06be4aa9150783f3722be133a28c8ef8}{
\index{aXe\_\-utils.h@{aXe\_\-utils.h}!MAXNCONF@{MAXNCONF}}
\index{MAXNCONF@{MAXNCONF}!aXe_utils.h@{aXe\_\-utils.h}}
\subsubsection[{MAXNCONF}]{\setlength{\rightskip}{0pt plus 5cm}\#define MAXNCONF~10}}
\label{aXe__utils_8h_a06be4aa9150783f3722be133a28c8ef8}


\subsection{Function Documentation}
\hypertarget{aXe__utils_8h_adb066a0a2f011d58fb3a8ecfce732d9f}{
\index{aXe\_\-utils.h@{aXe\_\-utils.h}!alloc\_\-char\_\-arr@{alloc\_\-char\_\-arr}}
\index{alloc\_\-char\_\-arr@{alloc\_\-char\_\-arr}!aXe_utils.h@{aXe\_\-utils.h}}
\subsubsection[{alloc\_\-char\_\-arr}]{\setlength{\rightskip}{0pt plus 5cm}char$\ast$$\ast$ alloc\_\-char\_\-arr (int {\em nrows}, \/  int {\em ncols})}}
\label{aXe__utils_8h_adb066a0a2f011d58fb3a8ecfce732d9f}
Function: alloc\_\-char\_\-arr The function allocates memory for a character array. The dimensions of the character array are specified with the number of columns per row and the number of rows in the input. The pointer to the allocated memory is returned.

Parameters: 
\begin{DoxyParams}{Parameters}
\item[{\em nrows}]-\/ number of rows to allocate \item[{\em ncols}]-\/ number of columns per row to allocate\end{DoxyParams}
Returns: \begin{DoxyReturn}{Returns}
char\_\-arr -\/ pointer to the allocated array 
\end{DoxyReturn}



\begin{DoxyCode}
1701 {
1702   char **char_arr;
1703   int i;
1704 
1705   // allocate the memory for the pointers to the individual rows
1706   char_arr = (char **) malloc(sizeof(char *)*nrows);
1707 
1708   // for each row:
1709   for (i=0; i < nrows; i++) 
1710     // allocate the columns
1711     char_arr[i] = malloc(sizeof(char)*ncols);
1712 
1713   // return the result
1714   return char_arr;
1715 }
\end{DoxyCode}
\hypertarget{aXe__utils_8h_a203bace423c84b28d48d305a99dfa81a}{
\index{aXe\_\-utils.h@{aXe\_\-utils.h}!apply\_\-DQ@{apply\_\-DQ}}
\index{apply\_\-DQ@{apply\_\-DQ}!aXe_utils.h@{aXe\_\-utils.h}}
\subsubsection[{apply\_\-DQ}]{\setlength{\rightskip}{0pt plus 5cm}void apply\_\-DQ ({\bf observation} $\ast$ {\em obs}, \/  int {\em dqmask})}}
\label{aXe__utils_8h_a203bace423c84b28d48d305a99dfa81a}
This function uses the DQ information contained in an \hyperlink{structobservation}{observation} structure together with a bitmask (represented as an integer) to determine if a pixel is to be flagged as bad or not. Flagged pixel are replaces by GSL\_\-NAN values.


\begin{DoxyParams}{Parameters}
\item[{\em obs}]a pointer to an exisiting \hyperlink{structobservation}{observation} structure \item[{\em dqmask}]an integer representation of a bit mask. \end{DoxyParams}



\begin{DoxyCode}
73 {
74   int             i, j;
75   fprintf(stdout, "DQMASK: %4i\n", dqmask);
76   
77   if ((obs->dq->size1 != obs->grism->size1) || (obs->dq->size2 != obs->grism->siz
      e2)) {
78     aXe_message(aXe_M_FATAL, __FILE__, __LINE__,
79                 "DQ array and DATA arrays have different sizes!\n");
80   }
81   if (obs->dq != NULL) {
82     for (i = 0; i < obs->dq->size1; i++) {
83       for (j = 0; j < obs->dq->size2; j++) {
84         if ((int)gsl_matrix_get(obs->dq, i, j) & dqmask) {
85           gsl_matrix_set(obs->grism, i, j, GSL_NAN);    
86         }
87       }
88     }
89     
90   }
91 }
\end{DoxyCode}
\hypertarget{aXe__utils_8h_a1b9693d2f0e0ff78e226ede6a839881c}{
\index{aXe\_\-utils.h@{aXe\_\-utils.h}!build\_\-config\_\-files@{build\_\-config\_\-files}}
\index{build\_\-config\_\-files@{build\_\-config\_\-files}!aXe_utils.h@{aXe\_\-utils.h}}
\subsubsection[{build\_\-config\_\-files}]{\setlength{\rightskip}{0pt plus 5cm}int build\_\-config\_\-files (char {\em list\_\-file}\mbox{[}$\,$\mbox{]}, \/  char $\ast$$\ast$ {\em list\_\-files}, \/  int {\em maxnrows})}}
\label{aXe__utils_8h_a1b9693d2f0e0ff78e226ede6a839881c}
Function: build\_\-config\_\-files The function parses a long character string and separates individual tokens along the character \char`\"{},\char`\"{}. The tokens are stored in a character array. A check is performed such that not more tokens are copied than there exist rows in the character array.

Parameters: 
\begin{DoxyParams}{Parameters}
\item[{\em list\_\-file}]-\/ the character string to parse \item[{\em list\_\-files}]-\/ the character array \item[{\em maxnrows}]-\/ the number of rows in the character array\end{DoxyParams}
Returns: \begin{DoxyReturn}{Returns}
nlist -\/ the number of tokens copied 
\end{DoxyReturn}



\begin{DoxyCode}
1759 {
1760 
1761   int nlist=0;
1762   int ii = 0;
1763   int i=0;
1764   int mod_maxrows;
1765 
1766   // create a modified maximum number fo an easy check 
1767   mod_maxrows = maxnrows -1;
1768 
1769   // go over the input string
1770   for (i=0; i<strlen(list_file); i++)
1771     {
1772 
1773       // check whether the actual character 
1774       // indicates the beginning of the next token
1775       if (list_file[i] != ',' && list_file[i] != '\0')
1776         {
1777           // check whether ther is space in the character array
1778           if (nlist > mod_maxrows)
1779             // give an error in case the char array is full
1780             aXe_message (aXe_M_FATAL, __FILE__, __LINE__,
1781                          "Too many configuration files! Maximum number: %i !\n", 
      maxnrows);
1782           else  
1783             // copy the actual character into the token
1784             list_files[nlist][ii++] = list_file[i];
1785         }  
1786     else
1787       {
1788         // write an end to the actual token
1789         list_files[nlist][ii] = '\0';
1790 
1791         // enhance the token counter 
1792         nlist++;
1793 
1794         // reset the position within the token
1795         ii = 0;
1796       }
1797     }
1798 
1799   // return the number of tokens
1800   return ++nlist;
1801 }
\end{DoxyCode}
\hypertarget{aXe__utils_8h_a6775cf9397e918007afce6147fa92ec8}{
\index{aXe\_\-utils.h@{aXe\_\-utils.h}!build\_\-path@{build\_\-path}}
\index{build\_\-path@{build\_\-path}!aXe_utils.h@{aXe\_\-utils.h}}
\subsubsection[{build\_\-path}]{\setlength{\rightskip}{0pt plus 5cm}void build\_\-path (char {\em envpathname}\mbox{[}$\,$\mbox{]}, \/  const char {\em file}\mbox{[}$\,$\mbox{]}, \/  char $\ast$ {\em filename})}}
\label{aXe__utils_8h_a6775cf9397e918007afce6147fa92ec8}
\hypertarget{aXe__utils_8h_a19a55b09e92561a904ece2b41f6a67e2}{
\index{aXe\_\-utils.h@{aXe\_\-utils.h}!create\_\-FITSimage@{create\_\-FITSimage}}
\index{create\_\-FITSimage@{create\_\-FITSimage}!aXe_utils.h@{aXe\_\-utils.h}}
\subsubsection[{create\_\-FITSimage}]{\setlength{\rightskip}{0pt plus 5cm}void create\_\-FITSimage (char $\ast$ {\em filename}, \/  int {\em overwrite})}}
\label{aXe__utils_8h_a19a55b09e92561a904ece2b41f6a67e2}
\hypertarget{aXe__utils_8h_aeed8cb8563260b750fda48d5636c92f2}{
\index{aXe\_\-utils.h@{aXe\_\-utils.h}!create\_\-FITSimage\_\-opened@{create\_\-FITSimage\_\-opened}}
\index{create\_\-FITSimage\_\-opened@{create\_\-FITSimage\_\-opened}!aXe_utils.h@{aXe\_\-utils.h}}
\subsubsection[{create\_\-FITSimage\_\-opened}]{\setlength{\rightskip}{0pt plus 5cm}fitsfile$\ast$ create\_\-FITSimage\_\-opened (char {\em filename}\mbox{[}$\,$\mbox{]}, \/  int {\em overwrite})}}
\label{aXe__utils_8h_aeed8cb8563260b750fda48d5636c92f2}
Function to create a new FITS image file with an empty first extension. If overwrite is non zero, any existing file is deleted.


\begin{DoxyParams}{Parameters}
\item[{\em filename}]a pointer to an array of character containing the filename \item[{\em overwrite}]if set to 1 exisiting file is deleted first \end{DoxyParams}
\begin{DoxyReturn}{Returns}
a fitsifle pointer to a newly created FITS file 
\end{DoxyReturn}



\begin{DoxyCode}
803 {
804      fitsfile *output;
805      int f_status = 0;
806      int hdunum,hdutype;
807 
808      // Try to open the file
809      {
810           FILE *in_file;
811           in_file = fopen (filename, "r");
812 
813           if ((overwrite == 1) && (in_file != NULL))
814             {
815                  //aXe_message (aXe_M_WARN3, __FILE__, __LINE__,
816                 //            "create_FITSimage_opened: File %s "
817                 //            "exits. Overwriting it.", filename);
818                  fclose (in_file);
819                  unlink (filename);
820             }
821           if ((overwrite != 1) && (in_file != NULL))
822             {
823             fits_open_file (&output, filename, READONLY, &f_status);
824             if (f_status)
825             {
826                 ffrprt (stderr, f_status);
827                 aXe_message (aXe_M_FATAL, __FILE__, __LINE__,
828                     "get_ID_index_to_MEPET:" " Could not open file: %s",
829                     filename);
830             }
831             fits_get_num_hdus (output, &hdunum, &f_status);
832             if (f_status)
833             {
834                 ffrprt (stderr, f_status);
835                 aXe_message (aXe_M_FATAL, __FILE__, __LINE__,
836                     "gsl_to_FITSimage: Could not get"
837                     " number of HDU from: %s", filename);
838             }
839 
840             /* Move to last HDU */
841             fits_movabs_hdu (output, hdunum, &hdutype, &f_status);
842             if (f_status)
843             {
844                 ffrprt (stderr, f_status);
845                 aXe_message (aXe_M_FATAL, __FILE__, __LINE__,
846                     "gsl_to_FITSimage: Could not mov"
847                     " to HDU number %d in file: %s", hdunum, filename);
848             }
849             return output;
850             }
851      }
852 
853      fits_create_file (&output, filename, &f_status);
854      if (f_status)
855        {
856             aXe_message (aXe_M_FATAL, __FILE__, __LINE__,
857                          "create_FITSimage_opened: Could not open" " file: %s", f
      ilename);
858        }
859 
860      // Create empty HDU
861      {
862           int naxis = 0;
863           long naxes[2];
864           ffiimg (output, 16, naxis, naxes, &f_status);
865           if (f_status)
866             {
867                  aXe_message (aXe_M_FATAL, __FILE__, __LINE__,
868                               "create_FITSimage_opened: Error creating "
869                               " empty first HDU in: %s", filename);
870             }
871      }
872     return output;
873 }
\end{DoxyCode}
\hypertarget{aXe__utils_8h_a6def7f1cbe94897d599552d9f95e1d7e}{
\index{aXe\_\-utils.h@{aXe\_\-utils.h}!drzprep\_\-fitstrans@{drzprep\_\-fitstrans}}
\index{drzprep\_\-fitstrans@{drzprep\_\-fitstrans}!aXe_utils.h@{aXe\_\-utils.h}}
\subsubsection[{drzprep\_\-fitstrans}]{\setlength{\rightskip}{0pt plus 5cm}int drzprep\_\-fitstrans (char {\em filename}\mbox{[}$\,$\mbox{]}, \/  int {\em hdunum}, \/  fitsfile $\ast$ {\em PET\_\-ptr})}}
\label{aXe__utils_8h_a6def7f1cbe94897d599552d9f95e1d7e}



\begin{DoxyCode}
2130                                                                      {
2131 
2132   char kname[FLEN_KEYWORD];
2133   char kvalue[FLEN_VALUE];
2134   char kcomment[FLEN_COMMENT];
2135   fitsfile *input;
2136   int      f_status=0, hdutype=0;
2137   //long tmp;
2138 
2139   fits_open_file (&input, filename, READONLY, &f_status);
2140   if (f_status)
2141     {
2142         ffrprt (stderr, f_status);
2143         aXe_message (aXe_M_FATAL, __FILE__, __LINE__,
2144             "drzprep_fitstrans: " "Could not open file: %s",
2145             filename);
2146     }
2147   // Move to the desired HDU
2148   fits_movabs_hdu (input, hdunum, &hdutype, &f_status);
2149   if (f_status)
2150     {
2151       ffrprt (stderr, f_status);
2152       aXe_message (aXe_M_FATAL, __FILE__, __LINE__,
2153                    "drzprep_fitstrans: " "Could not move to extension %d in file:
       %s",
2154                    hdunum,filename);
2155     }
2156 
2157   strcpy(kname, "OBJECTID");
2158   //  fits_read_key_lng (input, kname, &tmp, kcomment, &f_status);
2159   fits_read_key_str(input, kname, kvalue, kcomment, &f_status);
2160   if (f_status)
2161     {
2162       ffrprt (stderr, f_status);
2163       aXe_message (aXe_M_FATAL, __FILE__, __LINE__,
2164                    "drzprep_fitstrans: " "Could not get keyword: %s",
2165                    kname);
2166     }
2167 
2168   fits_write_key_str(PET_ptr, kname, kvalue, kcomment, &f_status);
2169   if (f_status)
2170     {
2171       ffrprt (stderr, f_status);
2172       aXe_message (aXe_M_FATAL, __FILE__, __LINE__,
2173                    "drzprep_fitstrans: " "Could not write keyword: %s",
2174                    kname);
2175     }
2176   strcpy(kname, "BEAMID");
2177   //  fits_read_key_lng (input, kname, &tmp, kcomment, &f_status);
2178   fits_read_key_str(input, kname, kvalue, kcomment, &f_status);
2179   if (f_status)
2180     {
2181       ffrprt (stderr, f_status);
2182       aXe_message (aXe_M_FATAL, __FILE__, __LINE__,
2183                    "drzprep_fitstrans: " "Could not get keyword: %s",
2184                    kname);
2185     }
2186 
2187   fits_write_key_str(PET_ptr, kname, kvalue, kcomment, &f_status);
2188   if (f_status)
2189     {
2190       ffrprt (stderr, f_status);
2191       aXe_message (aXe_M_FATAL, __FILE__, __LINE__,
2192                    "drzprep_fitstrans: " "Could not write keyword: %s",
2193                    kname);
2194     }
2195   fits_close_file (input, &f_status);
2196   if (f_status)
2197     {
2198       ffrprt (stderr, f_status);
2199       aXe_message (aXe_M_FATAL, __FILE__, __LINE__,
2200                    "drzprep_fitstrans: " "Could not close fitsfile.",
2201                    kname);
2202     }
2203   return 0;
2204 }
\end{DoxyCode}
\hypertarget{aXe__utils_8h_a791e8209e46381315c39a27890280053}{
\index{aXe\_\-utils.h@{aXe\_\-utils.h}!FITSextnum@{FITSextnum}}
\index{FITSextnum@{FITSextnum}!aXe_utils.h@{aXe\_\-utils.h}}
\subsubsection[{FITSextnum}]{\setlength{\rightskip}{0pt plus 5cm}int FITSextnum (const char $\ast$const  {\em fname})}}
\label{aXe__utils_8h_a791e8209e46381315c39a27890280053}
Return the number of extensions in a FITS image


\begin{DoxyParams}{Parameters}
\item[{\em fname}]File name of the FITS image \end{DoxyParams}
\begin{DoxyReturn}{Returns}
the number of extensions 
\end{DoxyReturn}



\begin{DoxyCode}
309 {
310      fitsfile *input;
311      int f_status = 0;
312      int hdunum;
313 
314      fits_open_file (&input, fname, READONLY, &f_status);
315      if (f_status)
316        {
317             aXe_message (aXe_M_FATAL, __FILE__, __LINE__,
318                          "Could not open file: %s", fname);
319        }
320      fits_get_num_hdus (input, &hdunum, &f_status);
321      if (f_status)
322        {
323             aXe_message (aXe_M_FATAL, __FILE__, __LINE__,
324                          "Could get number of extension in file: %s", fname);
325        }
326 
327      fits_close_file (input, &f_status);
328 
329      return hdunum;
330 }
\end{DoxyCode}
\hypertarget{aXe__utils_8h_afdee57669eb437afcad30e96223b48a2}{
\index{aXe\_\-utils.h@{aXe\_\-utils.h}!FITSHDU\_\-to\_\-gsl@{FITSHDU\_\-to\_\-gsl}}
\index{FITSHDU\_\-to\_\-gsl@{FITSHDU\_\-to\_\-gsl}!aXe_utils.h@{aXe\_\-utils.h}}
\subsubsection[{FITSHDU\_\-to\_\-gsl}]{\setlength{\rightskip}{0pt plus 5cm}gsl\_\-matrix$\ast$ FITSHDU\_\-to\_\-gsl (const char $\ast$const  {\em fname}, \/  fitsfile $\ast$ {\em fptr}, \/  int {\em fatal})}}
\label{aXe__utils_8h_afdee57669eb437afcad30e96223b48a2}
Read a FITS image from the current HDU into a gsl array


\begin{DoxyParams}{Parameters}
\item[{\em fname}]File name of the FITS image \item[{\em fptr}]the number of the extension to read in (first primary = 1) \item[{\em fatal}]if non zero an error loading the data will trigger an exception \end{DoxyParams}
\begin{DoxyReturn}{Returns}
a gsl\_\-matrix containing the image data or NULL 
\end{DoxyReturn}



\begin{DoxyCode}
641 {
642   int f_status = 0;
643   float nulval = 0;
644   int anynul;
645   int bitpix, naxis;
646   long naxes[2];
647   long zero[2] = { 1, 1 };
648   gsl_matrix *im;
649   PIXEL_T *storage;
650 
651   // determine the image information;
652   // complain if naxis is different from 1
653   ffgipr (fptr, 2, &bitpix, &naxis, naxes, &f_status);
654   if (naxis != 2) {
655           if (fatal) {
656                   fits_report_error (stderr, f_status);
657                   aXe_message (aXe_M_FATAL, __FILE__, __LINE__,
658                                   "FITSimage_to_gsl: " "%s is not a 2D FITS image
      .",
659                                   fname);
660           } else {
661                   fits_report_error (stderr, f_status);
662                   aXe_message (aXe_M_WARN4, __FILE__, __LINE__,
663                                   "FITSimage_to_gsl: " "%s is not a 2D FITS image
      .",
664                                   fname);
665                   return NULL;
666           }
667   }
668 
669   // allocate memory
670   if (!(storage = malloc (naxes[0] * naxes[1] * sizeof (double))))
671       aXe_message (aXe_M_FATAL, __FILE__, __LINE__,
672                    "FITSimage_to_gsl: " "Out of memory");
673 
674 
675   // transport the entire image data to the storage
676   ffgpxv (fptr, TFLOAT, zero, naxes[0] * naxes[1], &nulval, storage, &anynul, &f_
      status);
677   if (f_status) {
678           if (fatal) {
679                   fits_report_error (stderr, f_status);
680                   aXe_message (aXe_M_FATAL, __FILE__, __LINE__,
681                                   "FITSimage_to_gsl: " "Could not read data from 
      an extention "
682                                   " in file: %s", fname);
683           } else {
684                   fits_report_error (stderr, f_status);
685                   aXe_message (aXe_M_WARN4, __FILE__, __LINE__,
686                                   "FITSimage_to_gsl: " "Could not read data from 
      an extention"
687                                   " in file: %s", fname);
688                   f_status = 0;
689                   fits_close_file (fptr, &f_status);
690                   return NULL;
691           }
692   }
693 
694   // transfer the storage to a gsl-image
695   im = storage_to_gsl(naxes, storage);
696 
697   // mop up and return the gsl-image
698   free (storage);
699   storage = NULL;
700   return im;
701 }
\end{DoxyCode}
\hypertarget{aXe__utils_8h_ae608ee7bf2717c17c842cd3dfd327884}{
\index{aXe\_\-utils.h@{aXe\_\-utils.h}!FITSimage\_\-to\_\-gsl@{FITSimage\_\-to\_\-gsl}}
\index{FITSimage\_\-to\_\-gsl@{FITSimage\_\-to\_\-gsl}!aXe_utils.h@{aXe\_\-utils.h}}
\subsubsection[{FITSimage\_\-to\_\-gsl}]{\setlength{\rightskip}{0pt plus 5cm}gsl\_\-matrix$\ast$ FITSimage\_\-to\_\-gsl (const char $\ast$const  {\em fname}, \/  int {\em hdunum}, \/  int {\em fatal})}}
\label{aXe__utils_8h_ae608ee7bf2717c17c842cd3dfd327884}
Read a FITS image into a gsl array


\begin{DoxyParams}{Parameters}
\item[{\em fname}]File name of the FITS image \item[{\em hdunum}]the number of the extension to read in (first primary = 1) \item[{\em fatal}]if non zero an error loading the data will trigger an exception \end{DoxyParams}
\begin{DoxyReturn}{Returns}
a gsl\_\-matrix (overriden in \hyperlink{aXe__grism_8h}{aXe\_\-grism.h}) containing the image data or NULL 
\end{DoxyReturn}



\begin{DoxyCode}
552 {
553   fitsfile *input;
554   int f_status = 0;
555   gsl_matrix *im;
556   int hdutype;
557 
558   // open the fits file; complain if problems
559   fits_open_file (&input, fname, READONLY, &f_status);
560   if (f_status) {
561           if (fatal) {
562                   fits_report_error (stderr, f_status);
563                   aXe_message (aXe_M_FATAL, __FILE__, __LINE__,
564                                   "FITSimage_to_gsl: " "Could not open file %s:",
       fname);
565           } else {
566                   fits_report_error (stderr, f_status);
567                   aXe_message (aXe_M_WARN4, __FILE__, __LINE__,
568                                   "FITSimage_to_gsl: " "Could not open file %s:",
       fname);
569                   return NULL;
570           }
571   }
572 
573   // move to the correct HDU; complain if problems
574   fits_movabs_hdu (input, hdunum, &hdutype, &f_status);
575   if (f_status) {
576           if (fatal) {
577                   fits_report_error (stderr, f_status);
578                   aXe_message (aXe_M_FATAL, __FILE__, __LINE__,
579                                   "FITSimage_to_gsl: " "Could not read extention 
      %d"
580                                   " from file: %s", hdunum, fname);
581           } else {
582                   fits_report_error (stderr, f_status);
583                   aXe_message (aXe_M_WARN4, __FILE__, __LINE__,
584                                   "FITSimage_to_gsl: " "Could not read extention 
      %d"
585                                   " from file: %s", hdunum, fname);
586                   f_status = 0;
587                   fits_close_file (input, &f_status);
588                   return NULL;
589           }
590   }
591   if (hdutype != 0) {
592           if (fatal) {
593                   fits_report_error (stderr, f_status);
594                   aXe_message (aXe_M_FATAL, __FILE__, __LINE__,
595                                   "FITSimage_to_gsl: " "Extension %i of %s is not
       "
596                                   " an image type", hdunum, fname);
597           } else {
598                   fits_report_error (stderr, f_status);
599                   aXe_message (aXe_M_WARN4, __FILE__, __LINE__,
600                                   "FITSimage_to_gsl: " "Extension %i of %s is not
       "
601                                   " an image type", hdunum, fname);
602                   return NULL;
603           }
604   }
605 
606   // read the image data from the current HDU
607   im = FITSHDU_to_gsl(fname, input, fatal);
608 
609   // mop up
610   fits_close_file (input, &f_status);
611   if (f_status) {
612           if (fatal) {
613                   fits_report_error (stderr, f_status);
614                   aXe_message (aXe_M_FATAL, __FILE__, __LINE__,
615                                   "FITSimage_to_gsl: " "Could not close file: %s"
      , fname);
616           } else {
617                   fits_report_error (stderr, f_status);
618                   aXe_message (aXe_M_WARN4, __FILE__, __LINE__,
619                                   "FITSimage_to_gsl: " "Could not close  file: %s
      ", fname);
620                   f_status = 0;
621                   fits_close_file (input, &f_status);
622                   return NULL;
623           }
624   }
625 
626   // return the gsl-image
627   return im;
628 }
\end{DoxyCode}
\hypertarget{aXe__utils_8h_a18f07b887bcf78c0c0105912818b8a2b}{
\index{aXe\_\-utils.h@{aXe\_\-utils.h}!FITSimage\_\-to\_\-gslOld@{FITSimage\_\-to\_\-gslOld}}
\index{FITSimage\_\-to\_\-gslOld@{FITSimage\_\-to\_\-gslOld}!aXe_utils.h@{aXe\_\-utils.h}}
\subsubsection[{FITSimage\_\-to\_\-gslOld}]{\setlength{\rightskip}{0pt plus 5cm}gsl\_\-matrix$\ast$ FITSimage\_\-to\_\-gslOld (const char $\ast$const  {\em fname}, \/  int {\em hdunum}, \/  int {\em fatal})}}
\label{aXe__utils_8h_a18f07b887bcf78c0c0105912818b8a2b}
Read a FITS image into a gsl array


\begin{DoxyParams}{Parameters}
\item[{\em fname}]File name of the FITS image \item[{\em hdunum}]the number of the extension to read in (first primary = 1) \item[{\em fatal}]if non zero an error loading the data will trigger an exception \end{DoxyParams}
\begin{DoxyReturn}{Returns}
a gsl\_\-matrix (overriden in \hyperlink{aXe__grism_8h}{aXe\_\-grism.h}) containing the image data or NULL 
\end{DoxyReturn}



\begin{DoxyCode}
398 {
399   fitsfile *input;
400   int f_status = 0;
401   float nulval = 0;
402   int anynul;
403   int bitpix, naxis;
404   long naxes[2];
405   long zero[2] = { 1, 1 };
406   gsl_matrix *im;
407   PIXEL_T *storage, *dp;
408   int x, y;
409   int hdutype;
410   
411   fits_open_file (&input, fname, READONLY, &f_status);
412   if (f_status)
413     {
414       if (fatal) 
415         {
416           fits_report_error (stderr, f_status);
417           aXe_message (aXe_M_FATAL, __FILE__, __LINE__,
418                        "FITSimage_to_gsl: " "Could not open file %s:", fname);
419         } else {
420           fits_report_error (stderr, f_status);
421           aXe_message (aXe_M_WARN4, __FILE__, __LINE__,
422                        "FITSimage_to_gsl: " "Could not open file %s:", fname);
423           return NULL;
424         }
425     }
426   fits_movabs_hdu (input, hdunum, &hdutype, &f_status);
427   if (f_status)
428     {
429       if (fatal) 
430         {
431           fits_report_error (stderr, f_status);
432           aXe_message (aXe_M_FATAL, __FILE__, __LINE__,
433                        "FITSimage_to_gsl: " "Could not read extention %d"
434                        " from file: %s", hdunum, fname);
435         } else {
436           fits_report_error (stderr, f_status);
437           aXe_message (aXe_M_WARN4, __FILE__, __LINE__,
438                        "FITSimage_to_gsl: " "Could not read extention %d"
439                        " from file: %s", hdunum, fname);
440           f_status = 0;
441           fits_close_file (input, &f_status);
442           return NULL;
443         }
444     }
445   if (hdutype != 0)
446     {
447       if (fatal) 
448         {
449           fits_report_error (stderr, f_status);
450           aXe_message (aXe_M_FATAL, __FILE__, __LINE__,
451                        "FITSimage_to_gsl: " "Extension %i of %s is not "
452                          " an image type", hdunum, fname);
453         } else {
454           fits_report_error (stderr, f_status);
455           aXe_message (aXe_M_WARN4, __FILE__, __LINE__,
456                        "FITSimage_to_gsl: " "Extension %i of %s is not "
457                        " an image type", hdunum, fname);
458           return NULL;
459         }
460     }
461   ffgipr (input, 2, &bitpix, &naxis, naxes, &f_status);
462   
463   if (naxis != 2)
464     {
465       if (fatal) 
466         {
467             fits_report_error (stderr, f_status);
468             aXe_message (aXe_M_FATAL, __FILE__, __LINE__,
469                          "FITSimage_to_gsl: " "%s is not a 2D FITS image.",
470                          fname);
471         } else {
472           fits_report_error (stderr, f_status);
473           aXe_message (aXe_M_WARN4, __FILE__, __LINE__,
474                        "FITSimage_to_gsl: " "%s is not a 2D FITS image.",
475                        fname);
476           return NULL;
477         }
478     }
479   
480   if (!(storage = malloc (naxes[0] * naxes[1] * sizeof (double))))
481     {
482       fits_report_error (stderr, f_status);
483       aXe_message (aXe_M_FATAL, __FILE__, __LINE__,
484                    "FITSimage_to_gsl: " "Out of memory");
485     }
486   
487   ffgpxv (input, TFLOAT, zero, naxes[0] * naxes[1], &nulval,
488           storage, &anynul, &f_status);
489   if (f_status)
490     {
491       if (fatal) 
492         {
493           fits_report_error (stderr, f_status);
494           aXe_message (aXe_M_FATAL, __FILE__, __LINE__,
495                        "FITSimage_to_gsl: " "Could not read data from extention %
      d"
496                        " from file: %s", hdunum, fname);
497         } else {
498           fits_report_error (stderr, f_status);
499           aXe_message (aXe_M_WARN4, __FILE__, __LINE__,
500                        "FITSimage_to_gsl: " "Could not read data from extention %
      d"
501                          " from file: %s", hdunum, fname);
502           f_status = 0;
503           fits_close_file (input, &f_status);
504           return NULL;
505         }
506     }
507   fits_close_file (input, &f_status);
508   if (f_status)
509     {
510       if (fatal) 
511         {
512           fits_report_error (stderr, f_status);
513           aXe_message (aXe_M_FATAL, __FILE__, __LINE__,
514                        "FITSimage_to_gsl: " "Could not close file: %s", fname);
515         } else {
516           fits_report_error (stderr, f_status);
517           aXe_message (aXe_M_WARN4, __FILE__, __LINE__,
518                        "FITSimage_to_gsl: " "Could not close  file: %s", fname);
519           f_status = 0;
520           fits_close_file (input, &f_status);
521           return NULL;
522         }
523     }
524   im = gsl_matrix_alloc (naxes[0], naxes[1]);
525   dp = storage;
526   for (y = 0; y < naxes[1]; y++)
527     {
528       for (x = 0; x < naxes[0]; x++)
529         {
530           gsl_matrix_set (im, x, y, *dp++);
531           
532         }
533     }
534   
535   free (storage);
536   storage = NULL;
537   return im;
538 }
\end{DoxyCode}
\hypertarget{aXe__utils_8h_a74a75b4d9d74b257e44e6ec61ca79bf5}{
\index{aXe\_\-utils.h@{aXe\_\-utils.h}!FITSnaxes\_\-to\_\-gsl@{FITSnaxes\_\-to\_\-gsl}}
\index{FITSnaxes\_\-to\_\-gsl@{FITSnaxes\_\-to\_\-gsl}!aXe_utils.h@{aXe\_\-utils.h}}
\subsubsection[{FITSnaxes\_\-to\_\-gsl}]{\setlength{\rightskip}{0pt plus 5cm}gsl\_\-matrix$\ast$ FITSnaxes\_\-to\_\-gsl (const char $\ast$const  {\em fname}, \/  int {\em hdunum})}}
\label{aXe__utils_8h_a74a75b4d9d74b257e44e6ec61ca79bf5}
Read a FITS image, DO not read data but return an empty gsl array This function is meant to be a faster way to get information about an \hyperlink{structobservation}{observation} rather than the actual data.


\begin{DoxyParams}{Parameters}
\item[{\em fname}]File name of the FITS image \end{DoxyParams}
\begin{DoxyReturn}{Returns}
a gsl\_\-matrix (overriden in \hyperlink{aXe__grism_8h}{aXe\_\-grism.h}) containing the image data or NULL 
\end{DoxyReturn}



\begin{DoxyCode}
343 {
344      fitsfile *input;
345      int f_status = 0;
346      int bitpix, naxis;
347      long naxes[2];
348      gsl_matrix *im;
349      int hdutype;
350 
351      fits_open_file (&input, fname, READONLY, &f_status);
352      if (f_status)
353        {
354             aXe_message (aXe_M_FATAL, __FILE__, __LINE__,
355                          "Could not open" " file:", fname);
356        }
357      fits_movabs_hdu (input, hdunum, &hdutype, &f_status);
358      if (f_status)
359        {
360             aXe_message (aXe_M_FATAL, __FILE__, __LINE__,
361                          "Could not read extention %d" " from file: %s",
362                          hdunum, fname);
363        }
364      if (hdutype != 0)
365        {
366             aXe_message (aXe_M_FATAL, __FILE__, __LINE__,
367                          "Extension %i of %s is not " " an image type",
368                          hdunum, fname);
369        }
370      ffgipr(input, 2, &bitpix, &naxis, naxes, &f_status);
371 
372      if (naxis != 2)
373        {
374             aXe_message (aXe_M_FATAL, __FILE__, __LINE__,
375                          "%s is not a 2D" " FITS image.", fname);
376        }
377 
378      im = gsl_matrix_alloc (naxes[0], naxes[1]);
379 
380      gsl_matrix_set_all (im, 0.0);
381 
382 
383      return im;
384 }
\end{DoxyCode}
\hypertarget{aXe__utils_8h_ab728171bc22cb503b1904ed113a8c36e}{
\index{aXe\_\-utils.h@{aXe\_\-utils.h}!fprintf\_\-object@{fprintf\_\-object}}
\index{fprintf\_\-object@{fprintf\_\-object}!aXe_utils.h@{aXe\_\-utils.h}}
\subsubsection[{fprintf\_\-object}]{\setlength{\rightskip}{0pt plus 5cm}void fprintf\_\-object (FILE $\ast$ {\em output}, \/  {\bf object} $\ast$ {\em o})}}
\label{aXe__utils_8h_ab728171bc22cb503b1904ed113a8c36e}
output the content of an \hyperlink{structobject}{object} structure 


\begin{DoxyCode}
1881 {
1882      int i, j;
1883 
1884      fprintf (output, "object ID: %d\n", o->ID);
1885      fprintf (output, "object nbeams: %d\n", o->nbeams);
1886 
1887      for (i = 0; i < o->nbeams; i++)
1888        {
1889             fprintf (output, "object beam ID: #%d ID\n", o->beams[i].ID);
1890             fprintf (output, "object beam #%d refpixel: %f %f\n",
1891                      o->beams[i].ID, o->beams[i].refpoint.x,
1892                      o->beams[i].refpoint.y);
1893 
1894             for (j = 0; j < 4; j++)
1895               {
1896                    fprintf (output, "object beam #%d corner[%d]: %d %d\n",
1897                             o->beams[i].ID, j, o->beams[i].corners[j].x,
1898                             o->beams[i].corners[j].y);
1899               }
1900 
1901             for (j = 0; j < 2; j++)
1902               {
1903                    fprintf (output, "object beam #%d bbox[%d]: %d %d\n",
1904                             o->beams[i].ID, j, o->beams[i].bbox[j].x,
1905                             o->beams[i].bbox[j].y);
1906               }
1907 
1908             fprintf (output, "object beam #%d width: %f\n", o->beams[i].ID,
1909                      o->beams[i].width);
1910             fprintf (output, "object beam #%d orient: %f\n", o->beams[i].ID,
1911                      o->beams[i].orient);
1912 
1913 
1914        }
1915 
1916 
1917 
1918 }
\end{DoxyCode}
\hypertarget{aXe__utils_8h_ac8d8059b1a87e608b4570096fba84d01}{
\index{aXe\_\-utils.h@{aXe\_\-utils.h}!free\_\-char\_\-arr@{free\_\-char\_\-arr}}
\index{free\_\-char\_\-arr@{free\_\-char\_\-arr}!aXe_utils.h@{aXe\_\-utils.h}}
\subsubsection[{free\_\-char\_\-arr}]{\setlength{\rightskip}{0pt plus 5cm}void free\_\-char\_\-arr (char $\ast$$\ast$ {\em char\_\-arr}, \/  int {\em nrows})}}
\label{aXe__utils_8h_ac8d8059b1a87e608b4570096fba84d01}
Function: free\_\-char\_\-arr The function releases the memory allocated in a memory array.

Parameters: 
\begin{DoxyParams}{Parameters}
\item[{\em char\_\-arr}]-\/ pointer to the character array \item[{\em nrows}]-\/ the number of rows in the character array \end{DoxyParams}



\begin{DoxyCode}
1729 {
1730   int i;
1731 
1732   // for each row
1733   for(i=0; i < nrows; i++)
1734     // release the memory
1735     free(char_arr[i]);
1736 
1737   // release the rest
1738   free(char_arr);
1739 }
\end{DoxyCode}
\hypertarget{aXe__utils_8h_a1f63bfb071e9d0ea1f8854efdfae4692}{
\index{aXe\_\-utils.h@{aXe\_\-utils.h}!free\_\-oblist@{free\_\-oblist}}
\index{free\_\-oblist@{free\_\-oblist}!aXe_utils.h@{aXe\_\-utils.h}}
\subsubsection[{free\_\-oblist}]{\setlength{\rightskip}{0pt plus 5cm}void free\_\-oblist ({\bf object} $\ast$$\ast$ {\em oblist})}}
\label{aXe__utils_8h_a1f63bfb071e9d0ea1f8854efdfae4692}
Free a NULL terminated array of objects


\begin{DoxyParams}{Parameters}
\item[{\em sobjs,a}]NULL terminated array containing pointers to objects \end{DoxyParams}



\begin{DoxyCode}
1845 {
1846   int i, j, nobjs = 0;
1847 
1848   /* Find the number of objects in sobjs */
1849   while (oblist[nobjs])
1850     nobjs++;
1851   
1852   for (i = 0; i < nobjs; i++)
1853     {
1854       for (j=0;j < oblist[i]->nbeams; j++){
1855         free(oblist[i]->beams[j].spec_trace->data);
1856         free(oblist[i]->beams[j].spec_trace);
1857 
1858         if (oblist[i]->beams[j].flux != NULL){
1859           gsl_vector_free (oblist[i]->beams[j].flux);      
1860           //      fprintf(stderr, "FLux was freed\n");
1861         }
1862         else{
1863           //      fprintf(stderr, "FLux is NULL\n");
1864         }
1865         //free(oblist[i]->*beams[j]);
1866       }
1867       free (oblist[i]);
1868       oblist[i] = NULL;
1869     }
1870   free (oblist);
1871   oblist = NULL;
1872 }
\end{DoxyCode}
\hypertarget{aXe__utils_8h_aaf6850286e924fd44f65af2cf80894f0}{
\index{aXe\_\-utils.h@{aXe\_\-utils.h}!free\_\-observation@{free\_\-observation}}
\index{free\_\-observation@{free\_\-observation}!aXe_utils.h@{aXe\_\-utils.h}}
\subsubsection[{free\_\-observation}]{\setlength{\rightskip}{0pt plus 5cm}void free\_\-observation ({\bf observation} $\ast$ {\em obs})}}
\label{aXe__utils_8h_aaf6850286e924fd44f65af2cf80894f0}
Function to free an \hyperlink{structobservation}{observation} struture


\begin{DoxyParams}{Parameters}
\item[{\em obs}]an \hyperlink{structobservation}{observation} pointer \end{DoxyParams}



\begin{DoxyCode}
2001 {
2002   if (obs->grism != NULL)
2003     gsl_matrix_free (obs->grism);
2004   if (obs->pixerrs != NULL)
2005     gsl_matrix_free (obs->pixerrs);
2006   if (obs->dq != NULL)
2007     gsl_matrix_free (obs->dq);
2008   free (obs);
2009 }
\end{DoxyCode}
\hypertarget{aXe__utils_8h_aa1a7ef7b7d19206e1df681bf2bea0d7c}{
\index{aXe\_\-utils.h@{aXe\_\-utils.h}!get\_\-FITS\_\-cards@{get\_\-FITS\_\-cards}}
\index{get\_\-FITS\_\-cards@{get\_\-FITS\_\-cards}!aXe_utils.h@{aXe\_\-utils.h}}
\subsubsection[{get\_\-FITS\_\-cards}]{\setlength{\rightskip}{0pt plus 5cm}{\bf FITScards}$\ast$ get\_\-FITS\_\-cards (char {\em filename}\mbox{[}$\,$\mbox{]}, \/  int {\em hdu})}}
\label{aXe__utils_8h_aa1a7ef7b7d19206e1df681bf2bea0d7c}
Returns a NULL terminated array of $\ast$char which each contain a card from a given hdu from a given FITS file. NAXES, NAXIS, BITPIX, SIMPLE, EXTEND, ID$\ast$, DATE cards are ignored.


\begin{DoxyParams}{Parameters}
\item[{\em filename}]a pointer to a string containing the name of the FITS file to write to \item[{\em hdu}]the number of the HDU in the input FITS file to access\end{DoxyParams}
\begin{DoxyReturn}{Returns}
a NULL terminated array of char arrays 
\end{DoxyReturn}



\begin{DoxyCode}
1293 {
1294     int f_status=0;
1295     int ninc, nexc;
1296     fitsfile *input;
1297     FITScards *cards=NULL;
1298     int hdutype,i,n;
1299     char card[FLEN_CARD];
1300     char *inclist[1] = {
1301     "*"
1302     };
1303 
1304     char *exclist[7] = {
1305     "NAXES",
1306     "NAXIS*",
1307     "BITPIX",
1308     "SIMPLE",
1309     "EXTEND",
1310     "ID*",
1311     "DATE"
1312     };
1313 
1314     ninc = 1;
1315     nexc = 7;
1316 
1317 
1318     //  Open the file for creating/appending
1319     fits_open_file (&input, filename, READONLY, &f_status);
1320     if (f_status)
1321     {
1322         ffrprt (stderr, f_status);
1323         aXe_message (aXe_M_FATAL, __FILE__, __LINE__,
1324             "get_FITS_cards: " "Could not open file: %s",
1325             filename);
1326     }
1327 
1328     // Move to the desired HDU
1329     fits_movabs_hdu (input, hdu, &hdutype, &f_status);
1330     if (f_status)
1331     {
1332         ffrprt (stderr, f_status);
1333         aXe_message (aXe_M_FATAL, __FILE__, __LINE__,
1334             "get_FITS_cards: " "Could not move to extension %d in file: %s",
1335             hdu,filename);
1336     }
1337 
1338     // Find the number of cards in this HDU
1339     n = 0;    
1340     do {
1341         fits_find_nextkey (input, inclist, ninc, exclist,
1342          nexc, card, &f_status);    
1343         n++;
1344     }
1345     while (f_status==0);
1346     if (f_status!= KEY_NO_EXIST) {
1347         ffrprt (stderr, f_status);
1348         aXe_message (aXe_M_FATAL, __FILE__, __LINE__,
1349             "get_FITS_cards: " "Problem reading keys in extension %d of file: %s"
      ,
1350             hdu,filename);
1351     }
1352     f_status = 0;
1353 
1354 
1355     // Allocate enough room (n+1 for NULL termination) for all the cards
1356     //cards = (char **) malloc(sizeof(char *)*(n+1));
1357     //for(i=0;i<(n+1);i++) cards[i] = malloc(sizeof(char)*FLEN_CARD);
1358     cards = allocate_FITScards(n);
1359 
1360     // Move back tot he top of the HDU
1361     fits_read_record (input, 0, card, &f_status);
1362     if (f_status)
1363     {
1364         ffrprt (stderr, f_status);
1365         aXe_message (aXe_M_FATAL, __FILE__, __LINE__,
1366             "get_FITS_cards: " "Could not move to first card in extension %d in f
      ile: %s",
1367             hdu,filename);
1368     }
1369 
1370     // Read all cards 
1371     i=0;
1372     do {
1373         fits_find_nextkey (input, inclist, ninc, exclist,
1374          nexc, cards->cards[i], &f_status);    
1375         //fprintf(stderr,"%s\n",cards->cards[i]);
1376         i++;
1377     }
1378     while (f_status==0);
1379     if (f_status!= KEY_NO_EXIST) {
1380         ffrprt (stderr, f_status);
1381         aXe_message (aXe_M_FATAL, __FILE__, __LINE__,
1382             "get_FITS_cards: " "Problem reading keys in extension %d of file: %s"
      ,
1383             hdu,filename);
1384     }
1385     f_status = 0;
1386     
1387     // NULL terminate the card array
1388     //cards[n] = NULL;
1389 
1390     fits_close_file (input, &f_status);
1391     return cards;
1392 }
\end{DoxyCode}
\hypertarget{aXe__utils_8h_a27dd022a77729a35640126b146b35825}{
\index{aXe\_\-utils.h@{aXe\_\-utils.h}!get\_\-FITS\_\-cards\_\-opened@{get\_\-FITS\_\-cards\_\-opened}}
\index{get\_\-FITS\_\-cards\_\-opened@{get\_\-FITS\_\-cards\_\-opened}!aXe_utils.h@{aXe\_\-utils.h}}
\subsubsection[{get\_\-FITS\_\-cards\_\-opened}]{\setlength{\rightskip}{0pt plus 5cm}{\bf FITScards}$\ast$ get\_\-FITS\_\-cards\_\-opened (fitsfile $\ast$ {\em input})}}
\label{aXe__utils_8h_a27dd022a77729a35640126b146b35825}



\begin{DoxyCode}
1396 {
1397     int f_status=0;
1398     int ninc, nexc;
1399     FITScards *cards=NULL;
1400     //int hdutype;
1401         int i,n;
1402     char card[FLEN_CARD];
1403     char *inclist[1] = {
1404     "*"
1405     };
1406 
1407     char *exclist[15] = {
1408     "NAXES",
1409     "NAXIS*",
1410     "BITPIX",
1411     "SIMPLE",
1412     "EXTEND",
1413     "ID*",
1414     "DATE",
1415     "EXTNAME",
1416     "TTYPE*",
1417     "TFORM*",
1418     "TUNIT*",
1419     "TFIELDS",
1420     "XTENSION",
1421     "PCOUNT",
1422     "GCOUNT"
1423     };
1424 
1425     ninc = 1;
1426     nexc = 15;
1427 
1428 
1429     // Move back tot he top of the HDU
1430     fits_read_record (input, 0, card, &f_status);
1431     if (f_status)
1432     {
1433         ffrprt (stderr, f_status);
1434         aXe_message (aXe_M_FATAL, __FILE__, __LINE__,
1435             "get_FITS_cards: " "Could not move to first card in FITS extension");
      
1436     }
1437     // Find the number of cards in this HDU
1438     n = 0;    
1439     do {
1440         fits_find_nextkey (input, inclist, ninc, exclist,
1441          nexc, card, &f_status);    
1442         n++;
1443     }
1444     while (f_status==0);
1445     if (f_status!= KEY_NO_EXIST) {
1446         ffrprt (stderr, f_status);
1447         aXe_message (aXe_M_FATAL, __FILE__, __LINE__,
1448             "get_FITS_cards: " "Problem reading keys in FITS extension");
1449     }
1450     f_status = 0;
1451 
1452     // Allocate enough room for all the cards
1453     cards = allocate_FITScards(n);
1454     // Move back tot he top of the HDU
1455     fits_read_record (input, 0, card, &f_status);
1456     if (f_status)
1457     {
1458         ffrprt (stderr, f_status);
1459         aXe_message (aXe_M_FATAL, __FILE__, __LINE__,
1460             "get_FITS_cards: " "Could not move to first card in FITS extension");
      
1461     }
1462 
1463     // Read all cards 
1464     i=0;
1465     do {
1466         fits_find_nextkey (input, inclist, ninc, exclist,
1467          nexc, cards->cards[i], &f_status);    
1468         i++;
1469     } while (f_status==0);
1470     if (f_status!= KEY_NO_EXIST) {
1471         ffrprt (stderr, f_status);
1472         aXe_message (aXe_M_FATAL, __FILE__, __LINE__,
1473             "get_FITS_cards: " "Problem reading keys in FITS extension");
1474     }
1475     f_status = 0;
1476 
1477     return cards;
1478 }
\end{DoxyCode}
\hypertarget{aXe__utils_8h_a8817e86558786acb16965f3ac1215992}{
\index{aXe\_\-utils.h@{aXe\_\-utils.h}!get\_\-float\_\-from\_\-keyword@{get\_\-float\_\-from\_\-keyword}}
\index{get\_\-float\_\-from\_\-keyword@{get\_\-float\_\-from\_\-keyword}!aXe_utils.h@{aXe\_\-utils.h}}
\subsubsection[{get\_\-float\_\-from\_\-keyword}]{\setlength{\rightskip}{0pt plus 5cm}float get\_\-float\_\-from\_\-keyword (char $\ast$ {\em filename}, \/  int {\em hdunum}, \/  char $\ast$ {\em keyword})}}
\label{aXe__utils_8h_a8817e86558786acb16965f3ac1215992}
Read a FITS file header and return the value of the derired keyword. If the passed keyword string contains an actual number, then this number of converted to a float and returned. If keyword=None, then NULL is returned.


\begin{DoxyParams}{Parameters}
\item[{\em filename}]a pointer to a char array containing the name of the FITS file \item[{\em hdunum}]the number of the extension to access \item[{\em keyword}]a pointer to a char array containing the name of the keyword, or a number\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the floating point value read from the FITS file or converted from the passed string 
\end{DoxyReturn}



\begin{DoxyCode}
234 {
235   fitsfile *input;
236   int f_status = 0, hdutype;
237   float val=-1.0;
238   char comment[FLEN_COMMENT];
239 
240   /* If keyword contains an actual number, convert it to a float and
241      return the value */
242   //     fprintf(stdout, "opening: %s\n", filename);      
243   if (isnum2(keyword)) {
244     val =  atof(keyword);
245     return val;
246   }
247   
248   /* If keyword == None return NULL */
249   if (!strcmp(keyword,"None")) return GSL_NAN;
250   
251   //  Open the file for creating/appending
252   //   fprintf(stdout, "opening: %s\n", filename);        
253   fits_open_file (&input, filename, READONLY, &f_status);
254   if (f_status)
255     {
256       ffrprt (stderr, f_status);
257       aXe_message (aXe_M_FATAL, __FILE__, __LINE__,
258                    "get_float_from_keyword: " " Could not open file: %s",
259                    filename);
260     }
261   
262   fits_movabs_hdu (input, hdunum, &hdutype, &f_status);
263   if (f_status)
264     {
265       ffrprt (stderr, f_status);
266       aXe_message (aXe_M_FATAL, __FILE__, __LINE__,
267                    "get_float_from_keyword: "
268                    "Could not read extention %d from file: %s", hdunum,
269                    filename);
270     }
271 
272 
273   fits_read_key_flt (input, keyword, &val, comment, &f_status);
274   if (f_status)
275     {
276       //      aXe_message (aXe_M_WARN4, __FILE__, __LINE__,
277       //                   "get_float_from_keyword: Could not read keyword %s fro
      m file: %s \n",
278       //                   keyword,filename);
279       f_status=0;
280       fits_close_file (input, &f_status);
281       if (f_status)
282         {
283           aXe_message (aXe_M_FATAL, __FILE__, __LINE__,
284                        "get_float_from_keyword: " "Error closing file: %s ",
285                        filename);
286         }
287       return GSL_NAN;
288     }
289 
290 
291   fits_close_file (input, &f_status);
292   if (f_status)
293     {
294       aXe_message (aXe_M_FATAL, __FILE__, __LINE__,
295                    "get_float_from_keyword: " "Error closing file: %s ",
296                    filename);
297     }
298   
299   return val;
300 }
\end{DoxyCode}
\hypertarget{aXe__utils_8h_ae2b196b3eec481bec79c35394e75e4fc}{
\index{aXe\_\-utils.h@{aXe\_\-utils.h}!get\_\-hdunum\_\-from\_\-hduname@{get\_\-hdunum\_\-from\_\-hduname}}
\index{get\_\-hdunum\_\-from\_\-hduname@{get\_\-hdunum\_\-from\_\-hduname}!aXe_utils.h@{aXe\_\-utils.h}}
\subsubsection[{get\_\-hdunum\_\-from\_\-hduname}]{\setlength{\rightskip}{0pt plus 5cm}int get\_\-hdunum\_\-from\_\-hduname (char {\em filename}\mbox{[}$\,$\mbox{]}, \/  char {\em extname}\mbox{[}$\,$\mbox{]}, \/  char {\em keyword}\mbox{[}$\,$\mbox{]}, \/  char {\em keyval}\mbox{[}$\,$\mbox{]}, \/  int {\em extver})}}
\label{aXe__utils_8h_ae2b196b3eec481bec79c35394e75e4fc}
A helper function which returns the extension number in a FITS file which has a given name and also optionally containing a given keyword/key combination. The leyword/key pair is meant to diferentiate between different extensions os the same types. For example between two SCI extension containing CCDNUM=1 or CCDNUM=2 keys.


\begin{DoxyParams}{Parameters}
\item[{\em filename}]a pointer to a string containing the name of an existing FITS file \item[{\em extname}]a pointer to a string containing the name of the extension to look for \item[{\em keyword}]a pointer to a string containing the name of an extra keyword to lolok for. Can be set to NULL \item[{\em a}]pointer to a string containing the value of the optional key we are looking for \end{DoxyParams}



\begin{DoxyCode}
2032 {
2033   fitsfile *input;
2034   int f_status = 0;
2035   char comment[FLEN_COMMENT];
2036   char sval[FLEN_VALUE];
2037   int i,hdunum,hduext;
2038 
2039   /* If the extname is a number then we simply return that number */
2040   if (isnum2(extname)) {
2041     hdunum = (long) atoi(extname);
2042     return (int) hdunum;
2043   }
2044 
2045   /* If it not then we first look for the names extension */
2046   //  fprintf(stderr,"Extension keyword %s %i kkkk \n",filename, f_status);
2047   fits_open_file (&input, filename, READONLY, &f_status);
2048   if (f_status)
2049     {
2050       ffrprt (stderr, f_status);
2051       return -1;
2052     }
2053   i=0;
2054   while (!f_status) {
2055     /* Keep looking for extensions matching the required */
2056     /* extname */
2057     i++;
2058     fits_movabs_hdu (input, i, NULL, &f_status);
2059     if (f_status) {
2060       /* No more HDU found. If we are here then we failed to find */
2061       /* a matching extension and return -1 */
2062       f_status = 0;
2063       fits_close_file (input, &f_status);
2064       return -1;
2065     }
2066     /* Read extname and try to match it */
2067     fits_read_key_str (input, "EXTNAME", sval, comment, &f_status);
2068     if (f_status) {
2069       /* Did not manage to get EXTNAME, keep looking */
2070       f_status = 0;
2071       continue;
2072     } else {
2073       /* found EXTNAME, check if it is the one we want, or continue */
2074       //      fprintf(stdout,"Extension name %s kkkk \n",sval);
2075       if (strcmp(extname,sval)) {
2076         f_status = 0;
2077         continue;
2078       }
2079     }
2080     /* If the passed keyword is non NULL then we attempt to match it */
2081     /* otherwise, we are done */
2082     if (!strcmp(keyword,"None")) {
2083       fits_get_hdu_num(input,&hdunum);
2084       fits_close_file (input, &f_status);
2085       return hdunum;
2086     }
2087     fits_read_key_str (input, keyword, sval, comment, &f_status);
2088     if (f_status) {
2089 /* keyword was not found, try whether the EXTVER keyword matches */
2090       if (extver > -1){
2091         f_status = 0;
2092         fits_read_key_str (input, "EXTVER", sval, comment, &f_status);
2093         if (f_status) {
2094           f_status = 0;
2095           continue;
2096         }
2097         else{
2098           hduext = atoi(sval);
2099           if (hduext == extver){
2100             fits_get_hdu_num(input,&hdunum);
2101             fits_close_file (input, &f_status);
2102             return hdunum;
2103           }
2104           else{
2105           f_status = 0;
2106           continue;
2107           }
2108         }
2109       }
2110       else {
2111         f_status = 0;
2112         continue;
2113       }
2114     } else {
2115       if (strcmp(sval,keyval)) {
2116         /* keyword was found but does not match the passed value */
2117         /* skip to next HDU */
2118         continue;
2119       } else {
2120         /* keyword was found and the key matches, return the current */
2121         /* HDU number */
2122         fits_get_hdu_num(input,&hdunum);
2123         fits_close_file (input, &f_status);
2124         return hdunum;
2125       }
2126     }
2127   }
2128   return -1;
2129 }
\end{DoxyCode}
\hypertarget{aXe__utils_8h_ae7f4f277c2b5d03b7ce52b2392d176b2}{
\index{aXe\_\-utils.h@{aXe\_\-utils.h}!get\_\-npixel@{get\_\-npixel}}
\index{get\_\-npixel@{get\_\-npixel}!aXe_utils.h@{aXe\_\-utils.h}}
\subsubsection[{get\_\-npixel}]{\setlength{\rightskip}{0pt plus 5cm}{\bf px\_\-point} get\_\-npixel (const {\bf observation} $\ast$ {\em obs})}}
\label{aXe__utils_8h_ae7f4f277c2b5d03b7ce52b2392d176b2}
Function: get\_\-npixel The function extracts the number of pixels in x an y or the science image associated to an 'observation'-\/structure.

Parameters: 
\begin{DoxyParams}{Parameters}
\item[{\em obs}]-\/ the \hyperlink{structobservation}{observation} with the science image\end{DoxyParams}
Returns: \begin{DoxyReturn}{Returns}
npixels -\/ the struct to store the pixel numbers in x and y 
\end{DoxyReturn}



\begin{DoxyCode}
2220 {
2221 
2222   px_point npixels;
2223 
2224   npixels.x = obs->grism->size1;
2225   npixels.y = obs->grism->size2;
2226 
2227   return npixels;
2228 }
\end{DoxyCode}
\hypertarget{aXe__utils_8h_a7eb3cbe5ef0277544b00b2cc9c990e4c}{
\index{aXe\_\-utils.h@{aXe\_\-utils.h}!get\_\-npixels@{get\_\-npixels}}
\index{get\_\-npixels@{get\_\-npixels}!aXe_utils.h@{aXe\_\-utils.h}}
\subsubsection[{get\_\-npixels}]{\setlength{\rightskip}{0pt plus 5cm}{\bf px\_\-point} get\_\-npixels (const char $\ast$const  {\em fname}, \/  int {\em hdunum})}}
\label{aXe__utils_8h_a7eb3cbe5ef0277544b00b2cc9c990e4c}
Determine the dimension of an image


\begin{DoxyParams}{Parameters}
\item[{\em fname}]File name of the FITS image \item[{\em hdunum}]the number of the extension to read in (first primary = 1) \end{DoxyParams}
\begin{DoxyReturn}{Returns}
the dimensation of the image in the specified extension 
\end{DoxyReturn}



\begin{DoxyCode}
738 {
739      fitsfile *input;
740      int f_status = 0;
741      //float nulval = 0;
742      //int anynul;
743      int bitpix, naxis;
744      long naxes[2];
745      //long zero[2] = { 1, 1 };
746          //int x, y;
747      int hdutype;
748      px_point numpix;
749 
750      fits_open_file (&input, fname, READONLY, &f_status);
751      if (f_status)
752        {
753          fits_report_error (stderr, f_status);
754          aXe_message (aXe_M_FATAL, __FILE__, __LINE__,
755                       "FITSimage_to_gsl: " "Could not open file %s:", fname);
756        }
757      fits_movabs_hdu (input, hdunum, &hdutype, &f_status);
758      if (f_status)
759        {
760          fits_report_error (stderr, f_status);
761          aXe_message (aXe_M_FATAL, __FILE__, __LINE__,
762                       "FITSimage_to_gsl: " "Could not read extention %d"
763                       " from file: %s", hdunum, fname);
764        }
765      if (hdutype != 0)
766        {
767             fits_report_error (stderr, f_status);
768             aXe_message (aXe_M_FATAL, __FILE__, __LINE__,
769                          "FITSimage_to_gsl: " "Extension %i of %s is not "
770                          " an image type", hdunum, fname);
771        }
772      ffgipr (input, 2, &bitpix, &naxis, naxes, &f_status);
773      if (naxis != 2)
774        {
775          fits_report_error (stderr, f_status);
776          aXe_message (aXe_M_FATAL, __FILE__, __LINE__,
777                       "FITSimage_to_gsl: " "%s is not a 2D FITS image.",
778                       fname);
779        }
780 
781      numpix.x = (int)naxes[0];
782      numpix.y = (int)naxes[1];
783      fits_close_file (input, &f_status);
784      if (f_status)
785        {
786          fits_report_error (stderr, f_status);
787          aXe_message (aXe_M_FATAL, __FILE__, __LINE__,
788                       "FITSimage_to_gsl: " "Could not close file: %s", fname);
789        }
790      return numpix;
791 }
\end{DoxyCode}
\hypertarget{aXe__utils_8h_a831cd1049c0c8b8e918404c5035d5411}{
\index{aXe\_\-utils.h@{aXe\_\-utils.h}!get\_\-online\_\-option@{get\_\-online\_\-option}}
\index{get\_\-online\_\-option@{get\_\-online\_\-option}!aXe_utils.h@{aXe\_\-utils.h}}
\subsubsection[{get\_\-online\_\-option}]{\setlength{\rightskip}{0pt plus 5cm}char$\ast$ get\_\-online\_\-option (char {\em option\_\-name}\mbox{[}$\,$\mbox{]}, \/  int {\em argc}, \/  char $\ast$ {\em argv}\mbox{[}$\,$\mbox{]})}}
\label{aXe__utils_8h_a831cd1049c0c8b8e918404c5035d5411}
Function to parse the online arguments and look for an option (starting with a \char`\"{}-\/\char`\"{}) with a certain name. If found, a pointer to a string pointing to the value of the option (following a \char`\"{}=\char`\"{}) is returned. If no \char`\"{}=\char`\"{} is found, then the name of the option is returned. If the names is not found, then NULL is returned.


\begin{DoxyParams}{Parameters}
\item[{\em option\_\-name}]the name of the option to look for (without the \char`\"{}-\/\char`\"{}) \item[{\em argc}]the number of online parameter \item[{\em $\ast$argv}]a pointer to an array of strings containing all the online parameters.\end{DoxyParams}
\begin{DoxyReturn}{Returns}
a pointer to an array containing the value of the option, the name of the option if it is found but not value was found (i.e. toggle), and NULL if the option was not found at all. 
\end{DoxyReturn}



\begin{DoxyCode}
1939 {
1940      char *parname;
1941      char *val;
1942      static char wrkarg[MAXCHAR];
1943      int i;
1944 
1945      for (i = 1; i < argc; i++)
1946        {
1947             if (argv[i][0] == '-')
1948               {
1949                    strcpy (wrkarg, argv[i] + 1);
1950                    parname = strtok (wrkarg, "=");
1951                    if (!strcmp (parname, option_name))
1952                      {
1953                           val = strtok (NULL, "=");
1954                           if (val == NULL)
1955                                return parname;
1956                           return val;
1957                      }
1958               }
1959        }
1960      return NULL;
1961 
1962 }
\end{DoxyCode}
\hypertarget{aXe__utils_8h_a7c64494989064de2c0ca57df3d7f43a2}{
\index{aXe\_\-utils.h@{aXe\_\-utils.h}!get\_\-online\_\-option2@{get\_\-online\_\-option2}}
\index{get\_\-online\_\-option2@{get\_\-online\_\-option2}!aXe_utils.h@{aXe\_\-utils.h}}
\subsubsection[{get\_\-online\_\-option2}]{\setlength{\rightskip}{0pt plus 5cm}int get\_\-online\_\-option2 (char {\em option\_\-name}\mbox{[}$\,$\mbox{]}, \/  char {\em option\_\-value}\mbox{[}$\,$\mbox{]}, \/  int {\em argc}, \/  char $\ast$ {\em argv}\mbox{[}$\,$\mbox{]})}}
\label{aXe__utils_8h_a7c64494989064de2c0ca57df3d7f43a2}



\begin{DoxyCode}
1965 {
1966      char *parname;
1967      char *val;
1968      static char wrkarg[MAXCHAR];
1969      int i;
1970 
1971      for (i = 1; i < argc; i++)
1972        {
1973             if (argv[i][0] == '-')
1974               {
1975                    strcpy (wrkarg, argv[i] + 1);
1976                    parname = strtok (wrkarg, "=");
1977                    if (!strcmp (parname, option_name))
1978                      {
1979                           val = strtok (NULL, "=");
1980                           if (val == NULL)
1981                             {
1982                               strcpy(option_value,parname);
1983                               return 1;}
1984                           
1985                           strcpy(option_value,val);
1986                           return 1;
1987                      }
1988               }
1989        }
1990      return 0;
1991 
1992 }
\end{DoxyCode}
\hypertarget{aXe__utils_8h_a57559b109efa08c59a49d92479619d0d}{
\index{aXe\_\-utils.h@{aXe\_\-utils.h}!gsl\_\-matrix\_\-to\_\-pgm@{gsl\_\-matrix\_\-to\_\-pgm}}
\index{gsl\_\-matrix\_\-to\_\-pgm@{gsl\_\-matrix\_\-to\_\-pgm}!aXe_utils.h@{aXe\_\-utils.h}}
\subsubsection[{gsl\_\-matrix\_\-to\_\-pgm}]{\setlength{\rightskip}{0pt plus 5cm}int gsl\_\-matrix\_\-to\_\-pgm (const char $\ast$const  {\em fname}, \/  const gsl\_\-matrix $\ast$const  {\em m})}}
\label{aXe__utils_8h_a57559b109efa08c59a49d92479619d0d}
Saves a gsl matrix to a pgm image file, properly scaled and all.


\begin{DoxyParams}{Parameters}
\item[{\em fname}]name of pgm file to write \item[{\em m}]the matrix \end{DoxyParams}
\begin{DoxyReturn}{Returns}
0 for success, -\/1 for failure 
\end{DoxyReturn}



\begin{DoxyCode}
1252 {
1253      FILE *f;
1254      double max = gsl_matrix_float_max (m);
1255      double min = gsl_matrix_float_min (m);
1256      int x, y;
1257      int szx = m->size1;
1258      int szy = m->size2;
1259 
1260      f = fopen (fname, "w");
1261      if (!f)
1262        {
1263             aXe_message (aXe_M_FATAL, __FILE__, __LINE__,
1264                          "gsl_matrix_to_pgm: Could not open file: %s", fname);
1265        }
1266      fprintf (f, "P5\n%d %d\n255\n", szx, szy);
1267      for (y = 0; y < szy; y++)
1268        {
1269             for (x = 0; x < szx; x++)
1270               {
1271                    fprintf (f, "%c",
1272                             (int)
1273                             floor ((gsl_matrix_get (m, x, szy - 1 - y) /
1274                                     (max - min) - min) * 255));
1275               }
1276        }
1277      fclose (f);
1278      return 0;
1279 }
\end{DoxyCode}
\hypertarget{aXe__utils_8h_a6a5d64fa0baa598fc20741fa603bee11}{
\index{aXe\_\-utils.h@{aXe\_\-utils.h}!gsl\_\-to\_\-FITSimage@{gsl\_\-to\_\-FITSimage}}
\index{gsl\_\-to\_\-FITSimage@{gsl\_\-to\_\-FITSimage}!aXe_utils.h@{aXe\_\-utils.h}}
\subsubsection[{gsl\_\-to\_\-FITSimage}]{\setlength{\rightskip}{0pt plus 5cm}int gsl\_\-to\_\-FITSimage (gsl\_\-matrix $\ast$ {\em data}, \/  char {\em filename}\mbox{[}$\,$\mbox{]}, \/  int {\em overwrite}, \/  char {\em ID}\mbox{[}$\,$\mbox{]})}}
\label{aXe__utils_8h_a6a5d64fa0baa598fc20741fa603bee11}
Store the content of a gsl\_\-matrix into a FITS file


\begin{DoxyParams}{Parameters}
\item[{\em data}]a pointer to an existing gsl\_\-matrix structure \item[{\em fname}]a pointer to a string containing the name of the FITS file to write to \item[{\em overwrite}]if set to 1 then existing file is deleted, otherwise an extension is added \item[{\em ID}]an ID string which will be used to write an EXTNAME keyword in the extension. If NULL, no extension name is written. \item[{\em HDUfile}]\item[{\em HDUfilenum}]\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the number of the HDU written to 
\end{DoxyReturn}



\begin{DoxyCode}
1018 {
1019   fitsfile *output;
1020   long naxes[2];
1021   int f_status = 0;
1022   PIXEL_T *storage, *dp;
1023   int x, y;
1024   int hdunum = 1, hdutype;
1025 
1026   if (data!=NULL) {
1027     naxes[0] = data->size1;
1028     naxes[1] = data->size2;
1029   } else {
1030     naxes[0] = 0;
1031     naxes[1] = 0;
1032   }
1033 
1034   create_FITSimage(filename,overwrite);
1035   
1036   
1037   /* Moving pixels around into a CFITSIO friendly array */
1038   if (!(storage = malloc (naxes[0] * naxes[1] * sizeof (double))))
1039     {
1040       aXe_message (aXe_M_FATAL, __FILE__, __LINE__, "Out of memory");
1041     }
1042   dp = storage;
1043   for (y = 0; y < naxes[1]; y++)
1044     {
1045       for (x = 0; x < naxes[0]; x++)
1046         {
1047           *dp = gsl_matrix_get (data, x, y);
1048           dp++;
1049         }
1050     }
1051 
1052   //  Open the file for creating/appending
1053   fits_open_file (&output, filename, READWRITE, &f_status);
1054   if (f_status)
1055     {
1056       ffrprt (stderr, f_status);
1057       aXe_message (aXe_M_FATAL, __FILE__, __LINE__,
1058                    "gsl_to_FITSimage: " "Could not open file: %s",
1059                    filename);
1060     }
1061   
1062 
1063   fits_get_num_hdus (output, &hdunum, &f_status);
1064   if (f_status)
1065     {
1066       ffrprt (stderr, f_status);
1067       aXe_message (aXe_M_FATAL, __FILE__, __LINE__,
1068                    "gsl_to_FITSimage: Could not get"
1069                    " number of HDU from: %s", filename);
1070     }
1071 
1072   /* Move to last HDU */
1073   fits_movabs_hdu (output, hdunum, &hdutype, &f_status);
1074   if (f_status)
1075     {
1076       ffrprt (stderr, f_status);
1077       aXe_message (aXe_M_FATAL, __FILE__, __LINE__,
1078                    "gsl_to_FITSimage: Could not mov"
1079                    " to HDU number %d in file: %s", hdunum, filename);
1080     }
1081   /* Get current HDU number */
1082   fits_get_hdu_num (output, &hdunum);
1083   
1084   fits_create_img (output, -32, 2, naxes, &f_status);
1085   
1086   fits_write_img (output, TFLOAT, 1, naxes[0] * naxes[1], storage,
1087                   &f_status);
1088 
1089   /* Add an EXTNAME to this extension */
1090   if (ID!=NULL) {
1091     char comment[FLEN_COMMENT];
1092     char keyname[FLEN_KEYWORD];
1093     //fits_write_key_lng (input, ID, (long) hdunum, comment, &f_status);
1094     sprintf(keyname,"EXTNAME");
1095     sprintf(comment,"name of this extension");
1096     fits_update_key (output, TSTRING, keyname, ID, comment, &f_status);
1097   }
1098   fits_write_date (output, &f_status);
1099   
1100   fits_get_hdu_num(output,&hdunum);
1101   
1102   fits_close_file (output, &f_status);
1103   
1104   free (storage);
1105   storage = NULL;
1106 
1107   return hdunum;
1108 }
\end{DoxyCode}
\hypertarget{aXe__utils_8h_ad7667e161c8b5af380d7ff9f2433cd06}{
\index{aXe\_\-utils.h@{aXe\_\-utils.h}!gsl\_\-to\_\-FITSimage\_\-opened@{gsl\_\-to\_\-FITSimage\_\-opened}}
\index{gsl\_\-to\_\-FITSimage\_\-opened@{gsl\_\-to\_\-FITSimage\_\-opened}!aXe_utils.h@{aXe\_\-utils.h}}
\subsubsection[{gsl\_\-to\_\-FITSimage\_\-opened}]{\setlength{\rightskip}{0pt plus 5cm}void gsl\_\-to\_\-FITSimage\_\-opened (gsl\_\-matrix $\ast$ {\em data}, \/  fitsfile $\ast$ {\em output}, \/  int {\em overwrite}, \/  char {\em ID}\mbox{[}$\,$\mbox{]})}}
\label{aXe__utils_8h_ad7667e161c8b5af380d7ff9f2433cd06}
Store the content of a gsl\_\-matrix into a FITS file


\begin{DoxyParams}{Parameters}
\item[{\em data}]a pointer to an existing gsl\_\-matrix structure \item[{\em fname}]a pointer to a string containing the name of the FITS file to write to \item[{\em overwrite}]if set to 1 then existing file is deleted, otherwise an extension is added \item[{\em ID}]an ID string which will be used to write an EXTNAME keyword in the extension \item[{\em HDUfile}]\item[{\em HDUfilenum}]\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the number of the HDU written to 
\end{DoxyReturn}



\begin{DoxyCode}
950 {
951      long naxes[2];
952      int f_status = 0;
953      PIXEL_T *storage, *dp;
954      int x, y;
955 
956      if (data!=NULL) {
957          naxes[0] = data->size1;
958          naxes[1] = data->size2;
959     } else {
960         naxes[0] = 0;
961         naxes[1] = 0;
962     }
963 
964      //create_FITSimage(filename,overwrite);
965 
966 
967      /* Moving pixels around into a CFITSIO friendly array */
968      if (!(storage = malloc (naxes[0] * naxes[1] * sizeof (double))))
969        {
970             aXe_message (aXe_M_FATAL, __FILE__, __LINE__, "Out of memory");
971        }
972      dp = storage;
973      for (y = 0; y < naxes[1]; y++)
974        {
975             for (x = 0; x < naxes[0]; x++)
976               {
977                    *dp = gsl_matrix_get (data, x, y);
978                    dp++;
979               }
980        }
981 
982      fits_create_img (output, -32, 2, naxes, &f_status);
983 
984      fits_write_img (output, TFLOAT, 1, naxes[0] * naxes[1], storage,
985                      &f_status);
986 
987      /* Add an EXTNAME to this extension */
988      if (ID!=NULL) {
989          char comment[FLEN_COMMENT];
990          char keyname[FLEN_KEYWORD];
991         //fits_write_key_lng (input, ID, (long) hdunum, comment, &f_status);
992         sprintf(keyname,"EXTNAME");
993         sprintf(comment,"name of this extension");
994         fits_update_key (output, TSTRING, keyname, ID, comment, &f_status);
995      }
996      fits_write_date (output, &f_status);
997 
998 
999      free (storage);
1000      storage = NULL;
1001 
1002 }
\end{DoxyCode}
\hypertarget{aXe__utils_8h_ae3c5e11b29793d5fa85913a0df2f7761}{
\index{aXe\_\-utils.h@{aXe\_\-utils.h}!gsl\_\-to\_\-FITSimageHDU@{gsl\_\-to\_\-FITSimageHDU}}
\index{gsl\_\-to\_\-FITSimageHDU@{gsl\_\-to\_\-FITSimageHDU}!aXe_utils.h@{aXe\_\-utils.h}}
\subsubsection[{gsl\_\-to\_\-FITSimageHDU}]{\setlength{\rightskip}{0pt plus 5cm}int gsl\_\-to\_\-FITSimageHDU (gsl\_\-matrix $\ast$ {\em data}, \/  char {\em filename}\mbox{[}$\,$\mbox{]}, \/  int {\em overwrite}, \/  char {\em ID}\mbox{[}$\,$\mbox{]}, \/  int {\em hdu\_\-num})}}
\label{aXe__utils_8h_ae3c5e11b29793d5fa85913a0df2f7761}
Store the content of a gsl\_\-matrix into a FITS file


\begin{DoxyParams}{Parameters}
\item[{\em data}]a pointer to an existing gsl\_\-matrix structure \item[{\em fname}]a pointer to a string containing the name of the FITS file to write to \item[{\em overwrite}]if set to 1 then existing file is deleted, otherwise an extension is added \item[{\em ID}]an ID string which will be used to write an EXTNAME keyword in the extension. If NULL, no extension name is written. \item[{\em hdunum,an}]integer pinting to the HDU the image should be written to \item[{\em HDUfile}]\item[{\em HDUfilenum}]\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the number of the HDU written to 
\end{DoxyReturn}



\begin{DoxyCode}
1125 {
1126      fitsfile *output;
1127      long naxes[2];
1128      int f_status = 0;
1129      PIXEL_T *storage, *dp;
1130      int x, y;
1131      int hdunum = 1, hdutype;
1132 
1133      if (data!=NULL) {
1134          naxes[0] = data->size1;
1135          naxes[1] = data->size2;
1136     } else {
1137         naxes[0] = 0;
1138         naxes[1] = 0;
1139     }
1140 
1141      create_FITSimage(filename,overwrite);
1142 
1143 
1144      /* Moving pixels around into a CFITSIO friendly array */
1145      if (!(storage = malloc (naxes[0] * naxes[1] * sizeof (double))))
1146        {
1147             aXe_message (aXe_M_FATAL, __FILE__, __LINE__, "Out of memory");
1148        }
1149      dp = storage;
1150      for (y = 0; y < naxes[1]; y++)
1151        {
1152             for (x = 0; x < naxes[0]; x++)
1153               {
1154                    *dp = gsl_matrix_get (data, x, y);
1155                    dp++;
1156               }
1157        }
1158 
1159      //  Open the file for creating/appending
1160      fits_open_file (&output, filename, READWRITE, &f_status);
1161      if (f_status)
1162        {
1163             ffrprt (stderr, f_status);
1164             aXe_message (aXe_M_FATAL, __FILE__, __LINE__,
1165                          "gsl_to_FITSimage: " "Could not open file: %s",
1166                          filename);
1167        }
1168 
1169 
1170      //     fits_get_num_hdus (output, &hdunum, &f_status);
1171      //     if (f_status)
1172      //       {
1173      //     ffrprt (stderr, f_status);
1174      //     aXe_message (aXe_M_FATAL, __FILE__, __LINE__,
1175      //                  "gsl_to_FITSimage: Could not get"
1176      //                  " number of HDU from: %s", filename);
1177      //       }
1178 
1179      /* Move to last HDU */
1180      fits_movabs_hdu (output, hdu_num, &hdutype, &f_status);
1181      if (f_status)
1182        {
1183             ffrprt (stderr, f_status);
1184             aXe_message (aXe_M_FATAL, __FILE__, __LINE__,
1185                          "gsl_to_FITSimage: Could not mov"
1186                          " to HDU number %d in file: %s", hdunum, filename);
1187        }
1188      /* Get current HDU number */
1189      //     fits_get_hdu_num (output, &hdunum);
1190 
1191      //     fits_create_img (output, -32, 2, naxes, &f_status);
1192 
1193      fits_write_img (output, TFLOAT, 1, naxes[0] * naxes[1], storage,
1194                      &f_status);
1195 
1196      /* Add an EXTNAME to this extension */
1197      if (ID!=NULL) {
1198          char comment[FLEN_COMMENT];
1199          char keyname[FLEN_KEYWORD];
1200         //fits_write_key_lng (input, ID, (long) hdunum, comment, &f_status);
1201         sprintf(keyname,"EXTNAME");
1202         sprintf(comment,"name of this extension");
1203         fits_update_key (output, TSTRING, keyname, ID, comment, &f_status);
1204      }
1205      fits_write_date (output, &f_status);
1206 
1207      fits_get_hdu_num(output,&hdunum);
1208 
1209      fits_close_file (output, &f_status);
1210 
1211      free (storage);
1212      storage = NULL;
1213 
1214      return hdunum;
1215 }
\end{DoxyCode}
\hypertarget{aXe__utils_8h_a661333de2efcbef321b27520d40cc9cf}{
\index{aXe\_\-utils.h@{aXe\_\-utils.h}!load\_\-image@{load\_\-image}}
\index{load\_\-image@{load\_\-image}!aXe_utils.h@{aXe\_\-utils.h}}
\subsubsection[{load\_\-image}]{\setlength{\rightskip}{0pt plus 5cm}{\bf observation}$\ast$ load\_\-image (const char $\ast$const  {\em fname}, \/  int {\em hdunum\_\-data}, \/  int {\em hdunum\_\-err}, \/  int {\em hdunum\_\-dq}, \/  int {\em dqmask}, \/  float {\em exptime}, \/  float {\em gain})}}
\label{aXe__utils_8h_a661333de2efcbef321b27520d40cc9cf}
\hypertarget{aXe__utils_8h_ac87755b847abbd2c375032e14bd5561c}{
\index{aXe\_\-utils.h@{aXe\_\-utils.h}!load\_\-image\_\-t@{load\_\-image\_\-t}}
\index{load\_\-image\_\-t@{load\_\-image\_\-t}!aXe_utils.h@{aXe\_\-utils.h}}
\subsubsection[{load\_\-image\_\-t}]{\setlength{\rightskip}{0pt plus 5cm}{\bf observation}$\ast$ load\_\-image\_\-t (const char $\ast$const  {\em fname}, \/  int {\em hdunum\_\-data}, \/  int {\em hdunum\_\-err}, \/  int {\em hdunum\_\-dq}, \/  int {\em dqmask}, \/  const double {\em exptime}, \/  const double {\em rdnoise})}}
\label{aXe__utils_8h_ac87755b847abbd2c375032e14bd5561c}
Function to load a multiple extension FITS file into an \hyperlink{structobservation}{observation} structure


\begin{DoxyParams}{Parameters}
\item[{\em fname}]a pointer to a string containing the name of the file to open \item[{\em hdunum\_\-data}]the extension number containing the data array (first=1) \item[{\em hdunum\_\-err}]the extension number containing the err array (first=1) \item[{\em hdunum\_\-dq}]the extension number containing the DQ array (first=1) \item[{\em dqmask}]the bit mask (represented as an int) to apply using the DQ info to flag a pixel as good or bad \item[{\em exptime}]exposure time (only used to determine count noise) \item[{\em gain}]gain factor (only used to determine count noise) \end{DoxyParams}
\begin{DoxyReturn}{Returns}
\hyperlink{structobservation}{observation} a pointer to a new allocated, populated, DQ masked \hyperlink{structobservation}{observation} structure 
\end{DoxyReturn}



\begin{DoxyCode}
113 {
114   observation    *obs;
115   FILE           *infile;
116   
117   // check whether the image file 
118   // exists or not.
119   if (!(infile = fopen(fname, "r")))
120     aXe_message(aXe_M_FATAL, __FILE__, __LINE__,
121                 "Could not find %s\n", fname); 
122   else 
123     fclose(infile);
124 
125   // allocate memory  
126   obs = malloc(sizeof(observation));
127   
128   // load the science extension
129   fprintf(stdout,"Loading DATA from: %s...",fname);
130   obs->grism = FITSimage_to_gsl(fname, hdunum_data, 1);
131   fprintf(stdout,". Done.\n");
132 
133 
134   // check whether there
135   // is a dedicated error extension 
136   if (hdunum_err != -1)
137     {
138       // load the error extention
139       fprintf(stdout, "Loading ERR...");
140       obs->pixerrs = FITSimage_to_gsl(fname, hdunum_err, 0);
141       fprintf(stdout,". Done.\n");
142     } 
143   else
144     {
145       // simulate the error extension 
146       fprintf(stdout, "Simulating ERR with EXPTIME=%fs and RDNOISE= %fe ...", exp
      time, rdnoise);
147       obs->pixerrs = simulate_errors_t(obs->grism, exptime, rdnoise);
148       fprintf(stdout,". Done.\n");
149     }
150 
151 
152   // check whether there is a dedicated
153   // dq extention
154   if (hdunum_dq != -1)
155     {
156       // load the dq extention
157       fprintf(stdout, "Loading DQ...");
158       obs->dq = FITSimage_to_gsl(fname, hdunum_dq, 0);
159 
160       // apply the dq filter
161       if (dqmask>0) 
162         {
163           fprintf(stdout,"Applying MASK and seting DATA to NaN...");
164           apply_DQ(obs, dqmask);
165           fprintf(stdout,". Done.\n");
166         }
167     fprintf(stdout,". Done.\n");
168     }
169   else 
170     {
171       fprintf(stdout, " Not using DQ. Done.\n");
172       obs->dq = NULL;
173     }
174   fprintf(stdout,"\n");
175 
176   // return the structure created
177   return obs;
178 }
\end{DoxyCode}
\hypertarget{aXe__utils_8h_a1aa6f31280704fd7678c78b97d0f5456}{
\index{aXe\_\-utils.h@{aXe\_\-utils.h}!load\_\-sci\_\-image@{load\_\-sci\_\-image}}
\index{load\_\-sci\_\-image@{load\_\-sci\_\-image}!aXe_utils.h@{aXe\_\-utils.h}}
\subsubsection[{load\_\-sci\_\-image}]{\setlength{\rightskip}{0pt plus 5cm}{\bf observation}$\ast$ load\_\-sci\_\-image (const char $\ast$const  {\em fname}, \/  int {\em hdunum\_\-data})}}
\label{aXe__utils_8h_a1aa6f31280704fd7678c78b97d0f5456}
Function to load a multiple extension FITS file into an \hyperlink{structobservation}{observation} structure


\begin{DoxyParams}{Parameters}
\item[{\em fname}]a pointer to a string containing the name of the file to open \item[{\em hdunum\_\-data}]the extension number containing the data array (first=1) \item[{\em hdunum\_\-err}]the extension number containing the err array (first=1) \item[{\em hdunum\_\-dq}]the extension number containing the DQ array (first=1) \item[{\em dqmask}]the bit mask (represented as an int) to apply using the DQ info to flag a pixel as good or bad \item[{\em exptime}]exposure time (only used to determine count noise) \item[{\em gain}]gain factor (only used to determine count noise) \end{DoxyParams}
\begin{DoxyReturn}{Returns}
\hyperlink{structobservation}{observation} a pointer to a new allocated, populated, DQ masked \hyperlink{structobservation}{observation} structure 
\end{DoxyReturn}



\begin{DoxyCode}
197 {
198         observation    *obs;
199         FILE           *infile;
200                 
201         if (!(infile = fopen(fname, "r"))) {
202                 aXe_message(aXe_M_FATAL, __FILE__, __LINE__,
203                             "Could not find %s\n", fname);
204         } else {
205                 fclose(infile);
206         }
207         obs = malloc(sizeof(observation));
208 
209         fprintf(stdout,"Loading DATA from: %s...",fname);
210         obs->grism = FITSimage_to_gsl(fname, hdunum_data, 1);
211         fprintf(stdout,". Done.\n");
212 
213         obs->pixerrs = NULL;
214         obs->dq = NULL;
215 
216         fprintf(stdout,"\n");
217 
218         return obs;
219 }
\end{DoxyCode}
\hypertarget{aXe__utils_8h_a8abd9ee69f161e0ac3ee47dc722cebf0}{
\index{aXe\_\-utils.h@{aXe\_\-utils.h}!put\_\-FITS\_\-cards@{put\_\-FITS\_\-cards}}
\index{put\_\-FITS\_\-cards@{put\_\-FITS\_\-cards}!aXe_utils.h@{aXe\_\-utils.h}}
\subsubsection[{put\_\-FITS\_\-cards}]{\setlength{\rightskip}{0pt plus 5cm}void put\_\-FITS\_\-cards (char {\em filename}\mbox{[}$\,$\mbox{]}, \/  int {\em hdu}, \/  {\bf FITScards} $\ast$ {\em cards})}}
\label{aXe__utils_8h_a8abd9ee69f161e0ac3ee47dc722cebf0}
routine to write a set of FITS header cards into a FITS header of a given extension. Input cards are automatically formatted propely if they are not.


\begin{DoxyParams}{Parameters}
\item[{\em filename}]a pointer to a char array containing the name fo the existing FITS file \item[{\em hdu}]the number of the extension to write to (-\/1 for last one) \item[{\em cards}]a NULL terminated array of char arrays containing properly formatted cards \end{DoxyParams}



\begin{DoxyCode}
1490 {
1491     fitsfile *output;
1492     int hdutype,f_status = 0;
1493     int i, keytype;
1494     char card[FLEN_CARD];
1495 
1496     // Do nothing if there is nothing to do
1497     if (cards->n == 0) return;
1498 
1499     //  Open the file for creating/appending
1500     fits_open_file (&output, filename, READWRITE, &f_status);
1501     if (f_status)
1502     {
1503         ffrprt (stderr, f_status);
1504         aXe_message (aXe_M_FATAL, __FILE__, __LINE__,
1505             "put_FITS_cards: " "Could not open file: %s",
1506             filename);
1507     }
1508 
1509     // Move to the desired HDU
1510     // If -1 go to the last one
1511     if (hdu==-1) {
1512         fits_get_num_hdus (output, &hdu, &f_status);
1513         if (f_status)
1514         {
1515             ffrprt (stderr, f_status);
1516             aXe_message (aXe_M_FATAL, __FILE__, __LINE__,
1517                 "put_FITS_cards: Could not get"
1518                 " number of HDU from:", filename);
1519         }
1520     } 
1521     fits_movabs_hdu (output, hdu, &hdutype, &f_status);
1522     if (f_status)
1523     {
1524         ffrprt (stderr, f_status);
1525         aXe_message (aXe_M_FATAL, __FILE__, __LINE__,
1526             "put_FITS_cards: " "Could not move to extension %d in file: %s",
1527             hdu,filename);
1528     }
1529 
1530     for (i=0; i<cards->n;i++)
1531     {
1532         fits_parse_template (cards->cards[i], card, &keytype, &f_status);
1533 //fprintf(stderr,"%s\n",cards->cards[i]);
1534         if (f_status)
1535         {
1536             ffrprt (stderr, f_status);
1537             aXe_message (aXe_M_FATAL, __FILE__, __LINE__,
1538                 "put_FITS_cards: " "Could not reformet card:\n%s",cards[i]);
1539         }
1540         fits_write_record (output, card, &f_status);
1541         if (f_status)
1542         {
1543             ffrprt (stderr, f_status);
1544             aXe_message (aXe_M_FATAL, __FILE__, __LINE__,
1545                 "put_FITS_cards: " "Could not write card in extension %d in file:
       %s",
1546                 hdu,filename);
1547         }
1548     }
1549     fits_write_date (output, &f_status);
1550     fits_close_file (output, &f_status);
1551 
1552 }
\end{DoxyCode}
\hypertarget{aXe__utils_8h_a6652d52eca381c6c7fbc9913f2b42a0e}{
\index{aXe\_\-utils.h@{aXe\_\-utils.h}!put\_\-FITS\_\-cards\_\-opened@{put\_\-FITS\_\-cards\_\-opened}}
\index{put\_\-FITS\_\-cards\_\-opened@{put\_\-FITS\_\-cards\_\-opened}!aXe_utils.h@{aXe\_\-utils.h}}
\subsubsection[{put\_\-FITS\_\-cards\_\-opened}]{\setlength{\rightskip}{0pt plus 5cm}void put\_\-FITS\_\-cards\_\-opened (fitsfile $\ast$ {\em output}, \/  {\bf FITScards} $\ast$ {\em cards})}}
\label{aXe__utils_8h_a6652d52eca381c6c7fbc9913f2b42a0e}
routine to write a set of FITS header cards into a FITS header of a given extension. Input cards are automatically formatted propely if they are not.


\begin{DoxyParams}{Parameters}
\item[{\em input}]a fitsfile pointer pointing to the extension to write the cards to. \item[{\em hdu}]the number of the extension to write to (-\/1 for last one) \item[{\em cards}]a NULL terminated array of char arrays containing properly formatted cards \end{DoxyParams}



\begin{DoxyCode}
1564 {
1565     int f_status = 0;
1566     int i, keytype;
1567     char card[FLEN_CARD];
1568 
1569     // Do nothing if there is nothing to do
1570     if (cards->n == 0) return;
1571 
1572     for (i=0; i<cards->n;i++)
1573     {
1574         fits_parse_template (cards->cards[i], card, &keytype, &f_status);
1575         if (f_status)
1576         {
1577             ffrprt (stderr, f_status);
1578             aXe_message (aXe_M_FATAL, __FILE__, __LINE__,
1579                 "put_FITS_cards_opened: " "Could not reformat card:\n%s",cards[i]
      );
1580         }
1581         fits_write_record (output, card, &f_status);
1582         if (f_status)
1583         {
1584             ffrprt (stderr, f_status);
1585             fprintf(stderr, "FITScard:   %s\n", cards->cards[i]);
1586             fprintf(stderr, "FITSrecord: %s\n", card);
1587             aXe_message (aXe_M_FATAL, __FILE__, __LINE__,
1588                 "put_FITS_cards_opened: %i, %s" "Could not write cards.", i, card
      );
1589         }
1590     }
1591     fits_write_date (output, &f_status);
1592 }
\end{DoxyCode}
\hypertarget{aXe__utils_8h_a40b0ba7efd067d860b4f2a6948fea20b}{
\index{aXe\_\-utils.h@{aXe\_\-utils.h}!quad\_\-to\_\-bbox@{quad\_\-to\_\-bbox}}
\index{quad\_\-to\_\-bbox@{quad\_\-to\_\-bbox}!aXe_utils.h@{aXe\_\-utils.h}}
\subsubsection[{quad\_\-to\_\-bbox}]{\setlength{\rightskip}{0pt plus 5cm}void quad\_\-to\_\-bbox (const {\bf px\_\-point} $\ast$const  {\em corners}, \/  {\bf px\_\-point} $\ast$const  {\em ll}, \/  {\bf px\_\-point} $\ast$const  {\em ur})}}
\label{aXe__utils_8h_a40b0ba7efd067d860b4f2a6948fea20b}
computes the bbox of a general \hyperlink{structquadrangle}{quadrangle}.


\begin{DoxyParams}{Parameters}
\item[{\em corners}]the four corners of the \hyperlink{structquadrangle}{quadrangle} \item[{\em ll}]a \hyperlink{structpx__point}{px\_\-point} to hold the lower left corner \item[{\em ur}]a \hyperlink{structpx__point}{px\_\-point} to hold the upper right corner \end{DoxyParams}



\begin{DoxyCode}
1227 {
1228      ll->x =
1229           MIN (MIN (MIN (corners[0].x, corners[1].x), corners[2].x),
1230                corners[3].x);
1231      ll->y =
1232           MIN (MIN (MIN (corners[0].y, corners[1].y), corners[2].y),
1233                corners[3].y);
1234      ur->x =
1235           MAX (MAX (MAX (corners[0].x, corners[1].x), corners[2].x),
1236                corners[3].x);
1237      ur->y =
1238           MAX (MAX (MAX (corners[0].y, corners[1].y), corners[2].y),
1239                corners[3].y);
1240 }
\end{DoxyCode}
\hypertarget{aXe__utils_8h_a94637b37589d1f9b3c9418d620156519}{
\index{aXe\_\-utils.h@{aXe\_\-utils.h}!replace\_\-file\_\-extension@{replace\_\-file\_\-extension}}
\index{replace\_\-file\_\-extension@{replace\_\-file\_\-extension}!aXe_utils.h@{aXe\_\-utils.h}}
\subsubsection[{replace\_\-file\_\-extension}]{\setlength{\rightskip}{0pt plus 5cm}void replace\_\-file\_\-extension (char {\em infile}\mbox{[}$\,$\mbox{]}, \/  char {\em outfile}\mbox{[}$\,$\mbox{]}, \/  char {\em from\_\-ext}\mbox{[}$\,$\mbox{]}, \/  char {\em to\_\-ext}\mbox{[}$\,$\mbox{]}, \/  int {\em hdu})}}
\label{aXe__utils_8h_a94637b37589d1f9b3c9418d620156519}



\begin{DoxyCode}
1807 {
1808      char chdu[MAXCHAR];
1809      if (!infile)
1810        {
1811             aXe_message (aXe_M_FATAL, __FILE__, __LINE__,
1812                          "replace_file_extension: Input filename invalid");
1813        }
1814      if (!from_ext)
1815        {
1816             aXe_message (aXe_M_FATAL, __FILE__, __LINE__,
1817                          "replace_file_extension: Input extension invalid");
1818        }
1819      if (!to_ext)
1820        {
1821             aXe_message (aXe_M_FATAL, __FILE__, __LINE__,
1822                          "replace_file_extension: output extension invalid");
1823        }
1824 
1825      strcpy (outfile, infile);
1826      outfile[strlen (outfile) - strlen (from_ext)] = 0;
1827      if (hdu > 0)
1828        {
1829             sprintf (chdu, "_%d", hdu);
1830             strcat (outfile, chdu);
1831        }
1832      strcat (outfile, to_ext);
1833 
1834 
1835 }
\end{DoxyCode}
\hypertarget{aXe__utils_8h_a265457e88fc46b602e539e9a7b2a6c1e}{
\index{aXe\_\-utils.h@{aXe\_\-utils.h}!simulate\_\-errors@{simulate\_\-errors}}
\index{simulate\_\-errors@{simulate\_\-errors}!aXe_utils.h@{aXe\_\-utils.h}}
\subsubsection[{simulate\_\-errors}]{\setlength{\rightskip}{0pt plus 5cm}gsl\_\-matrix$\ast$ simulate\_\-errors (gsl\_\-matrix $\ast$ {\em img}, \/  float {\em exptime}, \/  float {\em gain})}}
\label{aXe__utils_8h_a265457e88fc46b602e539e9a7b2a6c1e}
\hypertarget{aXe__utils_8h_ad05c49b54279d1e4f6f49fe675ce254f}{
\index{aXe\_\-utils.h@{aXe\_\-utils.h}!simulate\_\-errors\_\-t@{simulate\_\-errors\_\-t}}
\index{simulate\_\-errors\_\-t@{simulate\_\-errors\_\-t}!aXe_utils.h@{aXe\_\-utils.h}}
\subsubsection[{simulate\_\-errors\_\-t}]{\setlength{\rightskip}{0pt plus 5cm}gsl\_\-matrix$\ast$ simulate\_\-errors\_\-t (gsl\_\-matrix $\ast$ {\em img}, \/  const double {\em exptime}, \/  const double {\em rdnoise})}}
\label{aXe__utils_8h_ad05c49b54279d1e4f6f49fe675ce254f}
A helper function which populates the error part of an \hyperlink{structobservation}{observation} structure using simple Poisson noise. Assumes data is in electrons.


\begin{DoxyParams}{Parameters}
\item[{\em img}]a pointer to an exisiting \hyperlink{structobservation}{observation} structure\end{DoxyParams}
\begin{DoxyReturn}{Returns}
a pointer to a GDL matrix containing the error array 
\end{DoxyReturn}



\begin{DoxyCode}
36 {
37 
38   gsl_matrix *err;
39 
40   double nc;
41   double sqr_rdnoise;
42 
43   int i, j;
44   
45   err = gsl_matrix_alloc(img->size1, img->size2);
46   
47   sqr_rdnoise = rdnoise*rdnoise;
48 
49   for (i = 0; i < img->size1; i++) {
50     for (j = 0; j < img->size2; j++) {
51 
52       nc = fabs(gsl_matrix_get(img, i, j));
53 
54       nc = sqrt(nc*exptime + sqr_rdnoise)/exptime;
55 
56       gsl_matrix_set(err, i, j, nc);
57     }
58   }
59   return err;
60 }
\end{DoxyCode}
\hypertarget{aXe__utils_8h_a616ed3bbb3c1b15f8127548fbe1d4701}{
\index{aXe\_\-utils.h@{aXe\_\-utils.h}!storage\_\-to\_\-gsl@{storage\_\-to\_\-gsl}}
\index{storage\_\-to\_\-gsl@{storage\_\-to\_\-gsl}!aXe_utils.h@{aXe\_\-utils.h}}
\subsubsection[{storage\_\-to\_\-gsl}]{\setlength{\rightskip}{0pt plus 5cm}gsl\_\-matrix$\ast$ storage\_\-to\_\-gsl (long $\ast$ {\em naxes}, \/  PIXEL\_\-T $\ast$ {\em storage})}}
\label{aXe__utils_8h_a616ed3bbb3c1b15f8127548fbe1d4701}
Transfer data from a pointer to a gsl-\/image


\begin{DoxyParams}{Parameters}
\item[{\em naxes}]axes of the image \item[{\em storage}]pointer to the data \end{DoxyParams}



\begin{DoxyCode}
711                                              {
712         int x, y;
713         gsl_matrix *im;
714         PIXEL_T *dp;
715 
716         // define the gsl matrix
717         im = gsl_matrix_alloc (naxes[0], naxes[1]);
718 
719         // initialize the pointer
720         dp = storage;
721         for (y = 0; y < naxes[1]; y++)
722                 for (x = 0; x < naxes[0]; x++)
723                         gsl_matrix_set (im, x, y, *dp++);
724 
725         return im;
726 }
\end{DoxyCode}
